;{try{(function(){var e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:{},n=(new e.Error).stack;n&&(e._sentryDebugIds=e._sentryDebugIds||{},e._sentryDebugIds[n]="ae702c37-d5b8-4570-9ccd-ce07eec3c1e5",e._sentryDebugIdIdentifier="sentry-dbid-ae702c37-d5b8-4570-9ccd-ce07eec3c1e5");})();}catch(e){}};
!function(){var e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:{};e.SENTRY_RELEASE={id:"00ee96a191eaa70b72f3e18304fd7a157fe83a8e"};}();
"use strict";
(self["webpackChunk_hydrooj_ui_default"] = self["webpackChunk_hydrooj_ui_default"] || []).push([["n.schemastery-react"],{

/***/ "../../node_modules/schemastery-react/lib/schemastery-react.esm.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/schemastery-react/lib/schemastery-react.esm.js ***!
  \*************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createSchemasteryReact: () => (/* binding */ iie)
/* harmony export */ });
/* harmony import */ var schemastery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! schemastery */ "../../node_modules/schemastery/lib/index.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ "../../node_modules/react-dom/index.js");
/* module decorator */ module = __webpack_require__.hmd(module);



const YO = "2.10.1", jy = Symbol("INSTALLED_KEY");
/**
* @vue/shared v3.5.16
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function ka(e10) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const n of e10.split(",")) t[n] = 1;
  return (n) => n in t;
}
const Zt =  true ? Object.freeze({}) : 0, As =  true ? Object.freeze([]) : 0, Mt = () => {
}, qO = () => false, Uu = (e10) => e10.charCodeAt(0) === 111 && e10.charCodeAt(1) === 110 && // uppercase letter
(e10.charCodeAt(2) > 122 || e10.charCodeAt(2) < 97), Pd = (e10) => e10.startsWith("onUpdate:"), gn = Object.assign, gm = (e10, t) => {
  const n = e10.indexOf(t);
  n > -1 && e10.splice(n, 1);
}, GO = Object.prototype.hasOwnProperty, Tt = (e10, t) => GO.call(e10, t), Se = Array.isArray, xl = (e10) => Yu(e10) === "[object Map]", Of = (e10) => Yu(e10) === "[object Set]", nl = (e10) => Yu(e10) === "[object Date]", Fe = (e10) => typeof e10 == "function", Ve = (e10) => typeof e10 == "string", pr = (e10) => typeof e10 == "symbol", at = (e10) => e10 !== null && typeof e10 == "object", ol = (e10) => (at(e10) || Fe(e10)) && Fe(e10.then) && Fe(e10.catch), Aw = Object.prototype.toString, Yu = (e10) => Aw.call(e10), ym = (e10) => Yu(e10).slice(8, -1), iu = (e10) => Yu(e10) === "[object Object]", bm = (e10) => Ve(e10) && e10 !== "NaN" && e10[0] !== "-" && "" + parseInt(e10, 10) === e10, Gi = /* @__PURE__ */ ka(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), XO = /* @__PURE__ */ ka(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
), $f = (e10) => {
  const t = /* @__PURE__ */ Object.create(null);
  return (n) => t[n] || (t[n] = e10(n));
}, JO = /-(\w)/g, Dn = $f(
  (e10) => e10.replace(JO, (t, n) => n ? n.toUpperCase() : "")
), ZO = /\B([A-Z])/g, Kr = $f(
  (e10) => e10.replace(ZO, "-$1").toLowerCase()
), rl = $f((e10) => e10.charAt(0).toUpperCase() + e10.slice(1)), fa = $f(
  (e10) => e10 ? `on${rl(e10)}` : ""
), el = (e10, t) => !Object.is(e10, t), Es = (e10, ...t) => {
  for (let n = 0; n < e10.length; n++)
    e10[n](...t);
}, Rd = (e10, t, n, o = false) => {
  Object.defineProperty(e10, t, {
    configurable: true,
    enumerable: false,
    writable: o,
    value: n
  });
}, Nv = (e10) => {
  const t = parseFloat(e10);
  return isNaN(t) ? e10 : t;
}, QO = (e10) => {
  const t = Ve(e10) ? Number(e10) : NaN;
  return isNaN(t) ? e10 : t;
};
let Uy;
const qu = () => Uy || (Uy = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof __webpack_require__.g < "u" ? __webpack_require__.g : {});
function ze(e10) {
  if (Se(e10)) {
    const t = {};
    for (let n = 0; n < e10.length; n++) {
      const o = e10[n], r = Ve(o) ? o$(o) : ze(o);
      if (r)
        for (const a in r)
          t[a] = r[a];
    }
    return t;
  } else if (Ve(e10) || at(e10))
    return e10;
}
const e$ = /;(?![^(]*\))/g, t$ = /:([^]+)/, n$ = /\/\*[^]*?\*\//g;
function o$(e10) {
  const t = {};
  return e10.replace(n$, "").split(e$).forEach((n) => {
    if (n) {
      const o = n.split(t$);
      o.length > 1 && (t[o[0].trim()] = o[1].trim());
    }
  }), t;
}
function I(e10) {
  let t = "";
  if (Ve(e10))
    t = e10;
  else if (Se(e10))
    for (let n = 0; n < e10.length; n++) {
      const o = I(e10[n]);
      o && (t += o + " ");
    }
  else if (at(e10))
    for (const n in e10)
      e10[n] && (t += n + " ");
  return t.trim();
}
function Ao(e10) {
  if (!e10) return null;
  let { class: t, style: n } = e10;
  return t && !Ve(t) && (e10.class = I(t)), n && (e10.style = ze(n)), e10;
}
const r$ = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", a$ = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view", l$ = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics", s$ = /* @__PURE__ */ ka(r$), i$ = /* @__PURE__ */ ka(a$), u$ = /* @__PURE__ */ ka(l$), c$ = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", d$ = /* @__PURE__ */ ka(c$);
function Lw(e10) {
  return !!e10 || e10 === "";
}
function f$(e10, t) {
  if (e10.length !== t.length) return false;
  let n = true;
  for (let o = 0; n && o < e10.length; o++)
    n = qs(e10[o], t[o]);
  return n;
}
function qs(e10, t) {
  if (e10 === t) return true;
  let n = nl(e10), o = nl(t);
  if (n || o)
    return n && o ? e10.getTime() === t.getTime() : false;
  if (n = pr(e10), o = pr(t), n || o)
    return e10 === t;
  if (n = Se(e10), o = Se(t), n || o)
    return n && o ? f$(e10, t) : false;
  if (n = at(e10), o = at(t), n || o) {
    if (!n || !o)
      return false;
    const r = Object.keys(e10).length, a = Object.keys(t).length;
    if (r !== a)
      return false;
    for (const l in e10) {
      const s = e10.hasOwnProperty(l), u = t.hasOwnProperty(l);
      if (s && !u || !s && u || !qs(e10[l], t[l]))
        return false;
    }
  }
  return String(e10) === String(t);
}
function xw(e10, t) {
  return e10.findIndex((n) => qs(n, t));
}
const Dw = (e10) => !!(e10 && e10.__v_isRef === true), _e = (e10) => Ve(e10) ? e10 : e10 == null ? "" : Se(e10) || at(e10) && (e10.toString === Aw || !Fe(e10.toString)) ? Dw(e10) ? _e(e10.value) : JSON.stringify(e10, Vw, 2) : String(e10), Vw = (e10, t) => Dw(t) ? Vw(e10, t.value) : xl(t) ? {
  [`Map(${t.size})`]: [...t.entries()].reduce(
    (n, [o, r], a) => (n[Rp(o, a) + " =>"] = r, n),
    {}
  )
} : Of(t) ? {
  [`Set(${t.size})`]: [...t.values()].map((n) => Rp(n))
} : pr(t) ? Rp(t) : at(t) && !Se(t) && !iu(t) ? String(t) : t, Rp = (e10, t = "") => {
  var n;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    pr(e10) ? `Symbol(${(n = e10.description) != null ? n : t})` : e10
  );
};
/**
* @vue/reactivity v3.5.16
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function Go(e10, ...t) {
  console.warn(`[Vue warn] ${e10}`, ...t);
}
let Xn;
class Fw {
  constructor(t = false) {
    this.detached = t, this._active = true, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = false, this.parent = Xn, !t && Xn && (this.index = (Xn.scopes || (Xn.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = true;
      let t, n;
      if (this.scopes)
        for (t = 0, n = this.scopes.length; t < n; t++)
          this.scopes[t].pause();
      for (t = 0, n = this.effects.length; t < n; t++)
        this.effects[t].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = false;
      let t, n;
      if (this.scopes)
        for (t = 0, n = this.scopes.length; t < n; t++)
          this.scopes[t].resume();
      for (t = 0, n = this.effects.length; t < n; t++)
        this.effects[t].resume();
    }
  }
  run(t) {
    if (this._active) {
      const n = Xn;
      try {
        return Xn = this, t();
      } finally {
        Xn = n;
      }
    } else  true && Go("cannot run an inactive effect scope.");
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ++this._on === 1 && (this.prevScope = Xn, Xn = this);
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    this._on > 0 && --this._on === 0 && (Xn = this.prevScope, this.prevScope = void 0);
  }
  stop(t) {
    if (this._active) {
      this._active = false;
      let n, o;
      for (n = 0, o = this.effects.length; n < o; n++)
        this.effects[n].stop();
      for (this.effects.length = 0, n = 0, o = this.cleanups.length; n < o; n++)
        this.cleanups[n]();
      if (this.cleanups.length = 0, this.scopes) {
        for (n = 0, o = this.scopes.length; n < o; n++)
          this.scopes[n].stop(true);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !t) {
        const r = this.parent.scopes.pop();
        r && r !== this && (this.parent.scopes[this.index] = r, r.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function Bw(e10) {
  return new Fw(e10);
}
function Hw() {
  return Xn;
}
function zw(e10, t = false) {
  Xn ? Xn.cleanups.push(e10) :  true && !t && Go(
    "onScopeDispose() is called when there is no active effect scope to be associated with."
  );
}
let Jt;
const Ap = /* @__PURE__ */ new WeakSet();
class Kw {
  constructor(t) {
    this.fn = t, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, Xn && Xn.active && Xn.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, Ap.has(this) && (Ap.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || jw(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, Yy(this), Uw(this);
    const t = Jt, n = cr;
    Jt = this, cr = true;
    try {
      return this.fn();
    } finally {
       true && Jt !== this && Go(
        "Active effect was not restored correctly - this is likely a Vue internal bug."
      ), Yw(this), Jt = t, cr = n, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let t = this.deps; t; t = t.nextDep)
        Cm(t);
      this.deps = this.depsTail = void 0, Yy(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? Ap.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    Tv(this) && this.run();
  }
  get dirty() {
    return Tv(this);
  }
}
let Ww = 0, Xi, Ji;
function jw(e10, t = false) {
  if (e10.flags |= 8, t) {
    e10.next = Ji, Ji = e10;
    return;
  }
  e10.next = Xi, Xi = e10;
}
function _m() {
  Ww++;
}
function wm() {
  if (--Ww > 0)
    return;
  if (Ji) {
    let t = Ji;
    for (Ji = void 0; t; ) {
      const n = t.next;
      t.next = void 0, t.flags &= -9, t = n;
    }
  }
  let e10;
  for (; Xi; ) {
    let t = Xi;
    for (Xi = void 0; t; ) {
      const n = t.next;
      if (t.next = void 0, t.flags &= -9, t.flags & 1)
        try {
          t.trigger();
        } catch (o) {
          e10 || (e10 = o);
        }
      t = n;
    }
  }
  if (e10) throw e10;
}
function Uw(e10) {
  for (let t = e10.deps; t; t = t.nextDep)
    t.version = -1, t.prevActiveLink = t.dep.activeLink, t.dep.activeLink = t;
}
function Yw(e10) {
  let t, n = e10.depsTail, o = n;
  for (; o; ) {
    const r = o.prevDep;
    o.version === -1 ? (o === n && (n = r), Cm(o), p$(o)) : t = o, o.dep.activeLink = o.prevActiveLink, o.prevActiveLink = void 0, o = r;
  }
  e10.deps = t, e10.depsTail = n;
}
function Tv(e10) {
  for (let t = e10.deps; t; t = t.nextDep)
    if (t.dep.version !== t.version || t.dep.computed && (qw(t.dep.computed) || t.dep.version !== t.version))
      return true;
  return !!e10._dirty;
}
function qw(e10) {
  if (e10.flags & 4 && !(e10.flags & 16) || (e10.flags &= -17, e10.globalVersion === uu) || (e10.globalVersion = uu, !e10.isSSR && e10.flags & 128 && (!e10.deps && !e10._dirty || !Tv(e10))))
    return;
  e10.flags |= 2;
  const t = e10.dep, n = Jt, o = cr;
  Jt = e10, cr = true;
  try {
    Uw(e10);
    const r = e10.fn(e10._value);
    (t.version === 0 || el(r, e10._value)) && (e10.flags |= 128, e10._value = r, t.version++);
  } catch (r) {
    throw t.version++, r;
  } finally {
    Jt = n, cr = o, Yw(e10), e10.flags &= -3;
  }
}
function Cm(e10, t = false) {
  const { dep: n, prevSub: o, nextSub: r } = e10;
  if (o && (o.nextSub = r, e10.prevSub = void 0), r && (r.prevSub = o, e10.nextSub = void 0),  true && n.subsHead === e10 && (n.subsHead = r), n.subs === e10 && (n.subs = o, !o && n.computed)) {
    n.computed.flags &= -5;
    for (let a = n.computed.deps; a; a = a.nextDep)
      Cm(a, true);
  }
  !t && !--n.sc && n.map && n.map.delete(n.key);
}
function p$(e10) {
  const { prevDep: t, nextDep: n } = e10;
  t && (t.nextDep = n, e10.prevDep = void 0), n && (n.prevDep = t, e10.nextDep = void 0);
}
let cr = true;
const Gw = [];
function vr() {
  Gw.push(cr), cr = false;
}
function hr() {
  const e10 = Gw.pop();
  cr = e10 === void 0 ? true : e10;
}
function Yy(e10) {
  const { cleanup: t } = e10;
  if (e10.cleanup = void 0, t) {
    const n = Jt;
    Jt = void 0;
    try {
      t();
    } finally {
      Jt = n;
    }
  }
}
let uu = 0, v$ = class {
  constructor(t, n) {
    this.sub = t, this.dep = n, this.version = n.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
};
class If {
  constructor(t) {
    this.computed = t, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0,  true && (this.subsHead = void 0);
  }
  track(t) {
    if (!Jt || !cr || Jt === this.computed)
      return;
    let n = this.activeLink;
    if (n === void 0 || n.sub !== Jt)
      n = this.activeLink = new v$(Jt, this), Jt.deps ? (n.prevDep = Jt.depsTail, Jt.depsTail.nextDep = n, Jt.depsTail = n) : Jt.deps = Jt.depsTail = n, Xw(n);
    else if (n.version === -1 && (n.version = this.version, n.nextDep)) {
      const o = n.nextDep;
      o.prevDep = n.prevDep, n.prevDep && (n.prevDep.nextDep = o), n.prevDep = Jt.depsTail, n.nextDep = void 0, Jt.depsTail.nextDep = n, Jt.depsTail = n, Jt.deps === n && (Jt.deps = o);
    }
    return  true && Jt.onTrack && Jt.onTrack(
      gn(
        {
          effect: Jt
        },
        t
      )
    ), n;
  }
  trigger(t) {
    this.version++, uu++, this.notify(t);
  }
  notify(t) {
    _m();
    try {
      if (true)
        for (let n = this.subsHead; n; n = n.nextSub)
          n.sub.onTrigger && !(n.sub.flags & 8) && n.sub.onTrigger(
            gn(
              {
                effect: n.sub
              },
              t
            )
          );
      for (let n = this.subs; n; n = n.prevSub)
        n.sub.notify() && n.sub.dep.notify();
    } finally {
      wm();
    }
  }
}
function Xw(e10) {
  if (e10.dep.sc++, e10.sub.flags & 4) {
    const t = e10.dep.computed;
    if (t && !e10.dep.subs) {
      t.flags |= 20;
      for (let o = t.deps; o; o = o.nextDep)
        Xw(o);
    }
    const n = e10.dep.subs;
    n !== e10 && (e10.prevSub = n, n && (n.nextSub = e10)),  true && e10.dep.subsHead === void 0 && (e10.dep.subsHead = e10), e10.dep.subs = e10;
  }
}
const Ad = /* @__PURE__ */ new WeakMap(), Dl = Symbol(
   true ? "Object iterate" : 0
), Ov = Symbol(
   true ? "Map keys iterate" : 0
), cu = Symbol(
   true ? "Array iterate" : 0
);
function On(e10, t, n) {
  if (cr && Jt) {
    let o = Ad.get(e10);
    o || Ad.set(e10, o = /* @__PURE__ */ new Map());
    let r = o.get(n);
    r || (o.set(n, r = new If()), r.map = o, r.key = n),  true ? r.track({
      target: e10,
      type: t,
      key: n
    }) : 0;
  }
}
function Lr(e10, t, n, o, r, a) {
  const l = Ad.get(e10);
  if (!l) {
    uu++;
    return;
  }
  const s = (u) => {
    u && ( true ? u.trigger({
      target: e10,
      type: t,
      key: n,
      newValue: o,
      oldValue: r,
      oldTarget: a
    }) : 0);
  };
  if (_m(), t === "clear")
    l.forEach(s);
  else {
    const u = Se(e10), c = u && bm(n);
    if (u && n === "length") {
      const d = Number(o);
      l.forEach((f, p) => {
        (p === "length" || p === cu || !pr(p) && p >= d) && s(f);
      });
    } else
      switch ((n !== void 0 || l.has(void 0)) && s(l.get(n)), c && s(l.get(cu)), t) {
        case "add":
          u ? c && s(l.get("length")) : (s(l.get(Dl)), xl(e10) && s(l.get(Ov)));
          break;
        case "delete":
          u || (s(l.get(Dl)), xl(e10) && s(l.get(Ov)));
          break;
        case "set":
          xl(e10) && s(l.get(Dl));
          break;
      }
  }
  wm();
}
function h$(e10, t) {
  const n = Ad.get(e10);
  return n && n.get(t);
}
function ps(e10) {
  const t = Rt(e10);
  return t === e10 ? t : (On(t, "iterate", cu), ho(e10) ? t : t.map(Kn));
}
function Mf(e10) {
  return On(e10 = Rt(e10), "iterate", cu), e10;
}
const m$ = {
  __proto__: null,
  [Symbol.iterator]() {
    return Lp(this, Symbol.iterator, Kn);
  },
  concat(...e10) {
    return ps(this).concat(
      ...e10.map((t) => Se(t) ? ps(t) : t)
    );
  },
  entries() {
    return Lp(this, "entries", (e10) => (e10[1] = Kn(e10[1]), e10));
  },
  every(e10, t) {
    return la(this, "every", e10, t, void 0, arguments);
  },
  filter(e10, t) {
    return la(this, "filter", e10, t, (n) => n.map(Kn), arguments);
  },
  find(e10, t) {
    return la(this, "find", e10, t, Kn, arguments);
  },
  findIndex(e10, t) {
    return la(this, "findIndex", e10, t, void 0, arguments);
  },
  findLast(e10, t) {
    return la(this, "findLast", e10, t, Kn, arguments);
  },
  findLastIndex(e10, t) {
    return la(this, "findLastIndex", e10, t, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(e10, t) {
    return la(this, "forEach", e10, t, void 0, arguments);
  },
  includes(...e10) {
    return xp(this, "includes", e10);
  },
  indexOf(...e10) {
    return xp(this, "indexOf", e10);
  },
  join(e10) {
    return ps(this).join(e10);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...e10) {
    return xp(this, "lastIndexOf", e10);
  },
  map(e10, t) {
    return la(this, "map", e10, t, void 0, arguments);
  },
  pop() {
    return Li(this, "pop");
  },
  push(...e10) {
    return Li(this, "push", e10);
  },
  reduce(e10, ...t) {
    return qy(this, "reduce", e10, t);
  },
  reduceRight(e10, ...t) {
    return qy(this, "reduceRight", e10, t);
  },
  shift() {
    return Li(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(e10, t) {
    return la(this, "some", e10, t, void 0, arguments);
  },
  splice(...e10) {
    return Li(this, "splice", e10);
  },
  toReversed() {
    return ps(this).toReversed();
  },
  toSorted(e10) {
    return ps(this).toSorted(e10);
  },
  toSpliced(...e10) {
    return ps(this).toSpliced(...e10);
  },
  unshift(...e10) {
    return Li(this, "unshift", e10);
  },
  values() {
    return Lp(this, "values", Kn);
  }
};
function Lp(e10, t, n) {
  const o = Mf(e10), r = o[t]();
  return o !== e10 && !ho(e10) && (r._next = r.next, r.next = () => {
    const a = r._next();
    return a.value && (a.value = n(a.value)), a;
  }), r;
}
const g$ = Array.prototype;
function la(e10, t, n, o, r, a) {
  const l = Mf(e10), s = l !== e10 && !ho(e10), u = l[t];
  if (u !== g$[t]) {
    const f = u.apply(e10, a);
    return s ? Kn(f) : f;
  }
  let c = n;
  l !== e10 && (s ? c = function(f, p) {
    return n.call(this, Kn(f), p, e10);
  } : n.length > 2 && (c = function(f, p) {
    return n.call(this, f, p, e10);
  }));
  const d = u.call(l, c, o);
  return s && r ? r(d) : d;
}
function qy(e10, t, n, o) {
  const r = Mf(e10);
  let a = n;
  return r !== e10 && (ho(e10) ? n.length > 3 && (a = function(l, s, u) {
    return n.call(this, l, s, u, e10);
  }) : a = function(l, s, u) {
    return n.call(this, l, Kn(s), u, e10);
  }), r[t](a, ...o);
}
function xp(e10, t, n) {
  const o = Rt(e10);
  On(o, "iterate", cu);
  const r = o[t](...n);
  return (r === -1 || r === false) && du(n[0]) ? (n[0] = Rt(n[0]), o[t](...n)) : r;
}
function Li(e10, t, n = []) {
  vr(), _m();
  const o = Rt(e10)[t].apply(e10, n);
  return wm(), hr(), o;
}
const y$ = /* @__PURE__ */ ka("__proto__,__v_isRef,__isVue"), Jw = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((e10) => e10 !== "arguments" && e10 !== "caller").map((e10) => Symbol[e10]).filter(pr)
);
function b$(e10) {
  pr(e10) || (e10 = String(e10));
  const t = Rt(this);
  return On(t, "has", e10), t.hasOwnProperty(e10);
}
class Zw {
  constructor(t = false, n = false) {
    this._isReadonly = t, this._isShallow = n;
  }
  get(t, n, o) {
    if (n === "__v_skip") return t.__v_skip;
    const r = this._isReadonly, a = this._isShallow;
    if (n === "__v_isReactive")
      return !r;
    if (n === "__v_isReadonly")
      return r;
    if (n === "__v_isShallow")
      return a;
    if (n === "__v_raw")
      return o === (r ? a ? rC : oC : a ? nC : tC).get(t) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(t) === Object.getPrototypeOf(o) ? t : void 0;
    const l = Se(t);
    if (!r) {
      let u;
      if (l && (u = m$[n]))
        return u;
      if (n === "hasOwnProperty")
        return b$;
    }
    const s = Reflect.get(
      t,
      n,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      Ot(t) ? t : o
    );
    return (pr(n) ? Jw.has(n) : y$(n)) || (r || On(t, "get", n), a) ? s : Ot(s) ? l && bm(n) ? s : s.value : at(s) ? r ? yi(s) : It(s) : s;
  }
}
class Qw extends Zw {
  constructor(t = false) {
    super(false, t);
  }
  set(t, n, o, r) {
    let a = t[n];
    if (!this._isShallow) {
      const u = Wr(a);
      if (!ho(o) && !Wr(o) && (a = Rt(a), o = Rt(o)), !Se(t) && Ot(a) && !Ot(o))
        return u ? false : (a.value = o, true);
    }
    const l = Se(t) && bm(n) ? Number(n) < t.length : Tt(t, n), s = Reflect.set(
      t,
      n,
      o,
      Ot(t) ? t : r
    );
    return t === Rt(r) && (l ? el(o, a) && Lr(t, "set", n, o, a) : Lr(t, "add", n, o)), s;
  }
  deleteProperty(t, n) {
    const o = Tt(t, n), r = t[n], a = Reflect.deleteProperty(t, n);
    return a && o && Lr(t, "delete", n, void 0, r), a;
  }
  has(t, n) {
    const o = Reflect.has(t, n);
    return (!pr(n) || !Jw.has(n)) && On(t, "has", n), o;
  }
  ownKeys(t) {
    return On(
      t,
      "iterate",
      Se(t) ? "length" : Dl
    ), Reflect.ownKeys(t);
  }
}
class eC extends Zw {
  constructor(t = false) {
    super(true, t);
  }
  set(t, n) {
    return  true && Go(
      `Set operation on key "${String(n)}" failed: target is readonly.`,
      t
    ), true;
  }
  deleteProperty(t, n) {
    return  true && Go(
      `Delete operation on key "${String(n)}" failed: target is readonly.`,
      t
    ), true;
  }
}
const _$ = /* @__PURE__ */ new Qw(), w$ = /* @__PURE__ */ new eC(), C$ = /* @__PURE__ */ new Qw(true), E$ = /* @__PURE__ */ new eC(true), $v = (e10) => e10, Nc = (e10) => Reflect.getPrototypeOf(e10);
function S$(e10, t, n) {
  return function(...o) {
    const r = this.__v_raw, a = Rt(r), l = xl(a), s = e10 === "entries" || e10 === Symbol.iterator && l, u = e10 === "keys" && l, c = r[e10](...o), d = n ? $v : t ? Ld : Kn;
    return !t && On(
      a,
      "iterate",
      u ? Ov : Dl
    ), {
      // iterator protocol
      next() {
        const { value: f, done: p } = c.next();
        return p ? { value: f, done: p } : {
          value: s ? [d(f[0]), d(f[1])] : d(f),
          done: p
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function Tc(e10) {
  return function(...t) {
    if (true) {
      const n = t[0] ? `on key "${t[0]}" ` : "";
      Go(
        `${rl(e10)} operation ${n}failed: target is readonly.`,
        Rt(this)
      );
    }
    return e10 === "delete" ? false : e10 === "clear" ? void 0 : this;
  };
}
function k$(e10, t) {
  const n = {
    get(r) {
      const a = this.__v_raw, l = Rt(a), s = Rt(r);
      e10 || (el(r, s) && On(l, "get", r), On(l, "get", s));
      const { has: u } = Nc(l), c = t ? $v : e10 ? Ld : Kn;
      if (u.call(l, r))
        return c(a.get(r));
      if (u.call(l, s))
        return c(a.get(s));
      a !== l && a.get(r);
    },
    get size() {
      const r = this.__v_raw;
      return !e10 && On(Rt(r), "iterate", Dl), Reflect.get(r, "size", r);
    },
    has(r) {
      const a = this.__v_raw, l = Rt(a), s = Rt(r);
      return e10 || (el(r, s) && On(l, "has", r), On(l, "has", s)), r === s ? a.has(r) : a.has(r) || a.has(s);
    },
    forEach(r, a) {
      const l = this, s = l.__v_raw, u = Rt(s), c = t ? $v : e10 ? Ld : Kn;
      return !e10 && On(u, "iterate", Dl), s.forEach((d, f) => r.call(a, c(d), c(f), l));
    }
  };
  return gn(
    n,
    e10 ? {
      add: Tc("add"),
      set: Tc("set"),
      delete: Tc("delete"),
      clear: Tc("clear")
    } : {
      add(r) {
        !t && !ho(r) && !Wr(r) && (r = Rt(r));
        const a = Rt(this);
        return Nc(a).has.call(a, r) || (a.add(r), Lr(a, "add", r, r)), this;
      },
      set(r, a) {
        !t && !ho(a) && !Wr(a) && (a = Rt(a));
        const l = Rt(this), { has: s, get: u } = Nc(l);
        let c = s.call(l, r);
        c ?  true && Gy(l, s, r) : (r = Rt(r), c = s.call(l, r));
        const d = u.call(l, r);
        return l.set(r, a), c ? el(a, d) && Lr(l, "set", r, a, d) : Lr(l, "add", r, a), this;
      },
      delete(r) {
        const a = Rt(this), { has: l, get: s } = Nc(a);
        let u = l.call(a, r);
        u ?  true && Gy(a, l, r) : (r = Rt(r), u = l.call(a, r));
        const c = s ? s.call(a, r) : void 0, d = a.delete(r);
        return u && Lr(a, "delete", r, void 0, c), d;
      },
      clear() {
        const r = Rt(this), a = r.size !== 0, l =  true ? xl(r) ? new Map(r) : new Set(r) : 0, s = r.clear();
        return a && Lr(
          r,
          "clear",
          void 0,
          void 0,
          l
        ), s;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((r) => {
    n[r] = S$(r, e10, t);
  }), n;
}
function Pf(e10, t) {
  const n = k$(e10, t);
  return (o, r, a) => r === "__v_isReactive" ? !e10 : r === "__v_isReadonly" ? e10 : r === "__v_raw" ? o : Reflect.get(
    Tt(n, r) && r in o ? n : o,
    r,
    a
  );
}
const N$ = {
  get: /* @__PURE__ */ Pf(false, false)
}, T$ = {
  get: /* @__PURE__ */ Pf(false, true)
}, O$ = {
  get: /* @__PURE__ */ Pf(true, false)
}, $$ = {
  get: /* @__PURE__ */ Pf(true, true)
};
function Gy(e10, t, n) {
  const o = Rt(n);
  if (o !== n && t.call(e10, o)) {
    const r = ym(e10);
    Go(
      `Reactive ${r} contains both the raw and reactive versions of the same object${r === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}
const tC = /* @__PURE__ */ new WeakMap(), nC = /* @__PURE__ */ new WeakMap(), oC = /* @__PURE__ */ new WeakMap(), rC = /* @__PURE__ */ new WeakMap();
function I$(e10) {
  switch (e10) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function M$(e10) {
  return e10.__v_skip || !Object.isExtensible(e10) ? 0 : I$(ym(e10));
}
function It(e10) {
  return Wr(e10) ? e10 : Rf(
    e10,
    false,
    _$,
    N$,
    tC
  );
}
function aC(e10) {
  return Rf(
    e10,
    false,
    C$,
    T$,
    nC
  );
}
function yi(e10) {
  return Rf(
    e10,
    true,
    w$,
    O$,
    oC
  );
}
function Vr(e10) {
  return Rf(
    e10,
    true,
    E$,
    $$,
    rC
  );
}
function Rf(e10, t, n, o, r) {
  if (!at(e10))
    return  true && Go(
      `value cannot be made ${t ? "readonly" : "reactive"}: ${String(
        e10
      )}`
    ), e10;
  if (e10.__v_raw && !(t && e10.__v_isReactive))
    return e10;
  const a = M$(e10);
  if (a === 0)
    return e10;
  const l = r.get(e10);
  if (l)
    return l;
  const s = new Proxy(
    e10,
    a === 2 ? o : n
  );
  return r.set(e10, s), s;
}
function Vl(e10) {
  return Wr(e10) ? Vl(e10.__v_raw) : !!(e10 && e10.__v_isReactive);
}
function Wr(e10) {
  return !!(e10 && e10.__v_isReadonly);
}
function ho(e10) {
  return !!(e10 && e10.__v_isShallow);
}
function du(e10) {
  return e10 ? !!e10.__v_raw : false;
}
function Rt(e10) {
  const t = e10 && e10.__v_raw;
  return t ? Rt(t) : e10;
}
function ya(e10) {
  return !Tt(e10, "__v_skip") && Object.isExtensible(e10) && Rd(e10, "__v_skip", true), e10;
}
const Kn = (e10) => at(e10) ? It(e10) : e10, Ld = (e10) => at(e10) ? yi(e10) : e10;
function Ot(e10) {
  return e10 ? e10.__v_isRef === true : false;
}
function L(e10) {
  return lC(e10, false);
}
function qt(e10) {
  return lC(e10, true);
}
function lC(e10, t) {
  return Ot(e10) ? e10 : new P$(e10, t);
}
class P$ {
  constructor(t, n) {
    this.dep = new If(), this.__v_isRef = true, this.__v_isShallow = false, this._rawValue = n ? t : Rt(t), this._value = n ? t : Kn(t), this.__v_isShallow = n;
  }
  get value() {
    return  true ? this.dep.track({
      target: this,
      type: "get",
      key: "value"
    }) : 0, this._value;
  }
  set value(t) {
    const n = this._rawValue, o = this.__v_isShallow || ho(t) || Wr(t);
    t = o ? t : Rt(t), el(t, n) && (this._rawValue = t, this._value = o ? t : Kn(t),  true ? this.dep.trigger({
      target: this,
      type: "set",
      key: "value",
      newValue: t,
      oldValue: n
    }) : 0);
  }
}
function i(e10) {
  return Ot(e10) ? e10.value : e10;
}
const R$ = {
  get: (e10, t, n) => t === "__v_raw" ? e10 : i(Reflect.get(e10, t, n)),
  set: (e10, t, n, o) => {
    const r = e10[t];
    return Ot(r) && !Ot(n) ? (r.value = n, true) : Reflect.set(e10, t, n, o);
  }
};
function sC(e10) {
  return Vl(e10) ? e10 : new Proxy(e10, R$);
}
class A$ {
  constructor(t) {
    this.__v_isRef = true, this._value = void 0;
    const n = this.dep = new If(), { get: o, set: r } = t(n.track.bind(n), n.trigger.bind(n));
    this._get = o, this._set = r;
  }
  get value() {
    return this._value = this._get();
  }
  set value(t) {
    this._set(t);
  }
}
function L$(e10) {
  return new A$(e10);
}
function Tn(e10) {
   true && !du(e10) && Go("toRefs() expects a reactive object but received a plain one.");
  const t = Se(e10) ? new Array(e10.length) : {};
  for (const n in e10)
    t[n] = iC(e10, n);
  return t;
}
class x$ {
  constructor(t, n, o) {
    this._object = t, this._key = n, this._defaultValue = o, this.__v_isRef = true, this._value = void 0;
  }
  get value() {
    const t = this._object[this._key];
    return this._value = t === void 0 ? this._defaultValue : t;
  }
  set value(t) {
    this._object[this._key] = t;
  }
  get dep() {
    return h$(Rt(this._object), this._key);
  }
}
class D$ {
  constructor(t) {
    this._getter = t, this.__v_isRef = true, this.__v_isReadonly = true, this._value = void 0;
  }
  get value() {
    return this._value = this._getter();
  }
}
function Lt(e10, t, n) {
  return Ot(e10) ? e10 : Fe(e10) ? new D$(e10) : at(e10) && arguments.length > 1 ? iC(e10, t, n) : L(e10);
}
function iC(e10, t, n) {
  const o = e10[t];
  return Ot(o) ? o : new x$(e10, t, n);
}
class V$ {
  constructor(t, n, o) {
    this.fn = t, this.setter = n, this._value = void 0, this.dep = new If(this), this.__v_isRef = true, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = uu - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !n, this.isSSR = o;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    Jt !== this)
      return jw(this, true), true;
    "development";
  }
  get value() {
    const t =  true ? this.dep.track({
      target: this,
      type: "get",
      key: "value"
    }) : 0;
    return qw(this), t && (t.version = this.dep.version), this._value;
  }
  set value(t) {
    this.setter ? this.setter(t) :  true && Go("Write operation failed: computed value is readonly");
  }
}
function F$(e10, t, n = false) {
  let o, r;
  Fe(e10) ? o = e10 : (o = e10.get, r = e10.set);
  const a = new V$(o, r, n);
  return "development", a;
}
const Oc = {}, xd = /* @__PURE__ */ new WeakMap();
let Sl;
function B$(e10, t = false, n = Sl) {
  if (n) {
    let o = xd.get(n);
    o || xd.set(n, o = []), o.push(e10);
  } else  true && !t && Go(
    "onWatcherCleanup() was called when there was no active watcher to associate with."
  );
}
function H$(e10, t, n = Zt) {
  const { immediate: o, deep: r, once: a, scheduler: l, augmentJob: s, call: u } = n, c = (C) => {
    (n.onWarn || Go)(
      "Invalid watch source: ",
      C,
      "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types."
    );
  }, d = (C) => r ? C : ho(C) || r === false || r === 0 ? va(C, 1) : va(C);
  let f, p, v, m, h = false, b = false;
  if (Ot(e10) ? (p = () => e10.value, h = ho(e10)) : Vl(e10) ? (p = () => d(e10), h = true) : Se(e10) ? (b = true, h = e10.some((C) => Vl(C) || ho(C)), p = () => e10.map((C) => {
    if (Ot(C))
      return C.value;
    if (Vl(C))
      return d(C);
    if (Fe(C))
      return u ? u(C, 2) : C();
     true && c(C);
  })) : Fe(e10) ? t ? p = u ? () => u(e10, 2) : e10 : p = () => {
    if (v) {
      vr();
      try {
        v();
      } finally {
        hr();
      }
    }
    const C = Sl;
    Sl = f;
    try {
      return u ? u(e10, 3, [m]) : e10(m);
    } finally {
      Sl = C;
    }
  } : (p = Mt,  true && c(e10)), t && r) {
    const C = p, E = r === true ? 1 / 0 : r;
    p = () => va(C(), E);
  }
  const g = Hw(), w = () => {
    f.stop(), g && g.active && gm(g.effects, f);
  };
  if (a && t) {
    const C = t;
    t = (...E) => {
      C(...E), w();
    };
  }
  let y = b ? new Array(e10.length).fill(Oc) : Oc;
  const _ = (C) => {
    if (!(!(f.flags & 1) || !f.dirty && !C))
      if (t) {
        const E = f.run();
        if (r || h || (b ? E.some((T, O) => el(T, y[O])) : el(E, y))) {
          v && v();
          const T = Sl;
          Sl = f;
          try {
            const O = [
              E,
              // pass undefined as the old value when it's changed for the first time
              y === Oc ? void 0 : b && y[0] === Oc ? [] : y,
              m
            ];
            y = E, u ? u(t, 3, O) : (
              // @ts-expect-error
              t(...O)
            );
          } finally {
            Sl = T;
          }
        }
      } else
        f.run();
  };
  return s && s(_), f = new Kw(p), f.scheduler = l ? () => l(_, false) : _, m = (C) => B$(C, false, f), v = f.onStop = () => {
    const C = xd.get(f);
    if (C) {
      if (u)
        u(C, 4);
      else
        for (const E of C) E();
      xd.delete(f);
    }
  },  true && (f.onTrack = n.onTrack, f.onTrigger = n.onTrigger), t ? o ? _(true) : y = f.run() : l ? l(_.bind(null, true), true) : f.run(), w.pause = f.pause.bind(f), w.resume = f.resume.bind(f), w.stop = w, w;
}
function va(e10, t = 1 / 0, n) {
  if (t <= 0 || !at(e10) || e10.__v_skip || (n = n || /* @__PURE__ */ new Set(), n.has(e10)))
    return e10;
  if (n.add(e10), t--, Ot(e10))
    va(e10.value, t, n);
  else if (Se(e10))
    for (let o = 0; o < e10.length; o++)
      va(e10[o], t, n);
  else if (Of(e10) || xl(e10))
    e10.forEach((o) => {
      va(o, t, n);
    });
  else if (iu(e10)) {
    for (const o in e10)
      va(e10[o], t, n);
    for (const o of Object.getOwnPropertySymbols(e10))
      Object.prototype.propertyIsEnumerable.call(e10, o) && va(e10[o], t, n);
  }
  return e10;
}
/**
* @vue/runtime-core v3.5.16
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const Fl = [];
function Zc(e10) {
  Fl.push(e10);
}
function Qc() {
  Fl.pop();
}
let Dp = false;
function Je(e10, ...t) {
  if (Dp) return;
  Dp = true, vr();
  const n = Fl.length ? Fl[Fl.length - 1].component : null, o = n && n.appContext.config.warnHandler, r = z$();
  if (o)
    bi(
      o,
      n,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        e10 + t.map((a) => {
          var l, s;
          return (s = (l = a.toString) == null ? void 0 : l.call(a)) != null ? s : JSON.stringify(a);
        }).join(""),
        n && n.proxy,
        r.map(
          ({ vnode: a }) => `at <${Hf(n, a.type)}>`
        ).join(`
`),
        r
      ]
    );
  else {
    const a = [`[Vue warn]: ${e10}`, ...t];
    r.length && a.push(`
`, ...K$(r)), console.warn(...a);
  }
  hr(), Dp = false;
}
function z$() {
  let e10 = Fl[Fl.length - 1];
  if (!e10)
    return [];
  const t = [];
  for (; e10; ) {
    const n = t[0];
    n && n.vnode === e10 ? n.recurseCount++ : t.push({
      vnode: e10,
      recurseCount: 0
    });
    const o = e10.component && e10.component.parent;
    e10 = o && o.vnode;
  }
  return t;
}
function K$(e10) {
  const t = [];
  return e10.forEach((n, o) => {
    t.push(...o === 0 ? [] : [`
`], ...W$(n));
  }), t;
}
function W$({ vnode: e10, recurseCount: t }) {
  const n = t > 0 ? `... (${t} recursive calls)` : "", o = e10.component ? e10.component.parent == null : false, r = ` at <${Hf(
    e10.component,
    e10.type,
    o
  )}`, a = ">" + n;
  return e10.props ? [r, ...j$(e10.props), a] : [r + a];
}
function j$(e10) {
  const t = [], n = Object.keys(e10);
  return n.slice(0, 3).forEach((o) => {
    t.push(...uC(o, e10[o]));
  }), n.length > 3 && t.push(" ..."), t;
}
function uC(e10, t, n) {
  return Ve(t) ? (t = JSON.stringify(t), n ? t : [`${e10}=${t}`]) : typeof t == "number" || typeof t == "boolean" || t == null ? n ? t : [`${e10}=${t}`] : Ot(t) ? (t = uC(e10, Rt(t.value), true), n ? t : [`${e10}=Ref<`, t, ">"]) : Fe(t) ? [`${e10}=fn${t.name ? `<${t.name}>` : ""}`] : (t = Rt(t), n ? t : [`${e10}=`, t]);
}
function U$(e10, t) {
   true && e10 !== void 0 && (typeof e10 != "number" ? Je(`${t} is not a valid number - got ${JSON.stringify(e10)}.`) : isNaN(e10) && Je(`${t} is NaN - the duration expression might be incorrect.`));
}
const Em = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  0: "setup function",
  1: "render function",
  2: "watcher getter",
  3: "watcher callback",
  4: "watcher cleanup function",
  5: "native event handler",
  6: "component event handler",
  7: "vnode hook",
  8: "directive hook",
  9: "transition hook",
  10: "app errorHandler",
  11: "app warnHandler",
  12: "ref function",
  13: "async component loader",
  14: "scheduler flush",
  15: "component update",
  16: "app unmount cleanup function"
};
function bi(e10, t, n, o) {
  try {
    return o ? e10(...o) : e10();
  } catch (r) {
    Gu(r, t, n);
  }
}
function mr(e10, t, n, o) {
  if (Fe(e10)) {
    const r = bi(e10, t, n, o);
    return r && ol(r) && r.catch((a) => {
      Gu(a, t, n);
    }), r;
  }
  if (Se(e10)) {
    const r = [];
    for (let a = 0; a < e10.length; a++)
      r.push(mr(e10[a], t, n, o));
    return r;
  } else  true && Je(
    `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof e10}`
  );
}
function Gu(e10, t, n, o = true) {
  const r = t ? t.vnode : null, { errorHandler: a, throwUnhandledErrorInProduction: l } = t && t.appContext.config || Zt;
  if (t) {
    let s = t.parent;
    const u = t.proxy, c =  true ? Em[n] : 0;
    for (; s; ) {
      const d = s.ec;
      if (d) {
        for (let f = 0; f < d.length; f++)
          if (d[f](e10, u, c) === false)
            return;
      }
      s = s.parent;
    }
    if (a) {
      vr(), bi(a, null, 10, [
        e10,
        u,
        c
      ]), hr();
      return;
    }
  }
  Y$(e10, n, r, o, l);
}
function Y$(e10, t, n, o = true, r = false) {
  if (true) {
    const a = Em[t];
    if (n && Zc(n), Je(`Unhandled error${a ? ` during execution of ${a}` : ""}`), n && Qc(), o)
      throw e10;
    console.error(e10);
  } else // removed by dead control flow
{}
}
const fo = [];
let Ar = -1;
const Ls = [];
let Ua = null, Ss = 0;
const cC = /* @__PURE__ */ Promise.resolve();
let Dd = null;
const q$ = 100;
function He(e10) {
  const t = Dd || cC;
  return e10 ? t.then(this ? e10.bind(this) : e10) : t;
}
function G$(e10) {
  let t = Ar + 1, n = fo.length;
  for (; t < n; ) {
    const o = t + n >>> 1, r = fo[o], a = fu(r);
    a < e10 || a === e10 && r.flags & 2 ? t = o + 1 : n = o;
  }
  return t;
}
function Af(e10) {
  if (!(e10.flags & 1)) {
    const t = fu(e10), n = fo[fo.length - 1];
    !n || // fast path when the job id is larger than the tail
    !(e10.flags & 2) && t >= fu(n) ? fo.push(e10) : fo.splice(G$(t), 0, e10), e10.flags |= 1, dC();
  }
}
function dC() {
  Dd || (Dd = cC.then(vC));
}
function fC(e10) {
  Se(e10) ? Ls.push(...e10) : Ua && e10.id === -1 ? Ua.splice(Ss + 1, 0, e10) : e10.flags & 1 || (Ls.push(e10), e10.flags |= 1), dC();
}
function Xy(e10, t, n = Ar + 1) {
  for ( true && (t = t || /* @__PURE__ */ new Map()); n < fo.length; n++) {
    const o = fo[n];
    if (o && o.flags & 2) {
      if (e10 && o.id !== e10.uid ||  true && Sm(t, o))
        continue;
      fo.splice(n, 1), n--, o.flags & 4 && (o.flags &= -2), o(), o.flags & 4 || (o.flags &= -2);
    }
  }
}
function pC(e10) {
  if (Ls.length) {
    const t = [...new Set(Ls)].sort(
      (n, o) => fu(n) - fu(o)
    );
    if (Ls.length = 0, Ua) {
      Ua.push(...t);
      return;
    }
    for (Ua = t,  true && (e10 = e10 || /* @__PURE__ */ new Map()), Ss = 0; Ss < Ua.length; Ss++) {
      const n = Ua[Ss];
       true && Sm(e10, n) || (n.flags & 4 && (n.flags &= -2), n.flags & 8 || n(), n.flags &= -2);
    }
    Ua = null, Ss = 0;
  }
}
const fu = (e10) => e10.id == null ? e10.flags & 2 ? -1 : 1 / 0 : e10.id;
function vC(e10) {
   true && (e10 = e10 || /* @__PURE__ */ new Map());
  const t =  true ? (n) => Sm(e10, n) : 0;
  try {
    for (Ar = 0; Ar < fo.length; Ar++) {
      const n = fo[Ar];
      if (n && !(n.flags & 8)) {
        if ( true && t(n))
          continue;
        n.flags & 4 && (n.flags &= -2), bi(
          n,
          n.i,
          n.i ? 15 : 14
        ), n.flags & 4 || (n.flags &= -2);
      }
    }
  } finally {
    for (; Ar < fo.length; Ar++) {
      const n = fo[Ar];
      n && (n.flags &= -2);
    }
    Ar = -1, fo.length = 0, pC(e10), Dd = null, (fo.length || Ls.length) && vC(e10);
  }
}
function Sm(e10, t) {
  const n = e10.get(t) || 0;
  if (n > q$) {
    const o = t.i, r = o && Lm(o.type);
    return Gu(
      `Maximum recursive updates exceeded${r ? ` in component <${r}>` : ""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
      null,
      10
    ), true;
  }
  return e10.set(t, n + 1), false;
}
let lr = false;
const ed = /* @__PURE__ */ new Map();
 true && (qu().__VUE_HMR_RUNTIME__ = {
  createRecord: Vp(hC),
  rerender: Vp(Z$),
  reload: Vp(Q$)
});
const Yl = /* @__PURE__ */ new Map();
function X$(e10) {
  const t = e10.type.__hmrId;
  let n = Yl.get(t);
  n || (hC(t, e10.type), n = Yl.get(t)), n.instances.add(e10);
}
function J$(e10) {
  Yl.get(e10.type.__hmrId).instances.delete(e10);
}
function hC(e10, t) {
  return Yl.has(e10) ? false : (Yl.set(e10, {
    initialDef: Vd(t),
    instances: /* @__PURE__ */ new Set()
  }), true);
}
function Vd(e10) {
  return sE(e10) ? e10.__vccOpts : e10;
}
function Z$(e10, t) {
  const n = Yl.get(e10);
  n && (n.initialDef.render = t, [...n.instances].forEach((o) => {
    t && (o.render = t, Vd(o.type).render = t), o.renderCache = [], lr = true, o.update(), lr = false;
  }));
}
function Q$(e10, t) {
  const n = Yl.get(e10);
  if (!n) return;
  t = Vd(t), Jy(n.initialDef, t);
  const o = [...n.instances];
  for (let r = 0; r < o.length; r++) {
    const a = o[r], l = Vd(a.type);
    let s = ed.get(l);
    s || (l !== n.initialDef && Jy(l, t), ed.set(l, s = /* @__PURE__ */ new Set())), s.add(a), a.appContext.propsCache.delete(a.type), a.appContext.emitsCache.delete(a.type), a.appContext.optionsCache.delete(a.type), a.ceReload ? (s.add(a), a.ceReload(t.styles), s.delete(a)) : a.parent ? Af(() => {
      lr = true, a.parent.update(), lr = false, s.delete(a);
    }) : a.appContext.reload ? a.appContext.reload() : typeof window < "u" ? window.location.reload() : console.warn(
      "[HMR] Root or manually mounted instance modified. Full reload required."
    ), a.root.ce && a !== a.root && a.root.ce._removeChildStyle(l);
  }
  fC(() => {
    ed.clear();
  });
}
function Jy(e10, t) {
  gn(e10, t);
  for (const n in e10)
    n !== "__file" && !(n in t) && delete e10[n];
}
function Vp(e10) {
  return (t, n) => {
    try {
      return e10(t, n);
    } catch (o) {
      console.error(o), console.warn(
        "[HMR] Something went wrong during Vue component hot-reload. Full reload required."
      );
    }
  };
}
let ar, Wi = [], Iv = false;
function Xu(e10, ...t) {
  ar ? ar.emit(e10, ...t) : Iv || Wi.push({ event: e10, args: t });
}
function km(e10, t) {
  var n, o;
  ar = e10, ar ? (ar.enabled = true, Wi.forEach(({ event: r, args: a }) => ar.emit(r, ...a)), Wi = []) : (
    /* handle late devtools injection - only do this if we are in an actual */
    /* browser environment to avoid the timer handle stalling test runner exit */
    /* (#4815) */
    typeof window < "u" && // some envs mock window but not fully
    window.HTMLElement && // also exclude jsdom
    // eslint-disable-next-line no-restricted-syntax
    !((o = (n = window.navigator) == null ? void 0 : n.userAgent) != null && o.includes("jsdom")) ? ((t.__VUE_DEVTOOLS_HOOK_REPLAY__ = t.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((a) => {
      km(a, t);
    }), setTimeout(() => {
      ar || (t.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, Iv = true, Wi = []);
    }, 3e3)) : (Iv = true, Wi = [])
  );
}
function eI(e10, t) {
  Xu("app:init", e10, t, {
    Fragment: Ie,
    Text: Zr,
    Comment: tn,
    Static: nd
  });
}
function tI(e10) {
  Xu("app:unmount", e10);
}
const nI = /* @__PURE__ */ Nm(
  "component:added"
  /* COMPONENT_ADDED */
), mC = /* @__PURE__ */ Nm(
  "component:updated"
  /* COMPONENT_UPDATED */
), oI = /* @__PURE__ */ Nm(
  "component:removed"
  /* COMPONENT_REMOVED */
), rI = (e10) => {
  ar && typeof ar.cleanupBuffer == "function" && // remove the component if it wasn't buffered
  !ar.cleanupBuffer(e10) && oI(e10);
};
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function Nm(e10) {
  return (t) => {
    Xu(
      e10,
      t.appContext.app,
      t.uid,
      t.parent ? t.parent.uid : void 0,
      t
    );
  };
}
const aI = /* @__PURE__ */ gC(
  "perf:start"
  /* PERFORMANCE_START */
), lI = /* @__PURE__ */ gC(
  "perf:end"
  /* PERFORMANCE_END */
);
function gC(e10) {
  return (t, n, o) => {
    Xu(e10, t.appContext.app, t.uid, t, n, o);
  };
}
function sI(e10, t, n) {
  Xu(
    "component:emit",
    e10.appContext.app,
    e10,
    t,
    n
  );
}
let Cn = null, yC = null;
function Fd(e10) {
  const t = Cn;
  return Cn = e10, yC = e10 && e10.type.__scopeId || null, t;
}
function H(e10, t = Cn, n) {
  if (!t || e10._n)
    return e10;
  const o = (...r) => {
    o._d && vb(-1);
    const a = Fd(t);
    let l;
    try {
      l = e10(...r);
    } finally {
      Fd(a), o._d && vb(1);
    }
    return  true && mC(t), l;
  };
  return o._n = true, o._c = true, o._d = true, o;
}
function bC(e10) {
  XO(e10) && Je("Do not use built-in directive ids as custom directive id: " + e10);
}
function lt(e10, t) {
  if (Cn === null)
    return  true && Je("withDirectives can only be used inside render functions."), e10;
  const n = Bf(Cn), o = e10.dirs || (e10.dirs = []);
  for (let r = 0; r < t.length; r++) {
    let [a, l, s, u = Zt] = t[r];
    a && (Fe(a) && (a = {
      mounted: a,
      updated: a
    }), a.deep && va(l), o.push({
      dir: a,
      instance: n,
      value: l,
      oldValue: void 0,
      arg: s,
      modifiers: u
    }));
  }
  return e10;
}
function _l(e10, t, n, o) {
  const r = e10.dirs, a = t && t.dirs;
  for (let l = 0; l < r.length; l++) {
    const s = r[l];
    a && (s.oldValue = a[l].value);
    let u = s.dir[o];
    u && (vr(), mr(u, n, 8, [
      e10.el,
      s,
      e10,
      t
    ]), hr());
  }
}
const _C = Symbol("_vte"), wC = (e10) => e10.__isTeleport, Bl = (e10) => e10 && (e10.disabled || e10.disabled === ""), Zy = (e10) => e10 && (e10.defer || e10.defer === ""), Qy = (e10) => typeof SVGElement < "u" && e10 instanceof SVGElement, eb = (e10) => typeof MathMLElement == "function" && e10 instanceof MathMLElement, Mv = (e10, t) => {
  const n = e10 && e10.to;
  if (Ve(n))
    if (t) {
      const o = t(n);
      return  true && !o && !Bl(e10) && Je(
        `Failed to locate Teleport target with selector "${n}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
      ), o;
    } else
      return  true && Je(
        "Current renderer does not support string target for Teleports. (missing querySelector renderer option)"
      ), null;
  else
    return  true && !n && !Bl(e10) && Je(`Invalid Teleport target: ${n}`), n;
}, CC = {
  name: "Teleport",
  __isTeleport: true,
  process(e10, t, n, o, r, a, l, s, u, c) {
    const {
      mc: d,
      pc: f,
      pbc: p,
      o: { insert: v, querySelector: m, createText: h, createComment: b }
    } = c, g = Bl(t.props);
    let { shapeFlag: w, children: y, dynamicChildren: _ } = t;
    if ( true && lr && (u = false, _ = null), e10 == null) {
      const C = t.el =  true ? b("teleport start") : 0, E = t.anchor =  true ? b("teleport end") : 0;
      v(C, n, o), v(E, n, o);
      const T = (N, $) => {
        w & 16 && (r && r.isCE && (r.ce._teleportTarget = N), d(
          y,
          N,
          $,
          r,
          a,
          l,
          s,
          u
        ));
      }, O = () => {
        const N = t.target = Mv(t.props, m), $ = SC(N, t, h, v);
        N ? (l !== "svg" && Qy(N) ? l = "svg" : l !== "mathml" && eb(N) && (l = "mathml"), g || (T(N, $), td(t, false))) :  true && !g && Je(
          "Invalid Teleport target on mount:",
          N,
          `(${typeof N})`
        );
      };
      g && (T(n, E), td(t, true)), Zy(t.props) ? (t.el.__isMounted = false, co(() => {
        O(), delete t.el.__isMounted;
      }, a)) : O();
    } else {
      if (Zy(t.props) && e10.el.__isMounted === false) {
        co(() => {
          CC.process(
            e10,
            t,
            n,
            o,
            r,
            a,
            l,
            s,
            u,
            c
          );
        }, a);
        return;
      }
      t.el = e10.el, t.targetStart = e10.targetStart;
      const C = t.anchor = e10.anchor, E = t.target = e10.target, T = t.targetAnchor = e10.targetAnchor, O = Bl(e10.props), N = O ? n : E, $ = O ? C : T;
      if (l === "svg" || Qy(E) ? l = "svg" : (l === "mathml" || eb(E)) && (l = "mathml"), _ ? (p(
        e10.dynamicChildren,
        _,
        N,
        r,
        a,
        l,
        s
      ), Zi(e10, t, "development" === "production")) : u || f(
        e10,
        t,
        N,
        $,
        r,
        a,
        l,
        s,
        false
      ), g)
        O ? t.props && e10.props && t.props.to !== e10.props.to && (t.props.to = e10.props.to) : $c(
          t,
          n,
          C,
          c,
          1
        );
      else if ((t.props && t.props.to) !== (e10.props && e10.props.to)) {
        const R = t.target = Mv(
          t.props,
          m
        );
        R ? $c(
          t,
          R,
          null,
          c,
          0
        ) :  true && Je(
          "Invalid Teleport target on update:",
          E,
          `(${typeof E})`
        );
      } else O && $c(
        t,
        E,
        T,
        c,
        1
      );
      td(t, g);
    }
  },
  remove(e10, t, n, { um: o, o: { remove: r } }, a) {
    const {
      shapeFlag: l,
      children: s,
      anchor: u,
      targetStart: c,
      targetAnchor: d,
      target: f,
      props: p
    } = e10;
    if (f && (r(c), r(d)), a && r(u), l & 16) {
      const v = a || !Bl(p);
      for (let m = 0; m < s.length; m++) {
        const h = s[m];
        o(
          h,
          t,
          n,
          v,
          !!h.dynamicChildren
        );
      }
    }
  },
  move: $c,
  hydrate: iI
};
function $c(e10, t, n, { o: { insert: o }, m: r }, a = 2) {
  a === 0 && o(e10.targetAnchor, t, n);
  const { el: l, anchor: s, shapeFlag: u, children: c, props: d } = e10, f = a === 2;
  if (f && o(l, t, n), (!f || Bl(d)) && u & 16)
    for (let p = 0; p < c.length; p++)
      r(
        c[p],
        t,
        n,
        2
      );
  f && o(s, t, n);
}
function iI(e10, t, n, o, r, a, {
  o: { nextSibling: l, parentNode: s, querySelector: u, insert: c, createText: d }
}, f) {
  const p = t.target = Mv(
    t.props,
    u
  );
  if (p) {
    const v = Bl(t.props), m = p._lpa || p.firstChild;
    if (t.shapeFlag & 16)
      if (v)
        t.anchor = f(
          l(e10),
          t,
          s(e10),
          n,
          o,
          r,
          a
        ), t.targetStart = m, t.targetAnchor = m && l(m);
      else {
        t.anchor = l(e10);
        let h = m;
        for (; h; ) {
          if (h && h.nodeType === 8) {
            if (h.data === "teleport start anchor")
              t.targetStart = h;
            else if (h.data === "teleport anchor") {
              t.targetAnchor = h, p._lpa = t.targetAnchor && l(t.targetAnchor);
              break;
            }
          }
          h = l(h);
        }
        t.targetAnchor || SC(p, t, d, c), f(
          m && l(m),
          t,
          p,
          n,
          o,
          r,
          a
        );
      }
    td(t, v);
  }
  return t.anchor && l(t.anchor);
}
const EC = CC;
function td(e10, t) {
  const n = e10.ctx;
  if (n && n.ut) {
    let o, r;
    for (t ? (o = e10.el, r = e10.anchor) : (o = e10.targetStart, r = e10.targetAnchor); o && o !== r; )
      o.nodeType === 1 && o.setAttribute("data-v-owner", n.uid), o = o.nextSibling;
    n.ut();
  }
}
function SC(e10, t, n, o) {
  const r = t.targetStart = n(""), a = t.targetAnchor = n("");
  return r[_C] = a, e10 && (o(r, e10), o(a, e10)), a;
}
const Ya = Symbol("_leaveCb"), Ic = Symbol("_enterCb");
function kC() {
  const e10 = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  return dt(() => {
    e10.isMounted = true;
  }), jt(() => {
    e10.isUnmounting = true;
  }), e10;
}
const Ho = [Function, Array], NC = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: Ho,
  onEnter: Ho,
  onAfterEnter: Ho,
  onEnterCancelled: Ho,
  // leave
  onBeforeLeave: Ho,
  onLeave: Ho,
  onAfterLeave: Ho,
  onLeaveCancelled: Ho,
  // appear
  onBeforeAppear: Ho,
  onAppear: Ho,
  onAfterAppear: Ho,
  onAppearCancelled: Ho
}, TC = (e10) => {
  const t = e10.subTree;
  return t.component ? TC(t.component) : t;
}, uI = {
  name: "BaseTransition",
  props: NC,
  setup(e10, { slots: t }) {
    const n = it(), o = kC();
    return () => {
      const r = t.default && Tm(t.default(), true);
      if (!r || !r.length)
        return;
      const a = OC(r), l = Rt(e10), { mode: s } = l;
      if ( true && s && s !== "in-out" && s !== "out-in" && s !== "default" && Je(`invalid <transition> mode: ${s}`), o.isLeaving)
        return Fp(a);
      const u = tb(a);
      if (!u)
        return Fp(a);
      let c = pu(
        u,
        l,
        o,
        n,
        // #11061, ensure enterHooks is fresh after clone
        (f) => c = f
      );
      u.type !== tn && ql(u, c);
      let d = n.subTree && tb(n.subTree);
      if (d && d.type !== tn && !kl(u, d) && TC(n).type !== tn) {
        let f = pu(
          d,
          l,
          o,
          n
        );
        if (ql(d, f), s === "out-in" && u.type !== tn)
          return o.isLeaving = true, f.afterLeave = () => {
            o.isLeaving = false, n.job.flags & 8 || n.update(), delete f.afterLeave, d = void 0;
          }, Fp(a);
        s === "in-out" && u.type !== tn ? f.delayLeave = (p, v, m) => {
          const h = $C(
            o,
            d
          );
          h[String(d.key)] = d, p[Ya] = () => {
            v(), p[Ya] = void 0, delete c.delayedLeave, d = void 0;
          }, c.delayedLeave = () => {
            m(), delete c.delayedLeave, d = void 0;
          };
        } : d = void 0;
      } else d && (d = void 0);
      return a;
    };
  }
};
function OC(e10) {
  let t = e10[0];
  if (e10.length > 1) {
    let n = false;
    for (const o of e10)
      if (o.type !== tn) {
        if ( true && n) {
          Je(
            "<transition> can only be used on a single element or component. Use <transition-group> for lists."
          );
          break;
        }
        if (t = o, n = true, "development" === "production") break;
      }
  }
  return t;
}
const cI = uI;
function $C(e10, t) {
  const { leavingVNodes: n } = e10;
  let o = n.get(t.type);
  return o || (o = /* @__PURE__ */ Object.create(null), n.set(t.type, o)), o;
}
function pu(e10, t, n, o, r) {
  const {
    appear: a,
    mode: l,
    persisted: s = false,
    onBeforeEnter: u,
    onEnter: c,
    onAfterEnter: d,
    onEnterCancelled: f,
    onBeforeLeave: p,
    onLeave: v,
    onAfterLeave: m,
    onLeaveCancelled: h,
    onBeforeAppear: b,
    onAppear: g,
    onAfterAppear: w,
    onAppearCancelled: y
  } = t, _ = String(e10.key), C = $C(n, e10), E = (N, $) => {
    N && mr(
      N,
      o,
      9,
      $
    );
  }, T = (N, $) => {
    const R = $[1];
    E(N, $), Se(N) ? N.every((P) => P.length <= 1) && R() : N.length <= 1 && R();
  }, O = {
    mode: l,
    persisted: s,
    beforeEnter(N) {
      let $ = u;
      if (!n.isMounted)
        if (a)
          $ = b || u;
        else
          return;
      N[Ya] && N[Ya](
        true
        /* cancelled */
      );
      const R = C[_];
      R && kl(e10, R) && R.el[Ya] && R.el[Ya](), E($, [N]);
    },
    enter(N) {
      let $ = c, R = d, P = f;
      if (!n.isMounted)
        if (a)
          $ = g || c, R = w || d, P = y || f;
        else
          return;
      let z = false;
      const Y = N[Ic] = (D) => {
        z || (z = true, D ? E(P, [N]) : E(R, [N]), O.delayedLeave && O.delayedLeave(), N[Ic] = void 0);
      };
      $ ? T($, [N, Y]) : Y();
    },
    leave(N, $) {
      const R = String(e10.key);
      if (N[Ic] && N[Ic](
        true
        /* cancelled */
      ), n.isUnmounting)
        return $();
      E(p, [N]);
      let P = false;
      const z = N[Ya] = (Y) => {
        P || (P = true, $(), Y ? E(h, [N]) : E(m, [N]), N[Ya] = void 0, C[R] === e10 && delete C[R]);
      };
      C[R] = e10, v ? T(v, [N, z]) : z();
    },
    clone(N) {
      const $ = pu(
        N,
        t,
        n,
        o,
        r
      );
      return r && r($), $;
    }
  };
  return O;
}
function Fp(e10) {
  if (Ju(e10))
    return e10 = gr(e10), e10.children = null, e10;
}
function tb(e10) {
  if (!Ju(e10))
    return wC(e10.type) && e10.children ? OC(e10.children) : e10;
  if (e10.component)
    return e10.component.subTree;
  const { shapeFlag: t, children: n } = e10;
  if (n) {
    if (t & 16)
      return n[0];
    if (t & 32 && Fe(n.default))
      return n.default();
  }
}
function ql(e10, t) {
  e10.shapeFlag & 6 && e10.component ? (e10.transition = t, ql(e10.component.subTree, t)) : e10.shapeFlag & 128 ? (e10.ssContent.transition = t.clone(e10.ssContent), e10.ssFallback.transition = t.clone(e10.ssFallback)) : e10.transition = t;
}
function Tm(e10, t = false, n) {
  let o = [], r = 0;
  for (let a = 0; a < e10.length; a++) {
    let l = e10[a];
    const s = n == null ? l.key : String(n) + String(l.key != null ? l.key : a);
    l.type === Ie ? (l.patchFlag & 128 && r++, o = o.concat(
      Tm(l.children, t, s)
    )) : (t || l.type !== tn) && o.push(s != null ? gr(l, { key: s }) : l);
  }
  if (r > 1)
    for (let a = 0; a < o.length; a++)
      o[a].patchFlag = -2;
  return o;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function j(e10, t) {
  return Fe(e10) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    gn({ name: e10.name }, t, { setup: e10 })
  ) : e10;
}
function IC(e10) {
  e10.ids = [e10.ids[0] + e10.ids[2]++ + "-", 0, 0];
}
const dI = /* @__PURE__ */ new WeakSet();
function Bd(e10, t, n, o, r = false) {
  if (Se(e10)) {
    e10.forEach(
      (m, h) => Bd(
        m,
        t && (Se(t) ? t[h] : t),
        n,
        o,
        r
      )
    );
    return;
  }
  if (xs(o) && !r) {
    o.shapeFlag & 512 && o.type.__asyncResolved && o.component.subTree.component && Bd(e10, t, n, o.component.subTree);
    return;
  }
  const a = o.shapeFlag & 4 ? Bf(o.component) : o.el, l = r ? null : a, { i: s, r: u } = e10;
  if ( true && !s) {
    Je(
      "Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function."
    );
    return;
  }
  const c = t && t.r, d = s.refs === Zt ? s.refs = {} : s.refs, f = s.setupState, p = Rt(f), v = f === Zt ? () => false : (m) =>  true && (Tt(p, m) && !Ot(p[m]) && Je(
    `Template ref "${m}" used on a non-ref value. It will not work in the production build.`
  ), dI.has(p[m])) ? false : Tt(p, m);
  if (c != null && c !== u && (Ve(c) ? (d[c] = null, v(c) && (f[c] = null)) : Ot(c) && (c.value = null)), Fe(u))
    bi(u, s, 12, [l, d]);
  else {
    const m = Ve(u), h = Ot(u);
    if (m || h) {
      const b = () => {
        if (e10.f) {
          const g = m ? v(u) ? f[u] : d[u] : u.value;
          r ? Se(g) && gm(g, a) : Se(g) ? g.includes(a) || g.push(a) : m ? (d[u] = [a], v(u) && (f[u] = d[u])) : (u.value = [a], e10.k && (d[e10.k] = u.value));
        } else m ? (d[u] = l, v(u) && (f[u] = l)) : h ? (u.value = l, e10.k && (d[e10.k] = l)) :  true && Je("Invalid template ref type:", u, `(${typeof u})`);
      };
      l ? (b.id = -1, co(b, n)) : b();
    } else  true && Je("Invalid template ref type:", u, `(${typeof u})`);
  }
}
qu().requestIdleCallback;
qu().cancelIdleCallback;
const xs = (e10) => !!e10.type.__asyncLoader, Ju = (e10) => e10.type.__isKeepAlive;
function Lf(e10, t) {
  PC(e10, "a", t);
}
function MC(e10, t) {
  PC(e10, "da", t);
}
function PC(e10, t, n = $n) {
  const o = e10.__wdc || (e10.__wdc = () => {
    let r = n;
    for (; r; ) {
      if (r.isDeactivated)
        return;
      r = r.parent;
    }
    return e10();
  });
  if (xf(t, o, n), n) {
    let r = n.parent;
    for (; r && r.parent; )
      Ju(r.parent.vnode) && fI(o, t, n, r), r = r.parent;
  }
}
function fI(e10, t, n, o) {
  const r = xf(
    t,
    e10,
    o,
    true
    /* prepend */
  );
  Jr(() => {
    gm(o[t], r);
  }, n);
}
function xf(e10, t, n = $n, o = false) {
  if (n) {
    const r = n[e10] || (n[e10] = []), a = t.__weh || (t.__weh = (...l) => {
      vr();
      const s = Zu(n), u = mr(t, n, e10, l);
      return s(), hr(), u;
    });
    return o ? r.unshift(a) : r.push(a), a;
  } else if (true) {
    const r = fa(Em[e10].replace(/ hook$/, ""));
    Je(
      `${r} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
    );
  }
}
const Na = (e10) => (t, n = $n) => {
  (!hu || e10 === "sp") && xf(e10, (...o) => t(...o), n);
}, Df = Na("bm"), dt = Na("m"), RC = Na(
  "bu"
), wr = Na("u"), jt = Na(
  "bum"
), Jr = Na("um"), pI = Na(
  "sp"
), vI = Na("rtg"), hI = Na("rtc");
function mI(e10, t = $n) {
  xf("ec", e10, t);
}
const Hd = "components", gI = "directives";
function je(e10, t) {
  return Om(Hd, e10, true, t) || e10;
}
const AC = Symbol.for("v-ndc");
function ht(e10) {
  return Ve(e10) ? Om(Hd, e10, false) || e10 : e10 || AC;
}
function Vf(e10) {
  return Om(gI, e10);
}
function Om(e10, t, n = true, o = false) {
  const r = Cn || $n;
  if (r) {
    const a = r.type;
    if (e10 === Hd) {
      const s = Lm(
        a,
        false
      );
      if (s && (s === t || s === Dn(t) || s === rl(Dn(t))))
        return a;
    }
    const l = (
      // local registration
      // check instance[type] first which is resolved for options API
      nb(r[e10] || a[e10], t) || // global registration
      nb(r.appContext[e10], t)
    );
    if (!l && o)
      return a;
    if ( true && n && !l) {
      const s = e10 === Hd ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : "";
      Je(`Failed to resolve ${e10.slice(0, -1)}: ${t}${s}`);
    }
    return l;
  } else  true && Je(
    `resolve${rl(e10.slice(0, -1))} can only be used in render() or setup().`
  );
}
function nb(e10, t) {
  return e10 && (e10[t] || e10[Dn(t)] || e10[rl(Dn(t))]);
}
function st(e10, t, n, o) {
  let r;
  const a = n, l = Se(e10);
  if (l || Ve(e10)) {
    const s = l && Vl(e10);
    let u = false, c = false;
    s && (u = !ho(e10), c = Wr(e10), e10 = Mf(e10)), r = new Array(e10.length);
    for (let d = 0, f = e10.length; d < f; d++)
      r[d] = t(
        u ? c ? Ld(Kn(e10[d])) : Kn(e10[d]) : e10[d],
        d,
        void 0,
        a
      );
  } else if (typeof e10 == "number") {
     true && !Number.isInteger(e10) && Je(`The v-for range expect an integer value but got ${e10}.`), r = new Array(e10);
    for (let s = 0; s < e10; s++)
      r[s] = t(s + 1, s, void 0, a);
  } else if (at(e10))
    if (e10[Symbol.iterator])
      r = Array.from(
        e10,
        (s, u) => t(s, u, void 0, a)
      );
    else {
      const s = Object.keys(e10);
      r = new Array(s.length);
      for (let u = 0, c = s.length; u < c; u++) {
        const d = s[u];
        r[u] = t(e10[d], d, u, a);
      }
    }
  else
    r = [];
  return r;
}
function ro(e10, t) {
  for (let n = 0; n < t.length; n++) {
    const o = t[n];
    if (Se(o))
      for (let r = 0; r < o.length; r++)
        e10[o[r].name] = o[r].fn;
    else o && (e10[o.name] = o.key ? (...r) => {
      const a = o.fn(...r);
      return a && (a.key = o.key), a;
    } : o.fn);
  }
  return e10;
}
function J(e10, t, n = {}, o, r) {
  if (Cn.ce || Cn.parent && xs(Cn.parent) && Cn.parent.ce)
    return t !== "default" && (n.name = t), k(), ae(
      Ie,
      null,
      [W("slot", n, o && o())],
      64
    );
  let a = e10[t];
   true && a && a.length > 1 && (Je(
    "SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template."
  ), a = () => []), a && a._c && (a._d = false), k();
  const l = a && LC(a(n)), s = n.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  l && l.key, u = ae(
    Ie,
    {
      key: (s && !pr(s) ? s : `_${t}`) + // #7256 force differentiate fallback content from actual content
      (!l && o ? "_fb" : "")
    },
    l || (o ? o() : []),
    l && e10._ === 1 ? 64 : -2
  );
  return !r && u.scopeId && (u.slotScopeIds = [u.scopeId + "-s"]), a && a._c && (a._d = true), u;
}
function LC(e10) {
  return e10.some((t) => Ut(t) ? !(t.type === tn || t.type === Ie && !LC(t.children)) : true) ? e10 : null;
}
function yI(e10, t) {
  const n = {};
  if ( true && !at(e10))
    return Je("v-on with no argument expects an object value."), n;
  for (const o in e10)
    n[fa(o)] = e10[o];
  return n;
}
const Pv = (e10) => e10 ? rE(e10) ? Bf(e10) : Pv(e10.parent) : null, Hl = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ gn(/* @__PURE__ */ Object.create(null), {
    $: (e10) => e10,
    $el: (e10) => e10.vnode.el,
    $data: (e10) => e10.data,
    $props: (e10) =>  true ? Vr(e10.props) : 0,
    $attrs: (e10) =>  true ? Vr(e10.attrs) : 0,
    $slots: (e10) =>  true ? Vr(e10.slots) : 0,
    $refs: (e10) =>  true ? Vr(e10.refs) : 0,
    $parent: (e10) => Pv(e10.parent),
    $root: (e10) => Pv(e10.root),
    $host: (e10) => e10.ce,
    $emit: (e10) => e10.emit,
    $options: (e10) => FC(e10),
    $forceUpdate: (e10) => e10.f || (e10.f = () => {
      Af(e10.update);
    }),
    $nextTick: (e10) => e10.n || (e10.n = He.bind(e10.proxy)),
    $watch: (e10) => XI.bind(e10)
  })
), $m = (e10) => e10 === "_" || e10 === "$", Bp = (e10, t) => e10 !== Zt && !e10.__isScriptSetup && Tt(e10, t), xC = {
  get({ _: e10 }, t) {
    if (t === "__v_skip")
      return true;
    const { ctx: n, setupState: o, data: r, props: a, accessCache: l, type: s, appContext: u } = e10;
    if ( true && t === "__isVue")
      return true;
    let c;
    if (t[0] !== "$") {
      const v = l[t];
      if (v !== void 0)
        switch (v) {
          case 1:
            return o[t];
          case 2:
            return r[t];
          case 4:
            return n[t];
          case 3:
            return a[t];
        }
      else {
        if (Bp(o, t))
          return l[t] = 1, o[t];
        if (r !== Zt && Tt(r, t))
          return l[t] = 2, r[t];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (c = e10.propsOptions[0]) && Tt(c, t)
        )
          return l[t] = 3, a[t];
        if (n !== Zt && Tt(n, t))
          return l[t] = 4, n[t];
        Rv && (l[t] = 0);
      }
    }
    const d = Hl[t];
    let f, p;
    if (d)
      return t === "$attrs" ? (On(e10.attrs, "get", ""),  true && Wd()) :  true && t === "$slots" && On(e10, "get", t), d(e10);
    if (
      // css module (injected by vue-loader)
      (f = s.__cssModules) && (f = f[t])
    )
      return f;
    if (n !== Zt && Tt(n, t))
      return l[t] = 4, n[t];
    if (
      // global properties
      p = u.config.globalProperties, Tt(p, t)
    )
      return p[t];
     true && Cn && (!Ve(t) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    t.indexOf("__v") !== 0) && (r !== Zt && $m(t[0]) && Tt(r, t) ? Je(
      `Property ${JSON.stringify(
        t
      )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
    ) : e10 === Cn && Je(
      `Property ${JSON.stringify(t)} was accessed during render but is not defined on instance.`
    ));
  },
  set({ _: e10 }, t, n) {
    const { data: o, setupState: r, ctx: a } = e10;
    return Bp(r, t) ? (r[t] = n, true) :  true && r.__isScriptSetup && Tt(r, t) ? (Je(`Cannot mutate <script setup> binding "${t}" from Options API.`), false) : o !== Zt && Tt(o, t) ? (o[t] = n, true) : Tt(e10.props, t) ? ( true && Je(`Attempting to mutate prop "${t}". Props are readonly.`), false) : t[0] === "$" && t.slice(1) in e10 ? ( true && Je(
      `Attempting to mutate public property "${t}". Properties starting with $ are reserved and readonly.`
    ), false) : ( true && t in e10.appContext.config.globalProperties ? Object.defineProperty(a, t, {
      enumerable: true,
      configurable: true,
      value: n
    }) : a[t] = n, true);
  },
  has({
    _: { data: e10, setupState: t, accessCache: n, ctx: o, appContext: r, propsOptions: a }
  }, l) {
    let s;
    return !!n[l] || e10 !== Zt && Tt(e10, l) || Bp(t, l) || (s = a[0]) && Tt(s, l) || Tt(o, l) || Tt(Hl, l) || Tt(r.config.globalProperties, l);
  },
  defineProperty(e10, t, n) {
    return n.get != null ? e10._.accessCache[t] = 0 : Tt(n, "value") && this.set(e10, t, n.value, null), Reflect.defineProperty(e10, t, n);
  }
};
 true && (xC.ownKeys = (e10) => (Je(
  "Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."
), Reflect.ownKeys(e10)));
function bI(e10) {
  const t = {};
  return Object.defineProperty(t, "_", {
    configurable: true,
    enumerable: false,
    get: () => e10
  }), Object.keys(Hl).forEach((n) => {
    Object.defineProperty(t, n, {
      configurable: true,
      enumerable: false,
      get: () => Hl[n](e10),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: Mt
    });
  }), t;
}
function _I(e10) {
  const {
    ctx: t,
    propsOptions: [n]
  } = e10;
  n && Object.keys(n).forEach((o) => {
    Object.defineProperty(t, o, {
      enumerable: true,
      configurable: true,
      get: () => e10.props[o],
      set: Mt
    });
  });
}
function wI(e10) {
  const { ctx: t, setupState: n } = e10;
  Object.keys(Rt(n)).forEach((o) => {
    if (!n.__isScriptSetup) {
      if ($m(o[0])) {
        Je(
          `setup() return property ${JSON.stringify(
            o
          )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
        );
        return;
      }
      Object.defineProperty(t, o, {
        enumerable: true,
        configurable: true,
        get: () => n[o],
        set: Mt
      });
    }
  });
}
function En() {
  return DC().slots;
}
function Ta() {
  return DC().attrs;
}
function DC() {
  const e10 = it();
  return  true && !e10 && Je("useContext() called without active instance."), e10.setupContext || (e10.setupContext = lE(e10));
}
function ob(e10) {
  return Se(e10) ? e10.reduce(
    (t, n) => (t[n] = null, t),
    {}
  ) : e10;
}
function CI() {
  const e10 = /* @__PURE__ */ Object.create(null);
  return (t, n) => {
    e10[n] ? Je(`${t} property "${n}" is already defined in ${e10[n]}.`) : e10[n] = t;
  };
}
let Rv = true;
function EI(e10) {
  const t = FC(e10), n = e10.proxy, o = e10.ctx;
  Rv = false, t.beforeCreate && rb(t.beforeCreate, e10, "bc");
  const {
    // state
    data: r,
    computed: a,
    methods: l,
    watch: s,
    provide: u,
    inject: c,
    // lifecycle
    created: d,
    beforeMount: f,
    mounted: p,
    beforeUpdate: v,
    updated: m,
    activated: h,
    deactivated: b,
    beforeDestroy: g,
    beforeUnmount: w,
    destroyed: y,
    unmounted: _,
    render: C,
    renderTracked: E,
    renderTriggered: T,
    errorCaptured: O,
    serverPrefetch: N,
    // public API
    expose: $,
    inheritAttrs: R,
    // assets
    components: P,
    directives: z,
    filters: Y
  } = t, D =  true ? CI() : 0;
  if (true) {
    const [F] = e10.propsOptions;
    if (F)
      for (const A in F)
        D("Props", A);
  }
  if (c && SI(c, o, D), l)
    for (const F in l) {
      const A = l[F];
      Fe(A) ? ( true ? Object.defineProperty(o, F, {
        value: A.bind(n),
        configurable: true,
        enumerable: true,
        writable: true
      }) : 0,  true && D("Methods", F)) :  true && Je(
        `Method "${F}" has type "${typeof A}" in the component definition. Did you reference the function correctly?`
      );
    }
  if (r) {
     true && !Fe(r) && Je(
      "The data option must be a function. Plain object usage is no longer supported."
    );
    const F = r.call(n, n);
    if ( true && ol(F) && Je(
      "data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."
    ), !at(F))
       true && Je("data() should return an object.");
    else if (e10.data = It(F), "development" !== "production")
      for (const A in F)
        D("Data", A), $m(A[0]) || Object.defineProperty(o, A, {
          configurable: true,
          enumerable: true,
          get: () => F[A],
          set: Mt
        });
  }
  if (Rv = true, a)
    for (const F in a) {
      const A = a[F], V = Fe(A) ? A.bind(n, n) : Fe(A.get) ? A.get.bind(n, n) : Mt;
       true && V === Mt && Je(`Computed property "${F}" has no getter.`);
      const Z = !Fe(A) && Fe(A.set) ? A.set.bind(n) :  true ? () => {
        Je(
          `Write operation failed: computed property "${F}" is readonly.`
        );
      } : 0, G = S({
        get: V,
        set: Z
      });
      Object.defineProperty(o, F, {
        enumerable: true,
        configurable: true,
        get: () => G.value,
        set: (le) => G.value = le
      }),  true && D("Computed", F);
    }
  if (s)
    for (const F in s)
      VC(s[F], o, n, F);
  if (u) {
    const F = Fe(u) ? u.call(n) : u;
    Reflect.ownKeys(F).forEach((A) => {
      yt(A, F[A]);
    });
  }
  d && rb(d, e10, "c");
  function M(F, A) {
    Se(A) ? A.forEach((V) => F(V.bind(n))) : A && F(A.bind(n));
  }
  if (M(Df, f), M(dt, p), M(RC, v), M(wr, m), M(Lf, h), M(MC, b), M(mI, O), M(hI, E), M(vI, T), M(jt, w), M(Jr, _), M(pI, N), Se($))
    if ($.length) {
      const F = e10.exposed || (e10.exposed = {});
      $.forEach((A) => {
        Object.defineProperty(F, A, {
          get: () => n[A],
          set: (V) => n[A] = V
        });
      });
    } else e10.exposed || (e10.exposed = {});
  C && e10.render === Mt && (e10.render = C), R != null && (e10.inheritAttrs = R), P && (e10.components = P), z && (e10.directives = z), N && IC(e10);
}
function SI(e10, t, n = Mt) {
  Se(e10) && (e10 = Av(e10));
  for (const o in e10) {
    const r = e10[o];
    let a;
    at(r) ? "default" in r ? a = Le(
      r.from || o,
      r.default,
      true
    ) : a = Le(r.from || o) : a = Le(r), Ot(a) ? Object.defineProperty(t, o, {
      enumerable: true,
      configurable: true,
      get: () => a.value,
      set: (l) => a.value = l
    }) : t[o] = a,  true && n("Inject", o);
  }
}
function rb(e10, t, n) {
  mr(
    Se(e10) ? e10.map((o) => o.bind(t.proxy)) : e10.bind(t.proxy),
    t,
    n
  );
}
function VC(e10, t, n, o) {
  let r = o.includes(".") ? XC(n, o) : () => n[o];
  if (Ve(e10)) {
    const a = t[e10];
    Fe(a) ? ge(r, a) :  true && Je(`Invalid watch handler specified by key "${e10}"`, a);
  } else if (Fe(e10))
    ge(r, e10.bind(n));
  else if (at(e10))
    if (Se(e10))
      e10.forEach((a) => VC(a, t, n, o));
    else {
      const a = Fe(e10.handler) ? e10.handler.bind(n) : t[e10.handler];
      Fe(a) ? ge(r, a, e10) :  true && Je(`Invalid watch handler specified by key "${e10.handler}"`, a);
    }
  else  true && Je(`Invalid watch option: "${o}"`, e10);
}
function FC(e10) {
  const t = e10.type, { mixins: n, extends: o } = t, {
    mixins: r,
    optionsCache: a,
    config: { optionMergeStrategies: l }
  } = e10.appContext, s = a.get(t);
  let u;
  return s ? u = s : !r.length && !n && !o ? u = t : (u = {}, r.length && r.forEach(
    (c) => zd(u, c, l, true)
  ), zd(u, t, l)), at(t) && a.set(t, u), u;
}
function zd(e10, t, n, o = false) {
  const { mixins: r, extends: a } = t;
  a && zd(e10, a, n, true), r && r.forEach(
    (l) => zd(e10, l, n, true)
  );
  for (const l in t)
    if (o && l === "expose")
       true && Je(
        '"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.'
      );
    else {
      const s = kI[l] || n && n[l];
      e10[l] = s ? s(e10[l], t[l]) : t[l];
    }
  return e10;
}
const kI = {
  data: ab,
  props: lb,
  emits: lb,
  // objects
  methods: ji,
  computed: ji,
  // lifecycle
  beforeCreate: so,
  created: so,
  beforeMount: so,
  mounted: so,
  beforeUpdate: so,
  updated: so,
  beforeDestroy: so,
  beforeUnmount: so,
  destroyed: so,
  unmounted: so,
  activated: so,
  deactivated: so,
  errorCaptured: so,
  serverPrefetch: so,
  // assets
  components: ji,
  directives: ji,
  // watch
  watch: TI,
  // provide / inject
  provide: ab,
  inject: NI
};
function ab(e10, t) {
  return t ? e10 ? function() {
    return gn(
      Fe(e10) ? e10.call(this, this) : e10,
      Fe(t) ? t.call(this, this) : t
    );
  } : t : e10;
}
function NI(e10, t) {
  return ji(Av(e10), Av(t));
}
function Av(e10) {
  if (Se(e10)) {
    const t = {};
    for (let n = 0; n < e10.length; n++)
      t[e10[n]] = e10[n];
    return t;
  }
  return e10;
}
function so(e10, t) {
  return e10 ? [...new Set([].concat(e10, t))] : t;
}
function ji(e10, t) {
  return e10 ? gn(/* @__PURE__ */ Object.create(null), e10, t) : t;
}
function lb(e10, t) {
  return e10 ? Se(e10) && Se(t) ? [.../* @__PURE__ */ new Set([...e10, ...t])] : gn(
    /* @__PURE__ */ Object.create(null),
    ob(e10),
    ob(t != null ? t : {})
  ) : t;
}
function TI(e10, t) {
  if (!e10) return t;
  if (!t) return e10;
  const n = gn(/* @__PURE__ */ Object.create(null), e10);
  for (const o in t)
    n[o] = so(e10[o], t[o]);
  return n;
}
function BC() {
  return {
    app: null,
    config: {
      isNativeTag: qO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let OI = 0;
function $I(e10, t) {
  return function(o, r = null) {
    Fe(o) || (o = gn({}, o)), r != null && !at(r) && ( true && Je("root props passed to app.mount() must be an object."), r = null);
    const a = BC(), l = /* @__PURE__ */ new WeakSet(), s = [];
    let u = false;
    const c = a.app = {
      _uid: OI++,
      _component: o,
      _props: r,
      _container: null,
      _context: a,
      _instance: null,
      version: yb,
      get config() {
        return a.config;
      },
      set config(d) {
         true && Je(
          "app.config cannot be replaced. Modify individual options instead."
        );
      },
      use(d, ...f) {
        return l.has(d) ?  true && Je("Plugin has already been applied to target app.") : d && Fe(d.install) ? (l.add(d), d.install(c, ...f)) : Fe(d) ? (l.add(d), d(c, ...f)) :  true && Je(
          'A plugin must either be a function or an object with an "install" function.'
        ), c;
      },
      mixin(d) {
        return a.mixins.includes(d) ?  true && Je(
          "Mixin has already been applied to target app" + (d.name ? `: ${d.name}` : "")
        ) : a.mixins.push(d), c;
      },
      component(d, f) {
        return  true && Fv(d, a.config), f ? ( true && a.components[d] && Je(`Component "${d}" has already been registered in target app.`), a.components[d] = f, c) : a.components[d];
      },
      directive(d, f) {
        return  true && bC(d), f ? ( true && a.directives[d] && Je(`Directive "${d}" has already been registered in target app.`), a.directives[d] = f, c) : a.directives[d];
      },
      mount(d, f, p) {
        if (u)
           true && Je(
            "App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`"
          );
        else {
           true && d.__vue_app__ && Je(
            "There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first."
          );
          const v = c._ceVNode || W(o, r);
          return v.appContext = a, p === true ? p = "svg" : p === false && (p = void 0),  true && (a.reload = () => {
            const m = gr(v);
            m.el = null, e10(m, d, p);
          }), e10(v, d, p), u = true, c._container = d, d.__vue_app__ = c,  true && (c._instance = v.component, eI(c, yb)), Bf(v.component);
        }
      },
      onUnmount(d) {
         true && typeof d != "function" && Je(
          `Expected function as first argument to app.onUnmount(), but got ${typeof d}`
        ), s.push(d);
      },
      unmount() {
        u ? (mr(
          s,
          c._instance,
          16
        ), e10(null, c._container),  true && (c._instance = null, tI(c)), delete c._container.__vue_app__) :  true && Je("Cannot unmount an app that is not mounted.");
      },
      provide(d, f) {
        return  true && d in a.provides && (Tt(a.provides, d) ? Je(
          `App already provides property with key "${String(d)}". It will be overwritten with the new value.`
        ) : Je(
          `App already provides property with key "${String(d)}" inherited from its parent element. It will be overwritten with the new value.`
        )), a.provides[d] = f, c;
      },
      runWithContext(d) {
        const f = Ds;
        Ds = c;
        try {
          return d();
        } finally {
          Ds = f;
        }
      }
    };
    return c;
  };
}
let Ds = null;
function yt(e10, t) {
  if (!$n)
     true && Je("provide() can only be used inside setup().");
  else {
    let n = $n.provides;
    const o = $n.parent && $n.parent.provides;
    o === n && (n = $n.provides = Object.create(o)), n[e10] = t;
  }
}
function Le(e10, t, n = false) {
  const o = $n || Cn;
  if (o || Ds) {
    let r = Ds ? Ds._context.provides : o ? o.parent == null || o.ce ? o.vnode.appContext && o.vnode.appContext.provides : o.parent.provides : void 0;
    if (r && e10 in r)
      return r[e10];
    if (arguments.length > 1)
      return n && Fe(t) ? t.call(o && o.proxy) : t;
     true && Je(`injection "${String(e10)}" not found.`);
  } else  true && Je("inject() can only be used inside setup() or functional components.");
}
const HC = {}, zC = () => Object.create(HC), KC = (e10) => Object.getPrototypeOf(e10) === HC;
function II(e10, t, n, o = false) {
  const r = {}, a = zC();
  e10.propsDefaults = /* @__PURE__ */ Object.create(null), WC(e10, t, r, a);
  for (const l in e10.propsOptions[0])
    l in r || (r[l] = void 0);
   true && UC(t || {}, r, e10), n ? e10.props = o ? r : aC(r) : e10.type.props ? e10.props = r : e10.props = a, e10.attrs = a;
}
function MI(e10) {
  for (; e10; ) {
    if (e10.type.__hmrId) return true;
    e10 = e10.parent;
  }
}
function PI(e10, t, n, o) {
  const {
    props: r,
    attrs: a,
    vnode: { patchFlag: l }
  } = e10, s = Rt(r), [u] = e10.propsOptions;
  let c = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !( true && MI(e10)) && (o || l > 0) && !(l & 16)
  ) {
    if (l & 8) {
      const d = e10.vnode.dynamicProps;
      for (let f = 0; f < d.length; f++) {
        let p = d[f];
        if (Ff(e10.emitsOptions, p))
          continue;
        const v = t[p];
        if (u)
          if (Tt(a, p))
            v !== a[p] && (a[p] = v, c = true);
          else {
            const m = Dn(p);
            r[m] = Lv(
              u,
              s,
              m,
              v,
              e10,
              false
            );
          }
        else
          v !== a[p] && (a[p] = v, c = true);
      }
    }
  } else {
    WC(e10, t, r, a) && (c = true);
    let d;
    for (const f in s)
      (!t || // for camelCase
      !Tt(t, f) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((d = Kr(f)) === f || !Tt(t, d))) && (u ? n && // for camelCase
      (n[f] !== void 0 || // for kebab-case
      n[d] !== void 0) && (r[f] = Lv(
        u,
        s,
        f,
        void 0,
        e10,
        true
      )) : delete r[f]);
    if (a !== s)
      for (const f in a)
        (!t || !Tt(t, f)) && (delete a[f], c = true);
  }
  c && Lr(e10.attrs, "set", ""),  true && UC(t || {}, r, e10);
}
function WC(e10, t, n, o) {
  const [r, a] = e10.propsOptions;
  let l = false, s;
  if (t)
    for (let u in t) {
      if (Gi(u))
        continue;
      const c = t[u];
      let d;
      r && Tt(r, d = Dn(u)) ? !a || !a.includes(d) ? n[d] = c : (s || (s = {}))[d] = c : Ff(e10.emitsOptions, u) || (!(u in o) || c !== o[u]) && (o[u] = c, l = true);
    }
  if (a) {
    const u = Rt(n), c = s || Zt;
    for (let d = 0; d < a.length; d++) {
      const f = a[d];
      n[f] = Lv(
        r,
        u,
        f,
        c[f],
        e10,
        !Tt(c, f)
      );
    }
  }
  return l;
}
function Lv(e10, t, n, o, r, a) {
  const l = e10[n];
  if (l != null) {
    const s = Tt(l, "default");
    if (s && o === void 0) {
      const u = l.default;
      if (l.type !== Function && !l.skipFactory && Fe(u)) {
        const { propsDefaults: c } = r;
        if (n in c)
          o = c[n];
        else {
          const d = Zu(r);
          o = c[n] = u.call(
            null,
            t
          ), d();
        }
      } else
        o = u;
      r.ce && r.ce._setProp(n, o);
    }
    l[
      0
      /* shouldCast */
    ] && (a && !s ? o = false : l[
      1
      /* shouldCastTrue */
    ] && (o === "" || o === Kr(n)) && (o = true));
  }
  return o;
}
const RI = /* @__PURE__ */ new WeakMap();
function jC(e10, t, n = false) {
  const o = n ? RI : t.propsCache, r = o.get(e10);
  if (r)
    return r;
  const a = e10.props, l = {}, s = [];
  let u = false;
  if (!Fe(e10)) {
    const d = (f) => {
      u = true;
      const [p, v] = jC(f, t, true);
      gn(l, p), v && s.push(...v);
    };
    !n && t.mixins.length && t.mixins.forEach(d), e10.extends && d(e10.extends), e10.mixins && e10.mixins.forEach(d);
  }
  if (!a && !u)
    return at(e10) && o.set(e10, As), As;
  if (Se(a))
    for (let d = 0; d < a.length; d++) {
       true && !Ve(a[d]) && Je("props must be strings when using array syntax.", a[d]);
      const f = Dn(a[d]);
      sb(f) && (l[f] = Zt);
    }
  else if (a) {
     true && !at(a) && Je("invalid props options", a);
    for (const d in a) {
      const f = Dn(d);
      if (sb(f)) {
        const p = a[d], v = l[f] = Se(p) || Fe(p) ? { type: p } : gn({}, p), m = v.type;
        let h = false, b = true;
        if (Se(m))
          for (let g = 0; g < m.length; ++g) {
            const w = m[g], y = Fe(w) && w.name;
            if (y === "Boolean") {
              h = true;
              break;
            } else y === "String" && (b = false);
          }
        else
          h = Fe(m) && m.name === "Boolean";
        v[
          0
          /* shouldCast */
        ] = h, v[
          1
          /* shouldCastTrue */
        ] = b, (h || Tt(v, "default")) && s.push(f);
      }
    }
  }
  const c = [l, s];
  return at(e10) && o.set(e10, c), c;
}
function sb(e10) {
  return e10[0] !== "$" && !Gi(e10) ? true : ( true && Je(`Invalid prop name: "${e10}" is a reserved property.`), false);
}
function AI(e10) {
  return e10 === null ? "null" : typeof e10 == "function" ? e10.name || "" : typeof e10 == "object" && e10.constructor && e10.constructor.name || "";
}
function UC(e10, t, n) {
  const o = Rt(t), r = n.propsOptions[0], a = Object.keys(e10).map((l) => Dn(l));
  for (const l in r) {
    let s = r[l];
    s != null && LI(
      l,
      o[l],
      s,
       true ? Vr(o) : 0,
      !a.includes(l)
    );
  }
}
function LI(e10, t, n, o, r) {
  const { type: a, required: l, validator: s, skipCheck: u } = n;
  if (l && r) {
    Je('Missing required prop: "' + e10 + '"');
    return;
  }
  if (!(t == null && !l)) {
    if (a != null && a !== true && !u) {
      let c = false;
      const d = Se(a) ? a : [a], f = [];
      for (let p = 0; p < d.length && !c; p++) {
        const { valid: v, expectedType: m } = DI(t, d[p]);
        f.push(m || ""), c = v;
      }
      if (!c) {
        Je(VI(e10, t, f));
        return;
      }
    }
    s && !s(t, o) && Je('Invalid prop: custom validator check failed for prop "' + e10 + '".');
  }
}
const xI = /* @__PURE__ */ ka(
  "String,Number,Boolean,Function,Symbol,BigInt"
);
function DI(e10, t) {
  let n;
  const o = AI(t);
  if (o === "null")
    n = e10 === null;
  else if (xI(o)) {
    const r = typeof e10;
    n = r === o.toLowerCase(), !n && r === "object" && (n = e10 instanceof t);
  } else o === "Object" ? n = at(e10) : o === "Array" ? n = Se(e10) : n = e10 instanceof t;
  return {
    valid: n,
    expectedType: o
  };
}
function VI(e10, t, n) {
  if (n.length === 0)
    return `Prop type [] for prop "${e10}" won't match anything. Did you mean to use type Array instead?`;
  let o = `Invalid prop: type check failed for prop "${e10}". Expected ${n.map(rl).join(" | ")}`;
  const r = n[0], a = ym(t), l = ib(t, r), s = ib(t, a);
  return n.length === 1 && ub(r) && !FI(r, a) && (o += ` with value ${l}`), o += `, got ${a} `, ub(a) && (o += `with value ${s}.`), o;
}
function ib(e10, t) {
  return t === "String" ? `"${e10}"` : t === "Number" ? `${Number(e10)}` : `${e10}`;
}
function ub(e10) {
  return ["string", "number", "boolean"].some((n) => e10.toLowerCase() === n);
}
function FI(...e10) {
  return e10.some((t) => t.toLowerCase() === "boolean");
}
const Im = (e10) => e10[0] === "_" || e10 === "$stable", Mm = (e10) => Se(e10) ? e10.map(or) : [or(e10)], BI = (e10, t, n) => {
  if (t._n)
    return t;
  const o = H((...r) => ( true && $n && !(n === null && Cn) && !(n && n.root !== $n.root) && Je(
    `Slot "${e10}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
  ), Mm(t(...r))), n);
  return o._c = false, o;
}, YC = (e10, t, n) => {
  const o = e10._ctx;
  for (const r in e10) {
    if (Im(r)) continue;
    const a = e10[r];
    if (Fe(a))
      t[r] = BI(r, a, o);
    else if (a != null) {
       true && Je(
        `Non-function value encountered for slot "${r}". Prefer function slots for better performance.`
      );
      const l = Mm(a);
      t[r] = () => l;
    }
  }
}, qC = (e10, t) => {
   true && !Ju(e10.vnode) && Je(
    "Non-function value encountered for default slot. Prefer function slots for better performance."
  );
  const n = Mm(t);
  e10.slots.default = () => n;
}, xv = (e10, t, n) => {
  for (const o in t)
    (n || !Im(o)) && (e10[o] = t[o]);
}, HI = (e10, t, n) => {
  const o = e10.slots = zC();
  if (e10.vnode.shapeFlag & 32) {
    const r = t._;
    r ? (xv(o, t, n), n && Rd(o, "_", r, true)) : YC(t, o);
  } else t && qC(e10, t);
}, zI = (e10, t, n) => {
  const { vnode: o, slots: r } = e10;
  let a = true, l = Zt;
  if (o.shapeFlag & 32) {
    const s = t._;
    s ?  true && lr ? (xv(r, t, n), Lr(e10, "set", "$slots")) : n && s === 1 ? a = false : xv(r, t, n) : (a = !t.$stable, YC(t, r)), l = t;
  } else t && (qC(e10, t), l = { default: 1 });
  if (a)
    for (const s in r)
      !Im(s) && l[s] == null && delete r[s];
};
let xi, Ga;
function vs(e10, t) {
  e10.appContext.config.performance && Kd() && Ga.mark(`vue-${t}-${e10.uid}`),  true && aI(e10, t, Kd() ? Ga.now() : Date.now());
}
function hs(e10, t) {
  if (e10.appContext.config.performance && Kd()) {
    const n = `vue-${t}-${e10.uid}`, o = n + ":end";
    Ga.mark(o), Ga.measure(
      `<${Hf(e10, e10.type)}> ${t}`,
      n,
      o
    ), Ga.clearMarks(n), Ga.clearMarks(o);
  }
   true && lI(e10, t, Kd() ? Ga.now() : Date.now());
}
function Kd() {
  return xi !== void 0 || (typeof window < "u" && window.performance ? (xi = true, Ga = window.performance) : xi = false), xi;
}
function KI() {
  const e10 = [];
  if ( true && e10.length) {
    const t = e10.length > 1;
    console.warn(
      `Feature flag${t ? "s" : ""} ${e10.join(", ")} ${t ? "are" : "is"} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
    );
  }
}
const co = o4;
function WI(e10) {
  return jI(e10);
}
function jI(e10, t) {
  KI();
  const n = qu();
  n.__VUE__ = true,  true && km(n.__VUE_DEVTOOLS_GLOBAL_HOOK__, n);
  const {
    insert: o,
    remove: r,
    patchProp: a,
    createElement: l,
    createText: s,
    createComment: u,
    setText: c,
    setElementText: d,
    parentNode: f,
    nextSibling: p,
    setScopeId: v = Mt,
    insertStaticContent: m
  } = e10, h = (U, re, he, Ee = null, ye = null, K = null, q = void 0, ue = null, be =  true && lr ? false : !!re.dynamicChildren) => {
    if (U === re)
      return;
    U && !kl(U, re) && (Ee = ve(U), X(U, ye, K, true), U = null), re.patchFlag === -2 && (be = false, re.dynamicChildren = null);
    const { type: ke, ref: Ae, shapeFlag: fe } = re;
    switch (ke) {
      case Zr:
        b(U, re, he, Ee);
        break;
      case tn:
        g(U, re, he, Ee);
        break;
      case nd:
        U == null ? w(re, he, Ee, q) :  true && y(U, re, he, q);
        break;
      case Ie:
        z(
          U,
          re,
          he,
          Ee,
          ye,
          K,
          q,
          ue,
          be
        );
        break;
      default:
        fe & 1 ? E(
          U,
          re,
          he,
          Ee,
          ye,
          K,
          q,
          ue,
          be
        ) : fe & 6 ? Y(
          U,
          re,
          he,
          Ee,
          ye,
          K,
          q,
          ue,
          be
        ) : fe & 64 || fe & 128 ? ke.process(
          U,
          re,
          he,
          Ee,
          ye,
          K,
          q,
          ue,
          be,
          Te
        ) :  true && Je("Invalid VNode type:", ke, `(${typeof ke})`);
    }
    Ae != null && ye && Bd(Ae, U && U.ref, K, re || U, !re);
  }, b = (U, re, he, Ee) => {
    if (U == null)
      o(
        re.el = s(re.children),
        he,
        Ee
      );
    else {
      const ye = re.el = U.el;
      re.children !== U.children && c(ye, re.children);
    }
  }, g = (U, re, he, Ee) => {
    U == null ? o(
      re.el = u(re.children || ""),
      he,
      Ee
    ) : re.el = U.el;
  }, w = (U, re, he, Ee) => {
    [U.el, U.anchor] = m(
      U.children,
      re,
      he,
      Ee,
      U.el,
      U.anchor
    );
  }, y = (U, re, he, Ee) => {
    if (re.children !== U.children) {
      const ye = p(U.anchor);
      C(U), [re.el, re.anchor] = m(
        re.children,
        he,
        ye,
        Ee
      );
    } else
      re.el = U.el, re.anchor = U.anchor;
  }, _ = ({ el: U, anchor: re }, he, Ee) => {
    let ye;
    for (; U && U !== re; )
      ye = p(U), o(U, he, Ee), U = ye;
    o(re, he, Ee);
  }, C = ({ el: U, anchor: re }) => {
    let he;
    for (; U && U !== re; )
      he = p(U), r(U), U = he;
    r(re);
  }, E = (U, re, he, Ee, ye, K, q, ue, be) => {
    re.type === "svg" ? q = "svg" : re.type === "math" && (q = "mathml"), U == null ? T(
      re,
      he,
      Ee,
      ye,
      K,
      q,
      ue,
      be
    ) : $(
      U,
      re,
      ye,
      K,
      q,
      ue,
      be
    );
  }, T = (U, re, he, Ee, ye, K, q, ue) => {
    let be, ke;
    const { props: Ae, shapeFlag: fe, transition: ie, dirs: Ce } = U;
    if (be = U.el = l(
      U.type,
      K,
      Ae && Ae.is,
      Ae
    ), fe & 8 ? d(be, U.children) : fe & 16 && N(
      U.children,
      be,
      null,
      Ee,
      ye,
      Hp(U, K),
      q,
      ue
    ), Ce && _l(U, null, Ee, "created"), O(be, U, U.scopeId, q, Ee), Ae) {
      for (const et in Ae)
        et !== "value" && !Gi(et) && a(be, et, null, Ae[et], K, Ee);
      "value" in Ae && a(be, "value", null, Ae.value, K), (ke = Ae.onVnodeBeforeMount) && Mr(ke, Ee, U);
    }
     true && (Rd(be, "__vnode", U, true), Rd(be, "__vueParentComponent", Ee, true)), Ce && _l(U, null, Ee, "beforeMount");
    const qe = UI(ye, ie);
    qe && ie.beforeEnter(be), o(be, re, he), ((ke = Ae && Ae.onVnodeMounted) || qe || Ce) && co(() => {
      ke && Mr(ke, Ee, U), qe && ie.enter(be), Ce && _l(U, null, Ee, "mounted");
    }, ye);
  }, O = (U, re, he, Ee, ye) => {
    if (he && v(U, he), Ee)
      for (let K = 0; K < Ee.length; K++)
        v(U, Ee[K]);
    if (ye) {
      let K = ye.subTree;
      if ( true && K.patchFlag > 0 && K.patchFlag & 2048 && (K = Rm(K.children) || K), re === K || QC(K.type) && (K.ssContent === re || K.ssFallback === re)) {
        const q = ye.vnode;
        O(
          U,
          q,
          q.scopeId,
          q.slotScopeIds,
          ye.parent
        );
      }
    }
  }, N = (U, re, he, Ee, ye, K, q, ue, be = 0) => {
    for (let ke = be; ke < U.length; ke++) {
      const Ae = U[ke] = ue ? qa(U[ke]) : or(U[ke]);
      h(
        null,
        Ae,
        re,
        he,
        Ee,
        ye,
        K,
        q,
        ue
      );
    }
  }, $ = (U, re, he, Ee, ye, K, q) => {
    const ue = re.el = U.el;
     true && (ue.__vnode = re);
    let { patchFlag: be, dynamicChildren: ke, dirs: Ae } = re;
    be |= U.patchFlag & 16;
    const fe = U.props || Zt, ie = re.props || Zt;
    let Ce;
    if (he && wl(he, false), (Ce = ie.onVnodeBeforeUpdate) && Mr(Ce, he, re, U), Ae && _l(re, U, he, "beforeUpdate"), he && wl(he, true),  true && lr && (be = 0, q = false, ke = null), (fe.innerHTML && ie.innerHTML == null || fe.textContent && ie.textContent == null) && d(ue, ""), ke ? (R(
      U.dynamicChildren,
      ke,
      ue,
      he,
      Ee,
      Hp(re, ye),
      K
    ),  true && Zi(U, re)) : q || V(
      U,
      re,
      ue,
      null,
      he,
      Ee,
      Hp(re, ye),
      K,
      false
    ), be > 0) {
      if (be & 16)
        P(ue, fe, ie, he, ye);
      else if (be & 2 && fe.class !== ie.class && a(ue, "class", null, ie.class, ye), be & 4 && a(ue, "style", fe.style, ie.style, ye), be & 8) {
        const qe = re.dynamicProps;
        for (let et = 0; et < qe.length; et++) {
          const ft = qe[et], bt = fe[ft], zt = ie[ft];
          (zt !== bt || ft === "value") && a(ue, ft, bt, zt, ye, he);
        }
      }
      be & 1 && U.children !== re.children && d(ue, re.children);
    } else !q && ke == null && P(ue, fe, ie, he, ye);
    ((Ce = ie.onVnodeUpdated) || Ae) && co(() => {
      Ce && Mr(Ce, he, re, U), Ae && _l(re, U, he, "updated");
    }, Ee);
  }, R = (U, re, he, Ee, ye, K, q) => {
    for (let ue = 0; ue < re.length; ue++) {
      const be = U[ue], ke = re[ue], Ae = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        be.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (be.type === Ie || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !kl(be, ke) || // - In the case of a component, it could contain anything.
        be.shapeFlag & 198) ? f(be.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          he
        )
      );
      h(
        be,
        ke,
        Ae,
        null,
        Ee,
        ye,
        K,
        q,
        true
      );
    }
  }, P = (U, re, he, Ee, ye) => {
    if (re !== he) {
      if (re !== Zt)
        for (const K in re)
          !Gi(K) && !(K in he) && a(
            U,
            K,
            re[K],
            null,
            ye,
            Ee
          );
      for (const K in he) {
        if (Gi(K)) continue;
        const q = he[K], ue = re[K];
        q !== ue && K !== "value" && a(U, K, ue, q, ye, Ee);
      }
      "value" in he && a(U, "value", re.value, he.value, ye);
    }
  }, z = (U, re, he, Ee, ye, K, q, ue, be) => {
    const ke = re.el = U ? U.el : s(""), Ae = re.anchor = U ? U.anchor : s("");
    let { patchFlag: fe, dynamicChildren: ie, slotScopeIds: Ce } = re;
     true && // #5523 dev root fragment may inherit directives
    (lr || fe & 2048) && (fe = 0, be = false, ie = null), Ce && (ue = ue ? ue.concat(Ce) : Ce), U == null ? (o(ke, he, Ee), o(Ae, he, Ee), N(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      re.children || [],
      he,
      Ae,
      ye,
      K,
      q,
      ue,
      be
    )) : fe > 0 && fe & 64 && ie && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    U.dynamicChildren ? (R(
      U.dynamicChildren,
      ie,
      he,
      ye,
      K,
      q,
      ue
    ),  true ? Zi(U, re) : (
      // #2080 if the stable fragment has a key, it's a <template v-for> that may
      //  get moved around. Make sure all root level vnodes inherit el.
      // #2134 or if it's a component root, it may also get moved around
      // as the component is being moved.
      0
    )) : V(
      U,
      re,
      he,
      Ae,
      ye,
      K,
      q,
      ue,
      be
    );
  }, Y = (U, re, he, Ee, ye, K, q, ue, be) => {
    re.slotScopeIds = ue, U == null ? re.shapeFlag & 512 ? ye.ctx.activate(
      re,
      he,
      Ee,
      q,
      be
    ) : D(
      re,
      he,
      Ee,
      ye,
      K,
      q,
      be
    ) : M(U, re, be);
  }, D = (U, re, he, Ee, ye, K, q) => {
    const ue = U.component = i4(
      U,
      Ee,
      ye
    );
    if ( true && ue.type.__hmrId && X$(ue),  true && (Zc(U), vs(ue, "mount")), Ju(U) && (ue.ctx.renderer = Te),  true && vs(ue, "init"), c4(ue, false, q),  true && hs(ue, "init"),  true && lr && (U.el = null), ue.asyncDep) {
      if (ye && ye.registerDep(ue, F, q), !U.el) {
        const be = ue.subTree = W(tn);
        g(null, be, re, he);
      }
    } else
      F(
        ue,
        U,
        re,
        he,
        ye,
        K,
        q
      );
     true && (Qc(), hs(ue, "mount"));
  }, M = (U, re, he) => {
    const Ee = re.component = U.component;
    if (t4(U, re, he))
      if (Ee.asyncDep && !Ee.asyncResolved) {
         true && Zc(re), A(Ee, re, he),  true && Qc();
        return;
      } else
        Ee.next = re, Ee.update();
    else
      re.el = U.el, Ee.vnode = re;
  }, F = (U, re, he, Ee, ye, K, q) => {
    const ue = () => {
      if (U.isMounted) {
        let { next: fe, bu: ie, u: Ce, parent: qe, vnode: et } = U;
        {
          const ct = GC(U);
          if (ct) {
            fe && (fe.el = et.el, A(U, fe, q)), ct.asyncDep.then(() => {
              U.isUnmounted || ue();
            });
            return;
          }
        }
        let ft = fe, bt;
         true && Zc(fe || U.vnode), wl(U, false), fe ? (fe.el = et.el, A(U, fe, q)) : fe = et, ie && Es(ie), (bt = fe.props && fe.props.onVnodeBeforeUpdate) && Mr(bt, qe, fe, et), wl(U, true),  true && vs(U, "render");
        const zt = db(U);
         true && hs(U, "render");
        const We = U.subTree;
        U.subTree = zt,  true && vs(U, "patch"), h(
          We,
          zt,
          // parent may have changed if it's in a teleport
          f(We.el),
          // anchor may have changed if it's in a fragment
          ve(We),
          U,
          ye,
          K
        ),  true && hs(U, "patch"), fe.el = zt.el, ft === null && n4(U, zt.el), Ce && co(Ce, ye), (bt = fe.props && fe.props.onVnodeUpdated) && co(
          () => Mr(bt, qe, fe, et),
          ye
        ),  true && mC(U),  true && Qc();
      } else {
        let fe;
        const { el: ie, props: Ce } = re, { bm: qe, m: et, parent: ft, root: bt, type: zt } = U, We = xs(re);
        wl(U, false), qe && Es(qe), !We && (fe = Ce && Ce.onVnodeBeforeMount) && Mr(fe, ft, re), wl(U, true);
        {
          bt.ce && bt.ce._injectChildStyle(zt),  true && vs(U, "render");
          const ct = U.subTree = db(U);
           true && hs(U, "render"),  true && vs(U, "patch"), h(
            null,
            ct,
            he,
            Ee,
            U,
            ye,
            K
          ),  true && hs(U, "patch"), re.el = ct.el;
        }
        if (et && co(et, ye), !We && (fe = Ce && Ce.onVnodeMounted)) {
          const ct = re;
          co(
            () => Mr(fe, ft, ct),
            ye
          );
        }
        (re.shapeFlag & 256 || ft && xs(ft.vnode) && ft.vnode.shapeFlag & 256) && U.a && co(U.a, ye), U.isMounted = true,  true && nI(U), re = he = Ee = null;
      }
    };
    U.scope.on();
    const be = U.effect = new Kw(ue);
    U.scope.off();
    const ke = U.update = be.run.bind(be), Ae = U.job = be.runIfDirty.bind(be);
    Ae.i = U, Ae.id = U.uid, be.scheduler = () => Af(Ae), wl(U, true),  true && (be.onTrack = U.rtc ? (fe) => Es(U.rtc, fe) : void 0, be.onTrigger = U.rtg ? (fe) => Es(U.rtg, fe) : void 0), ke();
  }, A = (U, re, he) => {
    re.component = U;
    const Ee = U.vnode.props;
    U.vnode = re, U.next = null, PI(U, re.props, Ee, he), zI(U, re.children, he), vr(), Xy(U), hr();
  }, V = (U, re, he, Ee, ye, K, q, ue, be = false) => {
    const ke = U && U.children, Ae = U ? U.shapeFlag : 0, fe = re.children, { patchFlag: ie, shapeFlag: Ce } = re;
    if (ie > 0) {
      if (ie & 128) {
        G(
          ke,
          fe,
          he,
          Ee,
          ye,
          K,
          q,
          ue,
          be
        );
        return;
      } else if (ie & 256) {
        Z(
          ke,
          fe,
          he,
          Ee,
          ye,
          K,
          q,
          ue,
          be
        );
        return;
      }
    }
    Ce & 8 ? (Ae & 16 && se(ke, ye, K), fe !== ke && d(he, fe)) : Ae & 16 ? Ce & 16 ? G(
      ke,
      fe,
      he,
      Ee,
      ye,
      K,
      q,
      ue,
      be
    ) : se(ke, ye, K, true) : (Ae & 8 && d(he, ""), Ce & 16 && N(
      fe,
      he,
      Ee,
      ye,
      K,
      q,
      ue,
      be
    ));
  }, Z = (U, re, he, Ee, ye, K, q, ue, be) => {
    U = U || As, re = re || As;
    const ke = U.length, Ae = re.length, fe = Math.min(ke, Ae);
    let ie;
    for (ie = 0; ie < fe; ie++) {
      const Ce = re[ie] = be ? qa(re[ie]) : or(re[ie]);
      h(
        U[ie],
        Ce,
        he,
        null,
        ye,
        K,
        q,
        ue,
        be
      );
    }
    ke > Ae ? se(
      U,
      ye,
      K,
      true,
      false,
      fe
    ) : N(
      re,
      he,
      Ee,
      ye,
      K,
      q,
      ue,
      be,
      fe
    );
  }, G = (U, re, he, Ee, ye, K, q, ue, be) => {
    let ke = 0;
    const Ae = re.length;
    let fe = U.length - 1, ie = Ae - 1;
    for (; ke <= fe && ke <= ie; ) {
      const Ce = U[ke], qe = re[ke] = be ? qa(re[ke]) : or(re[ke]);
      if (kl(Ce, qe))
        h(
          Ce,
          qe,
          he,
          null,
          ye,
          K,
          q,
          ue,
          be
        );
      else
        break;
      ke++;
    }
    for (; ke <= fe && ke <= ie; ) {
      const Ce = U[fe], qe = re[ie] = be ? qa(re[ie]) : or(re[ie]);
      if (kl(Ce, qe))
        h(
          Ce,
          qe,
          he,
          null,
          ye,
          K,
          q,
          ue,
          be
        );
      else
        break;
      fe--, ie--;
    }
    if (ke > fe) {
      if (ke <= ie) {
        const Ce = ie + 1, qe = Ce < Ae ? re[Ce].el : Ee;
        for (; ke <= ie; )
          h(
            null,
            re[ke] = be ? qa(re[ke]) : or(re[ke]),
            he,
            qe,
            ye,
            K,
            q,
            ue,
            be
          ), ke++;
      }
    } else if (ke > ie)
      for (; ke <= fe; )
        X(U[ke], ye, K, true), ke++;
    else {
      const Ce = ke, qe = ke, et = /* @__PURE__ */ new Map();
      for (ke = qe; ke <= ie; ke++) {
        const Q = re[ke] = be ? qa(re[ke]) : or(re[ke]);
        Q.key != null && ( true && et.has(Q.key) && Je(
          "Duplicate keys found during update:",
          JSON.stringify(Q.key),
          "Make sure keys are unique."
        ), et.set(Q.key, ke));
      }
      let ft, bt = 0;
      const zt = ie - qe + 1;
      let We = false, ct = 0;
      const oe = new Array(zt);
      for (ke = 0; ke < zt; ke++) oe[ke] = 0;
      for (ke = Ce; ke <= fe; ke++) {
        const Q = U[ke];
        if (bt >= zt) {
          X(Q, ye, K, true);
          continue;
        }
        let Me;
        if (Q.key != null)
          Me = et.get(Q.key);
        else
          for (ft = qe; ft <= ie; ft++)
            if (oe[ft - qe] === 0 && kl(Q, re[ft])) {
              Me = ft;
              break;
            }
        Me === void 0 ? X(Q, ye, K, true) : (oe[Me - qe] = ke + 1, Me >= ct ? ct = Me : We = true, h(
          Q,
          re[Me],
          he,
          null,
          ye,
          K,
          q,
          ue,
          be
        ), bt++);
      }
      const Ne = We ? YI(oe) : As;
      for (ft = Ne.length - 1, ke = zt - 1; ke >= 0; ke--) {
        const Q = qe + ke, Me = re[Q], Qe = Q + 1 < Ae ? re[Q + 1].el : Ee;
        oe[ke] === 0 ? h(
          null,
          Me,
          he,
          Qe,
          ye,
          K,
          q,
          ue,
          be
        ) : We && (ft < 0 || ke !== Ne[ft] ? le(Me, he, Qe, 2) : ft--);
      }
    }
  }, le = (U, re, he, Ee, ye = null) => {
    const { el: K, type: q, transition: ue, children: be, shapeFlag: ke } = U;
    if (ke & 6) {
      le(U.component.subTree, re, he, Ee);
      return;
    }
    if (ke & 128) {
      U.suspense.move(re, he, Ee);
      return;
    }
    if (ke & 64) {
      q.move(U, re, he, Te);
      return;
    }
    if (q === Ie) {
      o(K, re, he);
      for (let fe = 0; fe < be.length; fe++)
        le(be[fe], re, he, Ee);
      o(U.anchor, re, he);
      return;
    }
    if (q === nd) {
      _(U, re, he);
      return;
    }
    if (Ee !== 2 && ke & 1 && ue)
      if (Ee === 0)
        ue.beforeEnter(K), o(K, re, he), co(() => ue.enter(K), ye);
      else {
        const { leave: fe, delayLeave: ie, afterLeave: Ce } = ue, qe = () => {
          U.ctx.isUnmounted ? r(K) : o(K, re, he);
        }, et = () => {
          fe(K, () => {
            qe(), Ce && Ce();
          });
        };
        ie ? ie(K, qe, et) : et();
      }
    else
      o(K, re, he);
  }, X = (U, re, he, Ee = false, ye = false) => {
    const {
      type: K,
      props: q,
      ref: ue,
      children: be,
      dynamicChildren: ke,
      shapeFlag: Ae,
      patchFlag: fe,
      dirs: ie,
      cacheIndex: Ce
    } = U;
    if (fe === -2 && (ye = false), ue != null && (vr(), Bd(ue, null, he, U, true), hr()), Ce != null && (re.renderCache[Ce] = void 0), Ae & 256) {
      re.ctx.deactivate(U);
      return;
    }
    const qe = Ae & 1 && ie, et = !xs(U);
    let ft;
    if (et && (ft = q && q.onVnodeBeforeUnmount) && Mr(ft, re, U), Ae & 6)
      pe(U.component, he, Ee);
    else {
      if (Ae & 128) {
        U.suspense.unmount(he, Ee);
        return;
      }
      qe && _l(U, null, re, "beforeUnmount"), Ae & 64 ? U.type.remove(
        U,
        re,
        he,
        Te,
        Ee
      ) : ke && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !ke.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (K !== Ie || fe > 0 && fe & 64) ? se(
        ke,
        re,
        he,
        false,
        true
      ) : (K === Ie && fe & 384 || !ye && Ae & 16) && se(be, re, he), Ee && te(U);
    }
    (et && (ft = q && q.onVnodeUnmounted) || qe) && co(() => {
      ft && Mr(ft, re, U), qe && _l(U, null, re, "unmounted");
    }, he);
  }, te = (U) => {
    const { type: re, el: he, anchor: Ee, transition: ye } = U;
    if (re === Ie) {
       true && U.patchFlag > 0 && U.patchFlag & 2048 && ye && !ye.persisted ? U.children.forEach((q) => {
        q.type === tn ? r(q.el) : te(q);
      }) : ce(he, Ee);
      return;
    }
    if (re === nd) {
      C(U);
      return;
    }
    const K = () => {
      r(he), ye && !ye.persisted && ye.afterLeave && ye.afterLeave();
    };
    if (U.shapeFlag & 1 && ye && !ye.persisted) {
      const { leave: q, delayLeave: ue } = ye, be = () => q(he, K);
      ue ? ue(U.el, K, be) : be();
    } else
      K();
  }, ce = (U, re) => {
    let he;
    for (; U !== re; )
      he = p(U), r(U), U = he;
    r(re);
  }, pe = (U, re, he) => {
     true && U.type.__hmrId && J$(U);
    const {
      bum: Ee,
      scope: ye,
      job: K,
      subTree: q,
      um: ue,
      m: be,
      a: ke,
      parent: Ae,
      slots: { __: fe }
    } = U;
    cb(be), cb(ke), Ee && Es(Ee), Ae && Se(fe) && fe.forEach((ie) => {
      Ae.renderCache[ie] = void 0;
    }), ye.stop(), K && (K.flags |= 8, X(q, U, re, he)), ue && co(ue, re), co(() => {
      U.isUnmounted = true;
    }, re), re && re.pendingBranch && !re.isUnmounted && U.asyncDep && !U.asyncResolved && U.suspenseId === re.pendingId && (re.deps--, re.deps === 0 && re.resolve()),  true && rI(U);
  }, se = (U, re, he, Ee = false, ye = false, K = 0) => {
    for (let q = K; q < U.length; q++)
      X(U[q], re, he, Ee, ye);
  }, ve = (U) => {
    if (U.shapeFlag & 6)
      return ve(U.component.subTree);
    if (U.shapeFlag & 128)
      return U.suspense.next();
    const re = p(U.anchor || U.el), he = re && re[_C];
    return he ? p(he) : re;
  };
  let me = false;
  const De = (U, re, he) => {
    U == null ? re._vnode && X(re._vnode, null, null, true) : h(
      re._vnode || null,
      U,
      re,
      null,
      null,
      null,
      he
    ), re._vnode = U, me || (me = true, Xy(), pC(), me = false);
  }, Te = {
    p: h,
    um: X,
    m: le,
    r: te,
    mt: D,
    mc: N,
    pc: V,
    pbc: R,
    n: ve,
    o: e10
  };
  return {
    render: De,
    hydrate: void 0,
    createApp: $I(De)
  };
}
function Hp({ type: e10, props: t }, n) {
  return n === "svg" && e10 === "foreignObject" || n === "mathml" && e10 === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : n;
}
function wl({ effect: e10, job: t }, n) {
  n ? (e10.flags |= 32, t.flags |= 4) : (e10.flags &= -33, t.flags &= -5);
}
function UI(e10, t) {
  return (!e10 || e10 && !e10.pendingBranch) && t && !t.persisted;
}
function Zi(e10, t, n = false) {
  const o = e10.children, r = t.children;
  if (Se(o) && Se(r))
    for (let a = 0; a < o.length; a++) {
      const l = o[a];
      let s = r[a];
      s.shapeFlag & 1 && !s.dynamicChildren && ((s.patchFlag <= 0 || s.patchFlag === 32) && (s = r[a] = qa(r[a]), s.el = l.el), !n && s.patchFlag !== -2 && Zi(l, s)), s.type === Zr && (s.el = l.el), s.type === tn && !s.el && (s.el = l.el),  true && s.el && (s.el.__vnode = s);
    }
}
function YI(e10) {
  const t = e10.slice(), n = [0];
  let o, r, a, l, s;
  const u = e10.length;
  for (o = 0; o < u; o++) {
    const c = e10[o];
    if (c !== 0) {
      if (r = n[n.length - 1], e10[r] < c) {
        t[o] = r, n.push(o);
        continue;
      }
      for (a = 0, l = n.length - 1; a < l; )
        s = a + l >> 1, e10[n[s]] < c ? a = s + 1 : l = s;
      c < e10[n[a]] && (a > 0 && (t[o] = n[a - 1]), n[a] = o);
    }
  }
  for (a = n.length, l = n[a - 1]; a-- > 0; )
    n[a] = l, l = t[l];
  return n;
}
function GC(e10) {
  const t = e10.subTree.component;
  if (t)
    return t.asyncDep && !t.asyncResolved ? t : GC(t);
}
function cb(e10) {
  if (e10)
    for (let t = 0; t < e10.length; t++)
      e10[t].flags |= 8;
}
const qI = Symbol.for("v-scx"), GI = () => {
  {
    const e10 = Le(qI);
    return e10 ||  true && Je(
      "Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."
    ), e10;
  }
};
function Vn(e10, t) {
  return Pm(e10, null, t);
}
function ge(e10, t, n) {
  return  true && !Fe(t) && Je(
    "`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."
  ), Pm(e10, t, n);
}
function Pm(e10, t, n = Zt) {
  const { immediate: o, deep: r, flush: a, once: l } = n;
   true && !t && (o !== void 0 && Je(
    'watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'
  ), r !== void 0 && Je(
    'watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'
  ), l !== void 0 && Je(
    'watch() "once" option is only respected when using the watch(source, callback, options?) signature.'
  ));
  const s = gn({}, n);
   true && (s.onWarn = Je);
  const u = t && o || !t && a !== "post";
  let c;
  if (hu) {
    if (a === "sync") {
      const v = GI();
      c = v.__watcherHandles || (v.__watcherHandles = []);
    } else if (!u) {
      const v = () => {
      };
      return v.stop = Mt, v.resume = Mt, v.pause = Mt, v;
    }
  }
  const d = $n;
  s.call = (v, m, h) => mr(v, d, m, h);
  let f = false;
  a === "post" ? s.scheduler = (v) => {
    co(v, d && d.suspense);
  } : a !== "sync" && (f = true, s.scheduler = (v, m) => {
    m ? v() : Af(v);
  }), s.augmentJob = (v) => {
    t && (v.flags |= 4), f && (v.flags |= 2, d && (v.id = d.uid, v.i = d));
  };
  const p = H$(e10, t, s);
  return hu && (c ? c.push(p) : u && p()), p;
}
function XI(e10, t, n) {
  const o = this.proxy, r = Ve(e10) ? e10.includes(".") ? XC(o, e10) : () => o[e10] : e10.bind(o, o);
  let a;
  Fe(t) ? a = t : (a = t.handler, n = t);
  const l = Zu(this), s = Pm(r, a.bind(o), n);
  return l(), s;
}
function XC(e10, t) {
  const n = t.split(".");
  return () => {
    let o = e10;
    for (let r = 0; r < n.length && o; r++)
      o = o[n[r]];
    return o;
  };
}
const JI = (e10, t) => t === "modelValue" || t === "model-value" ? e10.modelModifiers : e10[`${t}Modifiers`] || e10[`${Dn(t)}Modifiers`] || e10[`${Kr(t)}Modifiers`];
function ZI(e10, t, ...n) {
  if (e10.isUnmounted) return;
  const o = e10.vnode.props || Zt;
  if (true) {
    const {
      emitsOptions: d,
      propsOptions: [f]
    } = e10;
    if (d)
      if (!(t in d))
        (!f || !(fa(Dn(t)) in f)) && Je(
          `Component emitted event "${t}" but it is neither declared in the emits option nor as an "${fa(Dn(t))}" prop.`
        );
      else {
        const p = d[t];
        Fe(p) && (p(...n) || Je(
          `Invalid event arguments: event validation failed for event "${t}".`
        ));
      }
  }
  let r = n;
  const a = t.startsWith("update:"), l = a && JI(o, t.slice(7));
  if (l && (l.trim && (r = n.map((d) => Ve(d) ? d.trim() : d)), l.number && (r = n.map(Nv))),  true && sI(e10, t, r), "development" !== "production") {
    const d = t.toLowerCase();
    d !== t && o[fa(d)] && Je(
      `Event "${d}" is emitted in component ${Hf(
        e10,
        e10.type
      )} but the handler is registered for "${t}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${Kr(
        t
      )}" instead of "${t}".`
    );
  }
  let s, u = o[s = fa(t)] || // also try camelCase event handler (#2249)
  o[s = fa(Dn(t))];
  !u && a && (u = o[s = fa(Kr(t))]), u && mr(
    u,
    e10,
    6,
    r
  );
  const c = o[s + "Once"];
  if (c) {
    if (!e10.emitted)
      e10.emitted = {};
    else if (e10.emitted[s])
      return;
    e10.emitted[s] = true, mr(
      c,
      e10,
      6,
      r
    );
  }
}
function JC(e10, t, n = false) {
  const o = t.emitsCache, r = o.get(e10);
  if (r !== void 0)
    return r;
  const a = e10.emits;
  let l = {}, s = false;
  if (!Fe(e10)) {
    const u = (c) => {
      const d = JC(c, t, true);
      d && (s = true, gn(l, d));
    };
    !n && t.mixins.length && t.mixins.forEach(u), e10.extends && u(e10.extends), e10.mixins && e10.mixins.forEach(u);
  }
  return !a && !s ? (at(e10) && o.set(e10, null), null) : (Se(a) ? a.forEach((u) => l[u] = null) : gn(l, a), at(e10) && o.set(e10, l), l);
}
function Ff(e10, t) {
  return !e10 || !Uu(t) ? false : (t = t.slice(2).replace(/Once$/, ""), Tt(e10, t[0].toLowerCase() + t.slice(1)) || Tt(e10, Kr(t)) || Tt(e10, t));
}
let Dv = false;
function Wd() {
  Dv = true;
}
function db(e10) {
  const {
    type: t,
    vnode: n,
    proxy: o,
    withProxy: r,
    propsOptions: [a],
    slots: l,
    attrs: s,
    emit: u,
    render: c,
    renderCache: d,
    props: f,
    data: p,
    setupState: v,
    ctx: m,
    inheritAttrs: h
  } = e10, b = Fd(e10);
  let g, w;
   true && (Dv = false);
  try {
    if (n.shapeFlag & 4) {
      const C = r || o, E =  true && v.__isScriptSetup ? new Proxy(C, {
        get(T, O, N) {
          return Je(
            `Property '${String(
              O
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          ), Reflect.get(T, O, N);
        }
      }) : C;
      g = or(
        c.call(
          E,
          C,
          d,
           true ? Vr(f) : 0,
          v,
          p,
          m
        )
      ), w = s;
    } else {
      const C = t;
       true && s === f && Wd(), g = or(
        C.length > 1 ? C(
           true ? Vr(f) : 0,
           true ? {
            get attrs() {
              return Wd(), Vr(s);
            },
            slots: l,
            emit: u
          } : 0
        ) : C(
           true ? Vr(f) : 0,
          null
        )
      ), w = t.props ? s : QI(s);
    }
  } catch (C) {
    Qi.length = 0, Gu(C, e10, 1), g = W(tn);
  }
  let y = g, _;
  if ( true && g.patchFlag > 0 && g.patchFlag & 2048 && ([y, _] = ZC(g)), w && h !== false) {
    const C = Object.keys(w), { shapeFlag: E } = y;
    if (C.length) {
      if (E & 7)
        a && C.some(Pd) && (w = e4(
          w,
          a
        )), y = gr(y, w, false, true);
      else if ( true && !Dv && y.type !== tn) {
        const T = Object.keys(s), O = [], N = [];
        for (let $ = 0, R = T.length; $ < R; $++) {
          const P = T[$];
          Uu(P) ? Pd(P) || O.push(P[2].toLowerCase() + P.slice(3)) : N.push(P);
        }
        N.length && Je(
          `Extraneous non-props attributes (${N.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text or teleport root nodes.`
        ), O.length && Je(
          `Extraneous non-emits event listeners (${O.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
        );
      }
    }
  }
  return n.dirs && ( true && !fb(y) && Je(
    "Runtime directive used on component with non-element root node. The directives will not function as intended."
  ), y = gr(y, null, false, true), y.dirs = y.dirs ? y.dirs.concat(n.dirs) : n.dirs), n.transition && ( true && !fb(y) && Je(
    "Component inside <Transition> renders non-element root node that cannot be animated."
  ), ql(y, n.transition)),  true && _ ? _(y) : g = y, Fd(b), g;
}
const ZC = (e10) => {
  const t = e10.children, n = e10.dynamicChildren, o = Rm(t, false);
  if (o) {
    if ( true && o.patchFlag > 0 && o.patchFlag & 2048)
      return ZC(o);
  } else return [e10, void 0];
  const r = t.indexOf(o), a = n ? n.indexOf(o) : -1, l = (s) => {
    t[r] = s, n && (a > -1 ? n[a] = s : s.patchFlag > 0 && (e10.dynamicChildren = [...n, s]));
  };
  return [or(o), l];
};
function Rm(e10, t = true) {
  let n;
  for (let o = 0; o < e10.length; o++) {
    const r = e10[o];
    if (Ut(r)) {
      if (r.type !== tn || r.children === "v-if") {
        if (n)
          return;
        if (n = r,  true && t && n.patchFlag > 0 && n.patchFlag & 2048)
          return Rm(n.children);
      }
    } else
      return;
  }
  return n;
}
const QI = (e10) => {
  let t;
  for (const n in e10)
    (n === "class" || n === "style" || Uu(n)) && ((t || (t = {}))[n] = e10[n]);
  return t;
}, e4 = (e10, t) => {
  const n = {};
  for (const o in e10)
    (!Pd(o) || !(o.slice(9) in t)) && (n[o] = e10[o]);
  return n;
}, fb = (e10) => e10.shapeFlag & 7 || e10.type === tn;
function t4(e10, t, n) {
  const { props: o, children: r, component: a } = e10, { props: l, children: s, patchFlag: u } = t, c = a.emitsOptions;
  if ( true && (r || s) && lr || t.dirs || t.transition)
    return true;
  if (n && u >= 0) {
    if (u & 1024)
      return true;
    if (u & 16)
      return o ? pb(o, l, c) : !!l;
    if (u & 8) {
      const d = t.dynamicProps;
      for (let f = 0; f < d.length; f++) {
        const p = d[f];
        if (l[p] !== o[p] && !Ff(c, p))
          return true;
      }
    }
  } else
    return (r || s) && (!s || !s.$stable) ? true : o === l ? false : o ? l ? pb(o, l, c) : true : !!l;
  return false;
}
function pb(e10, t, n) {
  const o = Object.keys(t);
  if (o.length !== Object.keys(e10).length)
    return true;
  for (let r = 0; r < o.length; r++) {
    const a = o[r];
    if (t[a] !== e10[a] && !Ff(n, a))
      return true;
  }
  return false;
}
function n4({ vnode: e10, parent: t }, n) {
  for (; t; ) {
    const o = t.subTree;
    if (o.suspense && o.suspense.activeBranch === e10 && (o.el = e10.el), o === e10)
      (e10 = t.vnode).el = n, t = t.parent;
    else
      break;
  }
}
const QC = (e10) => e10.__isSuspense;
function o4(e10, t) {
  t && t.pendingBranch ? Se(e10) ? t.effects.push(...e10) : t.effects.push(e10) : fC(e10);
}
const Ie = Symbol.for("v-fgt"), Zr = Symbol.for("v-txt"), tn = Symbol.for("v-cmt"), nd = Symbol.for("v-stc"), Qi = [];
let Lo = null;
function k(e10 = false) {
  Qi.push(Lo = e10 ? null : []);
}
function r4() {
  Qi.pop(), Lo = Qi[Qi.length - 1] || null;
}
let vu = 1;
function vb(e10, t = false) {
  vu += e10, e10 < 0 && Lo && t && (Lo.hasOnce = true);
}
function eE(e10) {
  return e10.dynamicChildren = vu > 0 ? Lo || As : null, r4(), vu > 0 && Lo && Lo.push(e10), e10;
}
function x(e10, t, n, o, r, a) {
  return eE(
    B(
      e10,
      t,
      n,
      o,
      r,
      a,
      true
    )
  );
}
function ae(e10, t, n, o, r) {
  return eE(
    W(
      e10,
      t,
      n,
      o,
      r,
      true
    )
  );
}
function Ut(e10) {
  return e10 ? e10.__v_isVNode === true : false;
}
function kl(e10, t) {
  if ( true && t.shapeFlag & 6 && e10.component) {
    const n = ed.get(t.type);
    if (n && n.has(e10.component))
      return e10.shapeFlag &= -257, t.shapeFlag &= -513, false;
  }
  return e10.type === t.type && e10.key === t.key;
}
const a4 = (...e10) => nE(
  ...e10
), tE = ({ key: e10 }) => e10 != null ? e10 : null, od = ({
  ref: e10,
  ref_key: t,
  ref_for: n
}) => (typeof e10 == "number" && (e10 = "" + e10), e10 != null ? Ve(e10) || Ot(e10) || Fe(e10) ? { i: Cn, r: e10, k: t, f: !!n } : e10 : null);
function B(e10, t = null, n = null, o = 0, r = null, a = e10 === Ie ? 0 : 1, l = false, s = false) {
  const u = {
    __v_isVNode: true,
    __v_skip: true,
    type: e10,
    props: t,
    key: t && tE(t),
    ref: t && od(t),
    scopeId: yC,
    slotScopeIds: null,
    children: n,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: a,
    patchFlag: o,
    dynamicProps: r,
    dynamicChildren: null,
    appContext: null,
    ctx: Cn
  };
  return s ? (Am(u, n), a & 128 && e10.normalize(u)) : n && (u.shapeFlag |= Ve(n) ? 8 : 16),  true && u.key !== u.key && Je("VNode created with invalid key (NaN). VNode type:", u.type), vu > 0 && // avoid a block node from tracking itself
  !l && // has current parent block
  Lo && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (u.patchFlag > 0 || a & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  u.patchFlag !== 32 && Lo.push(u), u;
}
const W =  true ? a4 : 0;
function nE(e10, t = null, n = null, o = 0, r = null, a = false) {
  if ((!e10 || e10 === AC) && ( true && !e10 && Je(`Invalid vnode type when creating vnode: ${e10}.`), e10 = tn), Ut(e10)) {
    const s = gr(
      e10,
      t,
      true
      /* mergeRef: true */
    );
    return n && Am(s, n), vu > 0 && !a && Lo && (s.shapeFlag & 6 ? Lo[Lo.indexOf(e10)] = s : Lo.push(s)), s.patchFlag = -2, s;
  }
  if (sE(e10) && (e10 = e10.__vccOpts), t) {
    t = jr(t);
    let { class: s, style: u } = t;
    s && !Ve(s) && (t.class = I(s)), at(u) && (du(u) && !Se(u) && (u = gn({}, u)), t.style = ze(u));
  }
  const l = Ve(e10) ? 1 : QC(e10) ? 128 : wC(e10) ? 64 : at(e10) ? 4 : Fe(e10) ? 2 : 0;
  return  true && l & 4 && du(e10) && (e10 = Rt(e10), Je(
    "Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.",
    `
Component that was made reactive: `,
    e10
  )), B(
    e10,
    t,
    n,
    o,
    r,
    l,
    a,
    true
  );
}
function jr(e10) {
  return e10 ? du(e10) || KC(e10) ? gn({}, e10) : e10 : null;
}
function gr(e10, t, n = false, o = false) {
  const { props: r, ref: a, patchFlag: l, children: s, transition: u } = e10, c = t ? vt(r || {}, t) : r, d = {
    __v_isVNode: true,
    __v_skip: true,
    type: e10.type,
    props: c,
    key: c && tE(c),
    ref: t && t.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      n && a ? Se(a) ? a.concat(od(t)) : [a, od(t)] : od(t)
    ) : a,
    scopeId: e10.scopeId,
    slotScopeIds: e10.slotScopeIds,
    children:  true && l === -1 && Se(s) ? s.map(oE) : s,
    target: e10.target,
    targetStart: e10.targetStart,
    targetAnchor: e10.targetAnchor,
    staticCount: e10.staticCount,
    shapeFlag: e10.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: t && e10.type !== Ie ? l === -1 ? 16 : l | 16 : l,
    dynamicProps: e10.dynamicProps,
    dynamicChildren: e10.dynamicChildren,
    appContext: e10.appContext,
    dirs: e10.dirs,
    transition: u,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: e10.component,
    suspense: e10.suspense,
    ssContent: e10.ssContent && gr(e10.ssContent),
    ssFallback: e10.ssFallback && gr(e10.ssFallback),
    el: e10.el,
    anchor: e10.anchor,
    ctx: e10.ctx,
    ce: e10.ce
  };
  return u && o && ql(
    d,
    u.clone(d)
  ), d;
}
function oE(e10) {
  const t = gr(e10);
  return Se(e10.children) && (t.children = e10.children.map(oE)), t;
}
function Ze(e10 = " ", t = 0) {
  return W(Zr, null, e10, t);
}
function ee(e10 = "", t = false) {
  return t ? (k(), ae(tn, null, e10)) : W(tn, null, e10);
}
function or(e10) {
  return e10 == null || typeof e10 == "boolean" ? W(tn) : Se(e10) ? W(
    Ie,
    null,
    // #3666, avoid reference pollution when reusing vnode
    e10.slice()
  ) : Ut(e10) ? qa(e10) : W(Zr, null, String(e10));
}
function qa(e10) {
  return e10.el === null && e10.patchFlag !== -1 || e10.memo ? e10 : gr(e10);
}
function Am(e10, t) {
  let n = 0;
  const { shapeFlag: o } = e10;
  if (t == null)
    t = null;
  else if (Se(t))
    n = 16;
  else if (typeof t == "object")
    if (o & 65) {
      const r = t.default;
      r && (r._c && (r._d = false), Am(e10, r()), r._c && (r._d = true));
      return;
    } else {
      n = 32;
      const r = t._;
      !r && !KC(t) ? t._ctx = Cn : r === 3 && Cn && (Cn.slots._ === 1 ? t._ = 1 : (t._ = 2, e10.patchFlag |= 1024));
    }
  else Fe(t) ? (t = { default: t, _ctx: Cn }, n = 32) : (t = String(t), o & 64 ? (n = 16, t = [Ze(t)]) : n = 8);
  e10.children = t, e10.shapeFlag |= n;
}
function vt(...e10) {
  const t = {};
  for (let n = 0; n < e10.length; n++) {
    const o = e10[n];
    for (const r in o)
      if (r === "class")
        t.class !== o.class && (t.class = I([t.class, o.class]));
      else if (r === "style")
        t.style = ze([t.style, o.style]);
      else if (Uu(r)) {
        const a = t[r], l = o[r];
        l && a !== l && !(Se(a) && a.includes(l)) && (t[r] = a ? [].concat(a, l) : l);
      } else r !== "" && (t[r] = o[r]);
  }
  return t;
}
function Mr(e10, t, n, o = null) {
  mr(e10, t, 7, [
    n,
    o
  ]);
}
const l4 = BC();
let s4 = 0;
function i4(e10, t, n) {
  const o = e10.type, r = (t ? t.appContext : e10.appContext) || l4, a = {
    uid: s4++,
    vnode: e10,
    type: o,
    parent: t,
    appContext: r,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new Fw(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: t ? t.provides : Object.create(r.provides),
    ids: t ? t.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: jC(o, r),
    emitsOptions: JC(o, r),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: Zt,
    // inheritAttrs
    inheritAttrs: o.inheritAttrs,
    // state
    ctx: Zt,
    data: Zt,
    props: Zt,
    attrs: Zt,
    slots: Zt,
    refs: Zt,
    setupState: Zt,
    setupContext: null,
    // suspense related
    suspense: n,
    suspenseId: n ? n.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return  true ? a.ctx = bI(a) : 0, a.root = t ? t.root : a, a.emit = ZI.bind(null, a), e10.ce && e10.ce(a), a;
}
let $n = null;
const it = () => $n || Cn;
let jd, Vv;
{
  const e10 = qu(), t = (n, o) => {
    let r;
    return (r = e10[n]) || (r = e10[n] = []), r.push(o), (a) => {
      r.length > 1 ? r.forEach((l) => l(a)) : r[0](a);
    };
  };
  jd = t(
    "__VUE_INSTANCE_SETTERS__",
    (n) => $n = n
  ), Vv = t(
    "__VUE_SSR_SETTERS__",
    (n) => hu = n
  );
}
const Zu = (e10) => {
  const t = $n;
  return jd(e10), e10.scope.on(), () => {
    e10.scope.off(), jd(t);
  };
}, hb = () => {
  $n && $n.scope.off(), jd(null);
}, u4 = /* @__PURE__ */ ka("slot,component");
function Fv(e10, { isNativeTag: t }) {
  (u4(e10) || t(e10)) && Je(
    "Do not use built-in or reserved HTML elements as component id: " + e10
  );
}
function rE(e10) {
  return e10.vnode.shapeFlag & 4;
}
let hu = false;
function c4(e10, t = false, n = false) {
  t && Vv(t);
  const { props: o, children: r } = e10.vnode, a = rE(e10);
  II(e10, o, a, t), HI(e10, r, n || t);
  const l = a ? d4(e10, t) : void 0;
  return t && Vv(false), l;
}
function d4(e10, t) {
  var n;
  const o = e10.type;
  if (true) {
    if (o.name && Fv(o.name, e10.appContext.config), o.components) {
      const a = Object.keys(o.components);
      for (let l = 0; l < a.length; l++)
        Fv(a[l], e10.appContext.config);
    }
    if (o.directives) {
      const a = Object.keys(o.directives);
      for (let l = 0; l < a.length; l++)
        bC(a[l]);
    }
    o.compilerOptions && f4() && Je(
      '"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.'
    );
  }
  e10.accessCache = /* @__PURE__ */ Object.create(null), e10.proxy = new Proxy(e10.ctx, xC),  true && _I(e10);
  const { setup: r } = o;
  if (r) {
    vr();
    const a = e10.setupContext = r.length > 1 ? lE(e10) : null, l = Zu(e10), s = bi(
      r,
      e10,
      0,
      [
         true ? Vr(e10.props) : 0,
        a
      ]
    ), u = ol(s);
    if (hr(), l(), (u || e10.sp) && !xs(e10) && IC(e10), u) {
      if (s.then(hb, hb), t)
        return s.then((c) => {
          mb(e10, c, t);
        }).catch((c) => {
          Gu(c, e10, 0);
        });
      if (e10.asyncDep = s,  true && !e10.suspense) {
        const c = (n = o.name) != null ? n : "Anonymous";
        Je(
          `Component <${c}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
        );
      }
    } else
      mb(e10, s, t);
  } else
    aE(e10, t);
}
function mb(e10, t, n) {
  Fe(t) ? e10.type.__ssrInlineRender ? e10.ssrRender = t : e10.render = t : at(t) ? ( true && Ut(t) && Je(
    "setup() should not return VNodes directly - return a render function instead."
  ),  true && (e10.devtoolsRawSetupState = t), e10.setupState = sC(t),  true && wI(e10)) :  true && t !== void 0 && Je(
    `setup() should return an object. Received: ${t === null ? "null" : typeof t}`
  ), aE(e10, n);
}
const f4 = () => true;
function aE(e10, t, n) {
  const o = e10.type;
  e10.render || (e10.render = o.render || Mt);
  {
    const r = Zu(e10);
    vr();
    try {
      EI(e10);
    } finally {
      hr(), r();
    }
  }
   true && !o.render && e10.render === Mt && !t && (o.template ? Je(
    'Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".'
  ) : Je("Component is missing template or render function: ", o));
}
const gb =  true ? {
  get(e10, t) {
    return Wd(), On(e10, "get", ""), e10[t];
  },
  set() {
    return Je("setupContext.attrs is readonly."), false;
  },
  deleteProperty() {
    return Je("setupContext.attrs is readonly."), false;
  }
} : 0;
function p4(e10) {
  return new Proxy(e10.slots, {
    get(t, n) {
      return On(e10, "get", "$slots"), t[n];
    }
  });
}
function lE(e10) {
  const t = (n) => {
    if ( true && (e10.exposed && Je("expose() should be called only once per setup()."), n != null)) {
      let o = typeof n;
      o === "object" && (Se(n) ? o = "array" : Ot(n) && (o = "ref")), o !== "object" && Je(
        `expose() should be passed a plain object, received ${o}.`
      );
    }
    e10.exposed = n || {};
  };
  if (true) {
    let n, o;
    return Object.freeze({
      get attrs() {
        return n || (n = new Proxy(e10.attrs, gb));
      },
      get slots() {
        return o || (o = p4(e10));
      },
      get emit() {
        return (r, ...a) => e10.emit(r, ...a);
      },
      expose: t
    });
  } else
    // removed by dead control flow
{}
}
function Bf(e10) {
  return e10.exposed ? e10.exposeProxy || (e10.exposeProxy = new Proxy(sC(ya(e10.exposed)), {
    get(t, n) {
      if (n in t)
        return t[n];
      if (n in Hl)
        return Hl[n](e10);
    },
    has(t, n) {
      return n in t || n in Hl;
    }
  })) : e10.proxy;
}
const v4 = /(?:^|[-_])(\w)/g, h4 = (e10) => e10.replace(v4, (t) => t.toUpperCase()).replace(/[-_]/g, "");
function Lm(e10, t = true) {
  return Fe(e10) ? e10.displayName || e10.name : e10.name || t && e10.__name;
}
function Hf(e10, t, n = false) {
  let o = Lm(t);
  if (!o && t.__file) {
    const r = t.__file.match(/([^/\\]+)\.\w+$/);
    r && (o = r[1]);
  }
  if (!o && e10 && e10.parent) {
    const r = (a) => {
      for (const l in a)
        if (a[l] === t)
          return l;
    };
    o = r(
      e10.components || e10.parent.type.components
    ) || r(e10.appContext.components);
  }
  return o ? h4(o) : n ? "App" : "Anonymous";
}
function sE(e10) {
  return Fe(e10) && "__vccOpts" in e10;
}
const S = (e10, t) => {
  const n = F$(e10, t, hu);
  if (true) {
    const o = it();
    o && o.appContext.config.warnRecursiveComputed && (n._warnRecursive = true);
  }
  return n;
};
function Ke(e10, t, n) {
  const o = arguments.length;
  return o === 2 ? at(t) && !Se(t) ? Ut(t) ? W(e10, null, [t]) : W(e10, t) : W(e10, null, t) : (o > 3 ? n = Array.prototype.slice.call(arguments, 2) : o === 3 && Ut(n) && (n = [n]), W(e10, t, n));
}
function m4() {
  if ( false || typeof window > "u")
    return;
  const e10 = { style: "color:#3ba776" }, t = { style: "color:#1677ff" }, n = { style: "color:#f5222d" }, o = { style: "color:#eb2f96" }, r = {
    __vue_custom_formatter: true,
    header(f) {
      if (!at(f))
        return null;
      if (f.__isVue)
        return ["div", e10, "VueInstance"];
      if (Ot(f)) {
        vr();
        const p = f.value;
        return hr(), [
          "div",
          {},
          ["span", e10, d(f)],
          "<",
          s(p),
          ">"
        ];
      } else {
        if (Vl(f))
          return [
            "div",
            {},
            ["span", e10, ho(f) ? "ShallowReactive" : "Reactive"],
            "<",
            s(f),
            `>${Wr(f) ? " (readonly)" : ""}`
          ];
        if (Wr(f))
          return [
            "div",
            {},
            ["span", e10, ho(f) ? "ShallowReadonly" : "Readonly"],
            "<",
            s(f),
            ">"
          ];
      }
      return null;
    },
    hasBody(f) {
      return f && f.__isVue;
    },
    body(f) {
      if (f && f.__isVue)
        return [
          "div",
          {},
          ...a(f.$)
        ];
    }
  };
  function a(f) {
    const p = [];
    f.type.props && f.props && p.push(l("props", Rt(f.props))), f.setupState !== Zt && p.push(l("setup", f.setupState)), f.data !== Zt && p.push(l("data", Rt(f.data)));
    const v = u(f, "computed");
    v && p.push(l("computed", v));
    const m = u(f, "inject");
    return m && p.push(l("injected", m)), p.push([
      "div",
      {},
      [
        "span",
        {
          style: o.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: f }]
    ]), p;
  }
  function l(f, p) {
    return p = gn({}, p), Object.keys(p).length ? [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        f
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(p).map((v) => [
          "div",
          {},
          ["span", o, v + ": "],
          s(p[v], false)
        ])
      ]
    ] : ["span", {}];
  }
  function s(f, p = true) {
    return typeof f == "number" ? ["span", t, f] : typeof f == "string" ? ["span", n, JSON.stringify(f)] : typeof f == "boolean" ? ["span", o, f] : at(f) ? ["object", { object: p ? Rt(f) : f }] : ["span", n, String(f)];
  }
  function u(f, p) {
    const v = f.type;
    if (Fe(v))
      return;
    const m = {};
    for (const h in f.ctx)
      c(v, h, p) && (m[h] = f.ctx[h]);
    return m;
  }
  function c(f, p, v) {
    const m = f[v];
    if (Se(m) && m.includes(p) || at(m) && p in m || f.extends && c(f.extends, p, v) || f.mixins && f.mixins.some((h) => c(h, p, v)))
      return true;
  }
  function d(f) {
    return ho(f) ? "ShallowRef" : f.effect ? "ComputedRef" : "Ref";
  }
  window.devtoolsFormatters ? window.devtoolsFormatters.push(r) : window.devtoolsFormatters = [r];
}
const yb = "3.5.16", dr =  true ? Je : 0;
"development";
"development";
/**
* @vue/runtime-dom v3.5.16
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let Bv;
const bb = typeof window < "u" && window.trustedTypes;
if (bb)
  try {
    Bv = /* @__PURE__ */ bb.createPolicy("vue", {
      createHTML: (e10) => e10
    });
  } catch (e10) {
     true && dr(`Error creating trusted types policy: ${e10}`);
  }
const iE = Bv ? (e10) => Bv.createHTML(e10) : (e10) => e10, g4 = "http://www.w3.org/2000/svg", y4 = "http://www.w3.org/1998/Math/MathML", ua = typeof document < "u" ? document : null, _b = ua && /* @__PURE__ */ ua.createElement("template"), b4 = {
  insert: (e10, t, n) => {
    t.insertBefore(e10, n || null);
  },
  remove: (e10) => {
    const t = e10.parentNode;
    t && t.removeChild(e10);
  },
  createElement: (e10, t, n, o) => {
    const r = t === "svg" ? ua.createElementNS(g4, e10) : t === "mathml" ? ua.createElementNS(y4, e10) : n ? ua.createElement(e10, { is: n }) : ua.createElement(e10);
    return e10 === "select" && o && o.multiple != null && r.setAttribute("multiple", o.multiple), r;
  },
  createText: (e10) => ua.createTextNode(e10),
  createComment: (e10) => ua.createComment(e10),
  setText: (e10, t) => {
    e10.nodeValue = t;
  },
  setElementText: (e10, t) => {
    e10.textContent = t;
  },
  parentNode: (e10) => e10.parentNode,
  nextSibling: (e10) => e10.nextSibling,
  querySelector: (e10) => ua.querySelector(e10),
  setScopeId(e10, t) {
    e10.setAttribute(t, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(e10, t, n, o, r, a) {
    const l = n ? n.previousSibling : t.lastChild;
    if (r && (r === a || r.nextSibling))
      for (; t.insertBefore(r.cloneNode(true), n), !(r === a || !(r = r.nextSibling)); )
        ;
    else {
      _b.innerHTML = iE(
        o === "svg" ? `<svg>${e10}</svg>` : o === "mathml" ? `<math>${e10}</math>` : e10
      );
      const s = _b.content;
      if (o === "svg" || o === "mathml") {
        const u = s.firstChild;
        for (; u.firstChild; )
          s.appendChild(u.firstChild);
        s.removeChild(u);
      }
      t.insertBefore(s, n);
    }
    return [
      // first
      l ? l.nextSibling : t.firstChild,
      // last
      n ? n.previousSibling : t.lastChild
    ];
  }
}, Ba = "transition", Di = "animation", Gs = Symbol("_vtc"), uE = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
}, cE = /* @__PURE__ */ gn(
  {},
  NC,
  uE
), _4 = (e10) => (e10.displayName = "Transition", e10.props = cE, e10), Rn = /* @__PURE__ */ _4(
  (e10, { slots: t }) => Ke(cI, dE(e10), t)
), Cl = (e10, t = []) => {
  Se(e10) ? e10.forEach((n) => n(...t)) : e10 && e10(...t);
}, wb = (e10) => e10 ? Se(e10) ? e10.some((t) => t.length > 1) : e10.length > 1 : false;
function dE(e10) {
  const t = {};
  for (const P in e10)
    P in uE || (t[P] = e10[P]);
  if (e10.css === false)
    return t;
  const {
    name: n = "v",
    type: o,
    duration: r,
    enterFromClass: a = `${n}-enter-from`,
    enterActiveClass: l = `${n}-enter-active`,
    enterToClass: s = `${n}-enter-to`,
    appearFromClass: u = a,
    appearActiveClass: c = l,
    appearToClass: d = s,
    leaveFromClass: f = `${n}-leave-from`,
    leaveActiveClass: p = `${n}-leave-active`,
    leaveToClass: v = `${n}-leave-to`
  } = e10, m = w4(r), h = m && m[0], b = m && m[1], {
    onBeforeEnter: g,
    onEnter: w,
    onEnterCancelled: y,
    onLeave: _,
    onLeaveCancelled: C,
    onBeforeAppear: E = g,
    onAppear: T = w,
    onAppearCancelled: O = y
  } = t, N = (P, z, Y, D) => {
    P._enterCancelled = D, Ka(P, z ? d : s), Ka(P, z ? c : l), Y && Y();
  }, $ = (P, z) => {
    P._isLeaving = false, Ka(P, f), Ka(P, v), Ka(P, p), z && z();
  }, R = (P) => (z, Y) => {
    const D = P ? T : w, M = () => N(z, P, Y);
    Cl(D, [z, M]), Cb(() => {
      Ka(z, P ? u : a), Rr(z, P ? d : s), wb(D) || Eb(z, o, h, M);
    });
  };
  return gn(t, {
    onBeforeEnter(P) {
      Cl(g, [P]), Rr(P, a), Rr(P, l);
    },
    onBeforeAppear(P) {
      Cl(E, [P]), Rr(P, u), Rr(P, c);
    },
    onEnter: R(false),
    onAppear: R(true),
    onLeave(P, z) {
      P._isLeaving = true;
      const Y = () => $(P, z);
      Rr(P, f), P._enterCancelled ? (Rr(P, p), Hv()) : (Hv(), Rr(P, p)), Cb(() => {
        P._isLeaving && (Ka(P, f), Rr(P, v), wb(_) || Eb(P, o, b, Y));
      }), Cl(_, [P, Y]);
    },
    onEnterCancelled(P) {
      N(P, false, void 0, true), Cl(y, [P]);
    },
    onAppearCancelled(P) {
      N(P, true, void 0, true), Cl(O, [P]);
    },
    onLeaveCancelled(P) {
      $(P), Cl(C, [P]);
    }
  });
}
function w4(e10) {
  if (e10 == null)
    return null;
  if (at(e10))
    return [zp(e10.enter), zp(e10.leave)];
  {
    const t = zp(e10);
    return [t, t];
  }
}
function zp(e10) {
  const t = QO(e10);
  return  true && U$(t, "<transition> explicit duration"), t;
}
function Rr(e10, t) {
  t.split(/\s+/).forEach((n) => n && e10.classList.add(n)), (e10[Gs] || (e10[Gs] = /* @__PURE__ */ new Set())).add(t);
}
function Ka(e10, t) {
  t.split(/\s+/).forEach((o) => o && e10.classList.remove(o));
  const n = e10[Gs];
  n && (n.delete(t), n.size || (e10[Gs] = void 0));
}
function Cb(e10) {
  requestAnimationFrame(() => {
    requestAnimationFrame(e10);
  });
}
let C4 = 0;
function Eb(e10, t, n, o) {
  const r = e10._endId = ++C4, a = () => {
    r === e10._endId && o();
  };
  if (n != null)
    return setTimeout(a, n);
  const { type: l, timeout: s, propCount: u } = fE(e10, t);
  if (!l)
    return o();
  const c = l + "end";
  let d = 0;
  const f = () => {
    e10.removeEventListener(c, p), a();
  }, p = (v) => {
    v.target === e10 && ++d >= u && f();
  };
  setTimeout(() => {
    d < u && f();
  }, s + 1), e10.addEventListener(c, p);
}
function fE(e10, t) {
  const n = window.getComputedStyle(e10), o = (m) => (n[m] || "").split(", "), r = o(`${Ba}Delay`), a = o(`${Ba}Duration`), l = Sb(r, a), s = o(`${Di}Delay`), u = o(`${Di}Duration`), c = Sb(s, u);
  let d = null, f = 0, p = 0;
  t === Ba ? l > 0 && (d = Ba, f = l, p = a.length) : t === Di ? c > 0 && (d = Di, f = c, p = u.length) : (f = Math.max(l, c), d = f > 0 ? l > c ? Ba : Di : null, p = d ? d === Ba ? a.length : u.length : 0);
  const v = d === Ba && /\b(transform|all)(,|$)/.test(
    o(`${Ba}Property`).toString()
  );
  return {
    type: d,
    timeout: f,
    propCount: p,
    hasTransform: v
  };
}
function Sb(e10, t) {
  for (; e10.length < t.length; )
    e10 = e10.concat(e10);
  return Math.max(...t.map((n, o) => kb(n) + kb(e10[o])));
}
function kb(e10) {
  return e10 === "auto" ? 0 : Number(e10.slice(0, -1).replace(",", ".")) * 1e3;
}
function Hv() {
  return document.body.offsetHeight;
}
function E4(e10, t, n) {
  const o = e10[Gs];
  o && (t = (t ? [t, ...o] : [...o]).join(" ")), t == null ? e10.removeAttribute("class") : n ? e10.setAttribute("class", t) : e10.className = t;
}
const Ud = Symbol("_vod"), pE = Symbol("_vsh"), Nt = {
  beforeMount(e10, { value: t }, { transition: n }) {
    e10[Ud] = e10.style.display === "none" ? "" : e10.style.display, n && t ? n.beforeEnter(e10) : Vi(e10, t);
  },
  mounted(e10, { value: t }, { transition: n }) {
    n && t && n.enter(e10);
  },
  updated(e10, { value: t, oldValue: n }, { transition: o }) {
    !t != !n && (o ? t ? (o.beforeEnter(e10), Vi(e10, true), o.enter(e10)) : o.leave(e10, () => {
      Vi(e10, false);
    }) : Vi(e10, t));
  },
  beforeUnmount(e10, { value: t }) {
    Vi(e10, t);
  }
};
 true && (Nt.name = "show");
function Vi(e10, t) {
  e10.style.display = t ? e10[Ud] : "none", e10[pE] = !t;
}
const S4 = Symbol( true ? "CSS_VAR_TEXT" : 0), k4 = /(^|;)\s*display\s*:/;
function N4(e10, t, n) {
  const o = e10.style, r = Ve(n);
  let a = false;
  if (n && !r) {
    if (t)
      if (Ve(t))
        for (const l of t.split(";")) {
          const s = l.slice(0, l.indexOf(":")).trim();
          n[s] == null && rd(o, s, "");
        }
      else
        for (const l in t)
          n[l] == null && rd(o, l, "");
    for (const l in n)
      l === "display" && (a = true), rd(o, l, n[l]);
  } else if (r) {
    if (t !== n) {
      const l = o[S4];
      l && (n += ";" + l), o.cssText = n, a = k4.test(n);
    }
  } else t && e10.removeAttribute("style");
  Ud in e10 && (e10[Ud] = a ? o.display : "", e10[pE] && (o.display = "none"));
}
const T4 = /[^\\];\s*$/, Nb = /\s*!important$/;
function rd(e10, t, n) {
  if (Se(n))
    n.forEach((o) => rd(e10, t, o));
  else if (n == null && (n = ""),  true && T4.test(n) && dr(
    `Unexpected semicolon at the end of '${t}' style value: '${n}'`
  ), t.startsWith("--"))
    e10.setProperty(t, n);
  else {
    const o = O4(e10, t);
    Nb.test(n) ? e10.setProperty(
      Kr(o),
      n.replace(Nb, ""),
      "important"
    ) : e10[o] = n;
  }
}
const Tb = ["Webkit", "Moz", "ms"], Kp = {};
function O4(e10, t) {
  const n = Kp[t];
  if (n)
    return n;
  let o = Dn(t);
  if (o !== "filter" && o in e10)
    return Kp[t] = o;
  o = rl(o);
  for (let r = 0; r < Tb.length; r++) {
    const a = Tb[r] + o;
    if (a in e10)
      return Kp[t] = a;
  }
  return t;
}
const Ob = "http://www.w3.org/1999/xlink";
function $b(e10, t, n, o, r, a = d$(t)) {
  o && t.startsWith("xlink:") ? n == null ? e10.removeAttributeNS(Ob, t.slice(6, t.length)) : e10.setAttributeNS(Ob, t, n) : n == null || a && !Lw(n) ? e10.removeAttribute(t) : e10.setAttribute(
    t,
    a ? "" : pr(n) ? String(n) : n
  );
}
function Ib(e10, t, n, o, r) {
  if (t === "innerHTML" || t === "textContent") {
    n != null && (e10[t] = t === "innerHTML" ? iE(n) : n);
    return;
  }
  const a = e10.tagName;
  if (t === "value" && a !== "PROGRESS" && // custom elements may use _value internally
  !a.includes("-")) {
    const s = a === "OPTION" ? e10.getAttribute("value") || "" : e10.value, u = n == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      e10.type === "checkbox" ? "on" : ""
    ) : String(n);
    (s !== u || !("_value" in e10)) && (e10.value = u), n == null && e10.removeAttribute(t), e10._value = n;
    return;
  }
  let l = false;
  if (n === "" || n == null) {
    const s = typeof e10[t];
    s === "boolean" ? n = Lw(n) : n == null && s === "string" ? (n = "", l = true) : s === "number" && (n = 0, l = true);
  }
  try {
    e10[t] = n;
  } catch (s) {
     true && !l && dr(
      `Failed setting prop "${t}" on <${a.toLowerCase()}>: value ${n} is invalid.`,
      s
    );
  }
  l && e10.removeAttribute(r || t);
}
function Xa(e10, t, n, o) {
  e10.addEventListener(t, n, o);
}
function $4(e10, t, n, o) {
  e10.removeEventListener(t, n, o);
}
const Mb = Symbol("_vei");
function I4(e10, t, n, o, r = null) {
  const a = e10[Mb] || (e10[Mb] = {}), l = a[t];
  if (o && l)
    l.value =  true ? Rb(o, t) : 0;
  else {
    const [s, u] = M4(t);
    if (o) {
      const c = a[t] = A4(
         true ? Rb(o, t) : 0,
        r
      );
      Xa(e10, s, c, u);
    } else l && ($4(e10, s, l, u), a[t] = void 0);
  }
}
const Pb = /(?:Once|Passive|Capture)$/;
function M4(e10) {
  let t;
  if (Pb.test(e10)) {
    t = {};
    let o;
    for (; o = e10.match(Pb); )
      e10 = e10.slice(0, e10.length - o[0].length), t[o[0].toLowerCase()] = true;
  }
  return [e10[2] === ":" ? e10.slice(3) : Kr(e10.slice(2)), t];
}
let Wp = 0;
const P4 = /* @__PURE__ */ Promise.resolve(), R4 = () => Wp || (P4.then(() => Wp = 0), Wp = Date.now());
function A4(e10, t) {
  const n = (o) => {
    if (!o._vts)
      o._vts = Date.now();
    else if (o._vts <= n.attached)
      return;
    mr(
      L4(o, n.value),
      t,
      5,
      [o]
    );
  };
  return n.value = e10, n.attached = R4(), n;
}
function Rb(e10, t) {
  return Fe(e10) || Se(e10) ? e10 : (dr(
    `Wrong type passed as event handler to ${t} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof e10}.`
  ), Mt);
}
function L4(e10, t) {
  if (Se(t)) {
    const n = e10.stopImmediatePropagation;
    return e10.stopImmediatePropagation = () => {
      n.call(e10), e10._stopped = true;
    }, t.map(
      (o) => (r) => !r._stopped && o && o(r)
    );
  } else
    return t;
}
const Ab = (e10) => e10.charCodeAt(0) === 111 && e10.charCodeAt(1) === 110 && // lowercase letter
e10.charCodeAt(2) > 96 && e10.charCodeAt(2) < 123, x4 = (e10, t, n, o, r, a) => {
  const l = r === "svg";
  t === "class" ? E4(e10, o, l) : t === "style" ? N4(e10, n, o) : Uu(t) ? Pd(t) || I4(e10, t, n, o, a) : (t[0] === "." ? (t = t.slice(1), true) : t[0] === "^" ? (t = t.slice(1), false) : D4(e10, t, o, l)) ? (Ib(e10, t, o), !e10.tagName.includes("-") && (t === "value" || t === "checked" || t === "selected") && $b(e10, t, o, l, a, t !== "value")) : (
    /* #11081 force set props for possible async custom element */
    e10._isVueCE && (/[A-Z]/.test(t) || !Ve(o)) ? Ib(e10, Dn(t), o, a, t) : (t === "true-value" ? e10._trueValue = o : t === "false-value" && (e10._falseValue = o), $b(e10, t, o, l))
  );
};
function D4(e10, t, n, o) {
  if (o)
    return !!(t === "innerHTML" || t === "textContent" || t in e10 && Ab(t) && Fe(n));
  if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "autocorrect" || t === "form" || t === "list" && e10.tagName === "INPUT" || t === "type" && e10.tagName === "TEXTAREA")
    return false;
  if (t === "width" || t === "height") {
    const r = e10.tagName;
    if (r === "IMG" || r === "VIDEO" || r === "CANVAS" || r === "SOURCE")
      return false;
  }
  return Ab(t) && Ve(n) ? false : t in e10;
}
const vE = /* @__PURE__ */ new WeakMap(), hE = /* @__PURE__ */ new WeakMap(), Yd = Symbol("_moveCb"), Lb = Symbol("_enterCb"), V4 = (e10) => (delete e10.props.mode, e10), F4 = /* @__PURE__ */ V4({
  name: "TransitionGroup",
  props: /* @__PURE__ */ gn({}, cE, {
    tag: String,
    moveClass: String
  }),
  setup(e10, { slots: t }) {
    const n = it(), o = kC();
    let r, a;
    return wr(() => {
      if (!r.length)
        return;
      const l = e10.moveClass || `${e10.name || "v"}-move`;
      if (!K4(
        r[0].el,
        n.vnode.el,
        l
      )) {
        r = [];
        return;
      }
      r.forEach(B4), r.forEach(H4);
      const s = r.filter(z4);
      Hv(), s.forEach((u) => {
        const c = u.el, d = c.style;
        Rr(c, l), d.transform = d.webkitTransform = d.transitionDuration = "";
        const f = c[Yd] = (p) => {
          p && p.target !== c || (!p || /transform$/.test(p.propertyName)) && (c.removeEventListener("transitionend", f), c[Yd] = null, Ka(c, l));
        };
        c.addEventListener("transitionend", f);
      }), r = [];
    }), () => {
      const l = Rt(e10), s = dE(l);
      let u = l.tag || Ie;
      if (r = [], a)
        for (let c = 0; c < a.length; c++) {
          const d = a[c];
          d.el && d.el instanceof Element && (r.push(d), ql(
            d,
            pu(
              d,
              s,
              o,
              n
            )
          ), vE.set(
            d,
            d.el.getBoundingClientRect()
          ));
        }
      a = t.default ? Tm(t.default()) : [];
      for (let c = 0; c < a.length; c++) {
        const d = a[c];
        d.key != null ? ql(
          d,
          pu(d, s, o, n)
        ) :  true && d.type !== Zr && dr("<TransitionGroup> children must be keyed.");
      }
      return W(u, null, a);
    };
  }
}), mE = F4;
function B4(e10) {
  const t = e10.el;
  t[Yd] && t[Yd](), t[Lb] && t[Lb]();
}
function H4(e10) {
  hE.set(e10, e10.el.getBoundingClientRect());
}
function z4(e10) {
  const t = vE.get(e10), n = hE.get(e10), o = t.left - n.left, r = t.top - n.top;
  if (o || r) {
    const a = e10.el.style;
    return a.transform = a.webkitTransform = `translate(${o}px,${r}px)`, a.transitionDuration = "0s", e10;
  }
}
function K4(e10, t, n) {
  const o = e10.cloneNode(), r = e10[Gs];
  r && r.forEach((s) => {
    s.split(/\s+/).forEach((u) => u && o.classList.remove(u));
  }), n.split(/\s+/).forEach((s) => s && o.classList.add(s)), o.style.display = "none";
  const a = t.nodeType === 1 ? t : t.parentNode;
  a.appendChild(o);
  const { hasTransform: l } = fE(o);
  return a.removeChild(o), l;
}
const Xs = (e10) => {
  const t = e10.props["onUpdate:modelValue"] || false;
  return Se(t) ? (n) => Es(t, n) : t;
};
function W4(e10) {
  e10.target.composing = true;
}
function xb(e10) {
  const t = e10.target;
  t.composing && (t.composing = false, t.dispatchEvent(new Event("input")));
}
const ba = Symbol("_assign"), Qu = {
  created(e10, { modifiers: { lazy: t, trim: n, number: o } }, r) {
    e10[ba] = Xs(r);
    const a = o || r.props && r.props.type === "number";
    Xa(e10, t ? "change" : "input", (l) => {
      if (l.target.composing) return;
      let s = e10.value;
      n && (s = s.trim()), a && (s = Nv(s)), e10[ba](s);
    }), n && Xa(e10, "change", () => {
      e10.value = e10.value.trim();
    }), t || (Xa(e10, "compositionstart", W4), Xa(e10, "compositionend", xb), Xa(e10, "change", xb));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(e10, { value: t }) {
    e10.value = t != null ? t : "";
  },
  beforeUpdate(e10, { value: t, oldValue: n, modifiers: { lazy: o, trim: r, number: a } }, l) {
    if (e10[ba] = Xs(l), e10.composing) return;
    const s = (a || e10.type === "number") && !/^0\d/.test(e10.value) ? Nv(e10.value) : e10.value, u = t != null ? t : "";
    s !== u && (document.activeElement === e10 && e10.type !== "range" && (o && t === n || r && e10.value.trim() === u) || (e10.value = u));
  }
}, qd = {
  // #4096 array checkboxes need to be deep traversed
  deep: true,
  created(e10, t, n) {
    e10[ba] = Xs(n), Xa(e10, "change", () => {
      const o = e10._modelValue, r = yE(e10), a = e10.checked, l = e10[ba];
      if (Se(o)) {
        const s = xw(o, r), u = s !== -1;
        if (a && !u)
          l(o.concat(r));
        else if (!a && u) {
          const c = [...o];
          c.splice(s, 1), l(c);
        }
      } else if (Of(o)) {
        const s = new Set(o);
        a ? s.add(r) : s.delete(r), l(s);
      } else
        l(bE(e10, a));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: Db,
  beforeUpdate(e10, t, n) {
    e10[ba] = Xs(n), Db(e10, t, n);
  }
};
function Db(e10, { value: t, oldValue: n }, o) {
  e10._modelValue = t;
  let r;
  if (Se(t))
    r = xw(t, o.props.value) > -1;
  else if (Of(t))
    r = t.has(o.props.value);
  else {
    if (t === n) return;
    r = qs(t, bE(e10, true));
  }
  e10.checked !== r && (e10.checked = r);
}
const gE = {
  created(e10, { value: t }, n) {
    e10.checked = qs(t, n.props.value), e10[ba] = Xs(n), Xa(e10, "change", () => {
      e10[ba](yE(e10));
    });
  },
  beforeUpdate(e10, { value: t, oldValue: n }, o) {
    e10[ba] = Xs(o), t !== n && (e10.checked = qs(t, o.props.value));
  }
};
function yE(e10) {
  return "_value" in e10 ? e10._value : e10.value;
}
function bE(e10, t) {
  const n = t ? "_trueValue" : "_falseValue";
  return n in e10 ? e10[n] : t;
}
const j4 = ["ctrl", "shift", "alt", "meta"], U4 = {
  stop: (e10) => e10.stopPropagation(),
  prevent: (e10) => e10.preventDefault(),
  self: (e10) => e10.target !== e10.currentTarget,
  ctrl: (e10) => !e10.ctrlKey,
  shift: (e10) => !e10.shiftKey,
  alt: (e10) => !e10.altKey,
  meta: (e10) => !e10.metaKey,
  left: (e10) => "button" in e10 && e10.button !== 0,
  middle: (e10) => "button" in e10 && e10.button !== 1,
  right: (e10) => "button" in e10 && e10.button !== 2,
  exact: (e10, t) => j4.some((n) => e10[`${n}Key`] && !t.includes(n))
}, Xe = (e10, t) => {
  const n = e10._withMods || (e10._withMods = {}), o = t.join(".");
  return n[o] || (n[o] = (r, ...a) => {
    for (let l = 0; l < t.length; l++) {
      const s = U4[t[l]];
      if (s && s(r, t)) return;
    }
    return e10(r, ...a);
  });
}, Y4 = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
}, Bt = (e10, t) => {
  const n = e10._withKeys || (e10._withKeys = {}), o = t.join(".");
  return n[o] || (n[o] = (r) => {
    if (!("key" in r))
      return;
    const a = Kr(r.key);
    if (t.some(
      (l) => l === a || Y4[l] === a
    ))
      return e10(r);
  });
}, q4 = /* @__PURE__ */ gn({ patchProp: x4 }, b4);
let Vb;
function _E() {
  return Vb || (Vb = WI(q4));
}
const al = (...e10) => {
  _E().render(...e10);
}, wE = (...e10) => {
  const t = _E().createApp(...e10);
   true && (X4(t), J4(t));
  const { mount: n } = t;
  return t.mount = (o) => {
    const r = Z4(o);
    if (!r) return;
    const a = t._component;
    !Fe(a) && !a.render && !a.template && (a.template = r.innerHTML), r.nodeType === 1 && (r.textContent = "");
    const l = n(r, false, G4(r));
    return r instanceof Element && (r.removeAttribute("v-cloak"), r.setAttribute("data-v-app", "")), l;
  }, t;
};
function G4(e10) {
  if (e10 instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && e10 instanceof MathMLElement)
    return "mathml";
}
function X4(e10) {
  Object.defineProperty(e10.config, "isNativeTag", {
    value: (t) => s$(t) || i$(t) || u$(t),
    writable: false
  });
}
function J4(e10) {
  {
    const t = e10.config.isCustomElement;
    Object.defineProperty(e10.config, "isCustomElement", {
      get() {
        return t;
      },
      set() {
        dr(
          "The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead."
        );
      }
    });
    const n = e10.config.compilerOptions, o = 'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc';
    Object.defineProperty(e10.config, "compilerOptions", {
      get() {
        return dr(o), n;
      },
      set() {
        dr(o);
      }
    });
  }
}
function Z4(e10) {
  if (Ve(e10)) {
    const t = document.querySelector(e10);
    return  true && !t && dr(
      `Failed to mount app: mount target selector "${e10}" returned null.`
    ), t;
  }
  return  true && window.ShadowRoot && e10 instanceof window.ShadowRoot && e10.mode === "closed" && dr(
    'mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'
  ), e10;
}
/**
* vue v3.5.16
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function Q4() {
  m4();
}
 true && Q4();
const CE = Symbol(), eu = "el", e3 = "is-", El = (e10, t, n, o, r) => {
  let a = `${e10}-${t}`;
  return n && (a += `-${n}`), o && (a += `__${o}`), r && (a += `--${r}`), a;
}, EE = Symbol("namespaceContextKey"), xm = (e10) => {
  const t = e10 || (it() ? Le(EE, L(eu)) : L(eu));
  return S(() => i(t) || eu);
}, we = (e10, t) => {
  const n = xm(t);
  return {
    namespace: n,
    b: (h = "") => El(n.value, e10, h, "", ""),
    e: (h) => h ? El(n.value, e10, "", h, "") : "",
    m: (h) => h ? El(n.value, e10, "", "", h) : "",
    be: (h, b) => h && b ? El(n.value, e10, h, b, "") : "",
    em: (h, b) => h && b ? El(n.value, e10, "", h, b) : "",
    bm: (h, b) => h && b ? El(n.value, e10, h, "", b) : "",
    bem: (h, b, g) => h && b && g ? El(n.value, e10, h, b, g) : "",
    is: (h, ...b) => {
      const g = b.length >= 1 ? b[0] : true;
      return h && g ? `${e3}${h}` : "";
    },
    cssVar: (h) => {
      const b = {};
      for (const g in h)
        h[g] && (b[`--${n.value}-${g}`] = h[g]);
      return b;
    },
    cssVarName: (h) => `--${n.value}-${h}`,
    cssVarBlock: (h) => {
      const b = {};
      for (const g in h)
        h[g] && (b[`--${n.value}-${e10}-${g}`] = h[g]);
      return b;
    },
    cssVarBlockName: (h) => `--${n.value}-${e10}-${h}`
  };
};
var SE = typeof __webpack_require__.g == "object" && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g, t3 = typeof self == "object" && self && self.Object === Object && self, Cr = SE || t3 || Function("return this")(), Xo = Cr.Symbol, kE = Object.prototype, n3 = kE.hasOwnProperty, o3 = kE.toString, Fi = Xo ? Xo.toStringTag : void 0;
function r3(e10) {
  var t = n3.call(e10, Fi), n = e10[Fi];
  try {
    e10[Fi] = void 0;
    var o = true;
  } catch {
  }
  var r = o3.call(e10);
  return o && (t ? e10[Fi] = n : delete e10[Fi]), r;
}
var a3 = Object.prototype, l3 = a3.toString;
function s3(e10) {
  return l3.call(e10);
}
var i3 = "[object Null]", u3 = "[object Undefined]", Fb = Xo ? Xo.toStringTag : void 0;
function ss(e10) {
  return e10 == null ? e10 === void 0 ? u3 : i3 : Fb && Fb in Object(e10) ? r3(e10) : s3(e10);
}
function Ur(e10) {
  return e10 != null && typeof e10 == "object";
}
var c3 = "[object Symbol]";
function zf(e10) {
  return typeof e10 == "symbol" || Ur(e10) && ss(e10) == c3;
}
function Dm(e10, t) {
  for (var n = -1, o = e10 == null ? 0 : e10.length, r = Array(o); ++n < o; )
    r[n] = t(e10[n], n, e10);
  return r;
}
var mo = Array.isArray, Bb = Xo ? Xo.prototype : void 0, Hb = Bb ? Bb.toString : void 0;
function NE(e10) {
  if (typeof e10 == "string")
    return e10;
  if (mo(e10))
    return Dm(e10, NE) + "";
  if (zf(e10))
    return Hb ? Hb.call(e10) : "";
  var t = e10 + "";
  return t == "0" && 1 / e10 == -1 / 0 ? "-0" : t;
}
var d3 = /\s/;
function f3(e10) {
  for (var t = e10.length; t-- && d3.test(e10.charAt(t)); )
    ;
  return t;
}
var p3 = /^\s+/;
function v3(e10) {
  return e10 && e10.slice(0, f3(e10) + 1).replace(p3, "");
}
function go(e10) {
  var t = typeof e10;
  return e10 != null && (t == "object" || t == "function");
}
var zb = NaN, h3 = /^[-+]0x[0-9a-f]+$/i, m3 = /^0b[01]+$/i, g3 = /^0o[0-7]+$/i, y3 = parseInt;
function Kb(e10) {
  if (typeof e10 == "number")
    return e10;
  if (zf(e10))
    return zb;
  if (go(e10)) {
    var t = typeof e10.valueOf == "function" ? e10.valueOf() : e10;
    e10 = go(t) ? t + "" : t;
  }
  if (typeof e10 != "string")
    return e10 === 0 ? e10 : +e10;
  e10 = v3(e10);
  var n = m3.test(e10);
  return n || g3.test(e10) ? y3(e10.slice(2), n ? 2 : 8) : h3.test(e10) ? zb : +e10;
}
function Vm(e10) {
  return e10;
}
var b3 = "[object AsyncFunction]", _3 = "[object Function]", w3 = "[object GeneratorFunction]", C3 = "[object Proxy]";
function Fm(e10) {
  if (!go(e10))
    return false;
  var t = ss(e10);
  return t == _3 || t == w3 || t == b3 || t == C3;
}
var jp = Cr["__core-js_shared__"], Wb = function() {
  var e10 = /[^.]+$/.exec(jp && jp.keys && jp.keys.IE_PROTO || "");
  return e10 ? "Symbol(src)_1." + e10 : "";
}();
function E3(e10) {
  return !!Wb && Wb in e10;
}
var S3 = Function.prototype, k3 = S3.toString;
function is(e10) {
  if (e10 != null) {
    try {
      return k3.call(e10);
    } catch {
    }
    try {
      return e10 + "";
    } catch {
    }
  }
  return "";
}
var N3 = /[\\^$.*+?()[\]{}|]/g, T3 = /^\[object .+?Constructor\]$/, O3 = Function.prototype, $3 = Object.prototype, I3 = O3.toString, M3 = $3.hasOwnProperty, P3 = RegExp(
  "^" + I3.call(M3).replace(N3, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function R3(e10) {
  if (!go(e10) || E3(e10))
    return false;
  var t = Fm(e10) ? P3 : T3;
  return t.test(is(e10));
}
function A3(e10, t) {
  return e10 == null ? void 0 : e10[t];
}
function us(e10, t) {
  var n = A3(e10, t);
  return R3(n) ? n : void 0;
}
var zv = us(Cr, "WeakMap"), jb = Object.create, L3 = /* @__PURE__ */ function() {
  function e10() {
  }
  return function(t) {
    if (!go(t))
      return {};
    if (jb)
      return jb(t);
    e10.prototype = t;
    var n = new e10();
    return e10.prototype = void 0, n;
  };
}();
function x3(e10, t, n) {
  switch (n.length) {
    case 0:
      return e10.call(t);
    case 1:
      return e10.call(t, n[0]);
    case 2:
      return e10.call(t, n[0], n[1]);
    case 3:
      return e10.call(t, n[0], n[1], n[2]);
  }
  return e10.apply(t, n);
}
function D3() {
}
function TE(e10, t) {
  var n = -1, o = e10.length;
  for (t || (t = Array(o)); ++n < o; )
    t[n] = e10[n];
  return t;
}
var V3 = 800, F3 = 16, B3 = Date.now;
function H3(e10) {
  var t = 0, n = 0;
  return function() {
    var o = B3(), r = F3 - (o - n);
    if (n = o, r > 0) {
      if (++t >= V3)
        return arguments[0];
    } else
      t = 0;
    return e10.apply(void 0, arguments);
  };
}
function z3(e10) {
  return function() {
    return e10;
  };
}
var Gd = function() {
  try {
    var e10 = us(Object, "defineProperty");
    return e10({}, "", {}), e10;
  } catch {
  }
}(), K3 = Gd ? function(e10, t) {
  return Gd(e10, "toString", {
    configurable: true,
    enumerable: false,
    value: z3(t),
    writable: true
  });
} : Vm, OE = H3(K3);
function W3(e10, t) {
  for (var n = -1, o = e10 == null ? 0 : e10.length; ++n < o && t(e10[n], n, e10) !== false; )
    ;
  return e10;
}
function $E(e10, t, n, o) {
  for (var r = e10.length, a = n + (o ? 1 : -1); o ? a-- : ++a < r; )
    if (t(e10[a], a, e10))
      return a;
  return -1;
}
function j3(e10) {
  return e10 !== e10;
}
function U3(e10, t, n) {
  for (var o = n - 1, r = e10.length; ++o < r; )
    if (e10[o] === t)
      return o;
  return -1;
}
function Y3(e10, t, n) {
  return t === t ? U3(e10, t, n) : $E(e10, j3, n);
}
function q3(e10, t) {
  var n = e10 == null ? 0 : e10.length;
  return !!n && Y3(e10, t, 0) > -1;
}
var G3 = 9007199254740991, X3 = /^(?:0|[1-9]\d*)$/;
function Kf(e10, t) {
  var n = typeof e10;
  return t = t != null ? t : G3, !!t && (n == "number" || n != "symbol" && X3.test(e10)) && e10 > -1 && e10 % 1 == 0 && e10 < t;
}
function Bm(e10, t, n) {
  t == "__proto__" && Gd ? Gd(e10, t, {
    configurable: true,
    enumerable: true,
    value: n,
    writable: true
  }) : e10[t] = n;
}
function ec(e10, t) {
  return e10 === t || e10 !== e10 && t !== t;
}
var J3 = Object.prototype, Z3 = J3.hasOwnProperty;
function Hm(e10, t, n) {
  var o = e10[t];
  (!(Z3.call(e10, t) && ec(o, n)) || n === void 0 && !(t in e10)) && Bm(e10, t, n);
}
function _i(e10, t, n, o) {
  var r = !n;
  n || (n = {});
  for (var a = -1, l = t.length; ++a < l; ) {
    var s = t[a], u = void 0;
    u === void 0 && (u = e10[s]), r ? Bm(n, s, u) : Hm(n, s, u);
  }
  return n;
}
var Ub = Math.max;
function IE(e10, t, n) {
  return t = Ub(t === void 0 ? e10.length - 1 : t, 0), function() {
    for (var o = arguments, r = -1, a = Ub(o.length - t, 0), l = Array(a); ++r < a; )
      l[r] = o[t + r];
    r = -1;
    for (var s = Array(t + 1); ++r < t; )
      s[r] = o[r];
    return s[t] = n(l), x3(e10, this, s);
  };
}
function ME(e10, t) {
  return OE(IE(e10, t, Vm), e10 + "");
}
var Q3 = 9007199254740991;
function zm(e10) {
  return typeof e10 == "number" && e10 > -1 && e10 % 1 == 0 && e10 <= Q3;
}
function wi(e10) {
  return e10 != null && zm(e10.length) && !Fm(e10);
}
function eM(e10, t, n) {
  if (!go(n))
    return false;
  var o = typeof t;
  return (o == "number" ? wi(n) && Kf(t, n.length) : o == "string" && t in n) ? ec(n[t], e10) : false;
}
function tM(e10) {
  return ME(function(t, n) {
    var o = -1, r = n.length, a = r > 1 ? n[r - 1] : void 0, l = r > 2 ? n[2] : void 0;
    for (a = e10.length > 3 && typeof a == "function" ? (r--, a) : void 0, l && eM(n[0], n[1], l) && (a = r < 3 ? void 0 : a, r = 1), t = Object(t); ++o < r; ) {
      var s = n[o];
      s && e10(t, s, o, a);
    }
    return t;
  });
}
var nM = Object.prototype;
function Km(e10) {
  var t = e10 && e10.constructor, n = typeof t == "function" && t.prototype || nM;
  return e10 === n;
}
function oM(e10, t) {
  for (var n = -1, o = Array(e10); ++n < e10; )
    o[n] = t(n);
  return o;
}
var rM = "[object Arguments]";
function Yb(e10) {
  return Ur(e10) && ss(e10) == rM;
}
var PE = Object.prototype, aM = PE.hasOwnProperty, lM = PE.propertyIsEnumerable, mu = Yb(/* @__PURE__ */ function() {
  return arguments;
}()) ? Yb : function(e10) {
  return Ur(e10) && aM.call(e10, "callee") && !lM.call(e10, "callee");
};
function sM() {
  return false;
}
var RE = typeof exports == "object" && exports && !exports.nodeType && exports, qb = RE && "object" == "object" && module && !module.nodeType && module, iM = qb && qb.exports === RE, Gb = iM ? Cr.Buffer : void 0, uM = Gb ? Gb.isBuffer : void 0, gu = uM || sM, cM = "[object Arguments]", dM = "[object Array]", fM = "[object Boolean]", pM = "[object Date]", vM = "[object Error]", hM = "[object Function]", mM = "[object Map]", gM = "[object Number]", yM = "[object Object]", bM = "[object RegExp]", _M = "[object Set]", wM = "[object String]", CM = "[object WeakMap]", EM = "[object ArrayBuffer]", SM = "[object DataView]", kM = "[object Float32Array]", NM = "[object Float64Array]", TM = "[object Int8Array]", OM = "[object Int16Array]", $M = "[object Int32Array]", IM = "[object Uint8Array]", MM = "[object Uint8ClampedArray]", PM = "[object Uint16Array]", RM = "[object Uint32Array]", fn = {};
fn[kM] = fn[NM] = fn[TM] = fn[OM] = fn[$M] = fn[IM] = fn[MM] = fn[PM] = fn[RM] = true;
fn[cM] = fn[dM] = fn[EM] = fn[fM] = fn[SM] = fn[pM] = fn[vM] = fn[hM] = fn[mM] = fn[gM] = fn[yM] = fn[bM] = fn[_M] = fn[wM] = fn[CM] = false;
function AM(e10) {
  return Ur(e10) && zm(e10.length) && !!fn[ss(e10)];
}
function Wm(e10) {
  return function(t) {
    return e10(t);
  };
}
var AE = typeof exports == "object" && exports && !exports.nodeType && exports, tu = AE && "object" == "object" && module && !module.nodeType && module, LM = tu && tu.exports === AE, Up = LM && SE.process, Js = function() {
  try {
    var e10 = tu && tu.require && tu.require("util").types;
    return e10 || Up && Up.binding && Up.binding("util");
  } catch {
  }
}(), Xb = Js && Js.isTypedArray, jm = Xb ? Wm(Xb) : AM, xM = Object.prototype, DM = xM.hasOwnProperty;
function LE(e10, t) {
  var n = mo(e10), o = !n && mu(e10), r = !n && !o && gu(e10), a = !n && !o && !r && jm(e10), l = n || o || r || a, s = l ? oM(e10.length, String) : [], u = s.length;
  for (var c in e10)
    (t || DM.call(e10, c)) && !(l && // Safari 9 has enumerable `arguments.length` in strict mode.
    (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    r && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    a && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
    Kf(c, u))) && s.push(c);
  return s;
}
function xE(e10, t) {
  return function(n) {
    return e10(t(n));
  };
}
var VM = xE(Object.keys, Object), FM = Object.prototype, BM = FM.hasOwnProperty;
function HM(e10) {
  if (!Km(e10))
    return VM(e10);
  var t = [];
  for (var n in Object(e10))
    BM.call(e10, n) && n != "constructor" && t.push(n);
  return t;
}
function tc(e10) {
  return wi(e10) ? LE(e10) : HM(e10);
}
function zM(e10) {
  var t = [];
  if (e10 != null)
    for (var n in Object(e10))
      t.push(n);
  return t;
}
var KM = Object.prototype, WM = KM.hasOwnProperty;
function jM(e10) {
  if (!go(e10))
    return zM(e10);
  var t = Km(e10), n = [];
  for (var o in e10)
    o == "constructor" && (t || !WM.call(e10, o)) || n.push(o);
  return n;
}
function nc(e10) {
  return wi(e10) ? LE(e10, true) : jM(e10);
}
var UM = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, YM = /^\w*$/;
function Um(e10, t) {
  if (mo(e10))
    return false;
  var n = typeof e10;
  return n == "number" || n == "symbol" || n == "boolean" || e10 == null || zf(e10) ? true : YM.test(e10) || !UM.test(e10) || t != null && e10 in Object(t);
}
var yu = us(Object, "create");
function qM() {
  this.__data__ = yu ? yu(null) : {}, this.size = 0;
}
function GM(e10) {
  var t = this.has(e10) && delete this.__data__[e10];
  return this.size -= t ? 1 : 0, t;
}
var XM = "__lodash_hash_undefined__", JM = Object.prototype, ZM = JM.hasOwnProperty;
function QM(e10) {
  var t = this.__data__;
  if (yu) {
    var n = t[e10];
    return n === XM ? void 0 : n;
  }
  return ZM.call(t, e10) ? t[e10] : void 0;
}
var eP = Object.prototype, tP = eP.hasOwnProperty;
function nP(e10) {
  var t = this.__data__;
  return yu ? t[e10] !== void 0 : tP.call(t, e10);
}
var oP = "__lodash_hash_undefined__";
function rP(e10, t) {
  var n = this.__data__;
  return this.size += this.has(e10) ? 0 : 1, n[e10] = yu && t === void 0 ? oP : t, this;
}
function Gl(e10) {
  var t = -1, n = e10 == null ? 0 : e10.length;
  for (this.clear(); ++t < n; ) {
    var o = e10[t];
    this.set(o[0], o[1]);
  }
}
Gl.prototype.clear = qM;
Gl.prototype.delete = GM;
Gl.prototype.get = QM;
Gl.prototype.has = nP;
Gl.prototype.set = rP;
function aP() {
  this.__data__ = [], this.size = 0;
}
function Wf(e10, t) {
  for (var n = e10.length; n--; )
    if (ec(e10[n][0], t))
      return n;
  return -1;
}
var lP = Array.prototype, sP = lP.splice;
function iP(e10) {
  var t = this.__data__, n = Wf(t, e10);
  if (n < 0)
    return false;
  var o = t.length - 1;
  return n == o ? t.pop() : sP.call(t, n, 1), --this.size, true;
}
function uP(e10) {
  var t = this.__data__, n = Wf(t, e10);
  return n < 0 ? void 0 : t[n][1];
}
function cP(e10) {
  return Wf(this.__data__, e10) > -1;
}
function dP(e10, t) {
  var n = this.__data__, o = Wf(n, e10);
  return o < 0 ? (++this.size, n.push([e10, t])) : n[o][1] = t, this;
}
function Oa(e10) {
  var t = -1, n = e10 == null ? 0 : e10.length;
  for (this.clear(); ++t < n; ) {
    var o = e10[t];
    this.set(o[0], o[1]);
  }
}
Oa.prototype.clear = aP;
Oa.prototype.delete = iP;
Oa.prototype.get = uP;
Oa.prototype.has = cP;
Oa.prototype.set = dP;
var bu = us(Cr, "Map");
function fP() {
  this.size = 0, this.__data__ = {
    hash: new Gl(),
    map: new (bu || Oa)(),
    string: new Gl()
  };
}
function pP(e10) {
  var t = typeof e10;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e10 !== "__proto__" : e10 === null;
}
function jf(e10, t) {
  var n = e10.__data__;
  return pP(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
}
function vP(e10) {
  var t = jf(this, e10).delete(e10);
  return this.size -= t ? 1 : 0, t;
}
function hP(e10) {
  return jf(this, e10).get(e10);
}
function mP(e10) {
  return jf(this, e10).has(e10);
}
function gP(e10, t) {
  var n = jf(this, e10), o = n.size;
  return n.set(e10, t), this.size += n.size == o ? 0 : 1, this;
}
function $a(e10) {
  var t = -1, n = e10 == null ? 0 : e10.length;
  for (this.clear(); ++t < n; ) {
    var o = e10[t];
    this.set(o[0], o[1]);
  }
}
$a.prototype.clear = fP;
$a.prototype.delete = vP;
$a.prototype.get = hP;
$a.prototype.has = mP;
$a.prototype.set = gP;
var yP = "Expected a function";
function Uf(e10, t) {
  if (typeof e10 != "function" || t != null && typeof t != "function")
    throw new TypeError(yP);
  var n = function() {
    var o = arguments, r = t ? t.apply(this, o) : o[0], a = n.cache;
    if (a.has(r))
      return a.get(r);
    var l = e10.apply(this, o);
    return n.cache = a.set(r, l) || a, l;
  };
  return n.cache = new (Uf.Cache || $a)(), n;
}
Uf.Cache = $a;
var bP = 500;
function _P(e10) {
  var t = Uf(e10, function(o) {
    return n.size === bP && n.clear(), o;
  }), n = t.cache;
  return t;
}
var wP = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, CP = /\\(\\)?/g, EP = _P(function(e10) {
  var t = [];
  return e10.charCodeAt(0) === 46 && t.push(""), e10.replace(wP, function(n, o, r, a) {
    t.push(r ? a.replace(CP, "$1") : o || n);
  }), t;
});
function SP(e10) {
  return e10 == null ? "" : NE(e10);
}
function Ci(e10, t) {
  return mo(e10) ? e10 : Um(e10, t) ? [e10] : EP(SP(e10));
}
function Ei(e10) {
  if (typeof e10 == "string" || zf(e10))
    return e10;
  var t = e10 + "";
  return t == "0" && 1 / e10 == -1 / 0 ? "-0" : t;
}
function Yf(e10, t) {
  t = Ci(t, e10);
  for (var n = 0, o = t.length; e10 != null && n < o; )
    e10 = e10[Ei(t[n++])];
  return n && n == o ? e10 : void 0;
}
function hn(e10, t, n) {
  var o = e10 == null ? void 0 : Yf(e10, t);
  return o === void 0 ? n : o;
}
function Ym(e10, t) {
  for (var n = -1, o = t.length, r = e10.length; ++n < o; )
    e10[r + n] = t[n];
  return e10;
}
var Jb = Xo ? Xo.isConcatSpreadable : void 0;
function kP(e10) {
  return mo(e10) || mu(e10) || !!(Jb && e10 && e10[Jb]);
}
function oc(e10, t, n, o, r) {
  var a = -1, l = e10.length;
  for (n || (n = kP), r || (r = []); ++a < l; ) {
    var s = e10[a];
    t > 0 && n(s) ? t > 1 ? oc(s, t - 1, n, o, r) : Ym(r, s) : o || (r[r.length] = s);
  }
  return r;
}
function DE(e10) {
  var t = e10 == null ? 0 : e10.length;
  return t ? oc(e10, 1) : [];
}
function VE(e10) {
  return OE(IE(e10, void 0, DE), e10 + "");
}
var qm = xE(Object.getPrototypeOf, Object), NP = "[object Object]", TP = Function.prototype, OP = Object.prototype, FE = TP.toString, $P = OP.hasOwnProperty, IP = FE.call(Object);
function BE(e10) {
  if (!Ur(e10) || ss(e10) != NP)
    return false;
  var t = qm(e10);
  if (t === null)
    return true;
  var n = $P.call(t, "constructor") && t.constructor;
  return typeof n == "function" && n instanceof n && FE.call(n) == IP;
}
function MP(e10, t, n) {
  var o = -1, r = e10.length;
  t < 0 && (t = -t > r ? 0 : r + t), n = n > r ? r : n, n < 0 && (n += r), r = t > n ? 0 : n - t >>> 0, t >>>= 0;
  for (var a = Array(r); ++o < r; )
    a[o] = e10[o + t];
  return a;
}
function Zn() {
  if (!arguments.length)
    return [];
  var e10 = arguments[0];
  return mo(e10) ? e10 : [e10];
}
function PP() {
  this.__data__ = new Oa(), this.size = 0;
}
function RP(e10) {
  var t = this.__data__, n = t.delete(e10);
  return this.size = t.size, n;
}
function AP(e10) {
  return this.__data__.get(e10);
}
function LP(e10) {
  return this.__data__.has(e10);
}
var xP = 200;
function DP(e10, t) {
  var n = this.__data__;
  if (n instanceof Oa) {
    var o = n.__data__;
    if (!bu || o.length < xP - 1)
      return o.push([e10, t]), this.size = ++n.size, this;
    n = this.__data__ = new $a(o);
  }
  return n.set(e10, t), this.size = n.size, this;
}
function fr(e10) {
  var t = this.__data__ = new Oa(e10);
  this.size = t.size;
}
fr.prototype.clear = PP;
fr.prototype.delete = RP;
fr.prototype.get = AP;
fr.prototype.has = LP;
fr.prototype.set = DP;
function VP(e10, t) {
  return e10 && _i(t, tc(t), e10);
}
function FP(e10, t) {
  return e10 && _i(t, nc(t), e10);
}
var HE = typeof exports == "object" && exports && !exports.nodeType && exports, Zb = HE && "object" == "object" && module && !module.nodeType && module, BP = Zb && Zb.exports === HE, Qb = BP ? Cr.Buffer : void 0, e0 = Qb ? Qb.allocUnsafe : void 0;
function zE(e10, t) {
  if (t)
    return e10.slice();
  var n = e10.length, o = e0 ? e0(n) : new e10.constructor(n);
  return e10.copy(o), o;
}
function HP(e10, t) {
  for (var n = -1, o = e10 == null ? 0 : e10.length, r = 0, a = []; ++n < o; ) {
    var l = e10[n];
    t(l, n, e10) && (a[r++] = l);
  }
  return a;
}
function KE() {
  return [];
}
var zP = Object.prototype, KP = zP.propertyIsEnumerable, t0 = Object.getOwnPropertySymbols, Gm = t0 ? function(e10) {
  return e10 == null ? [] : (e10 = Object(e10), HP(t0(e10), function(t) {
    return KP.call(e10, t);
  }));
} : KE;
function WP(e10, t) {
  return _i(e10, Gm(e10), t);
}
var jP = Object.getOwnPropertySymbols, WE = jP ? function(e10) {
  for (var t = []; e10; )
    Ym(t, Gm(e10)), e10 = qm(e10);
  return t;
} : KE;
function UP(e10, t) {
  return _i(e10, WE(e10), t);
}
function jE(e10, t, n) {
  var o = t(e10);
  return mo(e10) ? o : Ym(o, n(e10));
}
function Kv(e10) {
  return jE(e10, tc, Gm);
}
function UE(e10) {
  return jE(e10, nc, WE);
}
var Wv = us(Cr, "DataView"), jv = us(Cr, "Promise"), Vs = us(Cr, "Set"), n0 = "[object Map]", YP = "[object Object]", o0 = "[object Promise]", r0 = "[object Set]", a0 = "[object WeakMap]", l0 = "[object DataView]", qP = is(Wv), GP = is(bu), XP = is(jv), JP = is(Vs), ZP = is(zv), rr = ss;
(Wv && rr(new Wv(new ArrayBuffer(1))) != l0 || bu && rr(new bu()) != n0 || jv && rr(jv.resolve()) != o0 || Vs && rr(new Vs()) != r0 || zv && rr(new zv()) != a0) && (rr = function(e10) {
  var t = ss(e10), n = t == YP ? e10.constructor : void 0, o = n ? is(n) : "";
  if (o)
    switch (o) {
      case qP:
        return l0;
      case GP:
        return n0;
      case XP:
        return o0;
      case JP:
        return r0;
      case ZP:
        return a0;
    }
  return t;
});
var QP = Object.prototype, eR = QP.hasOwnProperty;
function tR(e10) {
  var t = e10.length, n = new e10.constructor(t);
  return t && typeof e10[0] == "string" && eR.call(e10, "index") && (n.index = e10.index, n.input = e10.input), n;
}
var Xd = Cr.Uint8Array;
function Xm(e10) {
  var t = new e10.constructor(e10.byteLength);
  return new Xd(t).set(new Xd(e10)), t;
}
function nR(e10, t) {
  var n = t ? Xm(e10.buffer) : e10.buffer;
  return new e10.constructor(n, e10.byteOffset, e10.byteLength);
}
var oR = /\w*$/;
function rR(e10) {
  var t = new e10.constructor(e10.source, oR.exec(e10));
  return t.lastIndex = e10.lastIndex, t;
}
var s0 = Xo ? Xo.prototype : void 0, i0 = s0 ? s0.valueOf : void 0;
function aR(e10) {
  return i0 ? Object(i0.call(e10)) : {};
}
function YE(e10, t) {
  var n = t ? Xm(e10.buffer) : e10.buffer;
  return new e10.constructor(n, e10.byteOffset, e10.length);
}
var lR = "[object Boolean]", sR = "[object Date]", iR = "[object Map]", uR = "[object Number]", cR = "[object RegExp]", dR = "[object Set]", fR = "[object String]", pR = "[object Symbol]", vR = "[object ArrayBuffer]", hR = "[object DataView]", mR = "[object Float32Array]", gR = "[object Float64Array]", yR = "[object Int8Array]", bR = "[object Int16Array]", _R = "[object Int32Array]", wR = "[object Uint8Array]", CR = "[object Uint8ClampedArray]", ER = "[object Uint16Array]", SR = "[object Uint32Array]";
function kR(e10, t, n) {
  var o = e10.constructor;
  switch (t) {
    case vR:
      return Xm(e10);
    case lR:
    case sR:
      return new o(+e10);
    case hR:
      return nR(e10, n);
    case mR:
    case gR:
    case yR:
    case bR:
    case _R:
    case wR:
    case CR:
    case ER:
    case SR:
      return YE(e10, n);
    case iR:
      return new o();
    case uR:
    case fR:
      return new o(e10);
    case cR:
      return rR(e10);
    case dR:
      return new o();
    case pR:
      return aR(e10);
  }
}
function qE(e10) {
  return typeof e10.constructor == "function" && !Km(e10) ? L3(qm(e10)) : {};
}
var NR = "[object Map]";
function TR(e10) {
  return Ur(e10) && rr(e10) == NR;
}
var u0 = Js && Js.isMap, OR = u0 ? Wm(u0) : TR, $R = "[object Set]";
function IR(e10) {
  return Ur(e10) && rr(e10) == $R;
}
var c0 = Js && Js.isSet, MR = c0 ? Wm(c0) : IR, PR = 1, RR = 2, AR = 4, GE = "[object Arguments]", LR = "[object Array]", xR = "[object Boolean]", DR = "[object Date]", VR = "[object Error]", XE = "[object Function]", FR = "[object GeneratorFunction]", BR = "[object Map]", HR = "[object Number]", JE = "[object Object]", zR = "[object RegExp]", KR = "[object Set]", WR = "[object String]", jR = "[object Symbol]", UR = "[object WeakMap]", YR = "[object ArrayBuffer]", qR = "[object DataView]", GR = "[object Float32Array]", XR = "[object Float64Array]", JR = "[object Int8Array]", ZR = "[object Int16Array]", QR = "[object Int32Array]", eA = "[object Uint8Array]", tA = "[object Uint8ClampedArray]", nA = "[object Uint16Array]", oA = "[object Uint32Array]", un = {};
un[GE] = un[LR] = un[YR] = un[qR] = un[xR] = un[DR] = un[GR] = un[XR] = un[JR] = un[ZR] = un[QR] = un[BR] = un[HR] = un[JE] = un[zR] = un[KR] = un[WR] = un[jR] = un[eA] = un[tA] = un[nA] = un[oA] = true;
un[VR] = un[XE] = un[UR] = false;
function Fs(e10, t, n, o, r, a) {
  var l, s = t & PR, u = t & RR, c = t & AR;
  if (n && (l = r ? n(e10, o, r, a) : n(e10)), l !== void 0)
    return l;
  if (!go(e10))
    return e10;
  var d = mo(e10);
  if (d) {
    if (l = tR(e10), !s)
      return TE(e10, l);
  } else {
    var f = rr(e10), p = f == XE || f == FR;
    if (gu(e10))
      return zE(e10, s);
    if (f == JE || f == GE || p && !r) {
      if (l = u || p ? {} : qE(e10), !s)
        return u ? UP(e10, FP(l, e10)) : WP(e10, VP(l, e10));
    } else {
      if (!un[f])
        return r ? e10 : {};
      l = kR(e10, f, s);
    }
  }
  a || (a = new fr());
  var v = a.get(e10);
  if (v)
    return v;
  a.set(e10, l), MR(e10) ? e10.forEach(function(b) {
    l.add(Fs(b, t, n, b, e10, a));
  }) : OR(e10) && e10.forEach(function(b, g) {
    l.set(g, Fs(b, t, n, g, e10, a));
  });
  var m = c ? u ? UE : Kv : u ? nc : tc, h = d ? void 0 : m(e10);
  return W3(h || e10, function(b, g) {
    h && (g = b, b = e10[g]), Hm(l, g, Fs(b, t, n, g, e10, a));
  }), l;
}
var rA = 4;
function d0(e10) {
  return Fs(e10, rA);
}
var aA = 1, lA = 4;
function Jd(e10) {
  return Fs(e10, aA | lA);
}
var sA = "__lodash_hash_undefined__";
function iA(e10) {
  return this.__data__.set(e10, sA), this;
}
function uA(e10) {
  return this.__data__.has(e10);
}
function _u(e10) {
  var t = -1, n = e10 == null ? 0 : e10.length;
  for (this.__data__ = new $a(); ++t < n; )
    this.add(e10[t]);
}
_u.prototype.add = _u.prototype.push = iA;
_u.prototype.has = uA;
function cA(e10, t) {
  for (var n = -1, o = e10 == null ? 0 : e10.length; ++n < o; )
    if (t(e10[n], n, e10))
      return true;
  return false;
}
function ZE(e10, t) {
  return e10.has(t);
}
var dA = 1, fA = 2;
function QE(e10, t, n, o, r, a) {
  var l = n & dA, s = e10.length, u = t.length;
  if (s != u && !(l && u > s))
    return false;
  var c = a.get(e10), d = a.get(t);
  if (c && d)
    return c == t && d == e10;
  var f = -1, p = true, v = n & fA ? new _u() : void 0;
  for (a.set(e10, t), a.set(t, e10); ++f < s; ) {
    var m = e10[f], h = t[f];
    if (o)
      var b = l ? o(h, m, f, t, e10, a) : o(m, h, f, e10, t, a);
    if (b !== void 0) {
      if (b)
        continue;
      p = false;
      break;
    }
    if (v) {
      if (!cA(t, function(g, w) {
        if (!ZE(v, w) && (m === g || r(m, g, n, o, a)))
          return v.push(w);
      })) {
        p = false;
        break;
      }
    } else if (!(m === h || r(m, h, n, o, a))) {
      p = false;
      break;
    }
  }
  return a.delete(e10), a.delete(t), p;
}
function pA(e10) {
  var t = -1, n = Array(e10.size);
  return e10.forEach(function(o, r) {
    n[++t] = [r, o];
  }), n;
}
function Jm(e10) {
  var t = -1, n = Array(e10.size);
  return e10.forEach(function(o) {
    n[++t] = o;
  }), n;
}
var vA = 1, hA = 2, mA = "[object Boolean]", gA = "[object Date]", yA = "[object Error]", bA = "[object Map]", _A = "[object Number]", wA = "[object RegExp]", CA = "[object Set]", EA = "[object String]", SA = "[object Symbol]", kA = "[object ArrayBuffer]", NA = "[object DataView]", f0 = Xo ? Xo.prototype : void 0, Yp = f0 ? f0.valueOf : void 0;
function TA(e10, t, n, o, r, a, l) {
  switch (n) {
    case NA:
      if (e10.byteLength != t.byteLength || e10.byteOffset != t.byteOffset)
        return false;
      e10 = e10.buffer, t = t.buffer;
    case kA:
      return !(e10.byteLength != t.byteLength || !a(new Xd(e10), new Xd(t)));
    case mA:
    case gA:
    case _A:
      return ec(+e10, +t);
    case yA:
      return e10.name == t.name && e10.message == t.message;
    case wA:
    case EA:
      return e10 == t + "";
    case bA:
      var s = pA;
    case CA:
      var u = o & vA;
      if (s || (s = Jm), e10.size != t.size && !u)
        return false;
      var c = l.get(e10);
      if (c)
        return c == t;
      o |= hA, l.set(e10, t);
      var d = QE(s(e10), s(t), o, r, a, l);
      return l.delete(e10), d;
    case SA:
      if (Yp)
        return Yp.call(e10) == Yp.call(t);
  }
  return false;
}
var OA = 1, $A = Object.prototype, IA = $A.hasOwnProperty;
function MA(e10, t, n, o, r, a) {
  var l = n & OA, s = Kv(e10), u = s.length, c = Kv(t), d = c.length;
  if (u != d && !l)
    return false;
  for (var f = u; f--; ) {
    var p = s[f];
    if (!(l ? p in t : IA.call(t, p)))
      return false;
  }
  var v = a.get(e10), m = a.get(t);
  if (v && m)
    return v == t && m == e10;
  var h = true;
  a.set(e10, t), a.set(t, e10);
  for (var b = l; ++f < u; ) {
    p = s[f];
    var g = e10[p], w = t[p];
    if (o)
      var y = l ? o(w, g, p, t, e10, a) : o(g, w, p, e10, t, a);
    if (!(y === void 0 ? g === w || r(g, w, n, o, a) : y)) {
      h = false;
      break;
    }
    b || (b = p == "constructor");
  }
  if (h && !b) {
    var _ = e10.constructor, C = t.constructor;
    _ != C && "constructor" in e10 && "constructor" in t && !(typeof _ == "function" && _ instanceof _ && typeof C == "function" && C instanceof C) && (h = false);
  }
  return a.delete(e10), a.delete(t), h;
}
var PA = 1, p0 = "[object Arguments]", v0 = "[object Array]", Mc = "[object Object]", RA = Object.prototype, h0 = RA.hasOwnProperty;
function AA(e10, t, n, o, r, a) {
  var l = mo(e10), s = mo(t), u = l ? v0 : rr(e10), c = s ? v0 : rr(t);
  u = u == p0 ? Mc : u, c = c == p0 ? Mc : c;
  var d = u == Mc, f = c == Mc, p = u == c;
  if (p && gu(e10)) {
    if (!gu(t))
      return false;
    l = true, d = false;
  }
  if (p && !d)
    return a || (a = new fr()), l || jm(e10) ? QE(e10, t, n, o, r, a) : TA(e10, t, u, n, o, r, a);
  if (!(n & PA)) {
    var v = d && h0.call(e10, "__wrapped__"), m = f && h0.call(t, "__wrapped__");
    if (v || m) {
      var h = v ? e10.value() : e10, b = m ? t.value() : t;
      return a || (a = new fr()), r(h, b, n, o, a);
    }
  }
  return p ? (a || (a = new fr()), MA(e10, t, n, o, r, a)) : false;
}
function qf(e10, t, n, o, r) {
  return e10 === t ? true : e10 == null || t == null || !Ur(e10) && !Ur(t) ? e10 !== e10 && t !== t : AA(e10, t, n, o, qf, r);
}
var LA = 1, xA = 2;
function DA(e10, t, n, o) {
  var r = n.length, a = r;
  if (e10 == null)
    return !a;
  for (e10 = Object(e10); r--; ) {
    var l = n[r];
    if (l[2] ? l[1] !== e10[l[0]] : !(l[0] in e10))
      return false;
  }
  for (; ++r < a; ) {
    l = n[r];
    var s = l[0], u = e10[s], c = l[1];
    if (l[2]) {
      if (u === void 0 && !(s in e10))
        return false;
    } else {
      var d = new fr(), f;
      if (!(f === void 0 ? qf(c, u, LA | xA, o, d) : f))
        return false;
    }
  }
  return true;
}
function eS(e10) {
  return e10 === e10 && !go(e10);
}
function VA(e10) {
  for (var t = tc(e10), n = t.length; n--; ) {
    var o = t[n], r = e10[o];
    t[n] = [o, r, eS(r)];
  }
  return t;
}
function tS(e10, t) {
  return function(n) {
    return n == null ? false : n[e10] === t && (t !== void 0 || e10 in Object(n));
  };
}
function FA(e10) {
  var t = VA(e10);
  return t.length == 1 && t[0][2] ? tS(t[0][0], t[0][1]) : function(n) {
    return n === e10 || DA(n, e10, t);
  };
}
function BA(e10, t) {
  return e10 != null && t in Object(e10);
}
function HA(e10, t, n) {
  t = Ci(t, e10);
  for (var o = -1, r = t.length, a = false; ++o < r; ) {
    var l = Ei(t[o]);
    if (!(a = e10 != null && n(e10, l)))
      break;
    e10 = e10[l];
  }
  return a || ++o != r ? a : (r = e10 == null ? 0 : e10.length, !!r && zm(r) && Kf(l, r) && (mo(e10) || mu(e10)));
}
function nS(e10, t) {
  return e10 != null && HA(e10, t, BA);
}
var zA = 1, KA = 2;
function WA(e10, t) {
  return Um(e10) && eS(t) ? tS(Ei(e10), t) : function(n) {
    var o = hn(n, e10);
    return o === void 0 && o === t ? nS(n, e10) : qf(t, o, zA | KA);
  };
}
function jA(e10) {
  return function(t) {
    return t == null ? void 0 : t[e10];
  };
}
function UA(e10) {
  return function(t) {
    return Yf(t, e10);
  };
}
function YA(e10) {
  return Um(e10) ? jA(Ei(e10)) : UA(e10);
}
function oS(e10) {
  return typeof e10 == "function" ? e10 : e10 == null ? Vm : typeof e10 == "object" ? mo(e10) ? WA(e10[0], e10[1]) : FA(e10) : YA(e10);
}
function qA(e10) {
  return function(t, n, o) {
    for (var r = -1, a = Object(t), l = o(t), s = l.length; s--; ) {
      var u = l[++r];
      if (n(a[u], u, a) === false)
        break;
    }
    return t;
  };
}
var rS = qA();
function GA(e10, t) {
  return e10 && rS(e10, t, tc);
}
function XA(e10, t) {
  return function(n, o) {
    if (n == null)
      return n;
    if (!wi(n))
      return e10(n, o);
    for (var r = n.length, a = -1, l = Object(n); ++a < r && o(l[a], a, l) !== false; )
      ;
    return n;
  };
}
var JA = XA(GA), qp = function() {
  return Cr.Date.now();
}, ZA = "Expected a function", QA = Math.max, eL = Math.min;
function Oo(e10, t, n) {
  var o, r, a, l, s, u, c = 0, d = false, f = false, p = true;
  if (typeof e10 != "function")
    throw new TypeError(ZA);
  t = Kb(t) || 0, go(n) && (d = !!n.leading, f = "maxWait" in n, a = f ? QA(Kb(n.maxWait) || 0, t) : a, p = "trailing" in n ? !!n.trailing : p);
  function v(E) {
    var T = o, O = r;
    return o = r = void 0, c = E, l = e10.apply(O, T), l;
  }
  function m(E) {
    return c = E, s = setTimeout(g, t), d ? v(E) : l;
  }
  function h(E) {
    var T = E - u, O = E - c, N = t - T;
    return f ? eL(N, a - O) : N;
  }
  function b(E) {
    var T = E - u, O = E - c;
    return u === void 0 || T >= t || T < 0 || f && O >= a;
  }
  function g() {
    var E = qp();
    if (b(E))
      return w(E);
    s = setTimeout(g, h(E));
  }
  function w(E) {
    return s = void 0, p && o ? v(E) : (o = r = void 0, l);
  }
  function y() {
    s !== void 0 && clearTimeout(s), c = 0, o = u = r = s = void 0;
  }
  function _() {
    return s === void 0 ? l : w(qp());
  }
  function C() {
    var E = qp(), T = b(E);
    if (o = arguments, r = this, u = E, T) {
      if (s === void 0)
        return m(u);
      if (f)
        return clearTimeout(s), s = setTimeout(g, t), v(u);
    }
    return s === void 0 && (s = setTimeout(g, t)), l;
  }
  return C.cancel = y, C.flush = _, C;
}
function Uv(e10, t, n) {
  (n !== void 0 && !ec(e10[t], n) || n === void 0 && !(t in e10)) && Bm(e10, t, n);
}
function aS(e10) {
  return Ur(e10) && wi(e10);
}
function Yv(e10, t) {
  if (!(t === "constructor" && typeof e10[t] == "function") && t != "__proto__")
    return e10[t];
}
function tL(e10) {
  return _i(e10, nc(e10));
}
function nL(e10, t, n, o, r, a, l) {
  var s = Yv(e10, n), u = Yv(t, n), c = l.get(u);
  if (c) {
    Uv(e10, n, c);
    return;
  }
  var d = a ? a(s, u, n + "", e10, t, l) : void 0, f = d === void 0;
  if (f) {
    var p = mo(u), v = !p && gu(u), m = !p && !v && jm(u);
    d = u, p || v || m ? mo(s) ? d = s : aS(s) ? d = TE(s) : v ? (f = false, d = zE(u, true)) : m ? (f = false, d = YE(u, true)) : d = [] : BE(u) || mu(u) ? (d = s, mu(s) ? d = tL(s) : (!go(s) || Fm(s)) && (d = qE(u))) : f = false;
  }
  f && (l.set(u, d), r(d, u, o, a, l), l.delete(u)), Uv(e10, n, d);
}
function lS(e10, t, n, o, r) {
  e10 !== t && rS(t, function(a, l) {
    if (r || (r = new fr()), go(a))
      nL(e10, t, l, n, lS, o, r);
    else {
      var s = o ? o(Yv(e10, l), a, l + "", e10, t, r) : void 0;
      s === void 0 && (s = a), Uv(e10, l, s);
    }
  }, nc);
}
function oL(e10) {
  var t = e10 == null ? 0 : e10.length;
  return t ? e10[t - 1] : void 0;
}
function sS(e10, t, n) {
  var o = e10 == null ? 0 : e10.length;
  if (!o)
    return -1;
  var r = o - 1;
  return $E(e10, oS(t), r, true);
}
function rL(e10, t) {
  var n = -1, o = wi(e10) ? Array(e10.length) : [];
  return JA(e10, function(r, a, l) {
    o[++n] = t(r, a, l);
  }), o;
}
function aL(e10, t) {
  var n = mo(e10) ? Dm : rL;
  return n(e10, oS(t));
}
function lL(e10, t) {
  return oc(aL(e10, t), 1);
}
var sL = 1 / 0;
function iL(e10) {
  var t = e10 == null ? 0 : e10.length;
  return t ? oc(e10, sL) : [];
}
function wu(e10) {
  for (var t = -1, n = e10 == null ? 0 : e10.length, o = {}; ++t < n; ) {
    var r = e10[t];
    o[r[0]] = r[1];
  }
  return o;
}
function uL(e10, t) {
  return t.length < 2 ? e10 : Yf(e10, MP(t, 0, -1));
}
function In(e10, t) {
  return qf(e10, t);
}
function Nn(e10) {
  return e10 == null;
}
function rc(e10) {
  return e10 === null;
}
function cL(e10) {
  return e10 === void 0;
}
var iS = tM(function(e10, t, n) {
  lS(e10, t, n);
});
function dL(e10, t) {
  return t = Ci(t, e10), e10 = uL(e10, t), e10 == null || delete e10[Ei(oL(t))];
}
function fL(e10) {
  return BE(e10) ? void 0 : e10;
}
var pL = 1, vL = 2, hL = 4, mL = VE(function(e10, t) {
  var n = {};
  if (e10 == null)
    return n;
  var o = false;
  t = Dm(t, function(a) {
    return a = Ci(a, e10), o || (o = a.length > 1), a;
  }), _i(e10, UE(e10), n), o && (n = Fs(n, pL | vL | hL, fL));
  for (var r = t.length; r--; )
    dL(n, t[r]);
  return n;
});
function uS(e10, t, n, o) {
  if (!go(e10))
    return e10;
  t = Ci(t, e10);
  for (var r = -1, a = t.length, l = a - 1, s = e10; s != null && ++r < a; ) {
    var u = Ei(t[r]), c = n;
    if (u === "__proto__" || u === "constructor" || u === "prototype")
      return e10;
    if (r != l) {
      var d = s[u];
      c = void 0, c === void 0 && (c = go(d) ? d : Kf(t[r + 1]) ? [] : {});
    }
    Hm(s, u, c), s = s[u];
  }
  return e10;
}
function gL(e10, t, n) {
  for (var o = -1, r = t.length, a = {}; ++o < r; ) {
    var l = t[o], s = Yf(e10, l);
    n(s, l) && uS(a, Ci(l, e10), s);
  }
  return a;
}
function yL(e10, t) {
  return gL(e10, t, function(n, o) {
    return nS(e10, o);
  });
}
var sr = VE(function(e10, t) {
  return e10 == null ? {} : yL(e10, t);
});
function bL(e10, t, n) {
  return e10 == null ? e10 : uS(e10, t, n);
}
var _L = "Expected a function";
function zl(e10, t, n) {
  var o = true, r = true;
  if (typeof e10 != "function")
    throw new TypeError(_L);
  return go(n) && (o = "leading" in n ? !!n.leading : o, r = "trailing" in n ? !!n.trailing : r), Oo(e10, t, {
    leading: o,
    maxWait: t,
    trailing: r
  });
}
var wL = 1 / 0, CL = Vs && 1 / Jm(new Vs([, -0]))[1] == wL ? function(e10) {
  return new Vs(e10);
} : D3, EL = 200;
function SL(e10, t, n) {
  var o = -1, r = q3, a = e10.length, l = true, s = [], u = s;
  if (a >= EL) {
    var c = CL(e10);
    if (c)
      return Jm(c);
    l = false, r = ZE, u = new _u();
  } else
    u = s;
  e:
    for (; ++o < a; ) {
      var d = e10[o], f = d;
      if (d = d !== 0 ? d : 0, l && f === f) {
        for (var p = u.length; p--; )
          if (u[p] === f)
            continue e;
        s.push(d);
      } else r(u, f, n) || (u !== s && u.push(f), s.push(d));
    }
  return s;
}
var Gp = ME(function(e10) {
  return SL(oc(e10, 1, aS, true));
});
const St = (e10) => e10 === void 0, Vt = (e10) => typeof e10 == "boolean", Ye = (e10) => typeof e10 == "number", Ro = (e10) => !e10 && e10 !== 0 || Se(e10) && e10.length === 0 || at(e10) && !Object.keys(e10).length, to = (e10) => typeof Element > "u" ? false : e10 instanceof Element, So = (e10) => Nn(e10), kL = (e10) => Ve(e10) ? !Number.isNaN(Number(e10)) : false, Gf = (e10) => e10 === window;
var NL = Object.defineProperty, TL = Object.defineProperties, OL = Object.getOwnPropertyDescriptors, m0 = Object.getOwnPropertySymbols, $L = Object.prototype.hasOwnProperty, IL = Object.prototype.propertyIsEnumerable, g0 = (e10, t, n) => t in e10 ? NL(e10, t, { enumerable: true, configurable: true, writable: true, value: n }) : e10[t] = n, ML = (e10, t) => {
  for (var n in t || (t = {}))
    $L.call(t, n) && g0(e10, n, t[n]);
  if (m0)
    for (var n of m0(t))
      IL.call(t, n) && g0(e10, n, t[n]);
  return e10;
}, PL = (e10, t) => TL(e10, OL(t));
function Zd(e10, t) {
  var n;
  const o = qt();
  return Vn(() => {
    o.value = e10();
  }, PL(ML({}, t), {
    flush: (n = void 0) != null ? n : "sync"
  })), yi(o);
}
var y0;
const Et = typeof window < "u", RL = (e10) => typeof e10 < "u", qv = (e10) => typeof e10 == "function", AL = (e10) => typeof e10 == "string", Zs = () => {
}, Qd = Et && ((y0 = window == null ? void 0 : window.navigator) == null ? void 0 : y0.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function ll(e10) {
  return typeof e10 == "function" ? e10() : i(e10);
}
function cS(e10, t) {
  function n(...o) {
    return new Promise((r, a) => {
      Promise.resolve(e10(() => t.apply(this, o), { fn: t, thisArg: this, args: o })).then(r).catch(a);
    });
  }
  return n;
}
function LL(e10, t = {}) {
  let n, o, r = Zs;
  const a = (s) => {
    clearTimeout(s), r(), r = Zs;
  };
  return (s) => {
    const u = ll(e10), c = ll(t.maxWait);
    return n && a(n), u <= 0 || c !== void 0 && c <= 0 ? (o && (a(o), o = null), Promise.resolve(s())) : new Promise((d, f) => {
      r = t.rejectOnCancel ? f : d, c && !o && (o = setTimeout(() => {
        n && a(n), o = null, d(s());
      }, c)), n = setTimeout(() => {
        o && a(o), o = null, d(s());
      }, u);
    });
  };
}
function xL(e10, t = true, n = true, o = false) {
  let r = 0, a, l = true, s = Zs, u;
  const c = () => {
    a && (clearTimeout(a), a = void 0, s(), s = Zs);
  };
  return (f) => {
    const p = ll(e10), v = Date.now() - r, m = () => u = f();
    return c(), p <= 0 ? (r = Date.now(), m()) : (v > p && (n || !l) ? (r = Date.now(), m()) : t && (u = new Promise((h, b) => {
      s = o ? b : h, a = setTimeout(() => {
        r = Date.now(), l = true, h(m()), c();
      }, Math.max(0, p - v));
    })), !n && !a && (a = setTimeout(() => l = true, p)), l = false, u);
  };
}
function DL(e10) {
  return e10;
}
function VL(e10, t) {
  let n, o, r;
  const a = L(true), l = () => {
    a.value = true, r();
  };
  ge(e10, l, { flush: "sync" });
  const s = qv(t) ? t : t.get, u = qv(t) ? void 0 : t.set, c = L$((d, f) => (o = d, r = f, {
    get() {
      return a.value && (n = s(), a.value = false), o(), n;
    },
    set(p) {
      u == null || u(p);
    }
  }));
  return Object.isExtensible(c) && (c.trigger = l), c;
}
function ac(e10) {
  return Hw() ? (zw(e10), true) : false;
}
function FL(e10, t = 200, n = {}) {
  return cS(LL(t, n), e10);
}
function BL(e10, t = 200, n = {}) {
  const o = L(e10.value), r = FL(() => {
    o.value = e10.value;
  }, t, n);
  return ge(e10, () => r()), o;
}
function dS(e10, t = 200, n = false, o = true, r = false) {
  return cS(xL(t, n, o, r), e10);
}
function Zm(e10, t = true) {
  it() ? dt(e10) : t ? e10() : He(e10);
}
function Xl(e10, t, n = {}) {
  const {
    immediate: o = true
  } = n, r = L(false);
  let a = null;
  function l() {
    a && (clearTimeout(a), a = null);
  }
  function s() {
    r.value = false, l();
  }
  function u(...c) {
    l(), r.value = true, a = setTimeout(() => {
      r.value = false, a = null, e10(...c);
    }, ll(t));
  }
  return o && (r.value = true, Et && u()), ac(s), {
    isPending: yi(r),
    start: u,
    stop: s
  };
}
function xn(e10) {
  var t;
  const n = ll(e10);
  return (t = n == null ? void 0 : n.$el) != null ? t : n;
}
const Ia = Et ? window : void 0, HL = Et ? window.document : void 0;
function Ft(...e10) {
  let t, n, o, r;
  if (AL(e10[0]) || Array.isArray(e10[0]) ? ([n, o, r] = e10, t = Ia) : [t, n, o, r] = e10, !t)
    return Zs;
  Array.isArray(n) || (n = [n]), Array.isArray(o) || (o = [o]);
  const a = [], l = () => {
    a.forEach((d) => d()), a.length = 0;
  }, s = (d, f, p, v) => (d.addEventListener(f, p, v), () => d.removeEventListener(f, p, v)), u = ge(() => [xn(t), ll(r)], ([d, f]) => {
    l(), d && a.push(...n.flatMap((p) => o.map((v) => s(d, p, v, f))));
  }, { immediate: true, flush: "post" }), c = () => {
    u(), l();
  };
  return ac(c), c;
}
let b0 = false;
function Qm(e10, t, n = {}) {
  const { window: o = Ia, ignore: r = [], capture: a = true, detectIframe: l = false } = n;
  if (!o)
    return;
  Qd && !b0 && (b0 = true, Array.from(o.document.body.children).forEach((p) => p.addEventListener("click", Zs)));
  let s = true;
  const u = (p) => r.some((v) => {
    if (typeof v == "string")
      return Array.from(o.document.querySelectorAll(v)).some((m) => m === p.target || p.composedPath().includes(m));
    {
      const m = xn(v);
      return m && (p.target === m || p.composedPath().includes(m));
    }
  }), d = [
    Ft(o, "click", (p) => {
      const v = xn(e10);
      if (!(!v || v === p.target || p.composedPath().includes(v))) {
        if (p.detail === 0 && (s = !u(p)), !s) {
          s = true;
          return;
        }
        t(p);
      }
    }, { passive: true, capture: a }),
    Ft(o, "pointerdown", (p) => {
      const v = xn(e10);
      v && (s = !p.composedPath().includes(v) && !u(p));
    }, { passive: true }),
    l && Ft(o, "blur", (p) => {
      var v;
      const m = xn(e10);
      ((v = o.document.activeElement) == null ? void 0 : v.tagName) === "IFRAME" && !(m != null && m.contains(o.document.activeElement)) && t(p);
    })
  ].filter(Boolean);
  return () => d.forEach((p) => p());
}
function zL(e10 = {}) {
  var t;
  const { window: n = Ia } = e10, o = (t = e10.document) != null ? t : n == null ? void 0 : n.document, r = VL(() => null, () => o == null ? void 0 : o.activeElement);
  return n && (Ft(n, "blur", (a) => {
    a.relatedTarget === null && r.trigger();
  }, true), Ft(n, "focus", r.trigger, true)), r;
}
function fS(e10, t = false) {
  const n = L(), o = () => n.value = !!e10();
  return o(), Zm(o, t), n;
}
function KL(e10) {
  return JSON.parse(JSON.stringify(e10));
}
const _0 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof __webpack_require__.g < "u" ? __webpack_require__.g : typeof self < "u" ? self : {}, w0 = "__vueuse_ssr_handlers__";
_0[w0] = _0[w0] || {};
function WL(e10, t, { window: n = Ia, initialValue: o = "" } = {}) {
  const r = L(o), a = S(() => {
    var l;
    return xn(t) || ((l = n == null ? void 0 : n.document) == null ? void 0 : l.documentElement);
  });
  return ge([a, () => ll(e10)], ([l, s]) => {
    var u;
    if (l && n) {
      const c = (u = n.getComputedStyle(l).getPropertyValue(s)) == null ? void 0 : u.trim();
      r.value = c || o;
    }
  }, { immediate: true }), ge(r, (l) => {
    var s;
    (s = a.value) != null && s.style && a.value.style.setProperty(ll(e10), l);
  }), r;
}
function jL({ document: e10 = HL } = {}) {
  if (!e10)
    return L("visible");
  const t = L(e10.visibilityState);
  return Ft(e10, "visibilitychange", () => {
    t.value = e10.visibilityState;
  }), t;
}
var C0 = Object.getOwnPropertySymbols, UL = Object.prototype.hasOwnProperty, YL = Object.prototype.propertyIsEnumerable, qL = (e10, t) => {
  var n = {};
  for (var o in e10)
    UL.call(e10, o) && t.indexOf(o) < 0 && (n[o] = e10[o]);
  if (e10 != null && C0)
    for (var o of C0(e10))
      t.indexOf(o) < 0 && YL.call(e10, o) && (n[o] = e10[o]);
  return n;
};
function en(e10, t, n = {}) {
  const o = n, { window: r = Ia } = o, a = qL(o, ["window"]);
  let l;
  const s = fS(() => r && "ResizeObserver" in r), u = () => {
    l && (l.disconnect(), l = void 0);
  }, c = ge(() => xn(e10), (f) => {
    u(), s.value && r && f && (l = new ResizeObserver(t), l.observe(f, a));
  }, { immediate: true, flush: "post" }), d = () => {
    u(), c();
  };
  return ac(d), {
    isSupported: s,
    stop: d
  };
}
function E0(e10, t = {}) {
  const {
    reset: n = true,
    windowResize: o = true,
    windowScroll: r = true,
    immediate: a = true
  } = t, l = L(0), s = L(0), u = L(0), c = L(0), d = L(0), f = L(0), p = L(0), v = L(0);
  function m() {
    const h = xn(e10);
    if (!h) {
      n && (l.value = 0, s.value = 0, u.value = 0, c.value = 0, d.value = 0, f.value = 0, p.value = 0, v.value = 0);
      return;
    }
    const b = h.getBoundingClientRect();
    l.value = b.height, s.value = b.bottom, u.value = b.left, c.value = b.right, d.value = b.top, f.value = b.width, p.value = b.x, v.value = b.y;
  }
  return en(e10, m), ge(() => xn(e10), (h) => !h && m()), r && Ft("scroll", m, { capture: true, passive: true }), o && Ft("resize", m, { passive: true }), Zm(() => {
    a && m();
  }), {
    height: l,
    bottom: s,
    left: u,
    right: c,
    top: d,
    width: f,
    x: p,
    y: v,
    update: m
  };
}
function GL(e10, t = { width: 0, height: 0 }, n = {}) {
  const { window: o = Ia, box: r = "content-box" } = n, a = S(() => {
    var u, c;
    return (c = (u = xn(e10)) == null ? void 0 : u.namespaceURI) == null ? void 0 : c.includes("svg");
  }), l = L(t.width), s = L(t.height);
  return en(e10, ([u]) => {
    const c = r === "border-box" ? u.borderBoxSize : r === "content-box" ? u.contentBoxSize : u.devicePixelContentBoxSize;
    if (o && a.value) {
      const d = xn(e10);
      if (d) {
        const f = o.getComputedStyle(d);
        l.value = parseFloat(f.width), s.value = parseFloat(f.height);
      }
    } else if (c) {
      const d = Array.isArray(c) ? c : [c];
      l.value = d.reduce((f, { inlineSize: p }) => f + p, 0), s.value = d.reduce((f, { blockSize: p }) => f + p, 0);
    } else
      l.value = u.contentRect.width, s.value = u.contentRect.height;
  }, n), ge(() => xn(e10), (u) => {
    l.value = u ? t.width : 0, s.value = u ? t.height : 0;
  }), {
    width: l,
    height: s
  };
}
var S0 = Object.getOwnPropertySymbols, XL = Object.prototype.hasOwnProperty, JL = Object.prototype.propertyIsEnumerable, ZL = (e10, t) => {
  var n = {};
  for (var o in e10)
    XL.call(e10, o) && t.indexOf(o) < 0 && (n[o] = e10[o]);
  if (e10 != null && S0)
    for (var o of S0(e10))
      t.indexOf(o) < 0 && JL.call(e10, o) && (n[o] = e10[o]);
  return n;
};
function pS(e10, t, n = {}) {
  const o = n, { window: r = Ia } = o, a = ZL(o, ["window"]);
  let l;
  const s = fS(() => r && "MutationObserver" in r), u = () => {
    l && (l.disconnect(), l = void 0);
  }, c = ge(() => xn(e10), (f) => {
    u(), s.value && r && f && (l = new MutationObserver(t), l.observe(f, a));
  }, { immediate: true }), d = () => {
    u(), c();
  };
  return ac(d), {
    isSupported: s,
    stop: d
  };
}
var k0;
(function(e10) {
  e10.UP = "UP", e10.RIGHT = "RIGHT", e10.DOWN = "DOWN", e10.LEFT = "LEFT", e10.NONE = "NONE";
})(k0 || (k0 = {}));
var QL = Object.defineProperty, N0 = Object.getOwnPropertySymbols, ex = Object.prototype.hasOwnProperty, tx = Object.prototype.propertyIsEnumerable, T0 = (e10, t, n) => t in e10 ? QL(e10, t, { enumerable: true, configurable: true, writable: true, value: n }) : e10[t] = n, nx = (e10, t) => {
  for (var n in t || (t = {}))
    ex.call(t, n) && T0(e10, n, t[n]);
  if (N0)
    for (var n of N0(t))
      tx.call(t, n) && T0(e10, n, t[n]);
  return e10;
};
const ox = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
nx({
  linear: DL
}, ox);
function vS(e10, t, n, o = {}) {
  var r, a, l;
  const {
    clone: s = false,
    passive: u = false,
    eventName: c,
    deep: d = false,
    defaultValue: f
  } = o, p = it(), v = n || (p == null ? void 0 : p.emit) || ((r = p == null ? void 0 : p.$emit) == null ? void 0 : r.bind(p)) || ((l = (a = p == null ? void 0 : p.proxy) == null ? void 0 : a.$emit) == null ? void 0 : l.bind(p == null ? void 0 : p.proxy));
  let m = c;
  t || (t = "modelValue"), m = c || m || `update:${t.toString()}`;
  const h = (g) => s ? qv(s) ? s(g) : KL(g) : g, b = () => RL(e10[t]) ? h(e10[t]) : f;
  if (u) {
    const g = b(), w = L(g);
    return ge(() => e10[t], (y) => w.value = h(y)), ge(w, (y) => {
      (y !== e10[t] || d) && v(m, y);
    }, { deep: d }), w;
  } else
    return S({
      get() {
        return b();
      },
      set(g) {
        v(m, g);
      }
    });
}
function rx({ window: e10 = Ia } = {}) {
  if (!e10)
    return L(false);
  const t = L(e10.document.hasFocus());
  return Ft(e10, "blur", () => {
    t.value = false;
  }), Ft(e10, "focus", () => {
    t.value = true;
  }), t;
}
function ax(e10 = {}) {
  const {
    window: t = Ia,
    initialWidth: n = 1 / 0,
    initialHeight: o = 1 / 0,
    listenOrientation: r = true,
    includeScrollbar: a = true
  } = e10, l = L(n), s = L(o), u = () => {
    t && (a ? (l.value = t.innerWidth, s.value = t.innerHeight) : (l.value = t.document.documentElement.clientWidth, s.value = t.document.documentElement.clientHeight));
  };
  return u(), Zm(u), Ft("resize", u, { passive: true }), r && Ft("orientationchange", u, { passive: true }), { width: l, height: s };
}
class hS extends Error {
  constructor(t) {
    super(t), this.name = "ElementPlusError";
  }
}
function Qt(e10, t) {
  throw new hS(`[${e10}] ${t}`);
}
function _t(e10, t) {
  if (true) {
    const n = Ve(e10) ? new hS(`[${e10}] ${t}`) : e10;
    console.warn(n);
  }
}
const O0 = {
  current: 0
}, $0 = L(0), mS = 2e3, I0 = Symbol("elZIndexContextKey"), gS = Symbol("zIndexContextKey"), Si = (e10) => {
  const t = it() ? Le(I0, O0) : O0, n = e10 || (it() ? Le(gS, void 0) : void 0), o = S(() => {
    const l = i(n);
    return Ye(l) ? l : mS;
  }), r = S(() => o.value + $0.value), a = () => (t.current++, $0.value = t.current, r.value);
  return !Et && !Le(I0) && _t("ZIndexInjection", `Looks like you are using server rendering, you must provide a z-index provider to ensure the hydration process to be succeed
usage: app.provide(ZINDEX_INJECTION_KEY, { current: 0 })`), {
    initialZIndex: o,
    currentZIndex: r,
    nextZIndex: a
  };
};
var lx = {
  name: "en",
  el: {
    breadcrumb: {
      label: "Breadcrumb"
    },
    colorpicker: {
      confirm: "OK",
      clear: "Clear",
      defaultLabel: "color picker",
      description: "current color is {color}. press enter to select a new color.",
      alphaLabel: "pick alpha value"
    },
    datepicker: {
      now: "Now",
      today: "Today",
      cancel: "Cancel",
      clear: "Clear",
      confirm: "OK",
      dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
      monthTablePrompt: "Use the arrow keys and enter to select the month",
      yearTablePrompt: "Use the arrow keys and enter to select the year",
      selectedDate: "Selected date",
      selectDate: "Select date",
      selectTime: "Select time",
      startDate: "Start Date",
      startTime: "Start Time",
      endDate: "End Date",
      endTime: "End Time",
      prevYear: "Previous Year",
      nextYear: "Next Year",
      prevMonth: "Previous Month",
      nextMonth: "Next Month",
      year: "",
      month1: "January",
      month2: "February",
      month3: "March",
      month4: "April",
      month5: "May",
      month6: "June",
      month7: "July",
      month8: "August",
      month9: "September",
      month10: "October",
      month11: "November",
      month12: "December",
      week: "week",
      weeks: {
        sun: "Sun",
        mon: "Mon",
        tue: "Tue",
        wed: "Wed",
        thu: "Thu",
        fri: "Fri",
        sat: "Sat"
      },
      weeksFull: {
        sun: "Sunday",
        mon: "Monday",
        tue: "Tuesday",
        wed: "Wednesday",
        thu: "Thursday",
        fri: "Friday",
        sat: "Saturday"
      },
      months: {
        jan: "Jan",
        feb: "Feb",
        mar: "Mar",
        apr: "Apr",
        may: "May",
        jun: "Jun",
        jul: "Jul",
        aug: "Aug",
        sep: "Sep",
        oct: "Oct",
        nov: "Nov",
        dec: "Dec"
      }
    },
    inputNumber: {
      decrease: "decrease number",
      increase: "increase number"
    },
    select: {
      loading: "Loading",
      noMatch: "No matching data",
      noData: "No data",
      placeholder: "Select"
    },
    mention: {
      loading: "Loading"
    },
    dropdown: {
      toggleDropdown: "Toggle Dropdown"
    },
    cascader: {
      noMatch: "No matching data",
      loading: "Loading",
      placeholder: "Select",
      noData: "No data"
    },
    pagination: {
      goto: "Go to",
      pagesize: "/page",
      total: "Total {total}",
      pageClassifier: "",
      page: "Page",
      prev: "Go to previous page",
      next: "Go to next page",
      currentPage: "page {pager}",
      prevPages: "Previous {pager} pages",
      nextPages: "Next {pager} pages",
      deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
    },
    dialog: {
      close: "Close this dialog"
    },
    drawer: {
      close: "Close this dialog"
    },
    messagebox: {
      title: "Message",
      confirm: "OK",
      cancel: "Cancel",
      error: "Illegal input",
      close: "Close this dialog"
    },
    upload: {
      deleteTip: "press delete to remove",
      delete: "Delete",
      preview: "Preview",
      continue: "Continue"
    },
    slider: {
      defaultLabel: "slider between {min} and {max}",
      defaultRangeStartLabel: "pick start value",
      defaultRangeEndLabel: "pick end value"
    },
    table: {
      emptyText: "No Data",
      confirmFilter: "Confirm",
      resetFilter: "Reset",
      clearFilter: "All",
      sumText: "Sum"
    },
    tour: {
      next: "Next",
      previous: "Previous",
      finish: "Finish"
    },
    tree: {
      emptyText: "No Data"
    },
    transfer: {
      noMatch: "No matching data",
      noData: "No data",
      titles: ["List 1", "List 2"],
      filterPlaceholder: "Enter keyword",
      noCheckedFormat: "{total} items",
      hasCheckedFormat: "{checked}/{total} checked"
    },
    image: {
      error: "FAILED"
    },
    pageHeader: {
      title: "Back"
    },
    popconfirm: {
      confirmButtonText: "Yes",
      cancelButtonText: "No"
    },
    carousel: {
      leftArrow: "Carousel arrow left",
      rightArrow: "Carousel arrow right",
      indicator: "Carousel switch to index {index}"
    }
  }
};
const sx = (e10) => (t, n) => ix(t, n, i(e10)), ix = (e10, t, n) => hn(n, e10, e10).replace(/\{(\w+)\}/g, (o, r) => {
  var a;
  return `${(a = t == null ? void 0 : t[r]) != null ? a : `{${r}}`}`;
}), ux = (e10) => {
  const t = S(() => i(e10).name), n = Ot(e10) ? e10 : L(e10);
  return {
    lang: t,
    locale: n,
    t: sx(e10)
  };
}, yS = Symbol("localeContextKey"), kt = (e10) => {
  const t = e10 || Le(yS, L());
  return ux(S(() => t.value || lx));
}, bS = "__epPropKey", ne = (e10) => e10, cx = (e10) => at(e10) && !!e10[bS], Er = (e10, t) => {
  if (!at(e10) || cx(e10))
    return e10;
  const { values: n, required: o, default: r, type: a, validator: l } = e10, u = {
    type: a,
    required: !!o,
    validator: n || l ? (c) => {
      let d = false, f = [];
      if (n && (f = Array.from(n), Tt(e10, "default") && f.push(r), d || (d = f.includes(c))), l && (d || (d = l(c))), !d && f.length > 0) {
        const p = [...new Set(f)].map((v) => JSON.stringify(v)).join(", ");
        dr(`Invalid prop: validation failed${t ? ` for prop "${t}"` : ""}. Expected one of [${p}], got value ${JSON.stringify(c)}.`);
      }
      return d;
    } : void 0,
    [bS]: true
  };
  return Tt(e10, "default") && (u.default = r), u;
}, Oe = (e10) => wu(Object.entries(e10).map(([t, n]) => [
  t,
  Er(n, t)
])), Qr = ["", "default", "small", "large"], _n = Er({
  type: String,
  values: Qr,
  required: false
}), _S = Symbol("size"), wS = () => {
  const e10 = Le(_S, {});
  return S(() => i(e10.size) || "");
}, CS = Symbol("emptyValuesContextKey"), dx = "use-empty-values", fx = ["", void 0, null], px = void 0, ki = Oe({
  emptyValues: Array,
  valueOnClear: {
    type: [String, Number, Boolean, Function],
    default: void 0,
    validator: (e10) => Fe(e10) ? !e10() : !e10
  }
}), Xf = (e10, t) => {
  const n = it() ? Le(CS, L({})) : L({}), o = S(() => e10.emptyValues || n.value.emptyValues || fx), r = S(() => Fe(e10.valueOnClear) ? e10.valueOnClear() : e10.valueOnClear !== void 0 ? e10.valueOnClear : Fe(n.value.valueOnClear) ? n.value.valueOnClear() : n.value.valueOnClear !== void 0 ? n.value.valueOnClear : t !== void 0 ? t : px), a = (l) => o.value.includes(l);
  return o.value.includes(r.value) || _t(dx, "value-on-clear should be a value of empty-values"), {
    emptyValues: o,
    valueOnClear: r,
    isEmptyValue: a
  };
}, Qs = (e10) => Object.keys(e10), ES = (e10) => Object.entries(e10), nu = (e10, t, n) => ({
  get value() {
    return hn(e10, t, n);
  },
  set value(o) {
    bL(e10, t, o);
  }
}), ef = L();
function lc(e10, t = void 0) {
  const n = it() ? Le(CE, ef) : ef;
  return e10 ? S(() => {
    var o, r;
    return (r = (o = n.value) == null ? void 0 : o[e10]) != null ? r : t;
  }) : n;
}
function Jf(e10, t) {
  const n = lc(), o = we(e10, S(() => {
    var s;
    return ((s = n.value) == null ? void 0 : s.namespace) || eu;
  })), r = kt(S(() => {
    var s;
    return (s = n.value) == null ? void 0 : s.locale;
  })), a = Si(S(() => {
    var s;
    return ((s = n.value) == null ? void 0 : s.zIndex) || mS;
  })), l = S(() => {
    var s;
    return i(t) || ((s = n.value) == null ? void 0 : s.size) || "";
  });
  return eg(S(() => i(n) || {})), {
    ns: o,
    locale: r,
    zIndex: a,
    size: l
  };
}
const eg = (e10, t, n = false) => {
  var o;
  const r = !!it(), a = r ? lc() : void 0, l = (o = t == null ? void 0 : t.provide) != null ? o : r ? yt : void 0;
  if (!l) {
    _t("provideGlobalConfig", "provideGlobalConfig() can only be used inside setup().");
    return;
  }
  const s = S(() => {
    const u = i(e10);
    return a != null && a.value ? vx(a.value, u) : u;
  });
  return l(CE, s), l(yS, S(() => s.value.locale)), l(EE, S(() => s.value.namespace)), l(gS, S(() => s.value.zIndex)), l(_S, {
    size: S(() => s.value.size || "")
  }), l(CS, S(() => ({
    emptyValues: s.value.emptyValues,
    valueOnClear: s.value.valueOnClear
  }))), (n || !ef.value) && (ef.value = s.value), s;
}, vx = (e10, t) => {
  const n = [.../* @__PURE__ */ new Set([...Qs(e10), ...Qs(t)])], o = {};
  for (const r of n)
    o[r] = t[r] !== void 0 ? t[r] : e10[r];
  return o;
}, hx = (e10 = []) => ({
  version: YO,
  install: (n, o) => {
    n[jy] || (n[jy] = true, e10.forEach((r) => n.use(r)), o && eg(o, n, true));
  }
}), nt = "update:modelValue", gt = "change", bn = "input", mx = Oe({
  zIndex: {
    type: ne([Number, String]),
    default: 100
  },
  target: {
    type: String,
    default: ""
  },
  offset: {
    type: Number,
    default: 0
  },
  position: {
    type: String,
    values: ["top", "bottom"],
    default: "top"
  }
}), gx = {
  scroll: ({ scrollTop: e10, fixed: t }) => Ye(e10) && Vt(t),
  [gt]: (e10) => Vt(e10)
};
var $e = (e10, t) => {
  const n = e10.__vccOpts || e10;
  for (const [o, r] of t)
    n[o] = r;
  return n;
};
function yx(e10, t, n, o) {
  const r = n - t;
  return e10 /= o / 2, e10 < 1 ? r / 2 * e10 * e10 * e10 + t : r / 2 * ((e10 -= 2) * e10 * e10 + 2) + t;
}
const sl = (e10) => Et ? window.requestAnimationFrame(e10) : setTimeout(e10, 16), Jl = (e10) => Et ? window.cancelAnimationFrame(e10) : clearTimeout(e10), bx = "utils/dom/style", SS = (e10 = "") => e10.split(" ").filter((t) => !!t.trim()), Eo = (e10, t) => {
  if (!e10 || !t)
    return false;
  if (t.includes(" "))
    throw new Error("className should not contain space.");
  return e10.classList.contains(t);
}, jo = (e10, t) => {
  !e10 || !t.trim() || e10.classList.add(...SS(t));
}, no = (e10, t) => {
  !e10 || !t.trim() || e10.classList.remove(...SS(t));
}, ha = (e10, t) => {
  var n;
  if (!Et || !e10 || !t)
    return "";
  let o = Dn(t);
  o === "float" && (o = "cssFloat");
  try {
    const r = e10.style[o];
    if (r)
      return r;
    const a = (n = document.defaultView) == null ? void 0 : n.getComputedStyle(e10, "");
    return a ? a[o] : "";
  } catch {
    return e10.style[o];
  }
}, kS = (e10, t, n) => {
  if (!(!e10 || !t))
    if (at(t))
      ES(t).forEach(([o, r]) => kS(e10, o, r));
    else {
      const o = Dn(t);
      e10.style[o] = n;
    }
};
function sn(e10, t = "px") {
  if (!e10)
    return "";
  if (Ye(e10) || kL(e10))
    return `${e10}${t}`;
  if (Ve(e10))
    return e10;
  _t(bx, "binding value must be a string or number");
}
const _x = (e10, t) => {
  if (!Et)
    return false;
  const n = {
    undefined: "overflow",
    true: "overflow-y",
    false: "overflow-x"
  }[String(t)], o = ha(e10, n);
  return ["scroll", "auto", "overlay"].some((r) => o.includes(r));
}, tg = (e10, t) => {
  if (!Et)
    return;
  let n = e10;
  for (; n; ) {
    if ([window, document, document.documentElement].includes(n))
      return window;
    if (_x(n, t))
      return n;
    n = n.parentNode;
  }
  return n;
};
let Pc;
const NS = (e10) => {
  var t;
  if (!Et)
    return 0;
  if (Pc !== void 0)
    return Pc;
  const n = document.createElement("div");
  n.className = `${e10}-scrollbar__wrap`, n.style.visibility = "hidden", n.style.width = "100px", n.style.position = "absolute", n.style.top = "-9999px", document.body.appendChild(n);
  const o = n.offsetWidth;
  n.style.overflow = "scroll";
  const r = document.createElement("div");
  r.style.width = "100%", n.appendChild(r);
  const a = r.offsetWidth;
  return (t = n.parentNode) == null || t.removeChild(n), Pc = o - a, Pc;
};
function ng(e10, t) {
  if (!Et)
    return;
  if (!t) {
    e10.scrollTop = 0;
    return;
  }
  const n = [];
  let o = t.offsetParent;
  for (; o !== null && e10 !== o && e10.contains(o); )
    n.push(o), o = o.offsetParent;
  const r = t.offsetTop + n.reduce((u, c) => u + c.offsetTop, 0), a = r + t.offsetHeight, l = e10.scrollTop, s = l + e10.clientHeight;
  r < l ? e10.scrollTop = r : a > s && (e10.scrollTop = a - e10.clientHeight);
}
function wx(e10, t, n, o, r) {
  const a = Date.now();
  let l;
  const s = () => {
    const c = Date.now() - a, d = yx(c > o ? o : c, t, n, o);
    Gf(e10) ? e10.scrollTo(window.pageXOffset, d) : e10.scrollTop = d, c < o ? l = sl(s) : Fe(r) && r();
  };
  return s(), () => {
    l && Jl(l);
  };
}
const M0 = (e10, t) => Gf(t) ? e10.ownerDocument.documentElement : t, P0 = (e10) => Gf(e10) ? window.scrollY : e10.scrollTop, TS = "ElAffix", Cx = /* @__PURE__ */ j({
  name: TS
}), Ex = /* @__PURE__ */ j({
  ...Cx,
  props: mx,
  emits: gx,
  setup(e10, { expose: t, emit: n }) {
    const o = e10, r = we("affix"), a = qt(), l = qt(), s = qt(), { height: u } = ax(), {
      height: c,
      width: d,
      top: f,
      bottom: p,
      update: v
    } = E0(l, { windowScroll: false }), m = E0(a), h = L(false), b = L(0), g = L(0), w = S(() => ({
      height: h.value ? `${c.value}px` : "",
      width: h.value ? `${d.value}px` : ""
    })), y = S(() => {
      if (!h.value)
        return {};
      const E = o.offset ? sn(o.offset) : 0;
      return {
        height: `${c.value}px`,
        width: `${d.value}px`,
        top: o.position === "top" ? E : "",
        bottom: o.position === "bottom" ? E : "",
        transform: g.value ? `translateY(${g.value}px)` : "",
        zIndex: o.zIndex
      };
    }), _ = () => {
      if (!s.value)
        return;
      b.value = s.value instanceof Window ? document.documentElement.scrollTop : s.value.scrollTop || 0;
      const { position: E, target: T, offset: O } = o, N = O + c.value;
      if (E === "top")
        if (T) {
          const $ = m.bottom.value - N;
          h.value = O > f.value && m.bottom.value > 0, g.value = $ < 0 ? $ : 0;
        } else
          h.value = O > f.value;
      else if (T) {
        const $ = u.value - m.top.value - N;
        h.value = u.value - O < p.value && u.value > m.top.value, g.value = $ < 0 ? -$ : 0;
      } else
        h.value = u.value - O < p.value;
    }, C = async () => {
      v(), await He(), n("scroll", {
        scrollTop: b.value,
        fixed: h.value
      });
    };
    return ge(h, (E) => n(gt, E)), dt(() => {
      var E;
      o.target ? (a.value = (E = document.querySelector(o.target)) != null ? E : void 0, a.value || Qt(TS, `Target does not exist: ${o.target}`)) : a.value = document.documentElement, s.value = tg(l.value, true), v();
    }), Ft(s, "scroll", C), Vn(_), t({
      update: _,
      updateRoot: v
    }), (E, T) => (k(), x("div", {
      ref_key: "root",
      ref: l,
      class: I(i(r).b()),
      style: ze(i(w))
    }, [
      B("div", {
        class: I({ [i(r).m("fixed")]: h.value }),
        style: ze(i(y))
      }, [
        J(E.$slots, "default")
      ], 6)
    ], 6));
  }
});
var Sx = /* @__PURE__ */ $e(Ex, [["__file", "affix.vue"]]);
const ut = (e10, t) => {
  if (e10.install = (n) => {
    for (const o of [e10, ...Object.values(t != null ? t : {})])
      n.component(o.name, o);
  }, t)
    for (const [n, o] of Object.entries(t))
      e10[n] = o;
  return e10;
}, OS = (e10, t) => (e10.install = (n) => {
  e10._context = n._context, n.config.globalProperties[t] = e10;
}, e10), kx = (e10, t) => (e10.install = (n) => {
  n.directive(t, e10);
}, e10), nn = (e10) => (e10.install = Mt, e10), Nx = ut(Sx), Tx = Oe({
  size: {
    type: ne([Number, String])
  },
  color: {
    type: String
  }
}), Ox = /* @__PURE__ */ j({
  name: "ElIcon",
  inheritAttrs: false
}), $x = /* @__PURE__ */ j({
  ...Ox,
  props: Tx,
  setup(e10) {
    const t = e10, n = we("icon"), o = S(() => {
      const { size: r, color: a } = t;
      return !r && !a ? {} : {
        fontSize: St(r) ? void 0 : sn(r),
        "--color": a
      };
    });
    return (r, a) => (k(), x("i", vt({
      class: i(n).b(),
      style: i(o)
    }, r.$attrs), [
      J(r.$slots, "default")
    ], 16));
  }
});
var Ix = /* @__PURE__ */ $e($x, [["__file", "icon.vue"]]);
const Be = ut(Ix);
function R0() {
  let e10;
  const t = (o, r) => {
    n(), e10 = window.setTimeout(o, r);
  }, n = () => window.clearTimeout(e10);
  return ac(() => n()), {
    registerTimeout: t,
    cancelTimeout: n
  };
}
const $S = Oe({
  showAfter: {
    type: Number,
    default: 0
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  autoClose: {
    type: Number,
    default: 0
  }
}), IS = ({
  showAfter: e10,
  hideAfter: t,
  autoClose: n,
  open: o,
  close: r
}) => {
  const { registerTimeout: a } = R0(), {
    registerTimeout: l,
    cancelTimeout: s
  } = R0();
  return {
    onOpen: (d) => {
      a(() => {
        o(d);
        const f = i(n);
        Ye(f) && f > 0 && l(() => {
          r(d);
        }, f);
      }, i(e10));
    },
    onClose: (d) => {
      s(), a(() => {
        r(d);
      }, i(t));
    }
  };
};
/*! Element Plus Icons Vue v2.3.1 */
var Mx = /* @__PURE__ */ j({
  name: "ArrowDown",
  __name: "arrow-down",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
      })
    ]));
  }
}), ea = Mx, Px = /* @__PURE__ */ j({
  name: "ArrowLeft",
  __name: "arrow-left",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z"
      })
    ]));
  }
}), wa = Px, Rx = /* @__PURE__ */ j({
  name: "ArrowRight",
  __name: "arrow-right",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
      })
    ]));
  }
}), oo = Rx, Ax = /* @__PURE__ */ j({
  name: "ArrowUp",
  __name: "arrow-up",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0"
      })
    ]));
  }
}), Zf = Ax, Lx = /* @__PURE__ */ j({
  name: "Back",
  __name: "back",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M224 480h640a32 32 0 1 1 0 64H224a32 32 0 0 1 0-64"
      }),
      B("path", {
        fill: "currentColor",
        d: "m237.248 512 265.408 265.344a32 32 0 0 1-45.312 45.312l-288-288a32 32 0 0 1 0-45.312l288-288a32 32 0 1 1 45.312 45.312z"
      })
    ]));
  }
}), xx = Lx, Dx = /* @__PURE__ */ j({
  name: "Calendar",
  __name: "calendar",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M128 384v512h768V192H768v32a32 32 0 1 1-64 0v-32H320v32a32 32 0 0 1-64 0v-32H128v128h768v64zm192-256h384V96a32 32 0 1 1 64 0v32h160a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h160V96a32 32 0 0 1 64 0zm-32 384h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m192-192h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m192-192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64"
      })
    ]));
  }
}), Vx = Dx, Fx = /* @__PURE__ */ j({
  name: "CaretRight",
  __name: "caret-right",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M384 192v640l384-320.064z"
      })
    ]));
  }
}), MS = Fx, Bx = /* @__PURE__ */ j({
  name: "CaretTop",
  __name: "caret-top",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M512 320 192 704h639.936z"
      })
    ]));
  }
}), Hx = Bx, zx = /* @__PURE__ */ j({
  name: "Check",
  __name: "check",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M406.656 706.944 195.84 496.256a32 32 0 1 0-45.248 45.248l256 256 512-512a32 32 0 0 0-45.248-45.248L406.592 706.944z"
      })
    ]));
  }
}), sc = zx, Kx = /* @__PURE__ */ j({
  name: "CircleCheckFilled",
  __name: "circle-check-filled",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z"
      })
    ]));
  }
}), Wx = Kx, jx = /* @__PURE__ */ j({
  name: "CircleCheck",
  __name: "circle-check",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
      }),
      B("path", {
        fill: "currentColor",
        d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
      })
    ]));
  }
}), og = jx, Ux = /* @__PURE__ */ j({
  name: "CircleCloseFilled",
  __name: "circle-close-filled",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336z"
      })
    ]));
  }
}), rg = Ux, Yx = /* @__PURE__ */ j({
  name: "CircleClose",
  __name: "circle-close",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248z"
      }),
      B("path", {
        fill: "currentColor",
        d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
      })
    ]));
  }
}), Ma = Yx, qx = /* @__PURE__ */ j({
  name: "Clock",
  __name: "clock",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
      }),
      B("path", {
        fill: "currentColor",
        d: "M480 256a32 32 0 0 1 32 32v256a32 32 0 0 1-64 0V288a32 32 0 0 1 32-32"
      }),
      B("path", {
        fill: "currentColor",
        d: "M480 512h256q32 0 32 32t-32 32H480q-32 0-32-32t32-32"
      })
    ]));
  }
}), PS = qx, Gx = /* @__PURE__ */ j({
  name: "Close",
  __name: "close",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
      })
    ]));
  }
}), Jo = Gx, Xx = /* @__PURE__ */ j({
  name: "DArrowLeft",
  __name: "d-arrow-left",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M529.408 149.376a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L259.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L197.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224zm256 0a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L515.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L453.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224z"
      })
    ]));
  }
}), il = Xx, Jx = /* @__PURE__ */ j({
  name: "DArrowRight",
  __name: "d-arrow-right",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M452.864 149.312a29.12 29.12 0 0 1 41.728.064L826.24 489.664a32 32 0 0 1 0 44.672L494.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L764.736 512 452.864 192a30.592 30.592 0 0 1 0-42.688m-256 0a29.12 29.12 0 0 1 41.728.064L570.24 489.664a32 32 0 0 1 0 44.672L238.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L508.736 512 196.864 192a30.592 30.592 0 0 1 0-42.688z"
      })
    ]));
  }
}), ul = Jx, Zx = /* @__PURE__ */ j({
  name: "Delete",
  __name: "delete",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M160 256H96a32 32 0 0 1 0-64h256V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64h-64v672a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32zm448-64v-64H416v64zM224 896h576V256H224zm192-128a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32m192 0a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32"
      })
    ]));
  }
}), Qx = Zx, e8 = /* @__PURE__ */ j({
  name: "Document",
  __name: "document",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M832 384H576V128H192v768h640zm-26.496-64L640 154.496V320zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32m160 448h384v64H320zm0-192h160v64H320zm0 384h384v64H320z"
      })
    ]));
  }
}), t8 = e8, n8 = /* @__PURE__ */ j({
  name: "FullScreen",
  __name: "full-screen",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "m160 96.064 192 .192a32 32 0 0 1 0 64l-192-.192V352a32 32 0 0 1-64 0V96h64zm0 831.872V928H96V672a32 32 0 1 1 64 0v191.936l192-.192a32 32 0 1 1 0 64zM864 96.064V96h64v256a32 32 0 1 1-64 0V160.064l-192 .192a32 32 0 1 1 0-64l192-.192zm0 831.872-192-.192a32 32 0 0 1 0-64l192 .192V672a32 32 0 1 1 64 0v256h-64z"
      })
    ]));
  }
}), o8 = n8, r8 = /* @__PURE__ */ j({
  name: "Hide",
  __name: "hide",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2zM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z"
      }),
      B("path", {
        fill: "currentColor",
        d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z"
      })
    ]));
  }
}), a8 = r8, l8 = /* @__PURE__ */ j({
  name: "InfoFilled",
  __name: "info-filled",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64m67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344M590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
      })
    ]));
  }
}), Cu = l8, s8 = /* @__PURE__ */ j({
  name: "Loading",
  __name: "loading",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32m0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32m448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32m-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32M195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0m-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
      })
    ]));
  }
}), Yr = s8, i8 = /* @__PURE__ */ j({
  name: "Minus",
  __name: "minus",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64"
      })
    ]));
  }
}), u8 = i8, c8 = /* @__PURE__ */ j({
  name: "MoreFilled",
  __name: "more-filled",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M176 416a112 112 0 1 1 0 224 112 112 0 0 1 0-224m336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224m336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224"
      })
    ]));
  }
}), A0 = c8, d8 = /* @__PURE__ */ j({
  name: "More",
  __name: "more",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M176 416a112 112 0 1 0 0 224 112 112 0 0 0 0-224m0 64a48 48 0 1 1 0 96 48 48 0 0 1 0-96m336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224m0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96m336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224m0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96"
      })
    ]));
  }
}), f8 = d8, p8 = /* @__PURE__ */ j({
  name: "PictureFilled",
  __name: "picture-filled",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M96 896a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h832a32 32 0 0 1 32 32v704a32 32 0 0 1-32 32zm315.52-228.48-68.928-68.928a32 32 0 0 0-45.248 0L128 768.064h778.688l-242.112-290.56a32 32 0 0 0-49.216 0L458.752 665.408a32 32 0 0 1-47.232 2.112M256 384a96 96 0 1 0 192.064-.064A96 96 0 0 0 256 384"
      })
    ]));
  }
}), v8 = p8, h8 = /* @__PURE__ */ j({
  name: "Plus",
  __name: "plus",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64z"
      })
    ]));
  }
}), RS = h8, m8 = /* @__PURE__ */ j({
  name: "QuestionFilled",
  __name: "question-filled",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m23.744 191.488c-52.096 0-92.928 14.784-123.2 44.352-30.976 29.568-45.76 70.4-45.76 122.496h80.256c0-29.568 5.632-52.8 17.6-68.992 13.376-19.712 35.2-28.864 66.176-28.864 23.936 0 42.944 6.336 56.32 19.712 12.672 13.376 19.712 31.68 19.712 54.912 0 17.6-6.336 34.496-19.008 49.984l-8.448 9.856c-45.76 40.832-73.216 70.4-82.368 89.408-9.856 19.008-14.08 42.24-14.08 68.992v9.856h80.96v-9.856c0-16.896 3.52-31.68 10.56-45.76 6.336-12.672 15.488-24.64 28.16-35.2 33.792-29.568 54.208-48.576 60.544-55.616 16.896-22.528 26.048-51.392 26.048-86.592 0-42.944-14.08-76.736-42.24-101.376-28.16-25.344-65.472-37.312-111.232-37.312zm-12.672 406.208a54.272 54.272 0 0 0-38.72 14.784 49.408 49.408 0 0 0-15.488 38.016c0 15.488 4.928 28.16 15.488 38.016A54.848 54.848 0 0 0 523.072 768c15.488 0 28.16-4.928 38.72-14.784a51.52 51.52 0 0 0 16.192-38.72 51.968 51.968 0 0 0-15.488-38.016 55.936 55.936 0 0 0-39.424-14.784z"
      })
    ]));
  }
}), g8 = m8, y8 = /* @__PURE__ */ j({
  name: "RefreshLeft",
  __name: "refresh-left",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M289.088 296.704h92.992a32 32 0 0 1 0 64H232.96a32 32 0 0 1-32-32V179.712a32 32 0 0 1 64 0v50.56a384 384 0 0 1 643.84 282.88 384 384 0 0 1-383.936 384 384 384 0 0 1-384-384h64a320 320 0 1 0 640 0 320 320 0 0 0-555.712-216.448z"
      })
    ]));
  }
}), b8 = y8, _8 = /* @__PURE__ */ j({
  name: "RefreshRight",
  __name: "refresh-right",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384 384 384 0 0 1-384-384 384 384 0 0 1 643.712-282.88z"
      })
    ]));
  }
}), w8 = _8, C8 = /* @__PURE__ */ j({
  name: "ScaleToOriginal",
  __name: "scale-to-original",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M813.176 180.706a60.235 60.235 0 0 1 60.236 60.235v481.883a60.235 60.235 0 0 1-60.236 60.235H210.824a60.235 60.235 0 0 1-60.236-60.235V240.94a60.235 60.235 0 0 1 60.236-60.235h602.352zm0-60.235H210.824A120.47 120.47 0 0 0 90.353 240.94v481.883a120.47 120.47 0 0 0 120.47 120.47h602.353a120.47 120.47 0 0 0 120.471-120.47V240.94a120.47 120.47 0 0 0-120.47-120.47zm-120.47 180.705a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 0 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zm-361.412 0a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 1 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118M512 361.412a30.118 30.118 0 0 0-30.118 30.117v30.118a30.118 30.118 0 0 0 60.236 0V391.53A30.118 30.118 0 0 0 512 361.412M512 512a30.118 30.118 0 0 0-30.118 30.118v30.117a30.118 30.118 0 0 0 60.236 0v-30.117A30.118 30.118 0 0 0 512 512"
      })
    ]));
  }
}), E8 = C8, S8 = /* @__PURE__ */ j({
  name: "Search",
  __name: "search",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704"
      })
    ]));
  }
}), k8 = S8, N8 = /* @__PURE__ */ j({
  name: "SortDown",
  __name: "sort-down",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M576 96v709.568L333.312 562.816A32 32 0 1 0 288 608l297.408 297.344A32 32 0 0 0 640 882.688V96a32 32 0 0 0-64 0"
      })
    ]));
  }
}), T8 = N8, O8 = /* @__PURE__ */ j({
  name: "SortUp",
  __name: "sort-up",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M384 141.248V928a32 32 0 1 0 64 0V218.56l242.688 242.688A32 32 0 1 0 736 416L438.592 118.656A32 32 0 0 0 384 141.248"
      })
    ]));
  }
}), $8 = O8, I8 = /* @__PURE__ */ j({
  name: "StarFilled",
  __name: "star-filled",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M283.84 867.84 512 747.776l228.16 119.936a6.4 6.4 0 0 0 9.28-6.72l-43.52-254.08 184.512-179.904a6.4 6.4 0 0 0-3.52-10.88l-255.104-37.12L517.76 147.904a6.4 6.4 0 0 0-11.52 0L392.192 379.072l-255.104 37.12a6.4 6.4 0 0 0-3.52 10.88L318.08 606.976l-43.584 254.08a6.4 6.4 0 0 0 9.28 6.72z"
      })
    ]));
  }
}), Rc = I8, M8 = /* @__PURE__ */ j({
  name: "Star",
  __name: "star",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "m512 747.84 228.16 119.936a6.4 6.4 0 0 0 9.28-6.72l-43.52-254.08 184.512-179.904a6.4 6.4 0 0 0-3.52-10.88l-255.104-37.12L517.76 147.904a6.4 6.4 0 0 0-11.52 0L392.192 379.072l-255.104 37.12a6.4 6.4 0 0 0-3.52 10.88L318.08 606.976l-43.584 254.08a6.4 6.4 0 0 0 9.28 6.72zM313.6 924.48a70.4 70.4 0 0 1-102.144-74.24l37.888-220.928L88.96 472.96A70.4 70.4 0 0 1 128 352.896l221.76-32.256 99.2-200.96a70.4 70.4 0 0 1 126.208 0l99.2 200.96 221.824 32.256a70.4 70.4 0 0 1 39.04 120.064L774.72 629.376l37.888 220.928a70.4 70.4 0 0 1-102.144 74.24L512 820.096l-198.4 104.32z"
      })
    ]));
  }
}), P8 = M8, R8 = /* @__PURE__ */ j({
  name: "SuccessFilled",
  __name: "success-filled",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z"
      })
    ]));
  }
}), AS = R8, A8 = /* @__PURE__ */ j({
  name: "View",
  __name: "view",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352m0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448m0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160"
      })
    ]));
  }
}), L8 = A8, x8 = /* @__PURE__ */ j({
  name: "WarningFilled",
  __name: "warning-filled",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256m0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4"
      })
    ]));
  }
}), Qf = x8, D8 = /* @__PURE__ */ j({
  name: "ZoomIn",
  __name: "zoom-in",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704m-32-384v-96a32 32 0 0 1 64 0v96h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64z"
      })
    ]));
  }
}), LS = D8, V8 = /* @__PURE__ */ j({
  name: "ZoomOut",
  __name: "zoom-out",
  setup(e10) {
    return (t, n) => (k(), x("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      B("path", {
        fill: "currentColor",
        d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704M352 448h256a32 32 0 0 1 0 64H352a32 32 0 0 1 0-64"
      })
    ]));
  }
}), F8 = V8;
const Ht = ne([
  String,
  Object,
  Function
]), xS = {
  Close: Jo
}, ag = {
  Close: Jo,
  SuccessFilled: AS,
  InfoFilled: Cu,
  WarningFilled: Qf,
  CircleCloseFilled: rg
}, cl = {
  primary: Cu,
  success: AS,
  warning: Qf,
  error: rg,
  info: Cu
}, ep = {
  validating: Yr,
  success: og,
  error: Ma
}, B8 = ["light", "dark"], H8 = Oe({
  title: {
    type: String,
    default: ""
  },
  description: {
    type: String,
    default: ""
  },
  type: {
    type: String,
    values: Qs(cl),
    default: "info"
  },
  closable: {
    type: Boolean,
    default: true
  },
  closeText: {
    type: String,
    default: ""
  },
  showIcon: Boolean,
  center: Boolean,
  effect: {
    type: String,
    values: B8,
    default: "light"
  },
  ...$S
}), z8 = {
  open: () => true,
  close: (e10) => St(e10) || e10 instanceof Event
}, K8 = /* @__PURE__ */ j({
  name: "ElAlert"
}), W8 = /* @__PURE__ */ j({
  ...K8,
  props: H8,
  emits: z8,
  setup(e10, { emit: t }) {
    const n = e10, { Close: o } = ag, r = En(), a = we("alert"), l = L(false), s = S(() => cl[n.type]), u = S(() => !!(n.description || r.default)), c = () => {
      l.value = true, t("open");
    }, d = (v) => {
      l.value = false, t("close", v);
    }, { onOpen: f, onClose: p } = IS({
      showAfter: Lt(n, "showAfter"),
      hideAfter: Lt(n, "hideAfter"),
      autoClose: Lt(n, "autoClose"),
      open: c,
      close: d
    });
    return Et && f(), (v, m) => (k(), ae(Rn, {
      name: i(a).b("fade"),
      persisted: ""
    }, {
      default: H(() => [
        lt(B("div", {
          class: I([i(a).b(), i(a).m(v.type), i(a).is("center", v.center), i(a).is(v.effect)]),
          role: "alert"
        }, [
          v.showIcon && (v.$slots.icon || i(s)) ? (k(), ae(i(Be), {
            key: 0,
            class: I([i(a).e("icon"), { [i(a).is("big")]: i(u) }])
          }, {
            default: H(() => [
              J(v.$slots, "icon", {}, () => [
                (k(), ae(ht(i(s))))
              ])
            ]),
            _: 3
          }, 8, ["class"])) : ee("v-if", true),
          B("div", {
            class: I(i(a).e("content"))
          }, [
            v.title || v.$slots.title ? (k(), x("span", {
              key: 0,
              class: I([i(a).e("title"), { "with-description": i(u) }])
            }, [
              J(v.$slots, "title", {}, () => [
                Ze(_e(v.title), 1)
              ])
            ], 2)) : ee("v-if", true),
            i(u) ? (k(), x("p", {
              key: 1,
              class: I(i(a).e("description"))
            }, [
              J(v.$slots, "default", {}, () => [
                Ze(_e(v.description), 1)
              ])
            ], 2)) : ee("v-if", true),
            v.closable ? (k(), x(Ie, { key: 2 }, [
              v.closeText ? (k(), x("div", {
                key: 0,
                class: I([i(a).e("close-btn"), i(a).is("customed")]),
                onClick: d
              }, _e(v.closeText), 3)) : (k(), ae(i(Be), {
                key: 1,
                class: I(i(a).e("close-btn")),
                onClick: i(p)
              }, {
                default: H(() => [
                  W(i(o))
                ]),
                _: 1
              }, 8, ["class", "onClick"]))
            ], 64)) : ee("v-if", true)
          ], 2)
        ], 2), [
          [Nt, l.value]
        ])
      ]),
      _: 3
    }, 8, ["name"]));
  }
});
var j8 = /* @__PURE__ */ $e(W8, [["__file", "alert.vue"]]);
const U8 = ut(j8), lg = () => Et && /firefox/i.test(window.navigator.userAgent);
let bo;
const Y8 = {
  height: "0",
  visibility: "hidden",
  overflow: lg() ? "" : "hidden",
  position: "absolute",
  "z-index": "-1000",
  top: "0",
  right: "0"
}, q8 = [
  "letter-spacing",
  "line-height",
  "padding-top",
  "padding-bottom",
  "font-family",
  "font-weight",
  "font-size",
  "text-rendering",
  "text-transform",
  "width",
  "text-indent",
  "padding-left",
  "padding-right",
  "border-width",
  "box-sizing"
];
function G8(e10) {
  const t = window.getComputedStyle(e10), n = t.getPropertyValue("box-sizing"), o = Number.parseFloat(t.getPropertyValue("padding-bottom")) + Number.parseFloat(t.getPropertyValue("padding-top")), r = Number.parseFloat(t.getPropertyValue("border-bottom-width")) + Number.parseFloat(t.getPropertyValue("border-top-width"));
  return { contextStyle: q8.map((l) => [
    l,
    t.getPropertyValue(l)
  ]), paddingSize: o, borderSize: r, boxSizing: n };
}
function L0(e10, t = 1, n) {
  var o;
  bo || (bo = document.createElement("textarea"), document.body.appendChild(bo));
  const { paddingSize: r, borderSize: a, boxSizing: l, contextStyle: s } = G8(e10);
  s.forEach(([f, p]) => bo == null ? void 0 : bo.style.setProperty(f, p)), Object.entries(Y8).forEach(([f, p]) => bo == null ? void 0 : bo.style.setProperty(f, p, "important")), bo.value = e10.value || e10.placeholder || "";
  let u = bo.scrollHeight;
  const c = {};
  l === "border-box" ? u = u + a : l === "content-box" && (u = u - r), bo.value = "";
  const d = bo.scrollHeight - r;
  if (Ye(t)) {
    let f = d * t;
    l === "border-box" && (f = f + r + a), u = Math.max(f, u), c.minHeight = `${f}px`;
  }
  if (Ye(n)) {
    let f = d * n;
    l === "border-box" && (f = f + r + a), u = Math.min(f, u);
  }
  return c.height = `${u}px`, (o = bo.parentNode) == null || o.removeChild(bo), bo = void 0, c;
}
const rn = (e10) => e10, X8 = Oe({
  ariaLabel: String,
  ariaOrientation: {
    type: String,
    values: ["horizontal", "vertical", "undefined"]
  },
  ariaControls: String
}), Bn = (e10) => sr(X8, e10), sg = Oe({
  id: {
    type: String,
    default: void 0
  },
  size: _n,
  disabled: Boolean,
  modelValue: {
    type: ne([
      String,
      Number,
      Object
    ]),
    default: ""
  },
  maxlength: {
    type: [String, Number]
  },
  minlength: {
    type: [String, Number]
  },
  type: {
    type: String,
    default: "text"
  },
  resize: {
    type: String,
    values: ["none", "both", "horizontal", "vertical"]
  },
  autosize: {
    type: ne([Boolean, Object]),
    default: false
  },
  autocomplete: {
    type: String,
    default: "off"
  },
  formatter: {
    type: Function
  },
  parser: {
    type: Function
  },
  placeholder: {
    type: String
  },
  form: {
    type: String
  },
  readonly: Boolean,
  clearable: Boolean,
  showPassword: Boolean,
  showWordLimit: Boolean,
  suffixIcon: {
    type: Ht
  },
  prefixIcon: {
    type: Ht
  },
  containerRole: {
    type: String,
    default: void 0
  },
  tabindex: {
    type: [String, Number],
    default: 0
  },
  validateEvent: {
    type: Boolean,
    default: true
  },
  inputStyle: {
    type: ne([Object, Array, String]),
    default: () => rn({})
  },
  autofocus: Boolean,
  rows: {
    type: Number,
    default: 2
  },
  ...Bn(["ariaLabel"])
}), J8 = {
  [nt]: (e10) => Ve(e10),
  input: (e10) => Ve(e10),
  change: (e10) => Ve(e10),
  focus: (e10) => e10 instanceof FocusEvent,
  blur: (e10) => e10 instanceof FocusEvent,
  clear: () => true,
  mouseleave: (e10) => e10 instanceof MouseEvent,
  mouseenter: (e10) => e10 instanceof MouseEvent,
  keydown: (e10) => e10 instanceof Event,
  compositionstart: (e10) => e10 instanceof CompositionEvent,
  compositionupdate: (e10) => e10 instanceof CompositionEvent,
  compositionend: (e10) => e10 instanceof CompositionEvent
}, Z8 = ["class", "style"], Q8 = /^on[A-Z]/, ic = (e10 = {}) => {
  const { excludeListeners: t = false, excludeKeys: n } = e10, o = S(() => ((n == null ? void 0 : n.value) || []).concat(Z8)), r = it();
  return r ? S(() => {
    var a;
    return wu(Object.entries((a = r.proxy) == null ? void 0 : a.$attrs).filter(([l]) => !o.value.includes(l) && !(t && Q8.test(l))));
  }) : (_t("use-attrs", "getCurrentInstance() returned null. useAttrs() must be called at the top of a setup function"), S(() => ({})));
}, Gv = {
  prefix: Math.floor(Math.random() * 1e4),
  current: 0
}, eD = Symbol("elIdInjection"), ig = () => it() ? Le(eD, Gv) : Gv, Fn = (e10) => {
  const t = ig();
  !Et && t === Gv && _t("IdInjection", `Looks like you are using server rendering, you must provide a id provider to ensure the hydration process to be succeed
usage: app.provide(ID_INJECTION_KEY, {
  prefix: number,
  current: number,
})`);
  const n = xm();
  return Zd(() => i(e10) || `${n.value}-id-${t.prefix}-${t.current++}`);
}, cs = Symbol("formContextKey"), qr = Symbol("formItemContextKey"), Yn = () => {
  const e10 = Le(cs, void 0), t = Le(qr, void 0);
  return {
    form: e10,
    formItem: t
  };
}, tr = (e10, {
  formItemContext: t,
  disableIdGeneration: n,
  disableIdManagement: o
}) => {
  n || (n = L(false)), o || (o = L(false));
  const r = L();
  let a;
  const l = S(() => {
    var s;
    return !!(!(e10.label || e10.ariaLabel) && t && t.inputIds && ((s = t.inputIds) == null ? void 0 : s.length) <= 1);
  });
  return dt(() => {
    a = ge([Lt(e10, "id"), n], ([s, u]) => {
      const c = s != null ? s : u ? void 0 : Fn().value;
      c !== r.value && (t != null && t.removeInputId && (r.value && t.removeInputId(r.value), !(o != null && o.value) && !u && c && t.addInputId(c)), r.value = c);
    }, { immediate: true });
  }), Jr(() => {
    a && a(), t != null && t.removeInputId && r.value && t.removeInputId(r.value);
  }), {
    isLabeledByFormItem: l,
    inputId: r
  };
}, DS = (e10) => {
  const t = it();
  return S(() => {
    var n, o;
    return (o = (n = t == null ? void 0 : t.proxy) == null ? void 0 : n.$props) == null ? void 0 : o[e10];
  });
}, yn = (e10, t = {}) => {
  const n = L(void 0), o = t.prop ? n : DS("size"), r = t.global ? n : wS(), a = t.form ? { size: void 0 } : Le(cs, void 0), l = t.formItem ? { size: void 0 } : Le(qr, void 0);
  return S(() => o.value || i(e10) || (l == null ? void 0 : l.size) || (a == null ? void 0 : a.size) || r.value || "");
}, Hn = (e10) => {
  const t = DS("disabled"), n = Le(cs, void 0);
  return S(() => t.value || i(e10) || (n == null ? void 0 : n.disabled) || false);
};
function pl(e10, {
  beforeFocus: t,
  afterFocus: n,
  beforeBlur: o,
  afterBlur: r
} = {}) {
  const a = it(), { emit: l } = a, s = qt(), u = Hn(), c = L(false), d = (v) => {
    Fe(t) && t(v) || c.value || (c.value = true, l("focus", v), n == null || n());
  }, f = (v) => {
    var m;
    Fe(o) && o(v) || v.relatedTarget && ((m = s.value) != null && m.contains(v.relatedTarget)) || (c.value = false, l("blur", v), r == null || r());
  }, p = () => {
    var v, m;
    (v = s.value) != null && v.contains(document.activeElement) && s.value !== document.activeElement || u.value || (m = e10.value) == null || m.focus();
  };
  return ge([s, u], ([v, m]) => {
    v && (m ? v.removeAttribute("tabindex") : v.setAttribute("tabindex", "-1"));
  }), Ft(s, "focus", d, true), Ft(s, "blur", f, true), Ft(s, "click", p, true),  false && 0, {
    isFocused: c,
    wrapperRef: s,
    handleFocus: d,
    handleBlur: f
  };
}
const tD = (e10) => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(e10);
function uc({
  afterComposition: e10,
  emit: t
}) {
  const n = L(false), o = (s) => {
    t == null || t("compositionstart", s), n.value = true;
  }, r = (s) => {
    var u;
    t == null || t("compositionupdate", s);
    const c = (u = s.target) == null ? void 0 : u.value, d = c[c.length - 1] || "";
    n.value = !tD(d);
  }, a = (s) => {
    t == null || t("compositionend", s), n.value && (n.value = false, He(() => e10(s)));
  };
  return {
    isComposing: n,
    handleComposition: (s) => {
      s.type === "compositionend" ? a(s) : r(s);
    },
    handleCompositionStart: o,
    handleCompositionUpdate: r,
    handleCompositionEnd: a
  };
}
function nD(e10) {
  let t;
  function n() {
    if (e10.value == null)
      return;
    const { selectionStart: r, selectionEnd: a, value: l } = e10.value;
    if (r == null || a == null)
      return;
    const s = l.slice(0, Math.max(0, r)), u = l.slice(Math.max(0, a));
    t = {
      selectionStart: r,
      selectionEnd: a,
      value: l,
      beforeTxt: s,
      afterTxt: u
    };
  }
  function o() {
    if (e10.value == null || t == null)
      return;
    const { value: r } = e10.value, { beforeTxt: a, afterTxt: l, selectionStart: s } = t;
    if (a == null || l == null || s == null)
      return;
    let u = r.length;
    if (r.endsWith(l))
      u = r.length - l.length;
    else if (r.startsWith(a))
      u = a.length;
    else {
      const c = a[s - 1], d = r.indexOf(c, s - 1);
      d !== -1 && (u = d + 1);
    }
    e10.value.setSelectionRange(u, u);
  }
  return [n, o];
}
const VS = "ElInput", oD = /* @__PURE__ */ j({
  name: VS,
  inheritAttrs: false
}), rD = /* @__PURE__ */ j({
  ...oD,
  props: sg,
  emits: J8,
  setup(e10, { expose: t, emit: n }) {
    const o = e10, r = Ta(), a = ic(), l = En(), s = S(() => [
      o.type === "textarea" ? h.b() : m.b(),
      m.m(p.value),
      m.is("disabled", v.value),
      m.is("exceed", le.value),
      {
        [m.b("group")]: l.prepend || l.append,
        [m.m("prefix")]: l.prefix || o.prefixIcon,
        [m.m("suffix")]: l.suffix || o.suffixIcon || o.clearable || o.showPassword,
        [m.bm("suffix", "password-clear")]: A.value && V.value,
        [m.b("hidden")]: o.type === "hidden"
      },
      r.class
    ]), u = S(() => [
      m.e("wrapper"),
      m.is("focus", O.value)
    ]), { form: c, formItem: d } = Yn(), { inputId: f } = tr(o, {
      formItemContext: d
    }), p = yn(), v = Hn(), m = we("input"), h = we("textarea"), b = qt(), g = qt(), w = L(false), y = L(false), _ = L(), C = qt(o.inputStyle), E = S(() => b.value || g.value), { wrapperRef: T, isFocused: O, handleFocus: N, handleBlur: $ } = pl(E, {
      beforeFocus() {
        return v.value;
      },
      afterBlur() {
        var fe;
        o.validateEvent && ((fe = d == null ? void 0 : d.validate) == null || fe.call(d, "blur").catch((ie) => _t(ie)));
      }
    }), R = S(() => {
      var fe;
      return (fe = c == null ? void 0 : c.statusIcon) != null ? fe : false;
    }), P = S(() => (d == null ? void 0 : d.validateState) || ""), z = S(() => P.value && ep[P.value]), Y = S(() => y.value ? L8 : a8), D = S(() => [
      r.style
    ]), M = S(() => [
      o.inputStyle,
      C.value,
      { resize: o.resize }
    ]), F = S(() => Nn(o.modelValue) ? "" : String(o.modelValue)), A = S(() => o.clearable && !v.value && !o.readonly && !!F.value && (O.value || w.value)), V = S(() => o.showPassword && !v.value && !!F.value), Z = S(() => o.showWordLimit && !!o.maxlength && (o.type === "text" || o.type === "textarea") && !v.value && !o.readonly && !o.showPassword), G = S(() => F.value.length), le = S(() => !!Z.value && G.value > Number(o.maxlength)), X = S(() => !!l.suffix || !!o.suffixIcon || A.value || o.showPassword || Z.value || !!P.value && R.value), [te, ce] = nD(b);
    en(g, (fe) => {
      if (ve(), !Z.value || o.resize !== "both")
        return;
      const ie = fe[0], { width: Ce } = ie.contentRect;
      _.value = {
        right: `calc(100% - ${Ce + 15 + 6}px)`
      };
    });
    const pe = () => {
      const { type: fe, autosize: ie } = o;
      if (!(!Et || fe !== "textarea" || !g.value))
        if (ie) {
          const Ce = at(ie) ? ie.minRows : void 0, qe = at(ie) ? ie.maxRows : void 0, et = L0(g.value, Ce, qe);
          C.value = {
            overflowY: "hidden",
            ...et
          }, He(() => {
            g.value.offsetHeight, C.value = et;
          });
        } else
          C.value = {
            minHeight: L0(g.value).minHeight
          };
    }, ve = /* @__PURE__ */ ((fe) => {
      let ie = false;
      return () => {
        var Ce;
        if (ie || !o.autosize)
          return;
        ((Ce = g.value) == null ? void 0 : Ce.offsetParent) === null || (fe(), ie = true);
      };
    })(pe), me = () => {
      const fe = E.value, ie = o.formatter ? o.formatter(F.value) : F.value;
      !fe || fe.value === ie || (fe.value = ie);
    }, De = async (fe) => {
      te();
      let { value: ie } = fe.target;
      if (o.formatter && o.parser && (ie = o.parser(ie)), !de.value) {
        if (ie === F.value) {
          me();
          return;
        }
        n(nt, ie), n(bn, ie), await He(), me(), ce();
      }
    }, Te = (fe) => {
      let { value: ie } = fe.target;
      o.formatter && o.parser && (ie = o.parser(ie)), n(gt, ie);
    }, {
      isComposing: de,
      handleCompositionStart: U,
      handleCompositionUpdate: re,
      handleCompositionEnd: he
    } = uc({ emit: n, afterComposition: De }), Ee = () => {
      te(), y.value = !y.value, setTimeout(ce);
    }, ye = () => {
      var fe;
      return (fe = E.value) == null ? void 0 : fe.focus();
    }, K = () => {
      var fe;
      return (fe = E.value) == null ? void 0 : fe.blur();
    }, q = (fe) => {
      w.value = false, n("mouseleave", fe);
    }, ue = (fe) => {
      w.value = true, n("mouseenter", fe);
    }, be = (fe) => {
      n("keydown", fe);
    }, ke = () => {
      var fe;
      (fe = E.value) == null || fe.select();
    }, Ae = () => {
      n(nt, ""), n(gt, ""), n("clear"), n(bn, "");
    };
    return ge(() => o.modelValue, () => {
      var fe;
      He(() => pe()), o.validateEvent && ((fe = d == null ? void 0 : d.validate) == null || fe.call(d, "change").catch((ie) => _t(ie)));
    }), ge(F, () => me()), ge(() => o.type, async () => {
      await He(), me(), pe();
    }), dt(() => {
      !o.formatter && o.parser && _t(VS, "If you set the parser, you also need to set the formatter."), me(), He(pe);
    }), t({
      input: b,
      textarea: g,
      ref: E,
      textareaStyle: M,
      autosize: Lt(o, "autosize"),
      isComposing: de,
      focus: ye,
      blur: K,
      select: ke,
      clear: Ae,
      resizeTextarea: pe
    }), (fe, ie) => (k(), x("div", {
      class: I([
        i(s),
        {
          [i(m).bm("group", "append")]: fe.$slots.append,
          [i(m).bm("group", "prepend")]: fe.$slots.prepend
        }
      ]),
      style: ze(i(D)),
      onMouseenter: ue,
      onMouseleave: q
    }, [
      ee(" input "),
      fe.type !== "textarea" ? (k(), x(Ie, { key: 0 }, [
        ee(" prepend slot "),
        fe.$slots.prepend ? (k(), x("div", {
          key: 0,
          class: I(i(m).be("group", "prepend"))
        }, [
          J(fe.$slots, "prepend")
        ], 2)) : ee("v-if", true),
        B("div", {
          ref_key: "wrapperRef",
          ref: T,
          class: I(i(u))
        }, [
          ee(" prefix slot "),
          fe.$slots.prefix || fe.prefixIcon ? (k(), x("span", {
            key: 0,
            class: I(i(m).e("prefix"))
          }, [
            B("span", {
              class: I(i(m).e("prefix-inner"))
            }, [
              J(fe.$slots, "prefix"),
              fe.prefixIcon ? (k(), ae(i(Be), {
                key: 0,
                class: I(i(m).e("icon"))
              }, {
                default: H(() => [
                  (k(), ae(ht(fe.prefixIcon)))
                ]),
                _: 1
              }, 8, ["class"])) : ee("v-if", true)
            ], 2)
          ], 2)) : ee("v-if", true),
          B("input", vt({
            id: i(f),
            ref_key: "input",
            ref: b,
            class: i(m).e("inner")
          }, i(a), {
            minlength: fe.minlength,
            maxlength: fe.maxlength,
            type: fe.showPassword ? y.value ? "text" : "password" : fe.type,
            disabled: i(v),
            readonly: fe.readonly,
            autocomplete: fe.autocomplete,
            tabindex: fe.tabindex,
            "aria-label": fe.ariaLabel,
            placeholder: fe.placeholder,
            style: fe.inputStyle,
            form: fe.form,
            autofocus: fe.autofocus,
            role: fe.containerRole,
            onCompositionstart: i(U),
            onCompositionupdate: i(re),
            onCompositionend: i(he),
            onInput: De,
            onChange: Te,
            onKeydown: be
          }), null, 16, ["id", "minlength", "maxlength", "type", "disabled", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form", "autofocus", "role", "onCompositionstart", "onCompositionupdate", "onCompositionend"]),
          ee(" suffix slot "),
          i(X) ? (k(), x("span", {
            key: 1,
            class: I(i(m).e("suffix"))
          }, [
            B("span", {
              class: I(i(m).e("suffix-inner"))
            }, [
              !i(A) || !i(V) || !i(Z) ? (k(), x(Ie, { key: 0 }, [
                J(fe.$slots, "suffix"),
                fe.suffixIcon ? (k(), ae(i(Be), {
                  key: 0,
                  class: I(i(m).e("icon"))
                }, {
                  default: H(() => [
                    (k(), ae(ht(fe.suffixIcon)))
                  ]),
                  _: 1
                }, 8, ["class"])) : ee("v-if", true)
              ], 64)) : ee("v-if", true),
              i(A) ? (k(), ae(i(Be), {
                key: 1,
                class: I([i(m).e("icon"), i(m).e("clear")]),
                onMousedown: Xe(i(Mt), ["prevent"]),
                onClick: Ae
              }, {
                default: H(() => [
                  W(i(Ma))
                ]),
                _: 1
              }, 8, ["class", "onMousedown"])) : ee("v-if", true),
              i(V) ? (k(), ae(i(Be), {
                key: 2,
                class: I([i(m).e("icon"), i(m).e("password")]),
                onClick: Ee
              }, {
                default: H(() => [
                  (k(), ae(ht(i(Y))))
                ]),
                _: 1
              }, 8, ["class"])) : ee("v-if", true),
              i(Z) ? (k(), x("span", {
                key: 3,
                class: I(i(m).e("count"))
              }, [
                B("span", {
                  class: I(i(m).e("count-inner"))
                }, _e(i(G)) + " / " + _e(fe.maxlength), 3)
              ], 2)) : ee("v-if", true),
              i(P) && i(z) && i(R) ? (k(), ae(i(Be), {
                key: 4,
                class: I([
                  i(m).e("icon"),
                  i(m).e("validateIcon"),
                  i(m).is("loading", i(P) === "validating")
                ])
              }, {
                default: H(() => [
                  (k(), ae(ht(i(z))))
                ]),
                _: 1
              }, 8, ["class"])) : ee("v-if", true)
            ], 2)
          ], 2)) : ee("v-if", true)
        ], 2),
        ee(" append slot "),
        fe.$slots.append ? (k(), x("div", {
          key: 1,
          class: I(i(m).be("group", "append"))
        }, [
          J(fe.$slots, "append")
        ], 2)) : ee("v-if", true)
      ], 64)) : (k(), x(Ie, { key: 1 }, [
        ee(" textarea "),
        B("textarea", vt({
          id: i(f),
          ref_key: "textarea",
          ref: g,
          class: [i(h).e("inner"), i(m).is("focus", i(O))]
        }, i(a), {
          minlength: fe.minlength,
          maxlength: fe.maxlength,
          tabindex: fe.tabindex,
          disabled: i(v),
          readonly: fe.readonly,
          autocomplete: fe.autocomplete,
          style: i(M),
          "aria-label": fe.ariaLabel,
          placeholder: fe.placeholder,
          form: fe.form,
          autofocus: fe.autofocus,
          rows: fe.rows,
          role: fe.containerRole,
          onCompositionstart: i(U),
          onCompositionupdate: i(re),
          onCompositionend: i(he),
          onInput: De,
          onFocus: i(N),
          onBlur: i($),
          onChange: Te,
          onKeydown: be
        }), null, 16, ["id", "minlength", "maxlength", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form", "autofocus", "rows", "role", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onFocus", "onBlur"]),
        i(Z) ? (k(), x("span", {
          key: 0,
          style: ze(_.value),
          class: I(i(m).e("count"))
        }, _e(i(G)) + " / " + _e(fe.maxlength), 7)) : ee("v-if", true)
      ], 64))
    ], 38));
  }
});
var aD = /* @__PURE__ */ $e(rD, [["__file", "input.vue"]]);
const eo = ut(aD), ms = 4, FS = {
  vertical: {
    offset: "offsetHeight",
    scroll: "scrollTop",
    scrollSize: "scrollHeight",
    size: "height",
    key: "vertical",
    axis: "Y",
    client: "clientY",
    direction: "top"
  },
  horizontal: {
    offset: "offsetWidth",
    scroll: "scrollLeft",
    scrollSize: "scrollWidth",
    size: "width",
    key: "horizontal",
    axis: "X",
    client: "clientX",
    direction: "left"
  }
}, lD = ({
  move: e10,
  size: t,
  bar: n
}) => ({
  [n.size]: t,
  transform: `translate${n.axis}(${e10}%)`
}), ug = Symbol("scrollbarContextKey"), sD = Oe({
  vertical: Boolean,
  size: String,
  move: Number,
  ratio: {
    type: Number,
    required: true
  },
  always: Boolean
}), iD = "Thumb", uD = /* @__PURE__ */ j({
  __name: "thumb",
  props: sD,
  setup(e10) {
    const t = e10, n = Le(ug), o = we("scrollbar");
    n || Qt(iD, "can not inject scrollbar context");
    const r = L(), a = L(), l = L({}), s = L(false);
    let u = false, c = false, d = 0, f = Et ? document.onselectstart : null;
    const p = S(() => FS[t.vertical ? "vertical" : "horizontal"]), v = S(() => lD({
      size: t.size,
      move: t.move,
      bar: p.value
    })), m = S(() => r.value[p.value.offset] ** 2 / n.wrapElement[p.value.scrollSize] / t.ratio / a.value[p.value.offset]), h = (T) => {
      var O;
      if (T.stopPropagation(), T.ctrlKey || [1, 2].includes(T.button))
        return;
      (O = window.getSelection()) == null || O.removeAllRanges(), g(T);
      const N = T.currentTarget;
      N && (l.value[p.value.axis] = N[p.value.offset] - (T[p.value.client] - N.getBoundingClientRect()[p.value.direction]));
    }, b = (T) => {
      if (!a.value || !r.value || !n.wrapElement)
        return;
      const O = Math.abs(T.target.getBoundingClientRect()[p.value.direction] - T[p.value.client]), N = a.value[p.value.offset] / 2, $ = (O - N) * 100 * m.value / r.value[p.value.offset];
      n.wrapElement[p.value.scroll] = $ * n.wrapElement[p.value.scrollSize] / 100;
    }, g = (T) => {
      T.stopImmediatePropagation(), u = true, d = n.wrapElement.scrollHeight, document.addEventListener("mousemove", w), document.addEventListener("mouseup", y), f = document.onselectstart, document.onselectstart = () => false;
    }, w = (T) => {
      if (!r.value || !a.value || u === false)
        return;
      const O = l.value[p.value.axis];
      if (!O)
        return;
      const N = (r.value.getBoundingClientRect()[p.value.direction] - T[p.value.client]) * -1, $ = a.value[p.value.offset] - O, R = (N - $) * 100 * m.value / r.value[p.value.offset];
      n.wrapElement[p.value.scroll] = R * d / 100;
    }, y = () => {
      u = false, l.value[p.value.axis] = 0, document.removeEventListener("mousemove", w), document.removeEventListener("mouseup", y), E(), c && (s.value = false);
    }, _ = () => {
      c = false, s.value = !!t.size;
    }, C = () => {
      c = true, s.value = u;
    };
    jt(() => {
      E(), document.removeEventListener("mouseup", y);
    });
    const E = () => {
      document.onselectstart !== f && (document.onselectstart = f);
    };
    return Ft(Lt(n, "scrollbarElement"), "mousemove", _), Ft(Lt(n, "scrollbarElement"), "mouseleave", C), (T, O) => (k(), ae(Rn, {
      name: i(o).b("fade"),
      persisted: ""
    }, {
      default: H(() => [
        lt(B("div", {
          ref_key: "instance",
          ref: r,
          class: I([i(o).e("bar"), i(o).is(i(p).key)]),
          onMousedown: b,
          onClick: Xe(() => {
          }, ["stop"])
        }, [
          B("div", {
            ref_key: "thumb",
            ref: a,
            class: I(i(o).e("thumb")),
            style: ze(i(v)),
            onMousedown: h
          }, null, 38)
        ], 42, ["onClick"]), [
          [Nt, T.always || s.value]
        ])
      ]),
      _: 1
    }, 8, ["name"]));
  }
});
var x0 = /* @__PURE__ */ $e(uD, [["__file", "thumb.vue"]]);
const cD = Oe({
  always: {
    type: Boolean,
    default: true
  },
  minSize: {
    type: Number,
    required: true
  }
}), dD = /* @__PURE__ */ j({
  __name: "bar",
  props: cD,
  setup(e10, { expose: t }) {
    const n = e10, o = Le(ug), r = L(0), a = L(0), l = L(""), s = L(""), u = L(1), c = L(1);
    return t({
      handleScroll: (p) => {
        if (p) {
          const v = p.offsetHeight - ms, m = p.offsetWidth - ms;
          a.value = p.scrollTop * 100 / v * u.value, r.value = p.scrollLeft * 100 / m * c.value;
        }
      },
      update: () => {
        const p = o == null ? void 0 : o.wrapElement;
        if (!p)
          return;
        const v = p.offsetHeight - ms, m = p.offsetWidth - ms, h = v ** 2 / p.scrollHeight, b = m ** 2 / p.scrollWidth, g = Math.max(h, n.minSize), w = Math.max(b, n.minSize);
        u.value = h / (v - h) / (g / (v - g)), c.value = b / (m - b) / (w / (m - w)), s.value = g + ms < v ? `${g}px` : "", l.value = w + ms < m ? `${w}px` : "";
      }
    }), (p, v) => (k(), x(Ie, null, [
      W(x0, {
        move: r.value,
        ratio: c.value,
        size: l.value,
        always: p.always
      }, null, 8, ["move", "ratio", "size", "always"]),
      W(x0, {
        move: a.value,
        ratio: u.value,
        size: s.value,
        vertical: "",
        always: p.always
      }, null, 8, ["move", "ratio", "size", "always"])
    ], 64));
  }
});
var fD = /* @__PURE__ */ $e(dD, [["__file", "bar.vue"]]);
const pD = Oe({
  height: {
    type: [String, Number],
    default: ""
  },
  maxHeight: {
    type: [String, Number],
    default: ""
  },
  native: {
    type: Boolean,
    default: false
  },
  wrapStyle: {
    type: ne([String, Object, Array]),
    default: ""
  },
  wrapClass: {
    type: [String, Array],
    default: ""
  },
  viewClass: {
    type: [String, Array],
    default: ""
  },
  viewStyle: {
    type: [String, Array, Object],
    default: ""
  },
  noresize: Boolean,
  tag: {
    type: String,
    default: "div"
  },
  always: Boolean,
  minSize: {
    type: Number,
    default: 20
  },
  tabindex: {
    type: [String, Number],
    default: void 0
  },
  id: String,
  role: String,
  ...Bn(["ariaLabel", "ariaOrientation"])
}), BS = {
  "end-reached": (e10) => ["left", "right", "top", "bottom"].includes(e10),
  scroll: ({
    scrollTop: e10,
    scrollLeft: t
  }) => [e10, t].every(Ye)
}, Xv = "ElScrollbar", vD = /* @__PURE__ */ j({
  name: Xv
}), hD = /* @__PURE__ */ j({
  ...vD,
  props: pD,
  emits: BS,
  setup(e10, { expose: t, emit: n }) {
    const o = e10, r = we("scrollbar");
    let a, l, s = 0, u = 0, c = "";
    const d = L(), f = L(), p = L(), v = L(), m = S(() => {
      const E = {};
      return o.height && (E.height = sn(o.height)), o.maxHeight && (E.maxHeight = sn(o.maxHeight)), [o.wrapStyle, E];
    }), h = S(() => [
      o.wrapClass,
      r.e("wrap"),
      { [r.em("wrap", "hidden-default")]: !o.native }
    ]), b = S(() => [r.e("view"), o.viewClass]), g = () => {
      var E;
      if (f.value) {
        (E = v.value) == null || E.handleScroll(f.value);
        const T = s, O = u;
        s = f.value.scrollTop, u = f.value.scrollLeft;
        const N = {
          bottom: s + f.value.clientHeight >= f.value.scrollHeight,
          top: s <= 0 && T !== 0,
          right: u + f.value.clientWidth >= f.value.scrollWidth && O !== u,
          left: u <= 0 && O !== 0
        };
        T !== s && (c = s > T ? "bottom" : "top"), O !== u && (c = u > O ? "right" : "left"), n("scroll", {
          scrollTop: s,
          scrollLeft: u
        }), N[c] && n("end-reached", c);
      }
    };
    function w(E, T) {
      at(E) ? f.value.scrollTo(E) : Ye(E) && Ye(T) && f.value.scrollTo(E, T);
    }
    const y = (E) => {
      if (!Ye(E)) {
        _t(Xv, "value must be a number");
        return;
      }
      f.value.scrollTop = E;
    }, _ = (E) => {
      if (!Ye(E)) {
        _t(Xv, "value must be a number");
        return;
      }
      f.value.scrollLeft = E;
    }, C = () => {
      var E;
      (E = v.value) == null || E.update();
    };
    return ge(() => o.noresize, (E) => {
      E ? (a == null || a(), l == null || l()) : ({ stop: a } = en(p, C), l = Ft("resize", C));
    }, { immediate: true }), ge(() => [o.maxHeight, o.height], () => {
      o.native || He(() => {
        var E;
        C(), f.value && ((E = v.value) == null || E.handleScroll(f.value));
      });
    }), yt(ug, It({
      scrollbarElement: d,
      wrapElement: f
    })), Lf(() => {
      f.value && (f.value.scrollTop = s, f.value.scrollLeft = u);
    }), dt(() => {
      o.native || He(() => {
        C();
      });
    }), wr(() => C()), t({
      wrapRef: f,
      update: C,
      scrollTo: w,
      setScrollTop: y,
      setScrollLeft: _,
      handleScroll: g
    }), (E, T) => (k(), x("div", {
      ref_key: "scrollbarRef",
      ref: d,
      class: I(i(r).b())
    }, [
      B("div", {
        ref_key: "wrapRef",
        ref: f,
        class: I(i(h)),
        style: ze(i(m)),
        tabindex: E.tabindex,
        onScroll: g
      }, [
        (k(), ae(ht(E.tag), {
          id: E.id,
          ref_key: "resizeRef",
          ref: p,
          class: I(i(b)),
          style: ze(E.viewStyle),
          role: E.role,
          "aria-label": E.ariaLabel,
          "aria-orientation": E.ariaOrientation
        }, {
          default: H(() => [
            J(E.$slots, "default")
          ]),
          _: 3
        }, 8, ["id", "class", "style", "role", "aria-label", "aria-orientation"]))
      ], 46, ["tabindex"]),
      E.native ? ee("v-if", true) : (k(), ae(fD, {
        key: 0,
        ref_key: "barRef",
        ref: v,
        always: E.always,
        "min-size": E.minSize
      }, null, 8, ["always", "min-size"]))
    ], 2));
  }
});
var mD = /* @__PURE__ */ $e(hD, [["__file", "scrollbar.vue"]]);
const ta = ut(mD), cg = Symbol("popper"), HS = Symbol("popperContent"), zS = [
  "dialog",
  "grid",
  "group",
  "listbox",
  "menu",
  "navigation",
  "tooltip",
  "tree"
], KS = Oe({
  role: {
    type: String,
    values: zS,
    default: "tooltip"
  }
}), gD = /* @__PURE__ */ j({
  name: "ElPopper",
  inheritAttrs: false
}), yD = /* @__PURE__ */ j({
  ...gD,
  props: KS,
  setup(e10, { expose: t }) {
    const n = e10, o = L(), r = L(), a = L(), l = L(), s = S(() => n.role), u = {
      triggerRef: o,
      popperInstanceRef: r,
      contentRef: a,
      referenceRef: l,
      role: s
    };
    return t(u), yt(cg, u), (c, d) => J(c.$slots, "default");
  }
});
var bD = /* @__PURE__ */ $e(yD, [["__file", "popper.vue"]]);
const _D = /* @__PURE__ */ j({
  name: "ElPopperArrow",
  inheritAttrs: false
}), wD = /* @__PURE__ */ j({
  ..._D,
  setup(e10, { expose: t }) {
    const n = we("popper"), { arrowRef: o, arrowStyle: r } = Le(HS, void 0);
    return jt(() => {
      o.value = void 0;
    }), t({
      arrowRef: o
    }), (a, l) => (k(), x("span", {
      ref_key: "arrowRef",
      ref: o,
      class: I(i(n).e("arrow")),
      style: ze(i(r)),
      "data-popper-arrow": ""
    }, null, 6));
  }
});
var CD = /* @__PURE__ */ $e(wD, [["__file", "arrow.vue"]]);
const WS = Oe({
  virtualRef: {
    type: ne(Object)
  },
  virtualTriggering: Boolean,
  onMouseenter: {
    type: ne(Function)
  },
  onMouseleave: {
    type: ne(Function)
  },
  onClick: {
    type: ne(Function)
  },
  onKeydown: {
    type: ne(Function)
  },
  onFocus: {
    type: ne(Function)
  },
  onBlur: {
    type: ne(Function)
  },
  onContextmenu: {
    type: ne(Function)
  },
  id: String,
  open: Boolean
}), jS = Symbol("elForwardRef"), ED = (e10) => {
  yt(jS, {
    setForwardRef: (n) => {
      e10.value = n;
    }
  });
}, SD = (e10) => ({
  mounted(t) {
    e10(t);
  },
  updated(t) {
    e10(t);
  },
  unmounted() {
    e10(null);
  }
}), kD = 'a[href],button:not([disabled]),button:not([hidden]),:not([tabindex="-1"]),input:not([disabled]),input:not([type="hidden"]),select:not([disabled]),textarea:not([disabled])', ND = (e10) =>  false ? 0 : getComputedStyle(e10).position === "fixed" ? false : e10.offsetParent !== null, D0 = (e10) => Array.from(e10.querySelectorAll(kD)).filter((t) => tf(t) && ND(t)), tf = (e10) => {
  if (e10.tabIndex > 0 || e10.tabIndex === 0 && e10.getAttribute("tabIndex") !== null)
    return true;
  if (e10.tabIndex < 0 || e10.hasAttribute("disabled") || e10.getAttribute("aria-disabled") === "true")
    return false;
  switch (e10.nodeName) {
    case "A":
      return !!e10.href && e10.rel !== "ignore";
    case "INPUT":
      return !(e10.type === "hidden" || e10.type === "file");
    case "BUTTON":
    case "SELECT":
    case "TEXTAREA":
      return true;
    default:
      return false;
  }
}, ad = function(e10, t, ...n) {
  let o;
  t.includes("mouse") || t.includes("click") ? o = "MouseEvents" : t.includes("key") ? o = "KeyboardEvent" : o = "HTMLEvents";
  const r = document.createEvent(o);
  return r.initEvent(t, ...n), e10.dispatchEvent(r), e10;
}, US = (e10) => !e10.getAttribute("aria-owns"), YS = (e10, t, n) => {
  const { parentNode: o } = e10;
  if (!o)
    return null;
  const r = o.querySelectorAll(n), a = Array.prototype.indexOf.call(r, e10);
  return r[a + t] || null;
}, ld = (e10) => {
  e10 && (e10.focus(), !US(e10) && e10.click());
}, Xp = "ElOnlyChild", qS = /* @__PURE__ */ j({
  name: Xp,
  setup(e10, {
    slots: t,
    attrs: n
  }) {
    var o;
    const r = Le(jS), a = SD((o = r == null ? void 0 : r.setForwardRef) != null ? o : Mt);
    return () => {
      var l;
      const s = (l = t.default) == null ? void 0 : l.call(t, n);
      if (!s)
        return null;
      if (s.length > 1)
        return _t(Xp, "requires exact only one valid child."), null;
      const u = GS(s);
      return u ? lt(gr(u, n), [[a]]) : (_t(Xp, "no valid child node found"), null);
    };
  }
});
function GS(e10) {
  if (!e10)
    return null;
  const t = e10;
  for (const n of t) {
    if (at(n))
      switch (n.type) {
        case tn:
          continue;
        case Zr:
        case "svg":
          return V0(n);
        case Ie:
          return GS(n.children);
        default:
          return n;
      }
    return V0(n);
  }
  return null;
}
function V0(e10) {
  const t = we("only-child");
  return W("span", {
    class: t.e("content")
  }, [e10]);
}
const TD = /* @__PURE__ */ j({
  name: "ElPopperTrigger",
  inheritAttrs: false
}), OD = /* @__PURE__ */ j({
  ...TD,
  props: WS,
  setup(e10, { expose: t }) {
    const n = e10, { role: o, triggerRef: r } = Le(cg, void 0);
    ED(r);
    const a = S(() => s.value ? n.id : void 0), l = S(() => {
      if (o && o.value === "tooltip")
        return n.open && n.id ? n.id : void 0;
    }), s = S(() => {
      if (o && o.value !== "tooltip")
        return o.value;
    }), u = S(() => s.value ? `${n.open}` : void 0);
    let c;
    const d = [
      "onMouseenter",
      "onMouseleave",
      "onClick",
      "onKeydown",
      "onFocus",
      "onBlur",
      "onContextmenu"
    ];
    return dt(() => {
      ge(() => n.virtualRef, (f) => {
        f && (r.value = xn(f));
      }, {
        immediate: true
      }), ge(r, (f, p) => {
        c == null || c(), c = void 0, to(f) && (d.forEach((v) => {
          var m;
          const h = n[v];
          h && (f.addEventListener(v.slice(2).toLowerCase(), h), (m = p == null ? void 0 : p.removeEventListener) == null || m.call(p, v.slice(2).toLowerCase(), h));
        }), tf(f) && (c = ge([a, l, s, u], (v) => {
          [
            "aria-controls",
            "aria-describedby",
            "aria-haspopup",
            "aria-expanded"
          ].forEach((m, h) => {
            Nn(v[h]) ? f.removeAttribute(m) : f.setAttribute(m, v[h]);
          });
        }, { immediate: true }))), to(p) && tf(p) && [
          "aria-controls",
          "aria-describedby",
          "aria-haspopup",
          "aria-expanded"
        ].forEach((v) => p.removeAttribute(v));
      }, {
        immediate: true
      });
    }), jt(() => {
      if (c == null || c(), c = void 0, r.value && to(r.value)) {
        const f = r.value;
        d.forEach((p) => {
          const v = n[p];
          v && f.removeEventListener(p.slice(2).toLowerCase(), v);
        }), r.value = void 0;
      }
    }), t({
      triggerRef: r
    }), (f, p) => f.virtualTriggering ? ee("v-if", true) : (k(), ae(i(qS), vt({ key: 0 }, f.$attrs, {
      "aria-controls": i(a),
      "aria-describedby": i(l),
      "aria-expanded": i(u),
      "aria-haspopup": i(s)
    }), {
      default: H(() => [
        J(f.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"]));
  }
});
var $D = /* @__PURE__ */ $e(OD, [["__file", "trigger.vue"]]);
const Jp = "focus-trap.focus-after-trapped", Zp = "focus-trap.focus-after-released", ID = "focus-trap.focusout-prevented", F0 = {
  cancelable: true,
  bubbles: false
}, MD = {
  cancelable: true,
  bubbles: false
}, B0 = "focusAfterTrapped", H0 = "focusAfterReleased", dg = Symbol("elFocusTrap"), fg = L(), tp = L(0), pg = L(0);
let Ac = 0;
const XS = (e10) => {
  const t = [], n = document.createTreeWalker(e10, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (o) => {
      const r = o.tagName === "INPUT" && o.type === "hidden";
      return o.disabled || o.hidden || r ? NodeFilter.FILTER_SKIP : o.tabIndex >= 0 || o === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); )
    t.push(n.currentNode);
  return t;
}, z0 = (e10, t) => {
  for (const n of e10)
    if (!PD(n, t))
      return n;
}, PD = (e10, t) => {
  if (false)
    // removed by dead control flow
{}
  if (getComputedStyle(e10).visibility === "hidden")
    return true;
  for (; e10; ) {
    if (t && e10 === t)
      return false;
    if (getComputedStyle(e10).display === "none")
      return true;
    e10 = e10.parentElement;
  }
  return false;
}, RD = (e10) => {
  const t = XS(e10), n = z0(t, e10), o = z0(t.reverse(), e10);
  return [n, o];
}, AD = (e10) => e10 instanceof HTMLInputElement && "select" in e10, ca = (e10, t) => {
  if (e10 && e10.focus) {
    const n = document.activeElement;
    let o = false;
    to(e10) && !tf(e10) && !e10.getAttribute("tabindex") && (e10.setAttribute("tabindex", "-1"), o = true), e10.focus({ preventScroll: true }), pg.value = window.performance.now(), e10 !== n && AD(e10) && t && e10.select(), to(e10) && o && e10.removeAttribute("tabindex");
  }
};
function K0(e10, t) {
  const n = [...e10], o = e10.indexOf(t);
  return o !== -1 && n.splice(o, 1), n;
}
const LD = () => {
  let e10 = [];
  return {
    push: (o) => {
      const r = e10[0];
      r && o !== r && r.pause(), e10 = K0(e10, o), e10.unshift(o);
    },
    remove: (o) => {
      var r, a;
      e10 = K0(e10, o), (a = (r = e10[0]) == null ? void 0 : r.resume) == null || a.call(r);
    }
  };
}, xD = (e10, t = false) => {
  const n = document.activeElement;
  for (const o of e10)
    if (ca(o, t), document.activeElement !== n)
      return;
}, W0 = LD(), DD = () => tp.value > pg.value, Lc = () => {
  fg.value = "pointer", tp.value = window.performance.now();
}, j0 = () => {
  fg.value = "keyboard", tp.value = window.performance.now();
}, VD = () => (dt(() => {
  Ac === 0 && (document.addEventListener("mousedown", Lc), document.addEventListener("touchstart", Lc), document.addEventListener("keydown", j0)), Ac++;
}), jt(() => {
  Ac--, Ac <= 0 && (document.removeEventListener("mousedown", Lc), document.removeEventListener("touchstart", Lc), document.removeEventListener("keydown", j0));
}), {
  focusReason: fg,
  lastUserFocusTimestamp: tp,
  lastAutomatedFocusTimestamp: pg
}), xc = (e10) => new CustomEvent(ID, {
  ...MD,
  detail: e10
}), xe = {
  tab: "Tab",
  enter: "Enter",
  space: "Space",
  left: "ArrowLeft",
  up: "ArrowUp",
  right: "ArrowRight",
  down: "ArrowDown",
  esc: "Escape",
  delete: "Delete",
  backspace: "Backspace",
  numpadEnter: "NumpadEnter",
  pageUp: "PageUp",
  pageDown: "PageDown",
  home: "Home",
  end: "End"
};
let ks = [];
const U0 = (e10) => {
  e10.code === xe.esc && ks.forEach((t) => t(e10));
}, FD = (e10) => {
  dt(() => {
    ks.length === 0 && document.addEventListener("keydown", U0), Et && ks.push(e10);
  }), jt(() => {
    ks = ks.filter((t) => t !== e10), ks.length === 0 && Et && document.removeEventListener("keydown", U0);
  });
}, BD = /* @__PURE__ */ j({
  name: "ElFocusTrap",
  inheritAttrs: false,
  props: {
    loop: Boolean,
    trapped: Boolean,
    focusTrapEl: Object,
    focusStartEl: {
      type: [Object, String],
      default: "first"
    }
  },
  emits: [
    B0,
    H0,
    "focusin",
    "focusout",
    "focusout-prevented",
    "release-requested"
  ],
  setup(e10, { emit: t }) {
    const n = L();
    let o, r;
    const { focusReason: a } = VD();
    FD((m) => {
      e10.trapped && !l.paused && t("release-requested", m);
    });
    const l = {
      paused: false,
      pause() {
        this.paused = true;
      },
      resume() {
        this.paused = false;
      }
    }, s = (m) => {
      if (!e10.loop && !e10.trapped || l.paused)
        return;
      const { code: h, altKey: b, ctrlKey: g, metaKey: w, currentTarget: y, shiftKey: _ } = m, { loop: C } = e10, E = h === xe.tab && !b && !g && !w, T = document.activeElement;
      if (E && T) {
        const O = y, [N, $] = RD(O);
        if (N && $) {
          if (!_ && T === $) {
            const P = xc({
              focusReason: a.value
            });
            t("focusout-prevented", P), P.defaultPrevented || (m.preventDefault(), C && ca(N, true));
          } else if (_ && [N, O].includes(T)) {
            const P = xc({
              focusReason: a.value
            });
            t("focusout-prevented", P), P.defaultPrevented || (m.preventDefault(), C && ca($, true));
          }
        } else if (T === O) {
          const P = xc({
            focusReason: a.value
          });
          t("focusout-prevented", P), P.defaultPrevented || m.preventDefault();
        }
      }
    };
    yt(dg, {
      focusTrapRef: n,
      onKeydown: s
    }), ge(() => e10.focusTrapEl, (m) => {
      m && (n.value = m);
    }, { immediate: true }), ge([n], ([m], [h]) => {
      m && (m.addEventListener("keydown", s), m.addEventListener("focusin", d), m.addEventListener("focusout", f)), h && (h.removeEventListener("keydown", s), h.removeEventListener("focusin", d), h.removeEventListener("focusout", f));
    });
    const u = (m) => {
      t(B0, m);
    }, c = (m) => t(H0, m), d = (m) => {
      const h = i(n);
      if (!h)
        return;
      const b = m.target, g = m.relatedTarget, w = b && h.contains(b);
      e10.trapped || g && h.contains(g) || (o = g), w && t("focusin", m), !l.paused && e10.trapped && (w ? r = b : ca(r, true));
    }, f = (m) => {
      const h = i(n);
      if (!(l.paused || !h))
        if (e10.trapped) {
          const b = m.relatedTarget;
          !Nn(b) && !h.contains(b) && setTimeout(() => {
            if (!l.paused && e10.trapped) {
              const g = xc({
                focusReason: a.value
              });
              t("focusout-prevented", g), g.defaultPrevented || ca(r, true);
            }
          }, 0);
        } else {
          const b = m.target;
          b && h.contains(b) || t("focusout", m);
        }
    };
    async function p() {
      await He();
      const m = i(n);
      if (m) {
        W0.push(l);
        const h = m.contains(document.activeElement) ? o : document.activeElement;
        if (o = h, !m.contains(h)) {
          const g = new Event(Jp, F0);
          m.addEventListener(Jp, u), m.dispatchEvent(g), g.defaultPrevented || He(() => {
            let w = e10.focusStartEl;
            Ve(w) || (ca(w), document.activeElement !== w && (w = "first")), w === "first" && xD(XS(m), true), (document.activeElement === h || w === "container") && ca(m);
          });
        }
      }
    }
    function v() {
      const m = i(n);
      if (m) {
        m.removeEventListener(Jp, u);
        const h = new CustomEvent(Zp, {
          ...F0,
          detail: {
            focusReason: a.value
          }
        });
        m.addEventListener(Zp, c), m.dispatchEvent(h), !h.defaultPrevented && (a.value == "keyboard" || !DD() || m.contains(document.activeElement)) && ca(o != null ? o : document.body), m.removeEventListener(Zp, c), W0.remove(l);
      }
    }
    return dt(() => {
      e10.trapped && p(), ge(() => e10.trapped, (m) => {
        m ? p() : v();
      });
    }), jt(() => {
      e10.trapped && v(), n.value && (n.value.removeEventListener("keydown", s), n.value.removeEventListener("focusin", d), n.value.removeEventListener("focusout", f), n.value = void 0);
    }), {
      onKeydown: s
    };
  }
});
function HD(e10, t, n, o, r, a) {
  return J(e10.$slots, "default", { handleKeydown: e10.onKeydown });
}
var Ni = /* @__PURE__ */ $e(BD, [["render", HD], ["__file", "focus-trap.vue"]]), ko = "top", Zo = "bottom", Qo = "right", No = "left", vg = "auto", cc = [ko, Zo, Qo, No], ei = "start", Eu = "end", zD = "clippingParents", JS = "viewport", Bi = "popper", KD = "reference", Y0 = cc.reduce(function(e10, t) {
  return e10.concat([t + "-" + ei, t + "-" + Eu]);
}, []), Pa = [].concat(cc, [vg]).reduce(function(e10, t) {
  return e10.concat([t, t + "-" + ei, t + "-" + Eu]);
}, []), WD = "beforeRead", jD = "read", UD = "afterRead", YD = "beforeMain", qD = "main", GD = "afterMain", XD = "beforeWrite", JD = "write", ZD = "afterWrite", QD = [WD, jD, UD, YD, qD, GD, XD, JD, ZD];
function Gr(e10) {
  return e10 ? (e10.nodeName || "").toLowerCase() : null;
}
function Sr(e10) {
  if (e10 == null) return window;
  if (e10.toString() !== "[object Window]") {
    var t = e10.ownerDocument;
    return t && t.defaultView || window;
  }
  return e10;
}
function ti(e10) {
  var t = Sr(e10).Element;
  return e10 instanceof t || e10 instanceof Element;
}
function Yo(e10) {
  var t = Sr(e10).HTMLElement;
  return e10 instanceof t || e10 instanceof HTMLElement;
}
function hg(e10) {
  if (typeof ShadowRoot > "u") return false;
  var t = Sr(e10).ShadowRoot;
  return e10 instanceof t || e10 instanceof ShadowRoot;
}
function eV(e10) {
  var t = e10.state;
  Object.keys(t.elements).forEach(function(n) {
    var o = t.styles[n] || {}, r = t.attributes[n] || {}, a = t.elements[n];
    !Yo(a) || !Gr(a) || (Object.assign(a.style, o), Object.keys(r).forEach(function(l) {
      var s = r[l];
      s === false ? a.removeAttribute(l) : a.setAttribute(l, s === true ? "" : s);
    }));
  });
}
function tV(e10) {
  var t = e10.state, n = { popper: { position: t.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
  return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow), function() {
    Object.keys(t.elements).forEach(function(o) {
      var r = t.elements[o], a = t.attributes[o] || {}, l = Object.keys(t.styles.hasOwnProperty(o) ? t.styles[o] : n[o]), s = l.reduce(function(u, c) {
        return u[c] = "", u;
      }, {});
      !Yo(r) || !Gr(r) || (Object.assign(r.style, s), Object.keys(a).forEach(function(u) {
        r.removeAttribute(u);
      }));
    });
  };
}
var ZS = { name: "applyStyles", enabled: true, phase: "write", fn: eV, effect: tV, requires: ["computeStyles"] };
function Hr(e10) {
  return e10.split("-")[0];
}
var Kl = Math.max, nf = Math.min, ni = Math.round;
function oi(e10, t) {
  t === void 0 && (t = false);
  var n = e10.getBoundingClientRect(), o = 1, r = 1;
  if (Yo(e10) && t) {
    var a = e10.offsetHeight, l = e10.offsetWidth;
    l > 0 && (o = ni(n.width) / l || 1), a > 0 && (r = ni(n.height) / a || 1);
  }
  return { width: n.width / o, height: n.height / r, top: n.top / r, right: n.right / o, bottom: n.bottom / r, left: n.left / o, x: n.left / o, y: n.top / r };
}
function mg(e10) {
  var t = oi(e10), n = e10.offsetWidth, o = e10.offsetHeight;
  return Math.abs(t.width - n) <= 1 && (n = t.width), Math.abs(t.height - o) <= 1 && (o = t.height), { x: e10.offsetLeft, y: e10.offsetTop, width: n, height: o };
}
function QS(e10, t) {
  var n = t.getRootNode && t.getRootNode();
  if (e10.contains(t)) return true;
  if (n && hg(n)) {
    var o = t;
    do {
      if (o && e10.isSameNode(o)) return true;
      o = o.parentNode || o.host;
    } while (o);
  }
  return false;
}
function Ca(e10) {
  return Sr(e10).getComputedStyle(e10);
}
function nV(e10) {
  return ["table", "td", "th"].indexOf(Gr(e10)) >= 0;
}
function vl(e10) {
  return ((ti(e10) ? e10.ownerDocument : e10.document) || window.document).documentElement;
}
function np(e10) {
  return Gr(e10) === "html" ? e10 : e10.assignedSlot || e10.parentNode || (hg(e10) ? e10.host : null) || vl(e10);
}
function q0(e10) {
  return !Yo(e10) || Ca(e10).position === "fixed" ? null : e10.offsetParent;
}
function oV(e10) {
  var t = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n = navigator.userAgent.indexOf("Trident") !== -1;
  if (n && Yo(e10)) {
    var o = Ca(e10);
    if (o.position === "fixed") return null;
  }
  var r = np(e10);
  for (hg(r) && (r = r.host); Yo(r) && ["html", "body"].indexOf(Gr(r)) < 0; ) {
    var a = Ca(r);
    if (a.transform !== "none" || a.perspective !== "none" || a.contain === "paint" || ["transform", "perspective"].indexOf(a.willChange) !== -1 || t && a.willChange === "filter" || t && a.filter && a.filter !== "none") return r;
    r = r.parentNode;
  }
  return null;
}
function dc(e10) {
  for (var t = Sr(e10), n = q0(e10); n && nV(n) && Ca(n).position === "static"; ) n = q0(n);
  return n && (Gr(n) === "html" || Gr(n) === "body" && Ca(n).position === "static") ? t : n || oV(e10) || t;
}
function gg(e10) {
  return ["top", "bottom"].indexOf(e10) >= 0 ? "x" : "y";
}
function ou(e10, t, n) {
  return Kl(e10, nf(t, n));
}
function rV(e10, t, n) {
  var o = ou(e10, t, n);
  return o > n ? n : o;
}
function e2() {
  return { top: 0, right: 0, bottom: 0, left: 0 };
}
function t2(e10) {
  return Object.assign({}, e2(), e10);
}
function n2(e10, t) {
  return t.reduce(function(n, o) {
    return n[o] = e10, n;
  }, {});
}
var aV = function(e10, t) {
  return e10 = typeof e10 == "function" ? e10(Object.assign({}, t.rects, { placement: t.placement })) : e10, t2(typeof e10 != "number" ? e10 : n2(e10, cc));
};
function lV(e10) {
  var t, n = e10.state, o = e10.name, r = e10.options, a = n.elements.arrow, l = n.modifiersData.popperOffsets, s = Hr(n.placement), u = gg(s), c = [No, Qo].indexOf(s) >= 0, d = c ? "height" : "width";
  if (!(!a || !l)) {
    var f = aV(r.padding, n), p = mg(a), v = u === "y" ? ko : No, m = u === "y" ? Zo : Qo, h = n.rects.reference[d] + n.rects.reference[u] - l[u] - n.rects.popper[d], b = l[u] - n.rects.reference[u], g = dc(a), w = g ? u === "y" ? g.clientHeight || 0 : g.clientWidth || 0 : 0, y = h / 2 - b / 2, _ = f[v], C = w - p[d] - f[m], E = w / 2 - p[d] / 2 + y, T = ou(_, E, C), O = u;
    n.modifiersData[o] = (t = {}, t[O] = T, t.centerOffset = T - E, t);
  }
}
function sV(e10) {
  var t = e10.state, n = e10.options, o = n.element, r = o === void 0 ? "[data-popper-arrow]" : o;
  r != null && (typeof r == "string" && (r = t.elements.popper.querySelector(r), !r) || !QS(t.elements.popper, r) || (t.elements.arrow = r));
}
var iV = { name: "arrow", enabled: true, phase: "main", fn: lV, effect: sV, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
function ri(e10) {
  return e10.split("-")[1];
}
var uV = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
function cV(e10) {
  var t = e10.x, n = e10.y, o = window, r = o.devicePixelRatio || 1;
  return { x: ni(t * r) / r || 0, y: ni(n * r) / r || 0 };
}
function G0(e10) {
  var t, n = e10.popper, o = e10.popperRect, r = e10.placement, a = e10.variation, l = e10.offsets, s = e10.position, u = e10.gpuAcceleration, c = e10.adaptive, d = e10.roundOffsets, f = e10.isFixed, p = l.x, v = p === void 0 ? 0 : p, m = l.y, h = m === void 0 ? 0 : m, b = typeof d == "function" ? d({ x: v, y: h }) : { x: v, y: h };
  v = b.x, h = b.y;
  var g = l.hasOwnProperty("x"), w = l.hasOwnProperty("y"), y = No, _ = ko, C = window;
  if (c) {
    var E = dc(n), T = "clientHeight", O = "clientWidth";
    if (E === Sr(n) && (E = vl(n), Ca(E).position !== "static" && s === "absolute" && (T = "scrollHeight", O = "scrollWidth")), E = E, r === ko || (r === No || r === Qo) && a === Eu) {
      _ = Zo;
      var N = f && E === C && C.visualViewport ? C.visualViewport.height : E[T];
      h -= N - o.height, h *= u ? 1 : -1;
    }
    if (r === No || (r === ko || r === Zo) && a === Eu) {
      y = Qo;
      var $ = f && E === C && C.visualViewport ? C.visualViewport.width : E[O];
      v -= $ - o.width, v *= u ? 1 : -1;
    }
  }
  var R = Object.assign({ position: s }, c && uV), P = d === true ? cV({ x: v, y: h }) : { x: v, y: h };
  if (v = P.x, h = P.y, u) {
    var z;
    return Object.assign({}, R, (z = {}, z[_] = w ? "0" : "", z[y] = g ? "0" : "", z.transform = (C.devicePixelRatio || 1) <= 1 ? "translate(" + v + "px, " + h + "px)" : "translate3d(" + v + "px, " + h + "px, 0)", z));
  }
  return Object.assign({}, R, (t = {}, t[_] = w ? h + "px" : "", t[y] = g ? v + "px" : "", t.transform = "", t));
}
function dV(e10) {
  var t = e10.state, n = e10.options, o = n.gpuAcceleration, r = o === void 0 ? true : o, a = n.adaptive, l = a === void 0 ? true : a, s = n.roundOffsets, u = s === void 0 ? true : s, c = { placement: Hr(t.placement), variation: ri(t.placement), popper: t.elements.popper, popperRect: t.rects.popper, gpuAcceleration: r, isFixed: t.options.strategy === "fixed" };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, G0(Object.assign({}, c, { offsets: t.modifiersData.popperOffsets, position: t.options.strategy, adaptive: l, roundOffsets: u })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, G0(Object.assign({}, c, { offsets: t.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets: u })))), t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-placement": t.placement });
}
var o2 = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: dV, data: {} }, Dc = { passive: true };
function fV(e10) {
  var t = e10.state, n = e10.instance, o = e10.options, r = o.scroll, a = r === void 0 ? true : r, l = o.resize, s = l === void 0 ? true : l, u = Sr(t.elements.popper), c = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return a && c.forEach(function(d) {
    d.addEventListener("scroll", n.update, Dc);
  }), s && u.addEventListener("resize", n.update, Dc), function() {
    a && c.forEach(function(d) {
      d.removeEventListener("scroll", n.update, Dc);
    }), s && u.removeEventListener("resize", n.update, Dc);
  };
}
var r2 = { name: "eventListeners", enabled: true, phase: "write", fn: function() {
}, effect: fV, data: {} }, pV = { left: "right", right: "left", bottom: "top", top: "bottom" };
function sd(e10) {
  return e10.replace(/left|right|bottom|top/g, function(t) {
    return pV[t];
  });
}
var vV = { start: "end", end: "start" };
function X0(e10) {
  return e10.replace(/start|end/g, function(t) {
    return vV[t];
  });
}
function yg(e10) {
  var t = Sr(e10), n = t.pageXOffset, o = t.pageYOffset;
  return { scrollLeft: n, scrollTop: o };
}
function bg(e10) {
  return oi(vl(e10)).left + yg(e10).scrollLeft;
}
function hV(e10) {
  var t = Sr(e10), n = vl(e10), o = t.visualViewport, r = n.clientWidth, a = n.clientHeight, l = 0, s = 0;
  return o && (r = o.width, a = o.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (l = o.offsetLeft, s = o.offsetTop)), { width: r, height: a, x: l + bg(e10), y: s };
}
function mV(e10) {
  var t, n = vl(e10), o = yg(e10), r = (t = e10.ownerDocument) == null ? void 0 : t.body, a = Kl(n.scrollWidth, n.clientWidth, r ? r.scrollWidth : 0, r ? r.clientWidth : 0), l = Kl(n.scrollHeight, n.clientHeight, r ? r.scrollHeight : 0, r ? r.clientHeight : 0), s = -o.scrollLeft + bg(e10), u = -o.scrollTop;
  return Ca(r || n).direction === "rtl" && (s += Kl(n.clientWidth, r ? r.clientWidth : 0) - a), { width: a, height: l, x: s, y: u };
}
function _g(e10) {
  var t = Ca(e10), n = t.overflow, o = t.overflowX, r = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + r + o);
}
function a2(e10) {
  return ["html", "body", "#document"].indexOf(Gr(e10)) >= 0 ? e10.ownerDocument.body : Yo(e10) && _g(e10) ? e10 : a2(np(e10));
}
function ru(e10, t) {
  var n;
  t === void 0 && (t = []);
  var o = a2(e10), r = o === ((n = e10.ownerDocument) == null ? void 0 : n.body), a = Sr(o), l = r ? [a].concat(a.visualViewport || [], _g(o) ? o : []) : o, s = t.concat(l);
  return r ? s : s.concat(ru(np(l)));
}
function Jv(e10) {
  return Object.assign({}, e10, { left: e10.x, top: e10.y, right: e10.x + e10.width, bottom: e10.y + e10.height });
}
function gV(e10) {
  var t = oi(e10);
  return t.top = t.top + e10.clientTop, t.left = t.left + e10.clientLeft, t.bottom = t.top + e10.clientHeight, t.right = t.left + e10.clientWidth, t.width = e10.clientWidth, t.height = e10.clientHeight, t.x = t.left, t.y = t.top, t;
}
function J0(e10, t) {
  return t === JS ? Jv(hV(e10)) : ti(t) ? gV(t) : Jv(mV(vl(e10)));
}
function yV(e10) {
  var t = ru(np(e10)), n = ["absolute", "fixed"].indexOf(Ca(e10).position) >= 0, o = n && Yo(e10) ? dc(e10) : e10;
  return ti(o) ? t.filter(function(r) {
    return ti(r) && QS(r, o) && Gr(r) !== "body";
  }) : [];
}
function bV(e10, t, n) {
  var o = t === "clippingParents" ? yV(e10) : [].concat(t), r = [].concat(o, [n]), a = r[0], l = r.reduce(function(s, u) {
    var c = J0(e10, u);
    return s.top = Kl(c.top, s.top), s.right = nf(c.right, s.right), s.bottom = nf(c.bottom, s.bottom), s.left = Kl(c.left, s.left), s;
  }, J0(e10, a));
  return l.width = l.right - l.left, l.height = l.bottom - l.top, l.x = l.left, l.y = l.top, l;
}
function l2(e10) {
  var t = e10.reference, n = e10.element, o = e10.placement, r = o ? Hr(o) : null, a = o ? ri(o) : null, l = t.x + t.width / 2 - n.width / 2, s = t.y + t.height / 2 - n.height / 2, u;
  switch (r) {
    case ko:
      u = { x: l, y: t.y - n.height };
      break;
    case Zo:
      u = { x: l, y: t.y + t.height };
      break;
    case Qo:
      u = { x: t.x + t.width, y: s };
      break;
    case No:
      u = { x: t.x - n.width, y: s };
      break;
    default:
      u = { x: t.x, y: t.y };
  }
  var c = r ? gg(r) : null;
  if (c != null) {
    var d = c === "y" ? "height" : "width";
    switch (a) {
      case ei:
        u[c] = u[c] - (t[d] / 2 - n[d] / 2);
        break;
      case Eu:
        u[c] = u[c] + (t[d] / 2 - n[d] / 2);
        break;
    }
  }
  return u;
}
function Su(e10, t) {
  t === void 0 && (t = {});
  var n = t, o = n.placement, r = o === void 0 ? e10.placement : o, a = n.boundary, l = a === void 0 ? zD : a, s = n.rootBoundary, u = s === void 0 ? JS : s, c = n.elementContext, d = c === void 0 ? Bi : c, f = n.altBoundary, p = f === void 0 ? false : f, v = n.padding, m = v === void 0 ? 0 : v, h = t2(typeof m != "number" ? m : n2(m, cc)), b = d === Bi ? KD : Bi, g = e10.rects.popper, w = e10.elements[p ? b : d], y = bV(ti(w) ? w : w.contextElement || vl(e10.elements.popper), l, u), _ = oi(e10.elements.reference), C = l2({ reference: _, element: g, placement: r }), E = Jv(Object.assign({}, g, C)), T = d === Bi ? E : _, O = { top: y.top - T.top + h.top, bottom: T.bottom - y.bottom + h.bottom, left: y.left - T.left + h.left, right: T.right - y.right + h.right }, N = e10.modifiersData.offset;
  if (d === Bi && N) {
    var $ = N[r];
    Object.keys(O).forEach(function(R) {
      var P = [Qo, Zo].indexOf(R) >= 0 ? 1 : -1, z = [ko, Zo].indexOf(R) >= 0 ? "y" : "x";
      O[R] += $[z] * P;
    });
  }
  return O;
}
function _V(e10, t) {
  t === void 0 && (t = {});
  var n = t, o = n.placement, r = n.boundary, a = n.rootBoundary, l = n.padding, s = n.flipVariations, u = n.allowedAutoPlacements, c = u === void 0 ? Pa : u, d = ri(o), f = d ? s ? Y0 : Y0.filter(function(m) {
    return ri(m) === d;
  }) : cc, p = f.filter(function(m) {
    return c.indexOf(m) >= 0;
  });
  p.length === 0 && (p = f);
  var v = p.reduce(function(m, h) {
    return m[h] = Su(e10, { placement: h, boundary: r, rootBoundary: a, padding: l })[Hr(h)], m;
  }, {});
  return Object.keys(v).sort(function(m, h) {
    return v[m] - v[h];
  });
}
function wV(e10) {
  if (Hr(e10) === vg) return [];
  var t = sd(e10);
  return [X0(e10), t, X0(t)];
}
function CV(e10) {
  var t = e10.state, n = e10.options, o = e10.name;
  if (!t.modifiersData[o]._skip) {
    for (var r = n.mainAxis, a = r === void 0 ? true : r, l = n.altAxis, s = l === void 0 ? true : l, u = n.fallbackPlacements, c = n.padding, d = n.boundary, f = n.rootBoundary, p = n.altBoundary, v = n.flipVariations, m = v === void 0 ? true : v, h = n.allowedAutoPlacements, b = t.options.placement, g = Hr(b), w = g === b, y = u || (w || !m ? [sd(b)] : wV(b)), _ = [b].concat(y).reduce(function(te, ce) {
      return te.concat(Hr(ce) === vg ? _V(t, { placement: ce, boundary: d, rootBoundary: f, padding: c, flipVariations: m, allowedAutoPlacements: h }) : ce);
    }, []), C = t.rects.reference, E = t.rects.popper, T = /* @__PURE__ */ new Map(), O = true, N = _[0], $ = 0; $ < _.length; $++) {
      var R = _[$], P = Hr(R), z = ri(R) === ei, Y = [ko, Zo].indexOf(P) >= 0, D = Y ? "width" : "height", M = Su(t, { placement: R, boundary: d, rootBoundary: f, altBoundary: p, padding: c }), F = Y ? z ? Qo : No : z ? Zo : ko;
      C[D] > E[D] && (F = sd(F));
      var A = sd(F), V = [];
      if (a && V.push(M[P] <= 0), s && V.push(M[F] <= 0, M[A] <= 0), V.every(function(te) {
        return te;
      })) {
        N = R, O = false;
        break;
      }
      T.set(R, V);
    }
    if (O) for (var Z = m ? 3 : 1, G = function(te) {
      var ce = _.find(function(pe) {
        var se = T.get(pe);
        if (se) return se.slice(0, te).every(function(ve) {
          return ve;
        });
      });
      if (ce) return N = ce, "break";
    }, le = Z; le > 0; le--) {
      var X = G(le);
      if (X === "break") break;
    }
    t.placement !== N && (t.modifiersData[o]._skip = true, t.placement = N, t.reset = true);
  }
}
var EV = { name: "flip", enabled: true, phase: "main", fn: CV, requiresIfExists: ["offset"], data: { _skip: false } };
function Z0(e10, t, n) {
  return n === void 0 && (n = { x: 0, y: 0 }), { top: e10.top - t.height - n.y, right: e10.right - t.width + n.x, bottom: e10.bottom - t.height + n.y, left: e10.left - t.width - n.x };
}
function Q0(e10) {
  return [ko, Qo, Zo, No].some(function(t) {
    return e10[t] >= 0;
  });
}
function SV(e10) {
  var t = e10.state, n = e10.name, o = t.rects.reference, r = t.rects.popper, a = t.modifiersData.preventOverflow, l = Su(t, { elementContext: "reference" }), s = Su(t, { altBoundary: true }), u = Z0(l, o), c = Z0(s, r, a), d = Q0(u), f = Q0(c);
  t.modifiersData[n] = { referenceClippingOffsets: u, popperEscapeOffsets: c, isReferenceHidden: d, hasPopperEscaped: f }, t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-reference-hidden": d, "data-popper-escaped": f });
}
var kV = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: SV };
function NV(e10, t, n) {
  var o = Hr(e10), r = [No, ko].indexOf(o) >= 0 ? -1 : 1, a = typeof n == "function" ? n(Object.assign({}, t, { placement: e10 })) : n, l = a[0], s = a[1];
  return l = l || 0, s = (s || 0) * r, [No, Qo].indexOf(o) >= 0 ? { x: s, y: l } : { x: l, y: s };
}
function TV(e10) {
  var t = e10.state, n = e10.options, o = e10.name, r = n.offset, a = r === void 0 ? [0, 0] : r, l = Pa.reduce(function(d, f) {
    return d[f] = NV(f, t.rects, a), d;
  }, {}), s = l[t.placement], u = s.x, c = s.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += u, t.modifiersData.popperOffsets.y += c), t.modifiersData[o] = l;
}
var OV = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: TV };
function $V(e10) {
  var t = e10.state, n = e10.name;
  t.modifiersData[n] = l2({ reference: t.rects.reference, element: t.rects.popper, placement: t.placement });
}
var s2 = { name: "popperOffsets", enabled: true, phase: "read", fn: $V, data: {} };
function IV(e10) {
  return e10 === "x" ? "y" : "x";
}
function MV(e10) {
  var t = e10.state, n = e10.options, o = e10.name, r = n.mainAxis, a = r === void 0 ? true : r, l = n.altAxis, s = l === void 0 ? false : l, u = n.boundary, c = n.rootBoundary, d = n.altBoundary, f = n.padding, p = n.tether, v = p === void 0 ? true : p, m = n.tetherOffset, h = m === void 0 ? 0 : m, b = Su(t, { boundary: u, rootBoundary: c, padding: f, altBoundary: d }), g = Hr(t.placement), w = ri(t.placement), y = !w, _ = gg(g), C = IV(_), E = t.modifiersData.popperOffsets, T = t.rects.reference, O = t.rects.popper, N = typeof h == "function" ? h(Object.assign({}, t.rects, { placement: t.placement })) : h, $ = typeof N == "number" ? { mainAxis: N, altAxis: N } : Object.assign({ mainAxis: 0, altAxis: 0 }, N), R = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, P = { x: 0, y: 0 };
  if (E) {
    if (a) {
      var z, Y = _ === "y" ? ko : No, D = _ === "y" ? Zo : Qo, M = _ === "y" ? "height" : "width", F = E[_], A = F + b[Y], V = F - b[D], Z = v ? -O[M] / 2 : 0, G = w === ei ? T[M] : O[M], le = w === ei ? -O[M] : -T[M], X = t.elements.arrow, te = v && X ? mg(X) : { width: 0, height: 0 }, ce = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : e2(), pe = ce[Y], se = ce[D], ve = ou(0, T[M], te[M]), me = y ? T[M] / 2 - Z - ve - pe - $.mainAxis : G - ve - pe - $.mainAxis, De = y ? -T[M] / 2 + Z + ve + se + $.mainAxis : le + ve + se + $.mainAxis, Te = t.elements.arrow && dc(t.elements.arrow), de = Te ? _ === "y" ? Te.clientTop || 0 : Te.clientLeft || 0 : 0, U = (z = R == null ? void 0 : R[_]) != null ? z : 0, re = F + me - U - de, he = F + De - U, Ee = ou(v ? nf(A, re) : A, F, v ? Kl(V, he) : V);
      E[_] = Ee, P[_] = Ee - F;
    }
    if (s) {
      var ye, K = _ === "x" ? ko : No, q = _ === "x" ? Zo : Qo, ue = E[C], be = C === "y" ? "height" : "width", ke = ue + b[K], Ae = ue - b[q], fe = [ko, No].indexOf(g) !== -1, ie = (ye = R == null ? void 0 : R[C]) != null ? ye : 0, Ce = fe ? ke : ue - T[be] - O[be] - ie + $.altAxis, qe = fe ? ue + T[be] + O[be] - ie - $.altAxis : Ae, et = v && fe ? rV(Ce, ue, qe) : ou(v ? Ce : ke, ue, v ? qe : Ae);
      E[C] = et, P[C] = et - ue;
    }
    t.modifiersData[o] = P;
  }
}
var PV = { name: "preventOverflow", enabled: true, phase: "main", fn: MV, requiresIfExists: ["offset"] };
function RV(e10) {
  return { scrollLeft: e10.scrollLeft, scrollTop: e10.scrollTop };
}
function AV(e10) {
  return e10 === Sr(e10) || !Yo(e10) ? yg(e10) : RV(e10);
}
function LV(e10) {
  var t = e10.getBoundingClientRect(), n = ni(t.width) / e10.offsetWidth || 1, o = ni(t.height) / e10.offsetHeight || 1;
  return n !== 1 || o !== 1;
}
function xV(e10, t, n) {
  n === void 0 && (n = false);
  var o = Yo(t), r = Yo(t) && LV(t), a = vl(t), l = oi(e10, r), s = { scrollLeft: 0, scrollTop: 0 }, u = { x: 0, y: 0 };
  return (o || !o && !n) && ((Gr(t) !== "body" || _g(a)) && (s = AV(t)), Yo(t) ? (u = oi(t, true), u.x += t.clientLeft, u.y += t.clientTop) : a && (u.x = bg(a))), { x: l.left + s.scrollLeft - u.x, y: l.top + s.scrollTop - u.y, width: l.width, height: l.height };
}
function DV(e10) {
  var t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), o = [];
  e10.forEach(function(a) {
    t.set(a.name, a);
  });
  function r(a) {
    n.add(a.name);
    var l = [].concat(a.requires || [], a.requiresIfExists || []);
    l.forEach(function(s) {
      if (!n.has(s)) {
        var u = t.get(s);
        u && r(u);
      }
    }), o.push(a);
  }
  return e10.forEach(function(a) {
    n.has(a.name) || r(a);
  }), o;
}
function VV(e10) {
  var t = DV(e10);
  return QD.reduce(function(n, o) {
    return n.concat(t.filter(function(r) {
      return r.phase === o;
    }));
  }, []);
}
function FV(e10) {
  var t;
  return function() {
    return t || (t = new Promise(function(n) {
      Promise.resolve().then(function() {
        t = void 0, n(e10());
      });
    })), t;
  };
}
function BV(e10) {
  var t = e10.reduce(function(n, o) {
    var r = n[o.name];
    return n[o.name] = r ? Object.assign({}, r, o, { options: Object.assign({}, r.options, o.options), data: Object.assign({}, r.data, o.data) }) : o, n;
  }, {});
  return Object.keys(t).map(function(n) {
    return t[n];
  });
}
var e1 = { placement: "bottom", modifiers: [], strategy: "absolute" };
function t1() {
  for (var e10 = arguments.length, t = new Array(e10), n = 0; n < e10; n++) t[n] = arguments[n];
  return !t.some(function(o) {
    return !(o && typeof o.getBoundingClientRect == "function");
  });
}
function wg(e10) {
  e10 === void 0 && (e10 = {});
  var t = e10, n = t.defaultModifiers, o = n === void 0 ? [] : n, r = t.defaultOptions, a = r === void 0 ? e1 : r;
  return function(l, s, u) {
    u === void 0 && (u = a);
    var c = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, e1, a), modifiersData: {}, elements: { reference: l, popper: s }, attributes: {}, styles: {} }, d = [], f = false, p = { state: c, setOptions: function(h) {
      var b = typeof h == "function" ? h(c.options) : h;
      m(), c.options = Object.assign({}, a, c.options, b), c.scrollParents = { reference: ti(l) ? ru(l) : l.contextElement ? ru(l.contextElement) : [], popper: ru(s) };
      var g = VV(BV([].concat(o, c.options.modifiers)));
      return c.orderedModifiers = g.filter(function(w) {
        return w.enabled;
      }), v(), p.update();
    }, forceUpdate: function() {
      if (!f) {
        var h = c.elements, b = h.reference, g = h.popper;
        if (t1(b, g)) {
          c.rects = { reference: xV(b, dc(g), c.options.strategy === "fixed"), popper: mg(g) }, c.reset = false, c.placement = c.options.placement, c.orderedModifiers.forEach(function(O) {
            return c.modifiersData[O.name] = Object.assign({}, O.data);
          });
          for (var w = 0; w < c.orderedModifiers.length; w++) {
            if (c.reset === true) {
              c.reset = false, w = -1;
              continue;
            }
            var y = c.orderedModifiers[w], _ = y.fn, C = y.options, E = C === void 0 ? {} : C, T = y.name;
            typeof _ == "function" && (c = _({ state: c, options: E, name: T, instance: p }) || c);
          }
        }
      }
    }, update: FV(function() {
      return new Promise(function(h) {
        p.forceUpdate(), h(c);
      });
    }), destroy: function() {
      m(), f = true;
    } };
    if (!t1(l, s)) return p;
    p.setOptions(u).then(function(h) {
      !f && u.onFirstUpdate && u.onFirstUpdate(h);
    });
    function v() {
      c.orderedModifiers.forEach(function(h) {
        var b = h.name, g = h.options, w = g === void 0 ? {} : g, y = h.effect;
        if (typeof y == "function") {
          var _ = y({ state: c, name: b, instance: p, options: w }), C = function() {
          };
          d.push(_ || C);
        }
      });
    }
    function m() {
      d.forEach(function(h) {
        return h();
      }), d = [];
    }
    return p;
  };
}
wg();
var HV = [r2, s2, o2, ZS];
wg({ defaultModifiers: HV });
var zV = [r2, s2, o2, ZS, OV, EV, PV, iV, kV], KV = wg({ defaultModifiers: zV });
const i2 = Oe({
  arrowOffset: {
    type: Number,
    default: 5
  }
}), WV = ["fixed", "absolute"], jV = Oe({
  boundariesPadding: {
    type: Number,
    default: 0
  },
  fallbackPlacements: {
    type: ne(Array),
    default: void 0
  },
  gpuAcceleration: {
    type: Boolean,
    default: true
  },
  offset: {
    type: Number,
    default: 12
  },
  placement: {
    type: String,
    values: Pa,
    default: "bottom"
  },
  popperOptions: {
    type: ne(Object),
    default: () => ({})
  },
  strategy: {
    type: String,
    values: WV,
    default: "absolute"
  }
}), u2 = Oe({
  ...jV,
  ...i2,
  id: String,
  style: {
    type: ne([String, Array, Object])
  },
  className: {
    type: ne([String, Array, Object])
  },
  effect: {
    type: ne(String),
    default: "dark"
  },
  visible: Boolean,
  enterable: {
    type: Boolean,
    default: true
  },
  pure: Boolean,
  focusOnShow: {
    type: Boolean,
    default: false
  },
  trapping: {
    type: Boolean,
    default: false
  },
  popperClass: {
    type: ne([String, Array, Object])
  },
  popperStyle: {
    type: ne([String, Array, Object])
  },
  referenceEl: {
    type: ne(Object)
  },
  triggerTargetEl: {
    type: ne(Object)
  },
  stopPopperMouseEvent: {
    type: Boolean,
    default: true
  },
  virtualTriggering: Boolean,
  zIndex: Number,
  ...Bn(["ariaLabel"])
}), UV = {
  mouseenter: (e10) => e10 instanceof MouseEvent,
  mouseleave: (e10) => e10 instanceof MouseEvent,
  focus: () => true,
  blur: () => true,
  close: () => true
}, YV = (e10, t) => {
  const n = L(false), o = L();
  return {
    focusStartRef: o,
    trapped: n,
    onFocusAfterReleased: (c) => {
      var d;
      ((d = c.detail) == null ? void 0 : d.focusReason) !== "pointer" && (o.value = "first", t("blur"));
    },
    onFocusAfterTrapped: () => {
      t("focus");
    },
    onFocusInTrap: (c) => {
      e10.visible && !n.value && (c.target && (o.value = c.target), n.value = true);
    },
    onFocusoutPrevented: (c) => {
      e10.trapping || (c.detail.focusReason === "pointer" && c.preventDefault(), n.value = false);
    },
    onReleaseRequested: () => {
      n.value = false, t("close");
    }
  };
}, qV = (e10, t = []) => {
  const { placement: n, strategy: o, popperOptions: r } = e10, a = {
    placement: n,
    strategy: o,
    ...r,
    modifiers: [...XV(e10), ...t]
  };
  return JV(a, r == null ? void 0 : r.modifiers), a;
}, GV = (e10) => {
  if (Et)
    return xn(e10);
};
function XV(e10) {
  const { offset: t, gpuAcceleration: n, fallbackPlacements: o } = e10;
  return [
    {
      name: "offset",
      options: {
        offset: [0, t != null ? t : 12]
      }
    },
    {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    },
    {
      name: "flip",
      options: {
        padding: 5,
        fallbackPlacements: o
      }
    },
    {
      name: "computeStyles",
      options: {
        gpuAcceleration: n
      }
    }
  ];
}
function JV(e10, t) {
  t && (e10.modifiers = [...e10.modifiers, ...t != null ? t : []]);
}
const ZV = (e10, t, n = {}) => {
  const o = {
    name: "updateState",
    enabled: true,
    phase: "write",
    fn: ({ state: u }) => {
      const c = QV(u);
      Object.assign(l.value, c);
    },
    requires: ["computeStyles"]
  }, r = S(() => {
    const { onFirstUpdate: u, placement: c, strategy: d, modifiers: f } = i(n);
    return {
      onFirstUpdate: u,
      placement: c || "bottom",
      strategy: d || "absolute",
      modifiers: [
        ...f || [],
        o,
        { name: "applyStyles", enabled: false }
      ]
    };
  }), a = qt(), l = L({
    styles: {
      popper: {
        position: i(r).strategy,
        left: "0",
        top: "0"
      },
      arrow: {
        position: "absolute"
      }
    },
    attributes: {}
  }), s = () => {
    a.value && (a.value.destroy(), a.value = void 0);
  };
  return ge(r, (u) => {
    const c = i(a);
    c && c.setOptions(u);
  }, {
    deep: true
  }), ge([e10, t], ([u, c]) => {
    s(), !(!u || !c) && (a.value = KV(u, c, i(r)));
  }), jt(() => {
    s();
  }), {
    state: S(() => {
      var u;
      return { ...((u = i(a)) == null ? void 0 : u.state) || {} };
    }),
    styles: S(() => i(l).styles),
    attributes: S(() => i(l).attributes),
    update: () => {
      var u;
      return (u = i(a)) == null ? void 0 : u.update();
    },
    forceUpdate: () => {
      var u;
      return (u = i(a)) == null ? void 0 : u.forceUpdate();
    },
    instanceRef: S(() => i(a))
  };
};
function QV(e10) {
  const t = Object.keys(e10.elements), n = wu(t.map((r) => [r, e10.styles[r] || {}])), o = wu(t.map((r) => [r, e10.attributes[r]]));
  return {
    styles: n,
    attributes: o
  };
}
const e6 = 0, t6 = (e10) => {
  const { popperInstanceRef: t, contentRef: n, triggerRef: o, role: r } = Le(cg, void 0), a = L(), l = S(() => e10.arrowOffset), s = S(() => ({
    name: "eventListeners",
    enabled: !!e10.visible
  })), u = S(() => {
    var g;
    const w = i(a), y = (g = i(l)) != null ? g : e6;
    return {
      name: "arrow",
      enabled: !cL(w),
      options: {
        element: w,
        padding: y
      }
    };
  }), c = S(() => ({
    onFirstUpdate: () => {
      m();
    },
    ...qV(e10, [
      i(u),
      i(s)
    ])
  })), d = S(() => GV(e10.referenceEl) || i(o)), { attributes: f, state: p, styles: v, update: m, forceUpdate: h, instanceRef: b } = ZV(d, n, c);
  return ge(b, (g) => t.value = g, {
    flush: "sync"
  }), dt(() => {
    ge(() => {
      var g;
      return (g = i(d)) == null ? void 0 : g.getBoundingClientRect();
    }, () => {
      m();
    });
  }), {
    attributes: f,
    arrowRef: a,
    contentRef: n,
    instanceRef: b,
    state: p,
    styles: v,
    role: r,
    forceUpdate: h,
    update: m
  };
}, n6 = (e10, {
  attributes: t,
  styles: n,
  role: o
}) => {
  const { nextZIndex: r } = Si(), a = we("popper"), l = S(() => i(t).popper), s = L(Ye(e10.zIndex) ? e10.zIndex : r()), u = S(() => [
    a.b(),
    a.is("pure", e10.pure),
    a.is(e10.effect),
    e10.popperClass
  ]), c = S(() => [
    { zIndex: i(s) },
    i(n).popper,
    e10.popperStyle || {}
  ]), d = S(() => o.value === "dialog" ? "false" : void 0), f = S(() => i(n).arrow || {});
  return {
    ariaModal: d,
    arrowStyle: f,
    contentAttrs: l,
    contentClass: u,
    contentStyle: c,
    contentZIndex: s,
    updateZIndex: () => {
      s.value = Ye(e10.zIndex) ? e10.zIndex : r();
    }
  };
}, o6 = /* @__PURE__ */ j({
  name: "ElPopperContent"
}), r6 = /* @__PURE__ */ j({
  ...o6,
  props: u2,
  emits: UV,
  setup(e10, { expose: t, emit: n }) {
    const o = e10, {
      focusStartRef: r,
      trapped: a,
      onFocusAfterReleased: l,
      onFocusAfterTrapped: s,
      onFocusInTrap: u,
      onFocusoutPrevented: c,
      onReleaseRequested: d
    } = YV(o, n), { attributes: f, arrowRef: p, contentRef: v, styles: m, instanceRef: h, role: b, update: g } = t6(o), {
      ariaModal: w,
      arrowStyle: y,
      contentAttrs: _,
      contentClass: C,
      contentStyle: E,
      updateZIndex: T
    } = n6(o, {
      styles: m,
      attributes: f,
      role: b
    }), O = Le(qr, void 0);
    yt(HS, {
      arrowStyle: y,
      arrowRef: p
    }), O && yt(qr, {
      ...O,
      addInputId: Mt,
      removeInputId: Mt
    });
    let N;
    const $ = (P = true) => {
      g(), P && T();
    }, R = () => {
      $(false), o.visible && o.focusOnShow ? a.value = true : o.visible === false && (a.value = false);
    };
    return dt(() => {
      ge(() => o.triggerTargetEl, (P, z) => {
        N == null || N(), N = void 0;
        const Y = i(P || v.value), D = i(z || v.value);
        to(Y) && (N = ge([b, () => o.ariaLabel, w, () => o.id], (M) => {
          ["role", "aria-label", "aria-modal", "id"].forEach((F, A) => {
            Nn(M[A]) ? Y.removeAttribute(F) : Y.setAttribute(F, M[A]);
          });
        }, { immediate: true })), D !== Y && to(D) && ["role", "aria-label", "aria-modal", "id"].forEach((M) => {
          D.removeAttribute(M);
        });
      }, { immediate: true }), ge(() => o.visible, R, { immediate: true });
    }), jt(() => {
      N == null || N(), N = void 0;
    }), t({
      popperContentRef: v,
      popperInstanceRef: h,
      updatePopper: $,
      contentStyle: E
    }), (P, z) => (k(), x("div", vt({
      ref_key: "contentRef",
      ref: v
    }, i(_), {
      style: i(E),
      class: i(C),
      tabindex: "-1",
      onMouseenter: (Y) => P.$emit("mouseenter", Y),
      onMouseleave: (Y) => P.$emit("mouseleave", Y)
    }), [
      W(i(Ni), {
        trapped: i(a),
        "trap-on-focus-in": true,
        "focus-trap-el": i(v),
        "focus-start-el": i(r),
        onFocusAfterTrapped: i(s),
        onFocusAfterReleased: i(l),
        onFocusin: i(u),
        onFocusoutPrevented: i(c),
        onReleaseRequested: i(d)
      }, {
        default: H(() => [
          J(P.$slots, "default")
        ]),
        _: 3
      }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
    ], 16, ["onMouseenter", "onMouseleave"]));
  }
});
var a6 = /* @__PURE__ */ $e(r6, [["__file", "content.vue"]]);
const c2 = ut(bD), op = Symbol("elTooltip"), rp = Oe({
  to: {
    type: ne([String, Object]),
    required: true
  },
  disabled: Boolean
}), vn = Oe({
  ...$S,
  ...u2,
  appendTo: {
    type: rp.to.type
  },
  content: {
    type: String,
    default: ""
  },
  rawContent: Boolean,
  persistent: Boolean,
  visible: {
    type: ne(Boolean),
    default: null
  },
  transition: String,
  teleported: {
    type: Boolean,
    default: true
  },
  disabled: Boolean,
  ...Bn(["ariaLabel"])
}), Bs = Oe({
  ...WS,
  disabled: Boolean,
  trigger: {
    type: ne([String, Array]),
    default: "hover"
  },
  triggerKeys: {
    type: ne(Array),
    default: () => [xe.enter, xe.numpadEnter, xe.space]
  }
}), l6 = Er({
  type: ne(Boolean),
  default: null
}), s6 = Er({
  type: ne(Function)
}), i6 = (e10) => {
  const t = `update:${e10}`, n = `onUpdate:${e10}`, o = [t], r = {
    [e10]: l6,
    [n]: s6
  };
  return {
    useModelToggle: ({
      indicator: l,
      toggleReason: s,
      shouldHideWhenRouteChanges: u,
      shouldProceed: c,
      onShow: d,
      onHide: f
    }) => {
      const p = it(), { emit: v } = p, m = p.props, h = S(() => Fe(m[n])), b = S(() => m[e10] === null), g = (T) => {
        l.value !== true && (l.value = true, s && (s.value = T), Fe(d) && d(T));
      }, w = (T) => {
        l.value !== false && (l.value = false, s && (s.value = T), Fe(f) && f(T));
      }, y = (T) => {
        if (m.disabled === true || Fe(c) && !c())
          return;
        const O = h.value && Et;
        O && v(t, true), (b.value || !O) && g(T);
      }, _ = (T) => {
        if (m.disabled === true || !Et)
          return;
        const O = h.value && Et;
        O && v(t, false), (b.value || !O) && w(T);
      }, C = (T) => {
        Vt(T) && (m.disabled && T ? h.value && v(t, false) : l.value !== T && (T ? g() : w()));
      }, E = () => {
        l.value ? _() : y();
      };
      return ge(() => m[e10], C), u && p.appContext.config.globalProperties.$route !== void 0 && ge(() => ({
        ...p.proxy.$route
      }), () => {
        u.value && l.value && _();
      }), dt(() => {
        C(m[e10]);
      }), {
        hide: _,
        show: y,
        toggle: E,
        hasUpdateHandler: h
      };
    },
    useModelToggleProps: r,
    useModelToggleEmits: o
  };
}, {
  useModelToggleProps: u6,
  useModelToggleEmits: c6,
  useModelToggle: d6
} = i6("visible"), f6 = Oe({
  ...KS,
  ...u6,
  ...vn,
  ...Bs,
  ...i2,
  showArrow: {
    type: Boolean,
    default: true
  }
}), p6 = [
  ...c6,
  "before-show",
  "before-hide",
  "show",
  "hide",
  "open",
  "close"
], v6 = (e10, t) => Se(e10) ? e10.includes(t) : e10 === t, gs = (e10, t, n) => (o) => {
  v6(i(e10), t) && n(o);
}, dn = (e10, t, { checkForDefaultPrevented: n = true } = {}) => (r) => {
  const a = e10 == null ? void 0 : e10(r);
  if (n === false || !a)
    return t == null ? void 0 : t(r);
}, n1 = (e10) => (t) => t.pointerType === "mouse" ? e10(t) : void 0, h6 = /* @__PURE__ */ j({
  name: "ElTooltipTrigger"
}), m6 = /* @__PURE__ */ j({
  ...h6,
  props: Bs,
  setup(e10, { expose: t }) {
    const n = e10, o = we("tooltip"), { controlled: r, id: a, open: l, onOpen: s, onClose: u, onToggle: c } = Le(op, void 0), d = L(null), f = () => {
      if (i(r) || n.disabled)
        return true;
    }, p = Lt(n, "trigger"), v = dn(f, gs(p, "hover", s)), m = dn(f, gs(p, "hover", u)), h = dn(f, gs(p, "click", (_) => {
      _.button === 0 && c(_);
    })), b = dn(f, gs(p, "focus", s)), g = dn(f, gs(p, "focus", u)), w = dn(f, gs(p, "contextmenu", (_) => {
      _.preventDefault(), c(_);
    })), y = dn(f, (_) => {
      const { code: C } = _;
      n.triggerKeys.includes(C) && (_.preventDefault(), c(_));
    });
    return t({
      triggerRef: d
    }), (_, C) => (k(), ae(i($D), {
      id: i(a),
      "virtual-ref": _.virtualRef,
      open: i(l),
      "virtual-triggering": _.virtualTriggering,
      class: I(i(o).e("trigger")),
      onBlur: i(g),
      onClick: i(h),
      onContextmenu: i(w),
      onFocus: i(b),
      onMouseenter: i(v),
      onMouseleave: i(m),
      onKeydown: i(y)
    }, {
      default: H(() => [
        J(_.$slots, "default")
      ]),
      _: 3
    }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]));
  }
});
var g6 = /* @__PURE__ */ $e(m6, [["__file", "trigger.vue"]]);
const y6 = /* @__PURE__ */ j({
  __name: "teleport",
  props: rp,
  setup(e10) {
    return (t, n) => t.disabled ? J(t.$slots, "default", { key: 0 }) : (k(), ae(EC, {
      key: 1,
      to: t.to
    }, [
      J(t.$slots, "default")
    ], 8, ["to"]));
  }
});
var b6 = /* @__PURE__ */ $e(y6, [["__file", "teleport.vue"]]);
const Ti = ut(b6), d2 = () => {
  const e10 = xm(), t = ig(), n = S(() => `${e10.value}-popper-container-${t.prefix}`), o = S(() => `#${n.value}`);
  return {
    id: n,
    selector: o
  };
}, _6 = (e10) => {
  const t = document.createElement("div");
  return t.id = e10, document.body.appendChild(t), t;
}, w6 = () => {
  const { id: e10, selector: t } = d2();
  return Df(() => {
    Et && ( false || !document.body.querySelector(t.value)) && _6(e10.value);
  }), {
    id: e10,
    selector: t
  };
}, C6 = /* @__PURE__ */ j({
  name: "ElTooltipContent",
  inheritAttrs: false
}), E6 = /* @__PURE__ */ j({
  ...C6,
  props: vn,
  setup(e10, { expose: t }) {
    const n = e10, { selector: o } = d2(), r = we("tooltip"), a = L(), l = Zd(() => {
      var A;
      return (A = a.value) == null ? void 0 : A.popperContentRef;
    });
    let s;
    const {
      controlled: u,
      id: c,
      open: d,
      trigger: f,
      onClose: p,
      onOpen: v,
      onShow: m,
      onHide: h,
      onBeforeShow: b,
      onBeforeHide: g
    } = Le(op, void 0), w = S(() => n.transition || `${r.namespace.value}-fade-in-linear`), y = S(() =>  false ? 0 : n.persistent);
    jt(() => {
      s == null || s();
    });
    const _ = S(() => i(y) ? true : i(d)), C = S(() => n.disabled ? false : i(d)), E = S(() => n.appendTo || o.value), T = S(() => {
      var A;
      return (A = n.style) != null ? A : {};
    }), O = L(true), N = () => {
      h(), F() && ca(document.body), O.value = true;
    }, $ = () => {
      if (i(u))
        return true;
    }, R = dn($, () => {
      n.enterable && i(f) === "hover" && v();
    }), P = dn($, () => {
      i(f) === "hover" && p();
    }), z = () => {
      var A, V;
      (V = (A = a.value) == null ? void 0 : A.updatePopper) == null || V.call(A), b == null || b();
    }, Y = () => {
      g == null || g();
    }, D = () => {
      m();
    }, M = () => {
      n.virtualTriggering || p();
    }, F = (A) => {
      var V;
      const Z = (V = a.value) == null ? void 0 : V.popperContentRef, G = (A == null ? void 0 : A.relatedTarget) || document.activeElement;
      return Z == null ? void 0 : Z.contains(G);
    };
    return ge(() => i(d), (A) => {
      A ? (O.value = false, s = Qm(l, () => {
        if (i(u))
          return;
        i(f) !== "hover" && p();
      })) : s == null || s();
    }, {
      flush: "post"
    }), ge(() => n.content, () => {
      var A, V;
      (V = (A = a.value) == null ? void 0 : A.updatePopper) == null || V.call(A);
    }), t({
      contentRef: a,
      isFocusInsideContent: F
    }), (A, V) => (k(), ae(i(Ti), {
      disabled: !A.teleported,
      to: i(E)
    }, {
      default: H(() => [
        W(Rn, {
          name: i(w),
          onAfterLeave: N,
          onBeforeEnter: z,
          onAfterEnter: D,
          onBeforeLeave: Y
        }, {
          default: H(() => [
            i(_) ? lt((k(), ae(i(a6), vt({
              key: 0,
              id: i(c),
              ref_key: "contentRef",
              ref: a
            }, A.$attrs, {
              "aria-label": A.ariaLabel,
              "aria-hidden": O.value,
              "boundaries-padding": A.boundariesPadding,
              "fallback-placements": A.fallbackPlacements,
              "gpu-acceleration": A.gpuAcceleration,
              offset: A.offset,
              placement: A.placement,
              "popper-options": A.popperOptions,
              "arrow-offset": A.arrowOffset,
              strategy: A.strategy,
              effect: A.effect,
              enterable: A.enterable,
              pure: A.pure,
              "popper-class": A.popperClass,
              "popper-style": [A.popperStyle, i(T)],
              "reference-el": A.referenceEl,
              "trigger-target-el": A.triggerTargetEl,
              visible: i(C),
              "z-index": A.zIndex,
              onMouseenter: i(R),
              onMouseleave: i(P),
              onBlur: M,
              onClose: i(p)
            }), {
              default: H(() => [
                J(A.$slots, "default")
              ]),
              _: 3
            }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "arrow-offset", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [
              [Nt, i(C)]
            ]) : ee("v-if", true)
          ]),
          _: 3
        }, 8, ["name"])
      ]),
      _: 3
    }, 8, ["disabled", "to"]));
  }
});
var S6 = /* @__PURE__ */ $e(E6, [["__file", "content.vue"]]);
const k6 = /* @__PURE__ */ j({
  name: "ElTooltip"
}), N6 = /* @__PURE__ */ j({
  ...k6,
  props: f6,
  emits: p6,
  setup(e10, { expose: t, emit: n }) {
    const o = e10;
    w6();
    const r = we("tooltip"), a = Fn(), l = L(), s = L(), u = () => {
      var y;
      const _ = i(l);
      _ && ((y = _.popperInstanceRef) == null || y.update());
    }, c = L(false), d = L(), { show: f, hide: p, hasUpdateHandler: v } = d6({
      indicator: c,
      toggleReason: d
    }), { onOpen: m, onClose: h } = IS({
      showAfter: Lt(o, "showAfter"),
      hideAfter: Lt(o, "hideAfter"),
      autoClose: Lt(o, "autoClose"),
      open: f,
      close: p
    }), b = S(() => Vt(o.visible) && !v.value), g = S(() => [r.b(), o.popperClass]);
    yt(op, {
      controlled: b,
      id: a,
      open: yi(c),
      trigger: Lt(o, "trigger"),
      onOpen: (y) => {
        m(y);
      },
      onClose: (y) => {
        h(y);
      },
      onToggle: (y) => {
        i(c) ? h(y) : m(y);
      },
      onShow: () => {
        n("show", d.value);
      },
      onHide: () => {
        n("hide", d.value);
      },
      onBeforeShow: () => {
        n("before-show", d.value);
      },
      onBeforeHide: () => {
        n("before-hide", d.value);
      },
      updatePopper: u
    }), ge(() => o.disabled, (y) => {
      y && c.value && (c.value = false);
    });
    const w = (y) => {
      var _;
      return (_ = s.value) == null ? void 0 : _.isFocusInsideContent(y);
    };
    return MC(() => c.value && p()), t({
      popperRef: l,
      contentRef: s,
      isFocusInsideContent: w,
      updatePopper: u,
      onOpen: m,
      onClose: h,
      hide: p
    }), (y, _) => (k(), ae(i(c2), {
      ref_key: "popperRef",
      ref: l,
      role: y.role
    }, {
      default: H(() => [
        W(g6, {
          disabled: y.disabled,
          trigger: y.trigger,
          "trigger-keys": y.triggerKeys,
          "virtual-ref": y.virtualRef,
          "virtual-triggering": y.virtualTriggering
        }, {
          default: H(() => [
            y.$slots.default ? J(y.$slots, "default", { key: 0 }) : ee("v-if", true)
          ]),
          _: 3
        }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]),
        W(S6, {
          ref_key: "contentRef",
          ref: s,
          "aria-label": y.ariaLabel,
          "boundaries-padding": y.boundariesPadding,
          content: y.content,
          disabled: y.disabled,
          effect: y.effect,
          enterable: y.enterable,
          "fallback-placements": y.fallbackPlacements,
          "hide-after": y.hideAfter,
          "gpu-acceleration": y.gpuAcceleration,
          offset: y.offset,
          persistent: y.persistent,
          "popper-class": i(g),
          "popper-style": y.popperStyle,
          placement: y.placement,
          "popper-options": y.popperOptions,
          "arrow-offset": y.arrowOffset,
          pure: y.pure,
          "raw-content": y.rawContent,
          "reference-el": y.referenceEl,
          "trigger-target-el": y.triggerTargetEl,
          "show-after": y.showAfter,
          strategy: y.strategy,
          teleported: y.teleported,
          transition: y.transition,
          "virtual-triggering": y.virtualTriggering,
          "z-index": y.zIndex,
          "append-to": y.appendTo
        }, {
          default: H(() => [
            J(y.$slots, "content", {}, () => [
              y.rawContent ? (k(), x("span", {
                key: 0,
                innerHTML: y.content
              }, null, 8, ["innerHTML"])) : (k(), x("span", { key: 1 }, _e(y.content), 1))
            ]),
            y.showArrow ? (k(), ae(i(CD), { key: 0 })) : ee("v-if", true)
          ]),
          _: 3
        }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "arrow-offset", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])
      ]),
      _: 3
    }, 8, ["role"]));
  }
});
var T6 = /* @__PURE__ */ $e(N6, [["__file", "tooltip.vue"]]);
const Un = ut(T6), O6 = Oe({
  valueKey: {
    type: String,
    default: "value"
  },
  modelValue: {
    type: [String, Number],
    default: ""
  },
  debounce: {
    type: Number,
    default: 300
  },
  placement: {
    type: ne(String),
    values: [
      "top",
      "top-start",
      "top-end",
      "bottom",
      "bottom-start",
      "bottom-end"
    ],
    default: "bottom-start"
  },
  fetchSuggestions: {
    type: ne([Function, Array]),
    default: Mt
  },
  popperClass: {
    type: String,
    default: ""
  },
  triggerOnFocus: {
    type: Boolean,
    default: true
  },
  selectWhenUnmatched: {
    type: Boolean,
    default: false
  },
  hideLoading: {
    type: Boolean,
    default: false
  },
  teleported: vn.teleported,
  appendTo: vn.appendTo,
  highlightFirstItem: {
    type: Boolean,
    default: false
  },
  fitInputWidth: {
    type: Boolean,
    default: false
  },
  clearable: {
    type: Boolean,
    default: false
  },
  disabled: {
    type: Boolean,
    default: false
  },
  name: String,
  ...Bn(["ariaLabel"])
}), $6 = {
  [nt]: (e10) => Ve(e10),
  [bn]: (e10) => Ve(e10),
  [gt]: (e10) => Ve(e10),
  focus: (e10) => e10 instanceof FocusEvent,
  blur: (e10) => e10 instanceof FocusEvent,
  clear: () => true,
  select: (e10) => at(e10)
}, f2 = "ElAutocomplete", I6 = /* @__PURE__ */ j({
  name: f2,
  inheritAttrs: false
}), M6 = /* @__PURE__ */ j({
  ...I6,
  props: O6,
  emits: $6,
  setup(e10, { expose: t, emit: n }) {
    const o = e10, r = ic(), a = Ta(), l = Hn(), s = we("autocomplete"), u = L(), c = L(), d = L(), f = L();
    let p = false, v = false;
    const m = L([]), h = L(-1), b = L(""), g = L(false), w = L(false), y = L(false), _ = Fn(), C = S(() => a.style), E = S(() => (m.value.length > 0 || y.value) && g.value), T = S(() => !o.hideLoading && y.value), O = S(() => u.value ? Array.from(u.value.$el.querySelectorAll("input")) : []), N = () => {
      E.value && (b.value = `${u.value.$el.offsetWidth}px`);
    }, $ = () => {
      h.value = -1;
    }, R = async (se) => {
      if (w.value)
        return;
      const ve = (me) => {
        y.value = false, !w.value && (Se(me) ? (m.value = me, h.value = o.highlightFirstItem ? 0 : -1) : Qt(f2, "autocomplete suggestions must be an array"));
      };
      if (y.value = true, Se(o.fetchSuggestions))
        ve(o.fetchSuggestions);
      else {
        const me = await o.fetchSuggestions(se, ve);
        Se(me) && ve(me);
      }
    }, P = Oo(R, o.debounce), z = (se) => {
      const ve = !!se;
      if (n(bn, se), n(nt, se), w.value = false, g.value || (g.value = ve), !o.triggerOnFocus && !se) {
        w.value = true, m.value = [];
        return;
      }
      P(se);
    }, Y = (se) => {
      var ve;
      l.value || (((ve = se.target) == null ? void 0 : ve.tagName) !== "INPUT" || O.value.includes(document.activeElement)) && (g.value = true);
    }, D = (se) => {
      n(gt, se);
    }, M = (se) => {
      var ve;
      if (v)
        v = false;
      else {
        g.value = true, n("focus", se);
        const me = (ve = o.modelValue) != null ? ve : "";
        o.triggerOnFocus && !p && P(String(me));
      }
    }, F = (se) => {
      setTimeout(() => {
        var ve;
        if ((ve = d.value) != null && ve.isFocusInsideContent()) {
          v = true;
          return;
        }
        g.value && G(), n("blur", se);
      });
    }, A = () => {
      g.value = false, n(nt, ""), n("clear");
    }, V = async () => {
      E.value && h.value >= 0 && h.value < m.value.length ? te(m.value[h.value]) : o.selectWhenUnmatched && (n("select", { value: o.modelValue }), m.value = [], h.value = -1);
    }, Z = (se) => {
      E.value && (se.preventDefault(), se.stopPropagation(), G());
    }, G = () => {
      g.value = false;
    }, le = () => {
      var se;
      (se = u.value) == null || se.focus();
    }, X = () => {
      var se;
      (se = u.value) == null || se.blur();
    }, te = async (se) => {
      n(bn, se[o.valueKey]), n(nt, se[o.valueKey]), n("select", se), m.value = [], h.value = -1;
    }, ce = (se) => {
      if (!E.value || y.value)
        return;
      if (se < 0) {
        h.value = -1;
        return;
      }
      se >= m.value.length && (se = m.value.length - 1);
      const ve = c.value.querySelector(`.${s.be("suggestion", "wrap")}`), De = ve.querySelectorAll(`.${s.be("suggestion", "list")} li`)[se], Te = ve.scrollTop, { offsetTop: de, scrollHeight: U } = De;
      de + U > Te + ve.clientHeight && (ve.scrollTop += U), de < Te && (ve.scrollTop -= U), h.value = se, u.value.ref.setAttribute("aria-activedescendant", `${_.value}-item-${h.value}`);
    }, pe = Qm(f, () => {
      var se;
      (se = d.value) != null && se.isFocusInsideContent() || E.value && G();
    });
    return jt(() => {
      pe == null || pe();
    }), dt(() => {
      u.value.ref.setAttribute("role", "textbox"), u.value.ref.setAttribute("aria-autocomplete", "list"), u.value.ref.setAttribute("aria-controls", "id"), u.value.ref.setAttribute("aria-activedescendant", `${_.value}-item-${h.value}`), p = u.value.ref.hasAttribute("readonly");
    }), t({
      highlightedIndex: h,
      activated: g,
      loading: y,
      inputRef: u,
      popperRef: d,
      suggestions: m,
      handleSelect: te,
      handleKeyEnter: V,
      focus: le,
      blur: X,
      close: G,
      highlight: ce,
      getData: R
    }), (se, ve) => (k(), ae(i(Un), {
      ref_key: "popperRef",
      ref: d,
      visible: i(E),
      placement: se.placement,
      "fallback-placements": ["bottom-start", "top-start"],
      "popper-class": [i(s).e("popper"), se.popperClass],
      teleported: se.teleported,
      "append-to": se.appendTo,
      "gpu-acceleration": false,
      pure: "",
      "manual-mode": "",
      effect: "light",
      trigger: "click",
      transition: `${i(s).namespace.value}-zoom-in-top`,
      persistent: "",
      role: "listbox",
      onBeforeShow: N,
      onHide: $
    }, {
      content: H(() => [
        B("div", {
          ref_key: "regionRef",
          ref: c,
          class: I([i(s).b("suggestion"), i(s).is("loading", i(T))]),
          style: ze({
            [se.fitInputWidth ? "width" : "minWidth"]: b.value,
            outline: "none"
          }),
          role: "region"
        }, [
          W(i(ta), {
            id: i(_),
            tag: "ul",
            "wrap-class": i(s).be("suggestion", "wrap"),
            "view-class": i(s).be("suggestion", "list"),
            role: "listbox"
          }, {
            default: H(() => [
              i(T) ? (k(), x("li", { key: 0 }, [
                J(se.$slots, "loading", {}, () => [
                  W(i(Be), {
                    class: I(i(s).is("loading"))
                  }, {
                    default: H(() => [
                      W(i(Yr))
                    ]),
                    _: 1
                  }, 8, ["class"])
                ])
              ])) : (k(true), x(Ie, { key: 1 }, st(m.value, (me, De) => (k(), x("li", {
                id: `${i(_)}-item-${De}`,
                key: De,
                class: I({ highlighted: h.value === De }),
                role: "option",
                "aria-selected": h.value === De,
                onClick: (Te) => te(me)
              }, [
                J(se.$slots, "default", { item: me }, () => [
                  Ze(_e(me[se.valueKey]), 1)
                ])
              ], 10, ["id", "aria-selected", "onClick"]))), 128))
            ]),
            _: 3
          }, 8, ["id", "wrap-class", "view-class"])
        ], 6)
      ]),
      default: H(() => [
        B("div", {
          ref_key: "listboxRef",
          ref: f,
          class: I([i(s).b(), se.$attrs.class]),
          style: ze(i(C)),
          role: "combobox",
          "aria-haspopup": "listbox",
          "aria-expanded": i(E),
          "aria-owns": i(_)
        }, [
          W(i(eo), vt({
            ref_key: "inputRef",
            ref: u
          }, i(r), {
            clearable: se.clearable,
            disabled: i(l),
            name: se.name,
            "model-value": se.modelValue,
            "aria-label": se.ariaLabel,
            onInput: z,
            onChange: D,
            onFocus: M,
            onBlur: F,
            onClear: A,
            onKeydown: [
              Bt(Xe((me) => ce(h.value - 1), ["prevent"]), ["up"]),
              Bt(Xe((me) => ce(h.value + 1), ["prevent"]), ["down"]),
              Bt(V, ["enter"]),
              Bt(G, ["tab"]),
              Bt(Z, ["esc"])
            ],
            onMousedown: Y
          }), ro({
            _: 2
          }, [
            se.$slots.prepend ? {
              name: "prepend",
              fn: H(() => [
                J(se.$slots, "prepend")
              ])
            } : void 0,
            se.$slots.append ? {
              name: "append",
              fn: H(() => [
                J(se.$slots, "append")
              ])
            } : void 0,
            se.$slots.prefix ? {
              name: "prefix",
              fn: H(() => [
                J(se.$slots, "prefix")
              ])
            } : void 0,
            se.$slots.suffix ? {
              name: "suffix",
              fn: H(() => [
                J(se.$slots, "suffix")
              ])
            } : void 0
          ]), 1040, ["clearable", "disabled", "name", "model-value", "aria-label", "onKeydown"])
        ], 14, ["aria-expanded", "aria-owns"])
      ]),
      _: 3
    }, 8, ["visible", "placement", "popper-class", "teleported", "append-to", "transition"]));
  }
});
var P6 = /* @__PURE__ */ $e(M6, [["__file", "autocomplete.vue"]]);
const R6 = ut(P6), A6 = Oe({
  size: {
    type: [Number, String],
    values: Qr,
    default: "",
    validator: (e10) => Ye(e10)
  },
  shape: {
    type: String,
    values: ["circle", "square"],
    default: "circle"
  },
  icon: {
    type: Ht
  },
  src: {
    type: String,
    default: ""
  },
  alt: String,
  srcSet: String,
  fit: {
    type: ne(String),
    default: "cover"
  }
}), L6 = {
  error: (e10) => e10 instanceof Event
}, x6 = /* @__PURE__ */ j({
  name: "ElAvatar"
}), D6 = /* @__PURE__ */ j({
  ...x6,
  props: A6,
  emits: L6,
  setup(e10, { emit: t }) {
    const n = e10, o = we("avatar"), r = L(false), a = S(() => {
      const { size: c, icon: d, shape: f } = n, p = [o.b()];
      return Ve(c) && p.push(o.m(c)), d && p.push(o.m("icon")), f && p.push(o.m(f)), p;
    }), l = S(() => {
      const { size: c } = n;
      return Ye(c) ? o.cssVarBlock({
        size: sn(c) || ""
      }) : void 0;
    }), s = S(() => ({
      objectFit: n.fit
    }));
    ge(() => n.src, () => r.value = false);
    function u(c) {
      r.value = true, t("error", c);
    }
    return (c, d) => (k(), x("span", {
      class: I(i(a)),
      style: ze(i(l))
    }, [
      (c.src || c.srcSet) && !r.value ? (k(), x("img", {
        key: 0,
        src: c.src,
        alt: c.alt,
        srcset: c.srcSet,
        style: ze(i(s)),
        onError: u
      }, null, 44, ["src", "alt", "srcset"])) : c.icon ? (k(), ae(i(Be), { key: 1 }, {
        default: H(() => [
          (k(), ae(ht(c.icon)))
        ]),
        _: 1
      })) : J(c.$slots, "default", { key: 2 })
    ], 6));
  }
});
var V6 = /* @__PURE__ */ $e(D6, [["__file", "avatar.vue"]]);
const F6 = ut(V6), B6 = {
  visibilityHeight: {
    type: Number,
    default: 200
  },
  target: {
    type: String,
    default: ""
  },
  right: {
    type: Number,
    default: 40
  },
  bottom: {
    type: Number,
    default: 40
  }
}, H6 = {
  click: (e10) => e10 instanceof MouseEvent
}, z6 = (e10, t, n) => {
  const o = qt(), r = qt(), a = L(false), l = () => {
    o.value && (a.value = o.value.scrollTop >= e10.visibilityHeight);
  }, s = (c) => {
    var d;
    (d = o.value) == null || d.scrollTo({ top: 0, behavior: "smooth" }), t("click", c);
  }, u = dS(l, 300, true);
  return Ft(r, "scroll", u), dt(() => {
    var c;
    r.value = document, o.value = document.documentElement, e10.target && (o.value = (c = document.querySelector(e10.target)) != null ? c : void 0, o.value || Qt(n, `target does not exist: ${e10.target}`), r.value = o.value), l();
  }), {
    visible: a,
    handleClick: s
  };
}, p2 = "ElBacktop", K6 = /* @__PURE__ */ j({
  name: p2
}), W6 = /* @__PURE__ */ j({
  ...K6,
  props: B6,
  emits: H6,
  setup(e10, { emit: t }) {
    const n = e10, o = we("backtop"), { handleClick: r, visible: a } = z6(n, t, p2), l = S(() => ({
      right: `${n.right}px`,
      bottom: `${n.bottom}px`
    }));
    return (s, u) => (k(), ae(Rn, {
      name: `${i(o).namespace.value}-fade-in`
    }, {
      default: H(() => [
        i(a) ? (k(), x("div", {
          key: 0,
          style: ze(i(l)),
          class: I(i(o).b()),
          onClick: Xe(i(r), ["stop"])
        }, [
          J(s.$slots, "default", {}, () => [
            W(i(Be), {
              class: I(i(o).e("icon"))
            }, {
              default: H(() => [
                W(i(Hx))
              ]),
              _: 1
            }, 8, ["class"])
          ])
        ], 14, ["onClick"])) : ee("v-if", true)
      ]),
      _: 3
    }, 8, ["name"]));
  }
});
var j6 = /* @__PURE__ */ $e(W6, [["__file", "backtop.vue"]]);
const U6 = ut(j6), Y6 = Oe({
  value: {
    type: [String, Number],
    default: ""
  },
  max: {
    type: Number,
    default: 99
  },
  isDot: Boolean,
  hidden: Boolean,
  type: {
    type: String,
    values: ["primary", "success", "warning", "info", "danger"],
    default: "danger"
  },
  showZero: {
    type: Boolean,
    default: true
  },
  color: String,
  badgeStyle: {
    type: ne([String, Object, Array])
  },
  offset: {
    type: ne(Array),
    default: [0, 0]
  },
  badgeClass: {
    type: String
  }
}), q6 = /* @__PURE__ */ j({
  name: "ElBadge"
}), G6 = /* @__PURE__ */ j({
  ...q6,
  props: Y6,
  setup(e10, { expose: t }) {
    const n = e10, o = we("badge"), r = S(() => n.isDot ? "" : Ye(n.value) && Ye(n.max) ? n.max < n.value ? `${n.max}+` : `${n.value}` : `${n.value}`), a = S(() => {
      var l, s, u, c, d;
      return [
        {
          backgroundColor: n.color,
          marginRight: sn(-((s = (l = n.offset) == null ? void 0 : l[0]) != null ? s : 0)),
          marginTop: sn((c = (u = n.offset) == null ? void 0 : u[1]) != null ? c : 0)
        },
        (d = n.badgeStyle) != null ? d : {}
      ];
    });
    return t({
      content: r
    }), (l, s) => (k(), x("div", {
      class: I(i(o).b())
    }, [
      J(l.$slots, "default"),
      W(Rn, {
        name: `${i(o).namespace.value}-zoom-in-center`,
        persisted: ""
      }, {
        default: H(() => [
          lt(B("sup", {
            class: I([
              i(o).e("content"),
              i(o).em("content", l.type),
              i(o).is("fixed", !!l.$slots.default),
              i(o).is("dot", l.isDot),
              i(o).is("hide-zero", !l.showZero && n.value === 0),
              l.badgeClass
            ]),
            style: ze(i(a))
          }, [
            J(l.$slots, "content", { value: i(r) }, () => [
              Ze(_e(i(r)), 1)
            ])
          ], 6), [
            [Nt, !l.hidden && (i(r) || l.isDot || l.$slots.content)]
          ])
        ]),
        _: 3
      }, 8, ["name"])
    ], 2));
  }
});
var X6 = /* @__PURE__ */ $e(G6, [["__file", "badge.vue"]]);
const v2 = ut(X6), h2 = Symbol("breadcrumbKey"), J6 = Oe({
  separator: {
    type: String,
    default: "/"
  },
  separatorIcon: {
    type: Ht
  }
}), Z6 = /* @__PURE__ */ j({
  name: "ElBreadcrumb"
}), Q6 = /* @__PURE__ */ j({
  ...Z6,
  props: J6,
  setup(e10) {
    const t = e10, { t: n } = kt(), o = we("breadcrumb"), r = L();
    return yt(h2, t), dt(() => {
      const a = r.value.querySelectorAll(`.${o.e("item")}`);
      a.length && a[a.length - 1].setAttribute("aria-current", "page");
    }), (a, l) => (k(), x("div", {
      ref_key: "breadcrumb",
      ref: r,
      class: I(i(o).b()),
      "aria-label": i(n)("el.breadcrumb.label"),
      role: "navigation"
    }, [
      J(a.$slots, "default")
    ], 10, ["aria-label"]));
  }
});
var eF = /* @__PURE__ */ $e(Q6, [["__file", "breadcrumb.vue"]]);
const tF = Oe({
  to: {
    type: ne([String, Object]),
    default: ""
  },
  replace: Boolean
}), nF = /* @__PURE__ */ j({
  name: "ElBreadcrumbItem"
}), oF = /* @__PURE__ */ j({
  ...nF,
  props: tF,
  setup(e10) {
    const t = e10, n = it(), o = Le(h2, void 0), r = we("breadcrumb"), a = n.appContext.config.globalProperties.$router, l = L(), s = () => {
      !t.to || !a || (t.replace ? a.replace(t.to) : a.push(t.to));
    };
    return (u, c) => {
      var d, f;
      return k(), x("span", {
        class: I(i(r).e("item"))
      }, [
        B("span", {
          ref_key: "link",
          ref: l,
          class: I([i(r).e("inner"), i(r).is("link", !!u.to)]),
          role: "link",
          onClick: s
        }, [
          J(u.$slots, "default")
        ], 2),
        (d = i(o)) != null && d.separatorIcon ? (k(), ae(i(Be), {
          key: 0,
          class: I(i(r).e("separator"))
        }, {
          default: H(() => [
            (k(), ae(ht(i(o).separatorIcon)))
          ]),
          _: 1
        }, 8, ["class"])) : (k(), x("span", {
          key: 1,
          class: I(i(r).e("separator")),
          role: "presentation"
        }, _e((f = i(o)) == null ? void 0 : f.separator), 3))
      ], 2);
    };
  }
});
var m2 = /* @__PURE__ */ $e(oF, [["__file", "breadcrumb-item.vue"]]);
const rF = ut(eF, {
  BreadcrumbItem: m2
}), aF = nn(m2), g2 = Symbol("buttonGroupContextKey"), _a = ({ from: e10, replacement: t, scope: n, version: o, ref: r, type: a = "API" }, l) => {
  ge(() => i(l), (s) => {
    s && _t(n, `[${a}] ${e10} is about to be deprecated in version ${o}, please use ${t} instead.
For more detail, please visit: ${r}
`);
  }, {
    immediate: true
  });
}, lF = (e10, t) => {
  _a({
    from: "type.text",
    replacement: "link",
    version: "3.0.0",
    scope: "props",
    ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
  }, S(() => e10.type === "text"));
  const n = Le(g2, void 0), o = lc("button"), { form: r } = Yn(), a = yn(S(() => n == null ? void 0 : n.size)), l = Hn(), s = L(), u = En(), c = S(() => {
    var b;
    return e10.type || (n == null ? void 0 : n.type) || ((b = o.value) == null ? void 0 : b.type) || "";
  }), d = S(() => {
    var b, g, w;
    return (w = (g = e10.autoInsertSpace) != null ? g : (b = o.value) == null ? void 0 : b.autoInsertSpace) != null ? w : false;
  }), f = S(() => {
    var b, g, w;
    return (w = (g = e10.plain) != null ? g : (b = o.value) == null ? void 0 : b.plain) != null ? w : false;
  }), p = S(() => {
    var b, g, w;
    return (w = (g = e10.round) != null ? g : (b = o.value) == null ? void 0 : b.round) != null ? w : false;
  }), v = S(() => e10.tag === "button" ? {
    ariaDisabled: l.value || e10.loading,
    disabled: l.value || e10.loading,
    autofocus: e10.autofocus,
    type: e10.nativeType
  } : {}), m = S(() => {
    var b;
    const g = (b = u.default) == null ? void 0 : b.call(u);
    if (d.value && (g == null ? void 0 : g.length) === 1) {
      const w = g[0];
      if ((w == null ? void 0 : w.type) === Zr) {
        const y = w.children;
        return new RegExp("^\\p{Unified_Ideograph}{2}$", "u").test(y.trim());
      }
    }
    return false;
  });
  return {
    _disabled: l,
    _size: a,
    _type: c,
    _ref: s,
    _props: v,
    _plain: f,
    _round: p,
    shouldAddSpace: m,
    handleClick: (b) => {
      if (l.value || e10.loading) {
        b.stopPropagation();
        return;
      }
      e10.nativeType === "reset" && (r == null || r.resetFields()), t("click", b);
    }
  };
}, Zv = [
  "default",
  "primary",
  "success",
  "warning",
  "info",
  "danger",
  "text",
  ""
], sF = ["button", "submit", "reset"], Qv = Oe({
  size: _n,
  disabled: Boolean,
  type: {
    type: String,
    values: Zv,
    default: ""
  },
  icon: {
    type: Ht
  },
  nativeType: {
    type: String,
    values: sF,
    default: "button"
  },
  loading: Boolean,
  loadingIcon: {
    type: Ht,
    default: () => Yr
  },
  plain: {
    type: Boolean,
    default: void 0
  },
  text: Boolean,
  link: Boolean,
  bg: Boolean,
  autofocus: Boolean,
  round: {
    type: Boolean,
    default: void 0
  },
  circle: Boolean,
  color: String,
  dark: Boolean,
  autoInsertSpace: {
    type: Boolean,
    default: void 0
  },
  tag: {
    type: ne([String, Object]),
    default: "button"
  }
}), iF = {
  click: (e10) => e10 instanceof MouseEvent
};
function Wn(e10, t) {
  uF(e10) && (e10 = "100%");
  var n = cF(e10);
  return e10 = t === 360 ? e10 : Math.min(t, Math.max(0, parseFloat(e10))), n && (e10 = parseInt(String(e10 * t), 10) / 100), Math.abs(e10 - t) < 1e-6 ? 1 : (t === 360 ? e10 = (e10 < 0 ? e10 % t + t : e10 % t) / parseFloat(String(t)) : e10 = e10 % t / parseFloat(String(t)), e10);
}
function Vc(e10) {
  return Math.min(1, Math.max(0, e10));
}
function uF(e10) {
  return typeof e10 == "string" && e10.indexOf(".") !== -1 && parseFloat(e10) === 1;
}
function cF(e10) {
  return typeof e10 == "string" && e10.indexOf("%") !== -1;
}
function y2(e10) {
  return e10 = parseFloat(e10), (isNaN(e10) || e10 < 0 || e10 > 1) && (e10 = 1), e10;
}
function Fc(e10) {
  return e10 <= 1 ? "".concat(Number(e10) * 100, "%") : e10;
}
function $l(e10) {
  return e10.length === 1 ? "0" + e10 : String(e10);
}
function dF(e10, t, n) {
  return {
    r: Wn(e10, 255) * 255,
    g: Wn(t, 255) * 255,
    b: Wn(n, 255) * 255
  };
}
function o1(e10, t, n) {
  e10 = Wn(e10, 255), t = Wn(t, 255), n = Wn(n, 255);
  var o = Math.max(e10, t, n), r = Math.min(e10, t, n), a = 0, l = 0, s = (o + r) / 2;
  if (o === r)
    l = 0, a = 0;
  else {
    var u = o - r;
    switch (l = s > 0.5 ? u / (2 - o - r) : u / (o + r), o) {
      case e10:
        a = (t - n) / u + (t < n ? 6 : 0);
        break;
      case t:
        a = (n - e10) / u + 2;
        break;
      case n:
        a = (e10 - t) / u + 4;
        break;
    }
    a /= 6;
  }
  return { h: a, s: l, l: s };
}
function Qp(e10, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e10 + (t - e10) * (6 * n) : n < 1 / 2 ? t : n < 2 / 3 ? e10 + (t - e10) * (2 / 3 - n) * 6 : e10;
}
function fF(e10, t, n) {
  var o, r, a;
  if (e10 = Wn(e10, 360), t = Wn(t, 100), n = Wn(n, 100), t === 0)
    r = n, a = n, o = n;
  else {
    var l = n < 0.5 ? n * (1 + t) : n + t - n * t, s = 2 * n - l;
    o = Qp(s, l, e10 + 1 / 3), r = Qp(s, l, e10), a = Qp(s, l, e10 - 1 / 3);
  }
  return { r: o * 255, g: r * 255, b: a * 255 };
}
function r1(e10, t, n) {
  e10 = Wn(e10, 255), t = Wn(t, 255), n = Wn(n, 255);
  var o = Math.max(e10, t, n), r = Math.min(e10, t, n), a = 0, l = o, s = o - r, u = o === 0 ? 0 : s / o;
  if (o === r)
    a = 0;
  else {
    switch (o) {
      case e10:
        a = (t - n) / s + (t < n ? 6 : 0);
        break;
      case t:
        a = (n - e10) / s + 2;
        break;
      case n:
        a = (e10 - t) / s + 4;
        break;
    }
    a /= 6;
  }
  return { h: a, s: u, v: l };
}
function pF(e10, t, n) {
  e10 = Wn(e10, 360) * 6, t = Wn(t, 100), n = Wn(n, 100);
  var o = Math.floor(e10), r = e10 - o, a = n * (1 - t), l = n * (1 - r * t), s = n * (1 - (1 - r) * t), u = o % 6, c = [n, l, a, a, s, n][u], d = [s, n, n, l, a, a][u], f = [a, a, s, n, n, l][u];
  return { r: c * 255, g: d * 255, b: f * 255 };
}
function a1(e10, t, n, o) {
  var r = [
    $l(Math.round(e10).toString(16)),
    $l(Math.round(t).toString(16)),
    $l(Math.round(n).toString(16))
  ];
  return o && r[0].startsWith(r[0].charAt(1)) && r[1].startsWith(r[1].charAt(1)) && r[2].startsWith(r[2].charAt(1)) ? r[0].charAt(0) + r[1].charAt(0) + r[2].charAt(0) : r.join("");
}
function vF(e10, t, n, o, r) {
  var a = [
    $l(Math.round(e10).toString(16)),
    $l(Math.round(t).toString(16)),
    $l(Math.round(n).toString(16)),
    $l(hF(o))
  ];
  return r && a[0].startsWith(a[0].charAt(1)) && a[1].startsWith(a[1].charAt(1)) && a[2].startsWith(a[2].charAt(1)) && a[3].startsWith(a[3].charAt(1)) ? a[0].charAt(0) + a[1].charAt(0) + a[2].charAt(0) + a[3].charAt(0) : a.join("");
}
function hF(e10) {
  return Math.round(parseFloat(e10) * 255).toString(16);
}
function l1(e10) {
  return Mo(e10) / 255;
}
function Mo(e10) {
  return parseInt(e10, 16);
}
function mF(e10) {
  return {
    r: e10 >> 16,
    g: (e10 & 65280) >> 8,
    b: e10 & 255
  };
}
var eh = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function gF(e10) {
  var t = { r: 0, g: 0, b: 0 }, n = 1, o = null, r = null, a = null, l = false, s = false;
  return typeof e10 == "string" && (e10 = _F(e10)), typeof e10 == "object" && (sa(e10.r) && sa(e10.g) && sa(e10.b) ? (t = dF(e10.r, e10.g, e10.b), l = true, s = String(e10.r).substr(-1) === "%" ? "prgb" : "rgb") : sa(e10.h) && sa(e10.s) && sa(e10.v) ? (o = Fc(e10.s), r = Fc(e10.v), t = pF(e10.h, o, r), l = true, s = "hsv") : sa(e10.h) && sa(e10.s) && sa(e10.l) && (o = Fc(e10.s), a = Fc(e10.l), t = fF(e10.h, o, a), l = true, s = "hsl"), Object.prototype.hasOwnProperty.call(e10, "a") && (n = e10.a)), n = y2(n), {
    ok: l,
    format: e10.format || s,
    r: Math.min(255, Math.max(t.r, 0)),
    g: Math.min(255, Math.max(t.g, 0)),
    b: Math.min(255, Math.max(t.b, 0)),
    a: n
  };
}
var yF = "[-\\+]?\\d+%?", bF = "[-\\+]?\\d*\\.\\d+%?", Ja = "(?:".concat(bF, ")|(?:").concat(yF, ")"), ev = "[\\s|\\(]+(".concat(Ja, ")[,|\\s]+(").concat(Ja, ")[,|\\s]+(").concat(Ja, ")\\s*\\)?"), tv = "[\\s|\\(]+(".concat(Ja, ")[,|\\s]+(").concat(Ja, ")[,|\\s]+(").concat(Ja, ")[,|\\s]+(").concat(Ja, ")\\s*\\)?"), nr = {
  CSS_UNIT: new RegExp(Ja),
  rgb: new RegExp("rgb" + ev),
  rgba: new RegExp("rgba" + tv),
  hsl: new RegExp("hsl" + ev),
  hsla: new RegExp("hsla" + tv),
  hsv: new RegExp("hsv" + ev),
  hsva: new RegExp("hsva" + tv),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function _F(e10) {
  if (e10 = e10.trim().toLowerCase(), e10.length === 0)
    return false;
  var t = false;
  if (eh[e10])
    e10 = eh[e10], t = true;
  else if (e10 === "transparent")
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  var n = nr.rgb.exec(e10);
  return n ? { r: n[1], g: n[2], b: n[3] } : (n = nr.rgba.exec(e10), n ? { r: n[1], g: n[2], b: n[3], a: n[4] } : (n = nr.hsl.exec(e10), n ? { h: n[1], s: n[2], l: n[3] } : (n = nr.hsla.exec(e10), n ? { h: n[1], s: n[2], l: n[3], a: n[4] } : (n = nr.hsv.exec(e10), n ? { h: n[1], s: n[2], v: n[3] } : (n = nr.hsva.exec(e10), n ? { h: n[1], s: n[2], v: n[3], a: n[4] } : (n = nr.hex8.exec(e10), n ? {
    r: Mo(n[1]),
    g: Mo(n[2]),
    b: Mo(n[3]),
    a: l1(n[4]),
    format: t ? "name" : "hex8"
  } : (n = nr.hex6.exec(e10), n ? {
    r: Mo(n[1]),
    g: Mo(n[2]),
    b: Mo(n[3]),
    format: t ? "name" : "hex"
  } : (n = nr.hex4.exec(e10), n ? {
    r: Mo(n[1] + n[1]),
    g: Mo(n[2] + n[2]),
    b: Mo(n[3] + n[3]),
    a: l1(n[4] + n[4]),
    format: t ? "name" : "hex8"
  } : (n = nr.hex3.exec(e10), n ? {
    r: Mo(n[1] + n[1]),
    g: Mo(n[2] + n[2]),
    b: Mo(n[3] + n[3]),
    format: t ? "name" : "hex"
  } : false)))))))));
}
function sa(e10) {
  return !!nr.CSS_UNIT.exec(String(e10));
}
var Is = (
  /** @class */
  function() {
    function e10(t, n) {
      t === void 0 && (t = ""), n === void 0 && (n = {});
      var o;
      if (t instanceof e10)
        return t;
      typeof t == "number" && (t = mF(t)), this.originalInput = t;
      var r = gF(t);
      this.originalInput = t, this.r = r.r, this.g = r.g, this.b = r.b, this.a = r.a, this.roundA = Math.round(100 * this.a) / 100, this.format = (o = n.format) !== null && o !== void 0 ? o : r.format, this.gradientType = n.gradientType, this.r < 1 && (this.r = Math.round(this.r)), this.g < 1 && (this.g = Math.round(this.g)), this.b < 1 && (this.b = Math.round(this.b)), this.isValid = r.ok;
    }
    return e10.prototype.isDark = function() {
      return this.getBrightness() < 128;
    }, e10.prototype.isLight = function() {
      return !this.isDark();
    }, e10.prototype.getBrightness = function() {
      var t = this.toRgb();
      return (t.r * 299 + t.g * 587 + t.b * 114) / 1e3;
    }, e10.prototype.getLuminance = function() {
      var t = this.toRgb(), n, o, r, a = t.r / 255, l = t.g / 255, s = t.b / 255;
      return a <= 0.03928 ? n = a / 12.92 : n = Math.pow((a + 0.055) / 1.055, 2.4), l <= 0.03928 ? o = l / 12.92 : o = Math.pow((l + 0.055) / 1.055, 2.4), s <= 0.03928 ? r = s / 12.92 : r = Math.pow((s + 0.055) / 1.055, 2.4), 0.2126 * n + 0.7152 * o + 0.0722 * r;
    }, e10.prototype.getAlpha = function() {
      return this.a;
    }, e10.prototype.setAlpha = function(t) {
      return this.a = y2(t), this.roundA = Math.round(100 * this.a) / 100, this;
    }, e10.prototype.isMonochrome = function() {
      var t = this.toHsl().s;
      return t === 0;
    }, e10.prototype.toHsv = function() {
      var t = r1(this.r, this.g, this.b);
      return { h: t.h * 360, s: t.s, v: t.v, a: this.a };
    }, e10.prototype.toHsvString = function() {
      var t = r1(this.r, this.g, this.b), n = Math.round(t.h * 360), o = Math.round(t.s * 100), r = Math.round(t.v * 100);
      return this.a === 1 ? "hsv(".concat(n, ", ").concat(o, "%, ").concat(r, "%)") : "hsva(".concat(n, ", ").concat(o, "%, ").concat(r, "%, ").concat(this.roundA, ")");
    }, e10.prototype.toHsl = function() {
      var t = o1(this.r, this.g, this.b);
      return { h: t.h * 360, s: t.s, l: t.l, a: this.a };
    }, e10.prototype.toHslString = function() {
      var t = o1(this.r, this.g, this.b), n = Math.round(t.h * 360), o = Math.round(t.s * 100), r = Math.round(t.l * 100);
      return this.a === 1 ? "hsl(".concat(n, ", ").concat(o, "%, ").concat(r, "%)") : "hsla(".concat(n, ", ").concat(o, "%, ").concat(r, "%, ").concat(this.roundA, ")");
    }, e10.prototype.toHex = function(t) {
      return t === void 0 && (t = false), a1(this.r, this.g, this.b, t);
    }, e10.prototype.toHexString = function(t) {
      return t === void 0 && (t = false), "#" + this.toHex(t);
    }, e10.prototype.toHex8 = function(t) {
      return t === void 0 && (t = false), vF(this.r, this.g, this.b, this.a, t);
    }, e10.prototype.toHex8String = function(t) {
      return t === void 0 && (t = false), "#" + this.toHex8(t);
    }, e10.prototype.toHexShortString = function(t) {
      return t === void 0 && (t = false), this.a === 1 ? this.toHexString(t) : this.toHex8String(t);
    }, e10.prototype.toRgb = function() {
      return {
        r: Math.round(this.r),
        g: Math.round(this.g),
        b: Math.round(this.b),
        a: this.a
      };
    }, e10.prototype.toRgbString = function() {
      var t = Math.round(this.r), n = Math.round(this.g), o = Math.round(this.b);
      return this.a === 1 ? "rgb(".concat(t, ", ").concat(n, ", ").concat(o, ")") : "rgba(".concat(t, ", ").concat(n, ", ").concat(o, ", ").concat(this.roundA, ")");
    }, e10.prototype.toPercentageRgb = function() {
      var t = function(n) {
        return "".concat(Math.round(Wn(n, 255) * 100), "%");
      };
      return {
        r: t(this.r),
        g: t(this.g),
        b: t(this.b),
        a: this.a
      };
    }, e10.prototype.toPercentageRgbString = function() {
      var t = function(n) {
        return Math.round(Wn(n, 255) * 100);
      };
      return this.a === 1 ? "rgb(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%)") : "rgba(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%, ").concat(this.roundA, ")");
    }, e10.prototype.toName = function() {
      if (this.a === 0)
        return "transparent";
      if (this.a < 1)
        return false;
      for (var t = "#" + a1(this.r, this.g, this.b, false), n = 0, o = Object.entries(eh); n < o.length; n++) {
        var r = o[n], a = r[0], l = r[1];
        if (t === l)
          return a;
      }
      return false;
    }, e10.prototype.toString = function(t) {
      var n = !!t;
      t = t != null ? t : this.format;
      var o = false, r = this.a < 1 && this.a >= 0, a = !n && r && (t.startsWith("hex") || t === "name");
      return a ? t === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (t === "rgb" && (o = this.toRgbString()), t === "prgb" && (o = this.toPercentageRgbString()), (t === "hex" || t === "hex6") && (o = this.toHexString()), t === "hex3" && (o = this.toHexString(true)), t === "hex4" && (o = this.toHex8String(true)), t === "hex8" && (o = this.toHex8String()), t === "name" && (o = this.toName()), t === "hsl" && (o = this.toHslString()), t === "hsv" && (o = this.toHsvString()), o || this.toHexString());
    }, e10.prototype.toNumber = function() {
      return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
    }, e10.prototype.clone = function() {
      return new e10(this.toString());
    }, e10.prototype.lighten = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.l += t / 100, n.l = Vc(n.l), new e10(n);
    }, e10.prototype.brighten = function(t) {
      t === void 0 && (t = 10);
      var n = this.toRgb();
      return n.r = Math.max(0, Math.min(255, n.r - Math.round(255 * -(t / 100)))), n.g = Math.max(0, Math.min(255, n.g - Math.round(255 * -(t / 100)))), n.b = Math.max(0, Math.min(255, n.b - Math.round(255 * -(t / 100)))), new e10(n);
    }, e10.prototype.darken = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.l -= t / 100, n.l = Vc(n.l), new e10(n);
    }, e10.prototype.tint = function(t) {
      return t === void 0 && (t = 10), this.mix("white", t);
    }, e10.prototype.shade = function(t) {
      return t === void 0 && (t = 10), this.mix("black", t);
    }, e10.prototype.desaturate = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.s -= t / 100, n.s = Vc(n.s), new e10(n);
    }, e10.prototype.saturate = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.s += t / 100, n.s = Vc(n.s), new e10(n);
    }, e10.prototype.greyscale = function() {
      return this.desaturate(100);
    }, e10.prototype.spin = function(t) {
      var n = this.toHsl(), o = (n.h + t) % 360;
      return n.h = o < 0 ? 360 + o : o, new e10(n);
    }, e10.prototype.mix = function(t, n) {
      n === void 0 && (n = 50);
      var o = this.toRgb(), r = new e10(t).toRgb(), a = n / 100, l = {
        r: (r.r - o.r) * a + o.r,
        g: (r.g - o.g) * a + o.g,
        b: (r.b - o.b) * a + o.b,
        a: (r.a - o.a) * a + o.a
      };
      return new e10(l);
    }, e10.prototype.analogous = function(t, n) {
      t === void 0 && (t = 6), n === void 0 && (n = 30);
      var o = this.toHsl(), r = 360 / n, a = [this];
      for (o.h = (o.h - (r * t >> 1) + 720) % 360; --t; )
        o.h = (o.h + r) % 360, a.push(new e10(o));
      return a;
    }, e10.prototype.complement = function() {
      var t = this.toHsl();
      return t.h = (t.h + 180) % 360, new e10(t);
    }, e10.prototype.monochromatic = function(t) {
      t === void 0 && (t = 6);
      for (var n = this.toHsv(), o = n.h, r = n.s, a = n.v, l = [], s = 1 / t; t--; )
        l.push(new e10({ h: o, s: r, v: a })), a = (a + s) % 1;
      return l;
    }, e10.prototype.splitcomplement = function() {
      var t = this.toHsl(), n = t.h;
      return [
        this,
        new e10({ h: (n + 72) % 360, s: t.s, l: t.l }),
        new e10({ h: (n + 216) % 360, s: t.s, l: t.l })
      ];
    }, e10.prototype.onBackground = function(t) {
      var n = this.toRgb(), o = new e10(t).toRgb(), r = n.a + o.a * (1 - n.a);
      return new e10({
        r: (n.r * n.a + o.r * o.a * (1 - n.a)) / r,
        g: (n.g * n.a + o.g * o.a * (1 - n.a)) / r,
        b: (n.b * n.a + o.b * o.a * (1 - n.a)) / r,
        a: r
      });
    }, e10.prototype.triad = function() {
      return this.polyad(3);
    }, e10.prototype.tetrad = function() {
      return this.polyad(4);
    }, e10.prototype.polyad = function(t) {
      for (var n = this.toHsl(), o = n.h, r = [this], a = 360 / t, l = 1; l < t; l++)
        r.push(new e10({ h: (o + l * a) % 360, s: n.s, l: n.l }));
      return r;
    }, e10.prototype.equals = function(t) {
      return this.toRgbString() === new e10(t).toRgbString();
    }, e10;
  }()
);
function Ha(e10, t = 20) {
  return e10.mix("#141414", t).toString();
}
function wF(e10) {
  const t = Hn(), n = we("button");
  return S(() => {
    let o = {}, r = e10.color;
    if (r) {
      const a = r.match(/var\((.*?)\)/);
      a && (r = window.getComputedStyle(window.document.documentElement).getPropertyValue(a[1]));
      const l = new Is(r), s = e10.dark ? l.tint(20).toString() : Ha(l, 20);
      if (e10.plain)
        o = n.cssVarBlock({
          "bg-color": e10.dark ? Ha(l, 90) : l.tint(90).toString(),
          "text-color": r,
          "border-color": e10.dark ? Ha(l, 50) : l.tint(50).toString(),
          "hover-text-color": `var(${n.cssVarName("color-white")})`,
          "hover-bg-color": r,
          "hover-border-color": r,
          "active-bg-color": s,
          "active-text-color": `var(${n.cssVarName("color-white")})`,
          "active-border-color": s
        }), t.value && (o[n.cssVarBlockName("disabled-bg-color")] = e10.dark ? Ha(l, 90) : l.tint(90).toString(), o[n.cssVarBlockName("disabled-text-color")] = e10.dark ? Ha(l, 50) : l.tint(50).toString(), o[n.cssVarBlockName("disabled-border-color")] = e10.dark ? Ha(l, 80) : l.tint(80).toString());
      else {
        const u = e10.dark ? Ha(l, 30) : l.tint(30).toString(), c = l.isDark() ? `var(${n.cssVarName("color-white")})` : `var(${n.cssVarName("color-black")})`;
        if (o = n.cssVarBlock({
          "bg-color": r,
          "text-color": c,
          "border-color": r,
          "hover-bg-color": u,
          "hover-text-color": c,
          "hover-border-color": u,
          "active-bg-color": s,
          "active-border-color": s
        }), t.value) {
          const d = e10.dark ? Ha(l, 50) : l.tint(50).toString();
          o[n.cssVarBlockName("disabled-bg-color")] = d, o[n.cssVarBlockName("disabled-text-color")] = e10.dark ? "rgba(255, 255, 255, 0.5)" : `var(${n.cssVarName("color-white")})`, o[n.cssVarBlockName("disabled-border-color")] = d;
        }
      }
    }
    return o;
  });
}
const CF = /* @__PURE__ */ j({
  name: "ElButton"
}), EF = /* @__PURE__ */ j({
  ...CF,
  props: Qv,
  emits: iF,
  setup(e10, { expose: t, emit: n }) {
    const o = e10, r = wF(o), a = we("button"), {
      _ref: l,
      _size: s,
      _type: u,
      _disabled: c,
      _props: d,
      _plain: f,
      _round: p,
      shouldAddSpace: v,
      handleClick: m
    } = lF(o, n), h = S(() => [
      a.b(),
      a.m(u.value),
      a.m(s.value),
      a.is("disabled", c.value),
      a.is("loading", o.loading),
      a.is("plain", f.value),
      a.is("round", p.value),
      a.is("circle", o.circle),
      a.is("text", o.text),
      a.is("link", o.link),
      a.is("has-bg", o.bg)
    ]);
    return t({
      ref: l,
      size: s,
      type: u,
      disabled: c,
      shouldAddSpace: v
    }), (b, g) => (k(), ae(ht(b.tag), vt({
      ref_key: "_ref",
      ref: l
    }, i(d), {
      class: i(h),
      style: i(r),
      onClick: i(m)
    }), {
      default: H(() => [
        b.loading ? (k(), x(Ie, { key: 0 }, [
          b.$slots.loading ? J(b.$slots, "loading", { key: 0 }) : (k(), ae(i(Be), {
            key: 1,
            class: I(i(a).is("loading"))
          }, {
            default: H(() => [
              (k(), ae(ht(b.loadingIcon)))
            ]),
            _: 1
          }, 8, ["class"]))
        ], 64)) : b.icon || b.$slots.icon ? (k(), ae(i(Be), { key: 1 }, {
          default: H(() => [
            b.icon ? (k(), ae(ht(b.icon), { key: 0 })) : J(b.$slots, "icon", { key: 1 })
          ]),
          _: 3
        })) : ee("v-if", true),
        b.$slots.default ? (k(), x("span", {
          key: 2,
          class: I({ [i(a).em("text", "expand")]: i(v) })
        }, [
          J(b.$slots, "default")
        ], 2)) : ee("v-if", true)
      ]),
      _: 3
    }, 16, ["class", "style", "onClick"]));
  }
});
var SF = /* @__PURE__ */ $e(EF, [["__file", "button.vue"]]);
const kF = {
  size: Qv.size,
  type: Qv.type
}, NF = /* @__PURE__ */ j({
  name: "ElButtonGroup"
}), TF = /* @__PURE__ */ j({
  ...NF,
  props: kF,
  setup(e10) {
    const t = e10;
    yt(g2, It({
      size: Lt(t, "size"),
      type: Lt(t, "type")
    }));
    const n = we("button");
    return (o, r) => (k(), x("div", {
      class: I(i(n).b("group"))
    }, [
      J(o.$slots, "default")
    ], 2));
  }
});
var b2 = /* @__PURE__ */ $e(TF, [["__file", "button-group.vue"]]);
const Mn = ut(SF, {
  ButtonGroup: b2
}), _2 = nn(b2);
function Ra(e10) {
  return e10 && e10.__esModule && Object.prototype.hasOwnProperty.call(e10, "default") ? e10.default : e10;
}
var id = { exports: {} }, OF = id.exports, s1;
function $F() {
  return s1 || (s1 = 1, function(e10, t) {
    (function(n, o) {
      e10.exports = o();
    })(OF, function() {
      var n = 1e3, o = 6e4, r = 36e5, a = "millisecond", l = "second", s = "minute", u = "hour", c = "day", d = "week", f = "month", p = "quarter", v = "year", m = "date", h = "Invalid Date", b = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, g = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, w = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(Y) {
        var D = ["th", "st", "nd", "rd"], M = Y % 100;
        return "[" + Y + (D[(M - 20) % 10] || D[M] || D[0]) + "]";
      } }, y = function(Y, D, M) {
        var F = String(Y);
        return !F || F.length >= D ? Y : "" + Array(D + 1 - F.length).join(M) + Y;
      }, _ = { s: y, z: function(Y) {
        var D = -Y.utcOffset(), M = Math.abs(D), F = Math.floor(M / 60), A = M % 60;
        return (D <= 0 ? "+" : "-") + y(F, 2, "0") + ":" + y(A, 2, "0");
      }, m: function Y(D, M) {
        if (D.date() < M.date()) return -Y(M, D);
        var F = 12 * (M.year() - D.year()) + (M.month() - D.month()), A = D.clone().add(F, f), V = M - A < 0, Z = D.clone().add(F + (V ? -1 : 1), f);
        return +(-(F + (M - A) / (V ? A - Z : Z - A)) || 0);
      }, a: function(Y) {
        return Y < 0 ? Math.ceil(Y) || 0 : Math.floor(Y);
      }, p: function(Y) {
        return { M: f, y: v, w: d, d: c, D: m, h: u, m: s, s: l, ms: a, Q: p }[Y] || String(Y || "").toLowerCase().replace(/s$/, "");
      }, u: function(Y) {
        return Y === void 0;
      } }, C = "en", E = {};
      E[C] = w;
      var T = "$isDayjsObject", O = function(Y) {
        return Y instanceof P || !(!Y || !Y[T]);
      }, N = function Y(D, M, F) {
        var A;
        if (!D) return C;
        if (typeof D == "string") {
          var V = D.toLowerCase();
          E[V] && (A = V), M && (E[V] = M, A = V);
          var Z = D.split("-");
          if (!A && Z.length > 1) return Y(Z[0]);
        } else {
          var G = D.name;
          E[G] = D, A = G;
        }
        return !F && A && (C = A), A || !F && C;
      }, $ = function(Y, D) {
        if (O(Y)) return Y.clone();
        var M = typeof D == "object" ? D : {};
        return M.date = Y, M.args = arguments, new P(M);
      }, R = _;
      R.l = N, R.i = O, R.w = function(Y, D) {
        return $(Y, { locale: D.$L, utc: D.$u, x: D.$x, $offset: D.$offset });
      };
      var P = function() {
        function Y(M) {
          this.$L = N(M.locale, null, true), this.parse(M), this.$x = this.$x || M.x || {}, this[T] = true;
        }
        var D = Y.prototype;
        return D.parse = function(M) {
          this.$d = function(F) {
            var A = F.date, V = F.utc;
            if (A === null) return /* @__PURE__ */ new Date(NaN);
            if (R.u(A)) return /* @__PURE__ */ new Date();
            if (A instanceof Date) return new Date(A);
            if (typeof A == "string" && !/Z$/i.test(A)) {
              var Z = A.match(b);
              if (Z) {
                var G = Z[2] - 1 || 0, le = (Z[7] || "0").substring(0, 3);
                return V ? new Date(Date.UTC(Z[1], G, Z[3] || 1, Z[4] || 0, Z[5] || 0, Z[6] || 0, le)) : new Date(Z[1], G, Z[3] || 1, Z[4] || 0, Z[5] || 0, Z[6] || 0, le);
              }
            }
            return new Date(A);
          }(M), this.init();
        }, D.init = function() {
          var M = this.$d;
          this.$y = M.getFullYear(), this.$M = M.getMonth(), this.$D = M.getDate(), this.$W = M.getDay(), this.$H = M.getHours(), this.$m = M.getMinutes(), this.$s = M.getSeconds(), this.$ms = M.getMilliseconds();
        }, D.$utils = function() {
          return R;
        }, D.isValid = function() {
          return this.$d.toString() !== h;
        }, D.isSame = function(M, F) {
          var A = $(M);
          return this.startOf(F) <= A && A <= this.endOf(F);
        }, D.isAfter = function(M, F) {
          return $(M) < this.startOf(F);
        }, D.isBefore = function(M, F) {
          return this.endOf(F) < $(M);
        }, D.$g = function(M, F, A) {
          return R.u(M) ? this[F] : this.set(A, M);
        }, D.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, D.valueOf = function() {
          return this.$d.getTime();
        }, D.startOf = function(M, F) {
          var A = this, V = !!R.u(F) || F, Z = R.p(M), G = function(me, De) {
            var Te = R.w(A.$u ? Date.UTC(A.$y, De, me) : new Date(A.$y, De, me), A);
            return V ? Te : Te.endOf(c);
          }, le = function(me, De) {
            return R.w(A.toDate()[me].apply(A.toDate("s"), (V ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(De)), A);
          }, X = this.$W, te = this.$M, ce = this.$D, pe = "set" + (this.$u ? "UTC" : "");
          switch (Z) {
            case v:
              return V ? G(1, 0) : G(31, 11);
            case f:
              return V ? G(1, te) : G(0, te + 1);
            case d:
              var se = this.$locale().weekStart || 0, ve = (X < se ? X + 7 : X) - se;
              return G(V ? ce - ve : ce + (6 - ve), te);
            case c:
            case m:
              return le(pe + "Hours", 0);
            case u:
              return le(pe + "Minutes", 1);
            case s:
              return le(pe + "Seconds", 2);
            case l:
              return le(pe + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, D.endOf = function(M) {
          return this.startOf(M, false);
        }, D.$set = function(M, F) {
          var A, V = R.p(M), Z = "set" + (this.$u ? "UTC" : ""), G = (A = {}, A[c] = Z + "Date", A[m] = Z + "Date", A[f] = Z + "Month", A[v] = Z + "FullYear", A[u] = Z + "Hours", A[s] = Z + "Minutes", A[l] = Z + "Seconds", A[a] = Z + "Milliseconds", A)[V], le = V === c ? this.$D + (F - this.$W) : F;
          if (V === f || V === v) {
            var X = this.clone().set(m, 1);
            X.$d[G](le), X.init(), this.$d = X.set(m, Math.min(this.$D, X.daysInMonth())).$d;
          } else G && this.$d[G](le);
          return this.init(), this;
        }, D.set = function(M, F) {
          return this.clone().$set(M, F);
        }, D.get = function(M) {
          return this[R.p(M)]();
        }, D.add = function(M, F) {
          var A, V = this;
          M = Number(M);
          var Z = R.p(F), G = function(te) {
            var ce = $(V);
            return R.w(ce.date(ce.date() + Math.round(te * M)), V);
          };
          if (Z === f) return this.set(f, this.$M + M);
          if (Z === v) return this.set(v, this.$y + M);
          if (Z === c) return G(1);
          if (Z === d) return G(7);
          var le = (A = {}, A[s] = o, A[u] = r, A[l] = n, A)[Z] || 1, X = this.$d.getTime() + M * le;
          return R.w(X, this);
        }, D.subtract = function(M, F) {
          return this.add(-1 * M, F);
        }, D.format = function(M) {
          var F = this, A = this.$locale();
          if (!this.isValid()) return A.invalidDate || h;
          var V = M || "YYYY-MM-DDTHH:mm:ssZ", Z = R.z(this), G = this.$H, le = this.$m, X = this.$M, te = A.weekdays, ce = A.months, pe = A.meridiem, se = function(De, Te, de, U) {
            return De && (De[Te] || De(F, V)) || de[Te].slice(0, U);
          }, ve = function(De) {
            return R.s(G % 12 || 12, De, "0");
          }, me = pe || function(De, Te, de) {
            var U = De < 12 ? "AM" : "PM";
            return de ? U.toLowerCase() : U;
          };
          return V.replace(g, function(De, Te) {
            return Te || function(de) {
              switch (de) {
                case "YY":
                  return String(F.$y).slice(-2);
                case "YYYY":
                  return R.s(F.$y, 4, "0");
                case "M":
                  return X + 1;
                case "MM":
                  return R.s(X + 1, 2, "0");
                case "MMM":
                  return se(A.monthsShort, X, ce, 3);
                case "MMMM":
                  return se(ce, X);
                case "D":
                  return F.$D;
                case "DD":
                  return R.s(F.$D, 2, "0");
                case "d":
                  return String(F.$W);
                case "dd":
                  return se(A.weekdaysMin, F.$W, te, 2);
                case "ddd":
                  return se(A.weekdaysShort, F.$W, te, 3);
                case "dddd":
                  return te[F.$W];
                case "H":
                  return String(G);
                case "HH":
                  return R.s(G, 2, "0");
                case "h":
                  return ve(1);
                case "hh":
                  return ve(2);
                case "a":
                  return me(G, le, true);
                case "A":
                  return me(G, le, false);
                case "m":
                  return String(le);
                case "mm":
                  return R.s(le, 2, "0");
                case "s":
                  return String(F.$s);
                case "ss":
                  return R.s(F.$s, 2, "0");
                case "SSS":
                  return R.s(F.$ms, 3, "0");
                case "Z":
                  return Z;
              }
              return null;
            }(De) || Z.replace(":", "");
          });
        }, D.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, D.diff = function(M, F, A) {
          var V, Z = this, G = R.p(F), le = $(M), X = (le.utcOffset() - this.utcOffset()) * o, te = this - le, ce = function() {
            return R.m(Z, le);
          };
          switch (G) {
            case v:
              V = ce() / 12;
              break;
            case f:
              V = ce();
              break;
            case p:
              V = ce() / 3;
              break;
            case d:
              V = (te - X) / 6048e5;
              break;
            case c:
              V = (te - X) / 864e5;
              break;
            case u:
              V = te / r;
              break;
            case s:
              V = te / o;
              break;
            case l:
              V = te / n;
              break;
            default:
              V = te;
          }
          return A ? V : R.a(V);
        }, D.daysInMonth = function() {
          return this.endOf(f).$D;
        }, D.$locale = function() {
          return E[this.$L];
        }, D.locale = function(M, F) {
          if (!M) return this.$L;
          var A = this.clone(), V = N(M, F, true);
          return V && (A.$L = V), A;
        }, D.clone = function() {
          return R.w(this.$d, this);
        }, D.toDate = function() {
          return new Date(this.valueOf());
        }, D.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, D.toISOString = function() {
          return this.$d.toISOString();
        }, D.toString = function() {
          return this.$d.toUTCString();
        }, Y;
      }(), z = P.prototype;
      return $.prototype = z, [["$ms", a], ["$s", l], ["$m", s], ["$H", u], ["$W", c], ["$M", f], ["$y", v], ["$D", m]].forEach(function(Y) {
        z[Y[1]] = function(D) {
          return this.$g(D, Y[0], Y[1]);
        };
      }), $.extend = function(Y, D) {
        return Y.$i || (Y(D, P, $), Y.$i = true), $;
      }, $.locale = N, $.isDayjs = O, $.unix = function(Y) {
        return $(1e3 * Y);
      }, $.en = E[C], $.Ls = E, $.p = {}, $;
    });
  }(id)), id.exports;
}
var IF = $F();
const rt = /* @__PURE__ */ Ra(IF), nv = (e10, t) => [
  e10 > 0 ? e10 - 1 : void 0,
  e10,
  e10 < t ? e10 + 1 : void 0
], tl = (e10) => Array.from(Array.from({ length: e10 }).keys()), w2 = (e10) => e10.replace(/\W?m{1,2}|\W?ZZ/g, "").replace(/\W?h{1,2}|\W?s{1,3}|\W?a/gi, "").trim(), C2 = (e10) => e10.replace(/\W?D{1,2}|\W?Do|\W?d{1,4}|\W?M{1,4}|\W?Y{2,4}/g, "").trim(), i1 = function(e10, t) {
  const n = nl(e10), o = nl(t);
  return n && o ? e10.getTime() === t.getTime() : !n && !o ? e10 === t : false;
}, u1 = function(e10, t) {
  const n = Se(e10), o = Se(t);
  return n && o ? e10.length !== t.length ? false : e10.every((r, a) => i1(r, t[a])) : !n && !o ? i1(e10, t) : false;
}, c1 = function(e10, t, n) {
  const o = Ro(t) || t === "x" ? rt(e10).locale(n) : rt(e10, t).locale(n);
  return o.isValid() ? o : void 0;
}, d1 = function(e10, t, n) {
  return Ro(t) ? e10 : t === "x" ? +e10 : rt(e10).locale(n).format(t);
}, ov = (e10, t) => {
  var n;
  const o = [], r = t == null ? void 0 : t();
  for (let a = 0; a < e10; a++)
    o.push((n = r == null ? void 0 : r.includes(a)) != null ? n : false);
  return o;
}, Bc = (e10) => Se(e10) ? e10.map((t) => t.toDate()) : e10.toDate(), MF = (e10, t) => {
  const n = e10.subtract(1, "month").endOf("month").date();
  return tl(t).map((o, r) => n - (t - r - 1));
}, PF = (e10) => {
  const t = e10.daysInMonth();
  return tl(t).map((n, o) => o + 1);
}, RF = (e10) => tl(e10.length / 7).map((t) => {
  const n = t * 7;
  return e10.slice(n, n + 7);
}), AF = Oe({
  selectedDay: {
    type: ne(Object)
  },
  range: {
    type: ne(Array)
  },
  date: {
    type: ne(Object),
    required: true
  },
  hideHeader: {
    type: Boolean
  }
}), LF = {
  pick: (e10) => at(e10)
};
var ud = { exports: {} }, xF = ud.exports, f1;
function DF() {
  return f1 || (f1 = 1, function(e10, t) {
    (function(n, o) {
      e10.exports = o();
    })(xF, function() {
      return function(n, o, r) {
        var a = o.prototype, l = function(f) {
          return f && (f.indexOf ? f : f.s);
        }, s = function(f, p, v, m, h) {
          var b = f.name ? f : f.$locale(), g = l(b[p]), w = l(b[v]), y = g || w.map(function(C) {
            return C.slice(0, m);
          });
          if (!h) return y;
          var _ = b.weekStart;
          return y.map(function(C, E) {
            return y[(E + (_ || 0)) % 7];
          });
        }, u = function() {
          return r.Ls[r.locale()];
        }, c = function(f, p) {
          return f.formats[p] || function(v) {
            return v.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(m, h, b) {
              return h || b.slice(1);
            });
          }(f.formats[p.toUpperCase()]);
        }, d = function() {
          var f = this;
          return { months: function(p) {
            return p ? p.format("MMMM") : s(f, "months");
          }, monthsShort: function(p) {
            return p ? p.format("MMM") : s(f, "monthsShort", "months", 3);
          }, firstDayOfWeek: function() {
            return f.$locale().weekStart || 0;
          }, weekdays: function(p) {
            return p ? p.format("dddd") : s(f, "weekdays");
          }, weekdaysMin: function(p) {
            return p ? p.format("dd") : s(f, "weekdaysMin", "weekdays", 2);
          }, weekdaysShort: function(p) {
            return p ? p.format("ddd") : s(f, "weekdaysShort", "weekdays", 3);
          }, longDateFormat: function(p) {
            return c(f.$locale(), p);
          }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
        };
        a.localeData = function() {
          return d.bind(this)();
        }, r.localeData = function() {
          var f = u();
          return { firstDayOfWeek: function() {
            return f.weekStart || 0;
          }, weekdays: function() {
            return r.weekdays();
          }, weekdaysShort: function() {
            return r.weekdaysShort();
          }, weekdaysMin: function() {
            return r.weekdaysMin();
          }, months: function() {
            return r.months();
          }, monthsShort: function() {
            return r.monthsShort();
          }, longDateFormat: function(p) {
            return c(f, p);
          }, meridiem: f.meridiem, ordinal: f.ordinal };
        }, r.months = function() {
          return s(u(), "months");
        }, r.monthsShort = function() {
          return s(u(), "monthsShort", "months", 3);
        }, r.weekdays = function(f) {
          return s(u(), "weekdays", null, null, f);
        }, r.weekdaysShort = function(f) {
          return s(u(), "weekdaysShort", "weekdays", 3, f);
        }, r.weekdaysMin = function(f) {
          return s(u(), "weekdaysMin", "weekdays", 2, f);
        };
      };
    });
  }(ud)), ud.exports;
}
var VF = DF();
const E2 = /* @__PURE__ */ Ra(VF), FF = [
  "year",
  "years",
  "month",
  "months",
  "date",
  "dates",
  "week",
  "datetime",
  "datetimerange",
  "daterange",
  "monthrange",
  "yearrange"
], rv = [
  "sun",
  "mon",
  "tue",
  "wed",
  "thu",
  "fri",
  "sat"
], BF = (e10, t) => {
  rt.extend(E2);
  const n = rt.localeData().firstDayOfWeek(), { t: o, lang: r } = kt(), a = rt().locale(r.value), l = S(() => !!e10.range && !!e10.range.length), s = S(() => {
    let p = [];
    if (l.value) {
      const [v, m] = e10.range, h = tl(m.date() - v.date() + 1).map((w) => ({
        text: v.date() + w,
        type: "current"
      }));
      let b = h.length % 7;
      b = b === 0 ? 0 : 7 - b;
      const g = tl(b).map((w, y) => ({
        text: y + 1,
        type: "next"
      }));
      p = h.concat(g);
    } else {
      const v = e10.date.startOf("month").day(), m = MF(e10.date, (v - n + 7) % 7).map((w) => ({
        text: w,
        type: "prev"
      })), h = PF(e10.date).map((w) => ({
        text: w,
        type: "current"
      }));
      p = [...m, ...h];
      const b = 7 - (p.length % 7 || 7), g = tl(b).map((w, y) => ({
        text: y + 1,
        type: "next"
      }));
      p = p.concat(g);
    }
    return RF(p);
  }), u = S(() => {
    const p = n;
    return p === 0 ? rv.map((v) => o(`el.datepicker.weeks.${v}`)) : rv.slice(p).concat(rv.slice(0, p)).map((v) => o(`el.datepicker.weeks.${v}`));
  }), c = (p, v) => {
    switch (v) {
      case "prev":
        return e10.date.startOf("month").subtract(1, "month").date(p);
      case "next":
        return e10.date.startOf("month").add(1, "month").date(p);
      case "current":
        return e10.date.date(p);
    }
  };
  return {
    now: a,
    isInRange: l,
    rows: s,
    weekDays: u,
    getFormattedDate: c,
    handlePickDay: ({ text: p, type: v }) => {
      const m = c(p, v);
      t("pick", m);
    },
    getSlotData: ({ text: p, type: v }) => {
      const m = c(p, v);
      return {
        isSelected: m.isSame(e10.selectedDay),
        type: `${v}-month`,
        day: m.format("YYYY-MM-DD"),
        date: m.toDate()
      };
    }
  };
}, HF = /* @__PURE__ */ j({
  name: "DateTable"
}), zF = /* @__PURE__ */ j({
  ...HF,
  props: AF,
  emits: LF,
  setup(e10, { expose: t, emit: n }) {
    const o = e10, {
      isInRange: r,
      now: a,
      rows: l,
      weekDays: s,
      getFormattedDate: u,
      handlePickDay: c,
      getSlotData: d
    } = BF(o, n), f = we("calendar-table"), p = we("calendar-day"), v = ({ text: m, type: h }) => {
      const b = [h];
      if (h === "current") {
        const g = u(m, h);
        g.isSame(o.selectedDay, "day") && b.push(p.is("selected")), g.isSame(a, "day") && b.push(p.is("today"));
      }
      return b;
    };
    return t({
      getFormattedDate: u
    }), (m, h) => (k(), x("table", {
      class: I([i(f).b(), i(f).is("range", i(r))]),
      cellspacing: "0",
      cellpadding: "0"
    }, [
      m.hideHeader ? ee("v-if", true) : (k(), x("thead", { key: 0 }, [
        B("tr", null, [
          (k(true), x(Ie, null, st(i(s), (b) => (k(), x("th", {
            key: b,
            scope: "col"
          }, _e(b), 1))), 128))
        ])
      ])),
      B("tbody", null, [
        (k(true), x(Ie, null, st(i(l), (b, g) => (k(), x("tr", {
          key: g,
          class: I({
            [i(f).e("row")]: true,
            [i(f).em("row", "hide-border")]: g === 0 && m.hideHeader
          })
        }, [
          (k(true), x(Ie, null, st(b, (w, y) => (k(), x("td", {
            key: y,
            class: I(v(w)),
            onClick: (_) => i(c)(w)
          }, [
            B("div", {
              class: I(i(p).b())
            }, [
              J(m.$slots, "date-cell", {
                data: i(d)(w)
              }, () => [
                B("span", null, _e(w.text), 1)
              ])
            ], 2)
          ], 10, ["onClick"]))), 128))
        ], 2))), 128))
      ])
    ], 2));
  }
});
var p1 = /* @__PURE__ */ $e(zF, [["__file", "date-table.vue"]]);
const KF = (e10, t) => {
  const n = e10.endOf("month"), o = t.startOf("month"), a = n.isSame(o, "week") ? o.add(1, "week") : o;
  return [
    [e10, n],
    [a.startOf("week"), t]
  ];
}, WF = (e10, t) => {
  const n = e10.endOf("month"), o = e10.add(1, "month").startOf("month"), r = n.isSame(o, "week") ? o.add(1, "week") : o, a = r.endOf("month"), l = t.startOf("month"), s = a.isSame(l, "week") ? l.add(1, "week") : l;
  return [
    [e10, n],
    [r.startOf("week"), a],
    [s.startOf("week"), t]
  ];
}, jF = (e10, t, n) => {
  const { lang: o } = kt(), r = L(), a = rt().locale(o.value), l = S({
    get() {
      return e10.modelValue ? u.value : r.value;
    },
    set(b) {
      if (!b)
        return;
      r.value = b;
      const g = b.toDate();
      t(bn, g), t(nt, g);
    }
  }), s = S(() => {
    if (!e10.range || !Se(e10.range) || e10.range.length !== 2 || e10.range.some((y) => !nl(y)))
      return [];
    const b = e10.range.map((y) => rt(y).locale(o.value)), [g, w] = b;
    return g.isAfter(w) ? (_t(n, "end time should be greater than start time"), []) : g.isSame(w, "month") ? v(g, w) : g.add(1, "month").month() !== w.month() ? (_t(n, "start time and end time interval must not exceed two months"), []) : v(g, w);
  }), u = S(() => e10.modelValue ? rt(e10.modelValue).locale(o.value) : l.value || (s.value.length ? s.value[0][0] : a)), c = S(() => u.value.subtract(1, "month").date(1)), d = S(() => u.value.add(1, "month").date(1)), f = S(() => u.value.subtract(1, "year").date(1)), p = S(() => u.value.add(1, "year").date(1)), v = (b, g) => {
    const w = b.startOf("week"), y = g.endOf("week"), _ = w.get("month"), C = y.get("month");
    return _ === C ? [[w, y]] : (_ + 1) % 12 === C ? KF(w, y) : _ + 2 === C || (_ + 1) % 11 === C ? WF(w, y) : (_t(n, "start time and end time interval must not exceed two months"), []);
  }, m = (b) => {
    l.value = b;
  };
  return {
    calculateValidatedDateRange: v,
    date: u,
    realSelectedDay: l,
    pickDay: m,
    selectDate: (b) => {
      const w = {
        "prev-month": c.value,
        "next-month": d.value,
        "prev-year": f.value,
        "next-year": p.value,
        today: a
      }[b];
      w.isSame(u.value, "day") || m(w);
    },
    validatedRange: s
  };
}, UF = (e10) => Se(e10) && e10.length === 2 && e10.every((t) => nl(t)), YF = Oe({
  modelValue: {
    type: Date
  },
  range: {
    type: ne(Array),
    validator: UF
  }
}), qF = {
  [nt]: (e10) => nl(e10),
  [bn]: (e10) => nl(e10)
}, S2 = "ElCalendar", GF = /* @__PURE__ */ j({
  name: S2
}), XF = /* @__PURE__ */ j({
  ...GF,
  props: YF,
  emits: qF,
  setup(e10, { expose: t, emit: n }) {
    const o = e10, r = we("calendar"), {
      calculateValidatedDateRange: a,
      date: l,
      pickDay: s,
      realSelectedDay: u,
      selectDate: c,
      validatedRange: d
    } = jF(o, n, S2), { t: f } = kt(), p = S(() => {
      const v = `el.datepicker.month${l.value.format("M")}`;
      return `${l.value.year()} ${f("el.datepicker.year")} ${f(v)}`;
    });
    return t({
      selectedDay: u,
      pickDay: s,
      selectDate: c,
      calculateValidatedDateRange: a
    }), (v, m) => (k(), x("div", {
      class: I(i(r).b())
    }, [
      B("div", {
        class: I(i(r).e("header"))
      }, [
        J(v.$slots, "header", { date: i(p) }, () => [
          B("div", {
            class: I(i(r).e("title"))
          }, _e(i(p)), 3),
          i(d).length === 0 ? (k(), x("div", {
            key: 0,
            class: I(i(r).e("button-group"))
          }, [
            W(i(_2), null, {
              default: H(() => [
                W(i(Mn), {
                  size: "small",
                  onClick: (h) => i(c)("prev-month")
                }, {
                  default: H(() => [
                    Ze(_e(i(f)("el.datepicker.prevMonth")), 1)
                  ]),
                  _: 1
                }, 8, ["onClick"]),
                W(i(Mn), {
                  size: "small",
                  onClick: (h) => i(c)("today")
                }, {
                  default: H(() => [
                    Ze(_e(i(f)("el.datepicker.today")), 1)
                  ]),
                  _: 1
                }, 8, ["onClick"]),
                W(i(Mn), {
                  size: "small",
                  onClick: (h) => i(c)("next-month")
                }, {
                  default: H(() => [
                    Ze(_e(i(f)("el.datepicker.nextMonth")), 1)
                  ]),
                  _: 1
                }, 8, ["onClick"])
              ]),
              _: 1
            })
          ], 2)) : ee("v-if", true)
        ])
      ], 2),
      i(d).length === 0 ? (k(), x("div", {
        key: 0,
        class: I(i(r).e("body"))
      }, [
        W(p1, {
          date: i(l),
          "selected-day": i(u),
          onPick: i(s)
        }, ro({
          _: 2
        }, [
          v.$slots["date-cell"] ? {
            name: "date-cell",
            fn: H((h) => [
              J(v.$slots, "date-cell", Ao(jr(h)))
            ])
          } : void 0
        ]), 1032, ["date", "selected-day", "onPick"])
      ], 2)) : (k(), x("div", {
        key: 1,
        class: I(i(r).e("body"))
      }, [
        (k(true), x(Ie, null, st(i(d), (h, b) => (k(), ae(p1, {
          key: b,
          date: h[0],
          "selected-day": i(u),
          range: h,
          "hide-header": b !== 0,
          onPick: i(s)
        }, ro({
          _: 2
        }, [
          v.$slots["date-cell"] ? {
            name: "date-cell",
            fn: H((g) => [
              J(v.$slots, "date-cell", Ao(jr(g)))
            ])
          } : void 0
        ]), 1032, ["date", "selected-day", "range", "hide-header", "onPick"]))), 128))
      ], 2))
    ], 2));
  }
});
var JF = /* @__PURE__ */ $e(XF, [["__file", "calendar.vue"]]);
const ZF = ut(JF), QF = Oe({
  header: {
    type: String,
    default: ""
  },
  footer: {
    type: String,
    default: ""
  },
  bodyStyle: {
    type: ne([String, Object, Array]),
    default: ""
  },
  headerClass: String,
  bodyClass: String,
  footerClass: String,
  shadow: {
    type: String,
    values: ["always", "hover", "never"],
    default: "always"
  }
}), e5 = /* @__PURE__ */ j({
  name: "ElCard"
}), t5 = /* @__PURE__ */ j({
  ...e5,
  props: QF,
  setup(e10) {
    const t = we("card");
    return (n, o) => (k(), x("div", {
      class: I([i(t).b(), i(t).is(`${n.shadow}-shadow`)])
    }, [
      n.$slots.header || n.header ? (k(), x("div", {
        key: 0,
        class: I([i(t).e("header"), n.headerClass])
      }, [
        J(n.$slots, "header", {}, () => [
          Ze(_e(n.header), 1)
        ])
      ], 2)) : ee("v-if", true),
      B("div", {
        class: I([i(t).e("body"), n.bodyClass]),
        style: ze(n.bodyStyle)
      }, [
        J(n.$slots, "default")
      ], 6),
      n.$slots.footer || n.footer ? (k(), x("div", {
        key: 1,
        class: I([i(t).e("footer"), n.footerClass])
      }, [
        J(n.$slots, "footer", {}, () => [
          Ze(_e(n.footer), 1)
        ])
      ], 2)) : ee("v-if", true)
    ], 2));
  }
});
var n5 = /* @__PURE__ */ $e(t5, [["__file", "card.vue"]]);
const o5 = ut(n5), r5 = Oe({
  initialIndex: {
    type: Number,
    default: 0
  },
  height: {
    type: String,
    default: ""
  },
  trigger: {
    type: String,
    values: ["hover", "click"],
    default: "hover"
  },
  autoplay: {
    type: Boolean,
    default: true
  },
  interval: {
    type: Number,
    default: 3e3
  },
  indicatorPosition: {
    type: String,
    values: ["", "none", "outside"],
    default: ""
  },
  arrow: {
    type: String,
    values: ["always", "hover", "never"],
    default: "hover"
  },
  type: {
    type: String,
    values: ["", "card"],
    default: ""
  },
  cardScale: {
    type: Number,
    default: 0.83
  },
  loop: {
    type: Boolean,
    default: true
  },
  direction: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "horizontal"
  },
  pauseOnHover: {
    type: Boolean,
    default: true
  },
  motionBlur: Boolean
}), a5 = {
  change: (e10, t) => [e10, t].every(Ye)
}, k2 = Symbol("carouselContextKey"), ku = "ElCarouselItem", l5 = "utils/vue/vnode";
var zo = /* @__PURE__ */ ((e10) => (e10[e10.TEXT = 1] = "TEXT", e10[e10.CLASS = 2] = "CLASS", e10[e10.STYLE = 4] = "STYLE", e10[e10.PROPS = 8] = "PROPS", e10[e10.FULL_PROPS = 16] = "FULL_PROPS", e10[e10.HYDRATE_EVENTS = 32] = "HYDRATE_EVENTS", e10[e10.STABLE_FRAGMENT = 64] = "STABLE_FRAGMENT", e10[e10.KEYED_FRAGMENT = 128] = "KEYED_FRAGMENT", e10[e10.UNKEYED_FRAGMENT = 256] = "UNKEYED_FRAGMENT", e10[e10.NEED_PATCH = 512] = "NEED_PATCH", e10[e10.DYNAMIC_SLOTS = 1024] = "DYNAMIC_SLOTS", e10[e10.HOISTED = -1] = "HOISTED", e10[e10.BAIL = -2] = "BAIL", e10))(zo || {});
function th(e10) {
  return Ut(e10) && e10.type === Ie;
}
function s5(e10) {
  return Ut(e10) && e10.type === tn;
}
function i5(e10) {
  return Ut(e10) && !th(e10) && !s5(e10);
}
const u5 = (e10) => {
  if (!Ut(e10))
    return _t(l5, "[getNormalizedProps] must be a VNode"), {};
  const t = e10.props || {}, n = (Ut(e10.type) ? e10.type.props : void 0) || {}, o = {};
  return Object.keys(n).forEach((r) => {
    Tt(n[r], "default") && (o[r] = n[r].default);
  }), Object.keys(t).forEach((r) => {
    o[Dn(r)] = t[r];
  }), o;
}, c5 = (e10) => {
  if (!Se(e10) || e10.length > 1)
    throw new Error("expect to receive a single Vue element child");
  return e10[0];
}, Fr = (e10) => {
  const t = Se(e10) ? e10 : [e10], n = [];
  return t.forEach((o) => {
    var r;
    Se(o) ? n.push(...Fr(o)) : Ut(o) && ((r = o.component) != null && r.subTree) ? n.push(o, ...Fr(o.component.subTree)) : Ut(o) && Se(o.children) ? n.push(...Fr(o.children)) : Ut(o) && o.shapeFlag === 2 ? n.push(...Fr(o.type())) : n.push(o);
  }), n;
}, d5 = (e10, t, n) => Fr(e10.subTree).filter((a) => {
  var l;
  return Ut(a) && ((l = a.type) == null ? void 0 : l.name) === t && !!a.component;
}).map((a) => a.component.uid).map((a) => n[a]).filter((a) => !!a), ap = (e10, t) => {
  const n = {}, o = qt([]);
  return {
    children: o,
    addChild: (l) => {
      n[l.uid] = l, o.value = d5(e10, t, n);
    },
    removeChild: (l) => {
      delete n[l], o.value = o.value.filter((s) => s.uid !== l);
    }
  };
}, v1 = 300, f5 = (e10, t, n) => {
  const {
    children: o,
    addChild: r,
    removeChild: a
  } = ap(it(), ku), l = En(), s = L(-1), u = L(null), c = L(false), d = L(), f = L(0), p = L(true), v = S(() => e10.arrow !== "never" && !i(b)), m = S(() => o.value.some((X) => X.props.label.toString().length > 0)), h = S(() => e10.type === "card"), b = S(() => e10.direction === "vertical"), g = S(() => e10.height !== "auto" ? {
    height: e10.height
  } : {
    height: `${f.value}px`,
    overflow: "hidden"
  }), w = zl((X) => {
    O(X);
  }, v1, { trailing: true }), y = zl((X) => {
    M(X);
  }, v1), _ = (X) => p.value ? s.value <= 1 ? X <= 1 : X > 1 : true;
  function C() {
    u.value && (clearInterval(u.value), u.value = null);
  }
  function E() {
    e10.interval <= 0 || !e10.autoplay || u.value || (u.value = setInterval(() => T(), e10.interval));
  }
  const T = () => {
    s.value < o.value.length - 1 ? s.value = s.value + 1 : e10.loop && (s.value = 0);
  };
  function O(X) {
    if (Ve(X)) {
      const pe = o.value.filter((se) => se.props.name === X);
      pe.length > 0 && (X = o.value.indexOf(pe[0]));
    }
    if (X = Number(X), Number.isNaN(X) || X !== Math.floor(X)) {
      _t(n, "index must be integer.");
      return;
    }
    const te = o.value.length, ce = s.value;
    X < 0 ? s.value = e10.loop ? te - 1 : 0 : X >= te ? s.value = e10.loop ? 0 : te - 1 : s.value = X, ce === s.value && N(ce), V();
  }
  function N(X) {
    o.value.forEach((te, ce) => {
      te.translateItem(ce, s.value, X);
    });
  }
  function $(X, te) {
    var ce, pe, se, ve;
    const me = i(o), De = me.length;
    if (De === 0 || !X.states.inStage)
      return false;
    const Te = te + 1, de = te - 1, U = De - 1, re = me[U].states.active, he = me[0].states.active, Ee = (pe = (ce = me[Te]) == null ? void 0 : ce.states) == null ? void 0 : pe.active, ye = (ve = (se = me[de]) == null ? void 0 : se.states) == null ? void 0 : ve.active;
    return te === U && he || Ee ? "left" : te === 0 && re || ye ? "right" : false;
  }
  function R() {
    c.value = true, e10.pauseOnHover && C();
  }
  function P() {
    c.value = false, E();
  }
  function z(X) {
    i(b) || o.value.forEach((te, ce) => {
      X === $(te, ce) && (te.states.hover = true);
    });
  }
  function Y() {
    i(b) || o.value.forEach((X) => {
      X.states.hover = false;
    });
  }
  function D(X) {
    s.value = X;
  }
  function M(X) {
    e10.trigger === "hover" && X !== s.value && (s.value = X);
  }
  function F() {
    O(s.value - 1);
  }
  function A() {
    O(s.value + 1);
  }
  function V() {
    C(), e10.pauseOnHover || E();
  }
  function Z(X) {
    e10.height === "auto" && (f.value = X);
  }
  function G() {
    var X;
    const te = (X = l.default) == null ? void 0 : X.call(l);
    if (!te)
      return null;
    const pe = Fr(te).filter((se) => Ut(se) && se.type.name === ku);
    return (pe == null ? void 0 : pe.length) === 2 && e10.loop && !h.value ? (p.value = true, pe) : (p.value = false, null);
  }
  ge(() => s.value, (X, te) => {
    N(te), p.value && (X = X % 2, te = te % 2), te > -1 && t(gt, X, te);
  }), ge(() => e10.autoplay, (X) => {
    X ? E() : C();
  }), ge(() => e10.loop, () => {
    O(s.value);
  }), ge(() => e10.interval, () => {
    V();
  });
  const le = qt();
  return dt(() => {
    ge(() => o.value, () => {
      o.value.length > 0 && O(e10.initialIndex);
    }, {
      immediate: true
    }), le.value = en(d.value, () => {
      N();
    }), E();
  }), jt(() => {
    C(), d.value && le.value && le.value.stop();
  }), yt(k2, {
    root: d,
    isCardType: h,
    isVertical: b,
    items: o,
    loop: e10.loop,
    cardScale: e10.cardScale,
    addItem: r,
    removeItem: a,
    setActiveItem: O,
    setContainerHeight: Z
  }), {
    root: d,
    activeIndex: s,
    arrowDisplay: v,
    hasLabel: m,
    hover: c,
    isCardType: h,
    items: o,
    isVertical: b,
    containerStyle: g,
    isItemsTwoLength: p,
    handleButtonEnter: z,
    handleButtonLeave: Y,
    handleIndicatorClick: D,
    handleMouseEnter: R,
    handleMouseLeave: P,
    setActiveItem: O,
    prev: F,
    next: A,
    PlaceholderItem: G,
    isTwoLengthShow: _,
    throttledArrowClick: w,
    throttledIndicatorHover: y
  };
}, N2 = "ElCarousel", p5 = /* @__PURE__ */ j({
  name: N2
}), v5 = /* @__PURE__ */ j({
  ...p5,
  props: r5,
  emits: a5,
  setup(e10, { expose: t, emit: n }) {
    const o = e10, {
      root: r,
      activeIndex: a,
      arrowDisplay: l,
      hasLabel: s,
      hover: u,
      isCardType: c,
      items: d,
      isVertical: f,
      containerStyle: p,
      handleButtonEnter: v,
      handleButtonLeave: m,
      handleIndicatorClick: h,
      handleMouseEnter: b,
      handleMouseLeave: g,
      setActiveItem: w,
      prev: y,
      next: _,
      PlaceholderItem: C,
      isTwoLengthShow: E,
      throttledArrowClick: T,
      throttledIndicatorHover: O
    } = f5(o, n, N2), N = we("carousel"), { t: $ } = kt(), R = S(() => {
      const D = [N.b(), N.m(o.direction)];
      return i(c) && D.push(N.m("card")), D;
    }), P = S(() => {
      const D = [N.e("indicators"), N.em("indicators", o.direction)];
      return i(s) && D.push(N.em("indicators", "labels")), o.indicatorPosition === "outside" && D.push(N.em("indicators", "outside")), i(f) && D.push(N.em("indicators", "right")), D;
    });
    function z(D) {
      if (!o.motionBlur)
        return;
      const M = i(f) ? `${N.namespace.value}-transitioning-vertical` : `${N.namespace.value}-transitioning`;
      D.currentTarget.classList.add(M);
    }
    function Y(D) {
      if (!o.motionBlur)
        return;
      const M = i(f) ? `${N.namespace.value}-transitioning-vertical` : `${N.namespace.value}-transitioning`;
      D.currentTarget.classList.remove(M);
    }
    return t({
      activeIndex: a,
      setActiveItem: w,
      prev: y,
      next: _
    }), (D, M) => (k(), x("div", {
      ref_key: "root",
      ref: r,
      class: I(i(R)),
      onMouseenter: Xe(i(b), ["stop"]),
      onMouseleave: Xe(i(g), ["stop"])
    }, [
      i(l) ? (k(), ae(Rn, {
        key: 0,
        name: "carousel-arrow-left",
        persisted: ""
      }, {
        default: H(() => [
          lt(B("button", {
            type: "button",
            class: I([i(N).e("arrow"), i(N).em("arrow", "left")]),
            "aria-label": i($)("el.carousel.leftArrow"),
            onMouseenter: (F) => i(v)("left"),
            onMouseleave: i(m),
            onClick: Xe((F) => i(T)(i(a) - 1), ["stop"])
          }, [
            W(i(Be), null, {
              default: H(() => [
                W(i(wa))
              ]),
              _: 1
            })
          ], 42, ["aria-label", "onMouseenter", "onMouseleave", "onClick"]), [
            [
              Nt,
              (D.arrow === "always" || i(u)) && (o.loop || i(a) > 0)
            ]
          ])
        ]),
        _: 1
      })) : ee("v-if", true),
      i(l) ? (k(), ae(Rn, {
        key: 1,
        name: "carousel-arrow-right",
        persisted: ""
      }, {
        default: H(() => [
          lt(B("button", {
            type: "button",
            class: I([i(N).e("arrow"), i(N).em("arrow", "right")]),
            "aria-label": i($)("el.carousel.rightArrow"),
            onMouseenter: (F) => i(v)("right"),
            onMouseleave: i(m),
            onClick: Xe((F) => i(T)(i(a) + 1), ["stop"])
          }, [
            W(i(Be), null, {
              default: H(() => [
                W(i(oo))
              ]),
              _: 1
            })
          ], 42, ["aria-label", "onMouseenter", "onMouseleave", "onClick"]), [
            [
              Nt,
              (D.arrow === "always" || i(u)) && (o.loop || i(a) < i(d).length - 1)
            ]
          ])
        ]),
        _: 1
      })) : ee("v-if", true),
      B("div", {
        class: I(i(N).e("container")),
        style: ze(i(p)),
        onTransitionstart: z,
        onTransitionend: Y
      }, [
        W(i(C)),
        J(D.$slots, "default")
      ], 38),
      D.indicatorPosition !== "none" ? (k(), x("ul", {
        key: 2,
        class: I(i(P))
      }, [
        (k(true), x(Ie, null, st(i(d), (F, A) => lt((k(), x("li", {
          key: A,
          class: I([
            i(N).e("indicator"),
            i(N).em("indicator", D.direction),
            i(N).is("active", A === i(a))
          ]),
          onMouseenter: (V) => i(O)(A),
          onClick: Xe((V) => i(h)(A), ["stop"])
        }, [
          B("button", {
            class: I(i(N).e("button")),
            "aria-label": i($)("el.carousel.indicator", { index: A + 1 })
          }, [
            i(s) ? (k(), x("span", { key: 0 }, _e(F.props.label), 1)) : ee("v-if", true)
          ], 10, ["aria-label"])
        ], 42, ["onMouseenter", "onClick"])), [
          [Nt, i(E)(A)]
        ])), 128))
      ], 2)) : ee("v-if", true),
      o.motionBlur ? (k(), x("svg", {
        key: 3,
        xmlns: "http://www.w3.org/2000/svg",
        version: "1.1",
        style: { display: "none" }
      }, [
        B("defs", null, [
          B("filter", { id: "elCarouselHorizontal" }, [
            B("feGaussianBlur", {
              in: "SourceGraphic",
              stdDeviation: "12,0"
            })
          ]),
          B("filter", { id: "elCarouselVertical" }, [
            B("feGaussianBlur", {
              in: "SourceGraphic",
              stdDeviation: "0,10"
            })
          ])
        ])
      ])) : ee("v-if", true)
    ], 42, ["onMouseenter", "onMouseleave"]));
  }
});
var h5 = /* @__PURE__ */ $e(v5, [["__file", "carousel.vue"]]);
const m5 = Oe({
  name: { type: String, default: "" },
  label: {
    type: [String, Number],
    default: ""
  }
}), g5 = (e10) => {
  const t = Le(k2), n = it();
  t || _t(ku, "usage: <el-carousel></el-carousel-item></el-carousel>"), n || _t(ku, "compositional hook can only be invoked inside setups");
  const o = L(), r = L(false), a = L(0), l = L(1), s = L(false), u = L(false), c = L(false), d = L(false), { isCardType: f, isVertical: p, cardScale: v } = t;
  function m(y, _, C) {
    const E = C - 1, T = _ - 1, O = _ + 1, N = C / 2;
    return _ === 0 && y === E ? -1 : _ === E && y === 0 ? C : y < T && _ - y >= N ? C + 1 : y > O && y - _ >= N ? -2 : y;
  }
  function h(y, _) {
    var C, E;
    const T = i(p) ? ((C = t.root.value) == null ? void 0 : C.offsetHeight) || 0 : ((E = t.root.value) == null ? void 0 : E.offsetWidth) || 0;
    return c.value ? T * ((2 - v) * (y - _) + 1) / 4 : y < _ ? -(1 + v) * T / 4 : (3 + v) * T / 4;
  }
  function b(y, _, C) {
    const E = t.root.value;
    return E ? ((C ? E.offsetHeight : E.offsetWidth) || 0) * (y - _) : 0;
  }
  const g = (y, _, C) => {
    var E;
    const T = i(f), O = (E = t.items.value.length) != null ? E : Number.NaN, N = y === _;
    !T && !St(C) && (d.value = N || y === C), !N && O > 2 && t.loop && (y = m(y, _, O));
    const $ = i(p);
    s.value = N, T ? (c.value = Math.round(Math.abs(y - _)) <= 1, a.value = h(y, _), l.value = i(s) ? 1 : v) : a.value = b(y, _, $), u.value = true, N && o.value && t.setContainerHeight(o.value.offsetHeight);
  };
  function w() {
    if (t && i(f)) {
      const y = t.items.value.findIndex(({ uid: _ }) => _ === n.uid);
      t.setActiveItem(y);
    }
  }
  return dt(() => {
    t.addItem({
      props: e10,
      states: It({
        hover: r,
        translate: a,
        scale: l,
        active: s,
        ready: u,
        inStage: c,
        animating: d
      }),
      uid: n.uid,
      translateItem: g
    });
  }), Jr(() => {
    t.removeItem(n.uid);
  }), {
    carouselItemRef: o,
    active: s,
    animating: d,
    hover: r,
    inStage: c,
    isVertical: p,
    translate: a,
    isCardType: f,
    scale: l,
    ready: u,
    handleItemClick: w
  };
}, y5 = /* @__PURE__ */ j({
  name: ku
}), b5 = /* @__PURE__ */ j({
  ...y5,
  props: m5,
  setup(e10) {
    const t = e10, n = we("carousel"), {
      carouselItemRef: o,
      active: r,
      animating: a,
      hover: l,
      inStage: s,
      isVertical: u,
      translate: c,
      isCardType: d,
      scale: f,
      ready: p,
      handleItemClick: v
    } = g5(t), m = S(() => [
      n.e("item"),
      n.is("active", r.value),
      n.is("in-stage", s.value),
      n.is("hover", l.value),
      n.is("animating", a.value),
      {
        [n.em("item", "card")]: d.value,
        [n.em("item", "card-vertical")]: d.value && u.value
      }
    ]), h = S(() => {
      const g = `${`translate${i(u) ? "Y" : "X"}`}(${i(c)}px)`, w = `scale(${i(f)})`;
      return {
        transform: [g, w].join(" ")
      };
    });
    return (b, g) => lt((k(), x("div", {
      ref_key: "carouselItemRef",
      ref: o,
      class: I(i(m)),
      style: ze(i(h)),
      onClick: i(v)
    }, [
      i(d) ? lt((k(), x("div", {
        key: 0,
        class: I(i(n).e("mask"))
      }, null, 2)), [
        [Nt, !i(r)]
      ]) : ee("v-if", true),
      J(b.$slots, "default")
    ], 14, ["onClick"])), [
      [Nt, i(p)]
    ]);
  }
});
var T2 = /* @__PURE__ */ $e(b5, [["__file", "carousel-item.vue"]]);
const _5 = ut(h5, {
  CarouselItem: T2
}), w5 = nn(T2), O2 = {
  modelValue: {
    type: [Number, String, Boolean],
    default: void 0
  },
  label: {
    type: [String, Boolean, Number, Object],
    default: void 0
  },
  value: {
    type: [String, Boolean, Number, Object],
    default: void 0
  },
  indeterminate: Boolean,
  disabled: Boolean,
  checked: Boolean,
  name: {
    type: String,
    default: void 0
  },
  trueValue: {
    type: [String, Number],
    default: void 0
  },
  falseValue: {
    type: [String, Number],
    default: void 0
  },
  trueLabel: {
    type: [String, Number],
    default: void 0
  },
  falseLabel: {
    type: [String, Number],
    default: void 0
  },
  id: {
    type: String,
    default: void 0
  },
  border: Boolean,
  size: _n,
  tabindex: [String, Number],
  validateEvent: {
    type: Boolean,
    default: true
  },
  ...Bn(["ariaControls"])
}, $2 = {
  [nt]: (e10) => Ve(e10) || Ye(e10) || Vt(e10),
  change: (e10) => Ve(e10) || Ye(e10) || Vt(e10)
}, Oi = Symbol("checkboxGroupContextKey"), C5 = ({
  model: e10,
  isChecked: t
}) => {
  const n = Le(Oi, void 0), o = S(() => {
    var a, l;
    const s = (a = n == null ? void 0 : n.max) == null ? void 0 : a.value, u = (l = n == null ? void 0 : n.min) == null ? void 0 : l.value;
    return !St(s) && e10.value.length >= s && !t.value || !St(u) && e10.value.length <= u && t.value;
  });
  return {
    isDisabled: Hn(S(() => (n == null ? void 0 : n.disabled.value) || o.value)),
    isLimitDisabled: o
  };
}, E5 = (e10, {
  model: t,
  isLimitExceeded: n,
  hasOwnLabel: o,
  isDisabled: r,
  isLabeledByFormItem: a
}) => {
  const l = Le(Oi, void 0), { formItem: s } = Yn(), { emit: u } = it();
  function c(m) {
    var h, b, g, w;
    return [true, e10.trueValue, e10.trueLabel].includes(m) ? (b = (h = e10.trueValue) != null ? h : e10.trueLabel) != null ? b : true : (w = (g = e10.falseValue) != null ? g : e10.falseLabel) != null ? w : false;
  }
  function d(m, h) {
    u(gt, c(m), h);
  }
  function f(m) {
    if (n.value)
      return;
    const h = m.target;
    u(gt, c(h.checked), m);
  }
  async function p(m) {
    n.value || !o.value && !r.value && a.value && (m.composedPath().some((g) => g.tagName === "LABEL") || (t.value = c([false, e10.falseValue, e10.falseLabel].includes(t.value)), await He(), d(t.value, m)));
  }
  const v = S(() => (l == null ? void 0 : l.validateEvent) || e10.validateEvent);
  return ge(() => e10.modelValue, () => {
    v.value && (s == null || s.validate("change").catch((m) => _t(m)));
  }), {
    handleChange: f,
    onClickRoot: p
  };
}, S5 = (e10) => {
  const t = L(false), { emit: n } = it(), o = Le(Oi, void 0), r = S(() => St(o) === false), a = L(false), l = S({
    get() {
      var s, u;
      return r.value ? (s = o == null ? void 0 : o.modelValue) == null ? void 0 : s.value : (u = e10.modelValue) != null ? u : t.value;
    },
    set(s) {
      var u, c;
      r.value && Se(s) ? (a.value = ((u = o == null ? void 0 : o.max) == null ? void 0 : u.value) !== void 0 && s.length > (o == null ? void 0 : o.max.value) && s.length > l.value.length, a.value === false && ((c = o == null ? void 0 : o.changeEvent) == null || c.call(o, s))) : (n(nt, s), t.value = s);
    }
  });
  return {
    model: l,
    isGroup: r,
    isLimitExceeded: a
  };
}, k5 = (e10, t, { model: n }) => {
  const o = Le(Oi, void 0), r = L(false), a = S(() => So(e10.value) ? e10.label : e10.value), l = S(() => {
    const d = n.value;
    return Vt(d) ? d : Se(d) ? at(a.value) ? d.map(Rt).some((f) => In(f, a.value)) : d.map(Rt).includes(a.value) : d != null ? d === e10.trueValue || d === e10.trueLabel : !!d;
  }), s = yn(S(() => {
    var d;
    return (d = o == null ? void 0 : o.size) == null ? void 0 : d.value;
  }), {
    prop: true
  }), u = yn(S(() => {
    var d;
    return (d = o == null ? void 0 : o.size) == null ? void 0 : d.value;
  })), c = S(() => !!t.default || !So(a.value));
  return {
    checkboxButtonSize: s,
    isChecked: l,
    isFocused: r,
    checkboxSize: u,
    hasOwnLabel: c,
    actualValue: a
  };
}, I2 = (e10, t) => {
  const { formItem: n } = Yn(), { model: o, isGroup: r, isLimitExceeded: a } = S5(e10), {
    isFocused: l,
    isChecked: s,
    checkboxButtonSize: u,
    checkboxSize: c,
    hasOwnLabel: d,
    actualValue: f
  } = k5(e10, t, { model: o }), { isDisabled: p } = C5({ model: o, isChecked: s }), { inputId: v, isLabeledByFormItem: m } = tr(e10, {
    formItemContext: n,
    disableIdGeneration: d,
    disableIdManagement: r
  }), { handleChange: h, onClickRoot: b } = E5(e10, {
    model: o,
    isLimitExceeded: a,
    hasOwnLabel: d,
    isDisabled: p,
    isLabeledByFormItem: m
  });
  return (() => {
    function w() {
      var y, _;
      Se(o.value) && !o.value.includes(f.value) ? o.value.push(f.value) : o.value = (_ = (y = e10.trueValue) != null ? y : e10.trueLabel) != null ? _ : true;
    }
    e10.checked && w();
  })(), _a({
    from: "label act as value",
    replacement: "value",
    version: "3.0.0",
    scope: "el-checkbox",
    ref: "https://element-plus.org/en-US/component/checkbox.html"
  }, S(() => r.value && So(e10.value))), _a({
    from: "true-label",
    replacement: "true-value",
    version: "3.0.0",
    scope: "el-checkbox",
    ref: "https://element-plus.org/en-US/component/checkbox.html"
  }, S(() => !!e10.trueLabel)), _a({
    from: "false-label",
    replacement: "false-value",
    version: "3.0.0",
    scope: "el-checkbox",
    ref: "https://element-plus.org/en-US/component/checkbox.html"
  }, S(() => !!e10.falseLabel)), {
    inputId: v,
    isLabeledByFormItem: m,
    isChecked: s,
    isDisabled: p,
    isFocused: l,
    checkboxButtonSize: u,
    checkboxSize: c,
    hasOwnLabel: d,
    model: o,
    actualValue: f,
    handleChange: h,
    onClickRoot: b
  };
}, N5 = /* @__PURE__ */ j({
  name: "ElCheckbox"
}), T5 = /* @__PURE__ */ j({
  ...N5,
  props: O2,
  emits: $2,
  setup(e10) {
    const t = e10, n = En(), {
      inputId: o,
      isLabeledByFormItem: r,
      isChecked: a,
      isDisabled: l,
      isFocused: s,
      checkboxSize: u,
      hasOwnLabel: c,
      model: d,
      actualValue: f,
      handleChange: p,
      onClickRoot: v
    } = I2(t, n), m = we("checkbox"), h = S(() => [
      m.b(),
      m.m(u.value),
      m.is("disabled", l.value),
      m.is("bordered", t.border),
      m.is("checked", a.value)
    ]), b = S(() => [
      m.e("input"),
      m.is("disabled", l.value),
      m.is("checked", a.value),
      m.is("indeterminate", t.indeterminate),
      m.is("focus", s.value)
    ]);
    return (g, w) => (k(), ae(ht(!i(c) && i(r) ? "span" : "label"), {
      class: I(i(h)),
      "aria-controls": g.indeterminate ? g.ariaControls : null,
      onClick: i(v)
    }, {
      default: H(() => {
        var y, _, C, E;
        return [
          B("span", {
            class: I(i(b))
          }, [
            g.trueValue || g.falseValue || g.trueLabel || g.falseLabel ? lt((k(), x("input", {
              key: 0,
              id: i(o),
              "onUpdate:modelValue": (T) => Ot(d) ? d.value = T : null,
              class: I(i(m).e("original")),
              type: "checkbox",
              indeterminate: g.indeterminate,
              name: g.name,
              tabindex: g.tabindex,
              disabled: i(l),
              "true-value": (_ = (y = g.trueValue) != null ? y : g.trueLabel) != null ? _ : true,
              "false-value": (E = (C = g.falseValue) != null ? C : g.falseLabel) != null ? E : false,
              onChange: i(p),
              onFocus: (T) => s.value = true,
              onBlur: (T) => s.value = false,
              onClick: Xe(() => {
              }, ["stop"])
            }, null, 42, ["id", "onUpdate:modelValue", "indeterminate", "name", "tabindex", "disabled", "true-value", "false-value", "onChange", "onFocus", "onBlur", "onClick"])), [
              [qd, i(d)]
            ]) : lt((k(), x("input", {
              key: 1,
              id: i(o),
              "onUpdate:modelValue": (T) => Ot(d) ? d.value = T : null,
              class: I(i(m).e("original")),
              type: "checkbox",
              indeterminate: g.indeterminate,
              disabled: i(l),
              value: i(f),
              name: g.name,
              tabindex: g.tabindex,
              onChange: i(p),
              onFocus: (T) => s.value = true,
              onBlur: (T) => s.value = false,
              onClick: Xe(() => {
              }, ["stop"])
            }, null, 42, ["id", "onUpdate:modelValue", "indeterminate", "disabled", "value", "name", "tabindex", "onChange", "onFocus", "onBlur", "onClick"])), [
              [qd, i(d)]
            ]),
            B("span", {
              class: I(i(m).e("inner"))
            }, null, 2)
          ], 2),
          i(c) ? (k(), x("span", {
            key: 0,
            class: I(i(m).e("label"))
          }, [
            J(g.$slots, "default"),
            g.$slots.default ? ee("v-if", true) : (k(), x(Ie, { key: 0 }, [
              Ze(_e(g.label), 1)
            ], 64))
          ], 2)) : ee("v-if", true)
        ];
      }),
      _: 3
    }, 8, ["class", "aria-controls", "onClick"]));
  }
});
var O5 = /* @__PURE__ */ $e(T5, [["__file", "checkbox.vue"]]);
const $5 = /* @__PURE__ */ j({
  name: "ElCheckboxButton"
}), I5 = /* @__PURE__ */ j({
  ...$5,
  props: O2,
  emits: $2,
  setup(e10) {
    const t = e10, n = En(), {
      isFocused: o,
      isChecked: r,
      isDisabled: a,
      checkboxButtonSize: l,
      model: s,
      actualValue: u,
      handleChange: c
    } = I2(t, n), d = Le(Oi, void 0), f = we("checkbox"), p = S(() => {
      var m, h, b, g;
      const w = (h = (m = d == null ? void 0 : d.fill) == null ? void 0 : m.value) != null ? h : "";
      return {
        backgroundColor: w,
        borderColor: w,
        color: (g = (b = d == null ? void 0 : d.textColor) == null ? void 0 : b.value) != null ? g : "",
        boxShadow: w ? `-1px 0 0 0 ${w}` : void 0
      };
    }), v = S(() => [
      f.b("button"),
      f.bm("button", l.value),
      f.is("disabled", a.value),
      f.is("checked", r.value),
      f.is("focus", o.value)
    ]);
    return (m, h) => {
      var b, g, w, y;
      return k(), x("label", {
        class: I(i(v))
      }, [
        m.trueValue || m.falseValue || m.trueLabel || m.falseLabel ? lt((k(), x("input", {
          key: 0,
          "onUpdate:modelValue": (_) => Ot(s) ? s.value = _ : null,
          class: I(i(f).be("button", "original")),
          type: "checkbox",
          name: m.name,
          tabindex: m.tabindex,
          disabled: i(a),
          "true-value": (g = (b = m.trueValue) != null ? b : m.trueLabel) != null ? g : true,
          "false-value": (y = (w = m.falseValue) != null ? w : m.falseLabel) != null ? y : false,
          onChange: i(c),
          onFocus: (_) => o.value = true,
          onBlur: (_) => o.value = false,
          onClick: Xe(() => {
          }, ["stop"])
        }, null, 42, ["onUpdate:modelValue", "name", "tabindex", "disabled", "true-value", "false-value", "onChange", "onFocus", "onBlur", "onClick"])), [
          [qd, i(s)]
        ]) : lt((k(), x("input", {
          key: 1,
          "onUpdate:modelValue": (_) => Ot(s) ? s.value = _ : null,
          class: I(i(f).be("button", "original")),
          type: "checkbox",
          name: m.name,
          tabindex: m.tabindex,
          disabled: i(a),
          value: i(u),
          onChange: i(c),
          onFocus: (_) => o.value = true,
          onBlur: (_) => o.value = false,
          onClick: Xe(() => {
          }, ["stop"])
        }, null, 42, ["onUpdate:modelValue", "name", "tabindex", "disabled", "value", "onChange", "onFocus", "onBlur", "onClick"])), [
          [qd, i(s)]
        ]),
        m.$slots.default || m.label ? (k(), x("span", {
          key: 2,
          class: I(i(f).be("button", "inner")),
          style: ze(i(r) ? i(p) : void 0)
        }, [
          J(m.$slots, "default", {}, () => [
            Ze(_e(m.label), 1)
          ])
        ], 6)) : ee("v-if", true)
      ], 2);
    };
  }
});
var M2 = /* @__PURE__ */ $e(I5, [["__file", "checkbox-button.vue"]]);
const M5 = Oe({
  modelValue: {
    type: ne(Array),
    default: () => []
  },
  disabled: Boolean,
  min: Number,
  max: Number,
  size: _n,
  fill: String,
  textColor: String,
  tag: {
    type: String,
    default: "div"
  },
  validateEvent: {
    type: Boolean,
    default: true
  },
  ...Bn(["ariaLabel"])
}), P5 = {
  [nt]: (e10) => Se(e10),
  change: (e10) => Se(e10)
}, R5 = /* @__PURE__ */ j({
  name: "ElCheckboxGroup"
}), A5 = /* @__PURE__ */ j({
  ...R5,
  props: M5,
  emits: P5,
  setup(e10, { emit: t }) {
    const n = e10, o = we("checkbox"), { formItem: r } = Yn(), { inputId: a, isLabeledByFormItem: l } = tr(n, {
      formItemContext: r
    }), s = async (c) => {
      t(nt, c), await He(), t(gt, c);
    }, u = S({
      get() {
        return n.modelValue;
      },
      set(c) {
        s(c);
      }
    });
    return yt(Oi, {
      ...sr(Tn(n), [
        "size",
        "min",
        "max",
        "disabled",
        "validateEvent",
        "fill",
        "textColor"
      ]),
      modelValue: u,
      changeEvent: s
    }), ge(() => n.modelValue, () => {
      n.validateEvent && (r == null || r.validate("change").catch((c) => _t(c)));
    }), (c, d) => {
      var f;
      return k(), ae(ht(c.tag), {
        id: i(a),
        class: I(i(o).b("group")),
        role: "group",
        "aria-label": i(l) ? void 0 : c.ariaLabel || "checkbox-group",
        "aria-labelledby": i(l) ? (f = i(r)) == null ? void 0 : f.labelId : void 0
      }, {
        default: H(() => [
          J(c.$slots, "default")
        ]),
        _: 3
      }, 8, ["id", "class", "aria-label", "aria-labelledby"]);
    };
  }
});
var P2 = /* @__PURE__ */ $e(A5, [["__file", "checkbox-group.vue"]]);
const er = ut(O5, {
  CheckboxButton: M2,
  CheckboxGroup: P2
}), L5 = nn(M2), R2 = nn(P2), A2 = Oe({
  modelValue: {
    type: [String, Number, Boolean],
    default: void 0
  },
  size: _n,
  disabled: Boolean,
  label: {
    type: [String, Number, Boolean],
    default: void 0
  },
  value: {
    type: [String, Number, Boolean],
    default: void 0
  },
  name: {
    type: String,
    default: void 0
  }
}), x5 = Oe({
  ...A2,
  border: Boolean
}), L2 = {
  [nt]: (e10) => Ve(e10) || Ye(e10) || Vt(e10),
  [gt]: (e10) => Ve(e10) || Ye(e10) || Vt(e10)
}, x2 = Symbol("radioGroupKey"), D2 = (e10, t) => {
  const n = L(), o = Le(x2, void 0), r = S(() => !!o), a = S(() => So(e10.value) ? e10.label : e10.value), l = S({
    get() {
      return r.value ? o.modelValue : e10.modelValue;
    },
    set(f) {
      r.value ? o.changeEvent(f) : t && t(nt, f), n.value.checked = e10.modelValue === a.value;
    }
  }), s = yn(S(() => o == null ? void 0 : o.size)), u = Hn(S(() => o == null ? void 0 : o.disabled)), c = L(false), d = S(() => u.value || r.value && l.value !== a.value ? -1 : 0);
  return _a({
    from: "label act as value",
    replacement: "value",
    version: "3.0.0",
    scope: "el-radio",
    ref: "https://element-plus.org/en-US/component/radio.html"
  }, S(() => r.value && So(e10.value))), {
    radioRef: n,
    isGroup: r,
    radioGroup: o,
    focus: c,
    size: s,
    disabled: u,
    tabIndex: d,
    modelValue: l,
    actualValue: a
  };
}, D5 = /* @__PURE__ */ j({
  name: "ElRadio"
}), V5 = /* @__PURE__ */ j({
  ...D5,
  props: x5,
  emits: L2,
  setup(e10, { emit: t }) {
    const n = e10, o = we("radio"), { radioRef: r, radioGroup: a, focus: l, size: s, disabled: u, modelValue: c, actualValue: d } = D2(n, t);
    function f() {
      He(() => t(gt, c.value));
    }
    return (p, v) => {
      var m;
      return k(), x("label", {
        class: I([
          i(o).b(),
          i(o).is("disabled", i(u)),
          i(o).is("focus", i(l)),
          i(o).is("bordered", p.border),
          i(o).is("checked", i(c) === i(d)),
          i(o).m(i(s))
        ])
      }, [
        B("span", {
          class: I([
            i(o).e("input"),
            i(o).is("disabled", i(u)),
            i(o).is("checked", i(c) === i(d))
          ])
        }, [
          lt(B("input", {
            ref_key: "radioRef",
            ref: r,
            "onUpdate:modelValue": (h) => Ot(c) ? c.value = h : null,
            class: I(i(o).e("original")),
            value: i(d),
            name: p.name || ((m = i(a)) == null ? void 0 : m.name),
            disabled: i(u),
            checked: i(c) === i(d),
            type: "radio",
            onFocus: (h) => l.value = true,
            onBlur: (h) => l.value = false,
            onChange: f,
            onClick: Xe(() => {
            }, ["stop"])
          }, null, 42, ["onUpdate:modelValue", "value", "name", "disabled", "checked", "onFocus", "onBlur", "onClick"]), [
            [gE, i(c)]
          ]),
          B("span", {
            class: I(i(o).e("inner"))
          }, null, 2)
        ], 2),
        B("span", {
          class: I(i(o).e("label")),
          onKeydown: Xe(() => {
          }, ["stop"])
        }, [
          J(p.$slots, "default", {}, () => [
            Ze(_e(p.label), 1)
          ])
        ], 42, ["onKeydown"])
      ], 2);
    };
  }
});
var F5 = /* @__PURE__ */ $e(V5, [["__file", "radio.vue"]]);
const B5 = Oe({
  ...A2
}), H5 = /* @__PURE__ */ j({
  name: "ElRadioButton"
}), z5 = /* @__PURE__ */ j({
  ...H5,
  props: B5,
  setup(e10) {
    const t = e10, n = we("radio"), { radioRef: o, focus: r, size: a, disabled: l, modelValue: s, radioGroup: u, actualValue: c } = D2(t), d = S(() => ({
      backgroundColor: (u == null ? void 0 : u.fill) || "",
      borderColor: (u == null ? void 0 : u.fill) || "",
      boxShadow: u != null && u.fill ? `-1px 0 0 0 ${u.fill}` : "",
      color: (u == null ? void 0 : u.textColor) || ""
    }));
    return (f, p) => {
      var v;
      return k(), x("label", {
        class: I([
          i(n).b("button"),
          i(n).is("active", i(s) === i(c)),
          i(n).is("disabled", i(l)),
          i(n).is("focus", i(r)),
          i(n).bm("button", i(a))
        ])
      }, [
        lt(B("input", {
          ref_key: "radioRef",
          ref: o,
          "onUpdate:modelValue": (m) => Ot(s) ? s.value = m : null,
          class: I(i(n).be("button", "original-radio")),
          value: i(c),
          type: "radio",
          name: f.name || ((v = i(u)) == null ? void 0 : v.name),
          disabled: i(l),
          onFocus: (m) => r.value = true,
          onBlur: (m) => r.value = false,
          onClick: Xe(() => {
          }, ["stop"])
        }, null, 42, ["onUpdate:modelValue", "value", "name", "disabled", "onFocus", "onBlur", "onClick"]), [
          [gE, i(s)]
        ]),
        B("span", {
          class: I(i(n).be("button", "inner")),
          style: ze(i(s) === i(c) ? i(d) : {}),
          onKeydown: Xe(() => {
          }, ["stop"])
        }, [
          J(f.$slots, "default", {}, () => [
            Ze(_e(f.label), 1)
          ])
        ], 46, ["onKeydown"])
      ], 2);
    };
  }
});
var V2 = /* @__PURE__ */ $e(z5, [["__file", "radio-button.vue"]]);
const K5 = Oe({
  id: {
    type: String,
    default: void 0
  },
  size: _n,
  disabled: Boolean,
  modelValue: {
    type: [String, Number, Boolean],
    default: void 0
  },
  fill: {
    type: String,
    default: ""
  },
  textColor: {
    type: String,
    default: ""
  },
  name: {
    type: String,
    default: void 0
  },
  validateEvent: {
    type: Boolean,
    default: true
  },
  ...Bn(["ariaLabel"])
}), W5 = L2, j5 = /* @__PURE__ */ j({
  name: "ElRadioGroup"
}), U5 = /* @__PURE__ */ j({
  ...j5,
  props: K5,
  emits: W5,
  setup(e10, { emit: t }) {
    const n = e10, o = we("radio"), r = Fn(), a = L(), { formItem: l } = Yn(), { inputId: s, isLabeledByFormItem: u } = tr(n, {
      formItemContext: l
    }), c = (f) => {
      t(nt, f), He(() => t(gt, f));
    };
    dt(() => {
      const f = a.value.querySelectorAll("[type=radio]"), p = f[0];
      !Array.from(f).some((v) => v.checked) && p && (p.tabIndex = 0);
    });
    const d = S(() => n.name || r.value);
    return yt(x2, It({
      ...Tn(n),
      changeEvent: c,
      name: d
    })), ge(() => n.modelValue, () => {
      n.validateEvent && (l == null || l.validate("change").catch((f) => _t(f)));
    }), (f, p) => (k(), x("div", {
      id: i(s),
      ref_key: "radioGroupRef",
      ref: a,
      class: I(i(o).b("group")),
      role: "radiogroup",
      "aria-label": i(u) ? void 0 : f.ariaLabel || "radio-group",
      "aria-labelledby": i(u) ? i(l).labelId : void 0
    }, [
      J(f.$slots, "default")
    ], 10, ["id", "aria-label", "aria-labelledby"]));
  }
});
var F2 = /* @__PURE__ */ $e(U5, [["__file", "radio-group.vue"]]);
const B2 = ut(F5, {
  RadioButton: V2,
  RadioGroup: F2
}), Y5 = nn(F2), q5 = nn(V2);
function G5(e10) {
  return !!(e10 != null && e10.every((t) => t.type === tn));
}
var X5 = /* @__PURE__ */ j({
  name: "NodeContent",
  setup() {
    return {
      ns: we("cascader-node")
    };
  },
  render() {
    const { ns: e10 } = this, { node: t, panel: n } = this.$parent, { data: o, label: r } = t, { renderLabelFn: a } = n, l = () => {
      let s = a == null ? void 0 : a({ node: t, data: o });
      return G5(s) && (s = r), s != null ? s : r;
    };
    return Ke("span", { class: e10.e("label") }, l());
  }
});
const Cg = Symbol(), J5 = /* @__PURE__ */ j({
  name: "ElCascaderNode",
  components: {
    ElCheckbox: er,
    ElRadio: B2,
    NodeContent: X5,
    ElIcon: Be,
    Check: sc,
    Loading: Yr,
    ArrowRight: oo
  },
  props: {
    node: {
      type: Object,
      required: true
    },
    menuId: String
  },
  emits: ["expand"],
  setup(e10, { emit: t }) {
    const n = Le(Cg), o = we("cascader-node"), r = S(() => n.isHoverMenu), a = S(() => n.config.multiple), l = S(() => n.config.checkStrictly), s = S(() => {
      var E;
      return (E = n.checkedNodes[0]) == null ? void 0 : E.uid;
    }), u = S(() => e10.node.isDisabled), c = S(() => e10.node.isLeaf), d = S(() => l.value && !c.value || !u.value), f = S(() => v(n.expandingNode)), p = S(() => l.value && n.checkedNodes.some(v)), v = (E) => {
      var T;
      const { level: O, uid: N } = e10.node;
      return ((T = E == null ? void 0 : E.pathNodes[O - 1]) == null ? void 0 : T.uid) === N;
    }, m = () => {
      f.value || n.expandNode(e10.node);
    }, h = (E) => {
      const { node: T } = e10;
      E !== T.checked && n.handleCheckChange(T, E);
    }, b = () => {
      n.lazyLoad(e10.node, () => {
        c.value || m();
      });
    }, g = (E) => {
      r.value && (w(), !c.value && t("expand", E));
    }, w = () => {
      const { node: E } = e10;
      !d.value || E.loading || (E.loaded ? m() : b());
    }, y = () => {
      r.value && !c.value || (c.value && !u.value && !l.value && !a.value ? C(true) : w());
    }, _ = (E) => {
      l.value ? (h(E), e10.node.loaded && m()) : C(E);
    }, C = (E) => {
      e10.node.loaded ? (h(E), !l.value && m()) : b();
    };
    return {
      panel: n,
      isHoverMenu: r,
      multiple: a,
      checkStrictly: l,
      checkedNodeId: s,
      isDisabled: u,
      isLeaf: c,
      expandable: d,
      inExpandingPath: f,
      inCheckedPath: p,
      ns: o,
      handleHoverExpand: g,
      handleExpand: w,
      handleClick: y,
      handleCheck: C,
      handleSelectCheck: _
    };
  }
});
function Z5(e10, t, n, o, r, a) {
  const l = je("el-checkbox"), s = je("el-radio"), u = je("check"), c = je("el-icon"), d = je("node-content"), f = je("loading"), p = je("arrow-right");
  return k(), x("li", {
    id: `${e10.menuId}-${e10.node.uid}`,
    role: "menuitem",
    "aria-haspopup": !e10.isLeaf,
    "aria-owns": e10.isLeaf ? void 0 : e10.menuId,
    "aria-expanded": e10.inExpandingPath,
    tabindex: e10.expandable ? -1 : void 0,
    class: I([
      e10.ns.b(),
      e10.ns.is("selectable", e10.checkStrictly),
      e10.ns.is("active", e10.node.checked),
      e10.ns.is("disabled", !e10.expandable),
      e10.inExpandingPath && "in-active-path",
      e10.inCheckedPath && "in-checked-path"
    ]),
    onMouseenter: e10.handleHoverExpand,
    onFocus: e10.handleHoverExpand,
    onClick: e10.handleClick
  }, [
    ee(" prefix "),
    e10.multiple ? (k(), ae(l, {
      key: 0,
      "model-value": e10.node.checked,
      indeterminate: e10.node.indeterminate,
      disabled: e10.isDisabled,
      onClick: Xe(() => {
      }, ["stop"]),
      "onUpdate:modelValue": e10.handleSelectCheck
    }, null, 8, ["model-value", "indeterminate", "disabled", "onClick", "onUpdate:modelValue"])) : e10.checkStrictly ? (k(), ae(s, {
      key: 1,
      "model-value": e10.checkedNodeId,
      label: e10.node.uid,
      disabled: e10.isDisabled,
      "onUpdate:modelValue": e10.handleSelectCheck,
      onClick: Xe(() => {
      }, ["stop"])
    }, {
      default: H(() => [
        ee(`
        Add an empty element to avoid render label,
        do not use empty fragment here for https://github.com/vuejs/vue-next/pull/2485
      `),
        B("span")
      ]),
      _: 1
    }, 8, ["model-value", "label", "disabled", "onUpdate:modelValue", "onClick"])) : e10.isLeaf && e10.node.checked ? (k(), ae(c, {
      key: 2,
      class: I(e10.ns.e("prefix"))
    }, {
      default: H(() => [
        W(u)
      ]),
      _: 1
    }, 8, ["class"])) : ee("v-if", true),
    ee(" content "),
    W(d),
    ee(" postfix "),
    e10.isLeaf ? ee("v-if", true) : (k(), x(Ie, { key: 3 }, [
      e10.node.loading ? (k(), ae(c, {
        key: 0,
        class: I([e10.ns.is("loading"), e10.ns.e("postfix")])
      }, {
        default: H(() => [
          W(f)
        ]),
        _: 1
      }, 8, ["class"])) : (k(), ae(c, {
        key: 1,
        class: I(["arrow-right", e10.ns.e("postfix")])
      }, {
        default: H(() => [
          W(p)
        ]),
        _: 1
      }, 8, ["class"]))
    ], 64))
  ], 42, ["id", "aria-haspopup", "aria-owns", "aria-expanded", "tabindex", "onMouseenter", "onFocus", "onClick"]);
}
var Q5 = /* @__PURE__ */ $e(J5, [["render", Z5], ["__file", "node.vue"]]);
const eB = /* @__PURE__ */ j({
  name: "ElCascaderMenu",
  components: {
    Loading: Yr,
    ElIcon: Be,
    ElScrollbar: ta,
    ElCascaderNode: Q5
  },
  props: {
    nodes: {
      type: Array,
      required: true
    },
    index: {
      type: Number,
      required: true
    }
  },
  setup(e10) {
    const t = it(), n = we("cascader-menu"), { t: o } = kt(), r = Fn();
    let a = null, l = null;
    const s = Le(Cg), u = L(null), c = S(() => !e10.nodes.length), d = S(() => !s.initialLoaded), f = S(() => `${r.value}-${e10.index}`), p = (b) => {
      a = b.target;
    }, v = (b) => {
      if (!(!s.isHoverMenu || !a || !u.value))
        if (a.contains(b.target)) {
          m();
          const g = t.vnode.el, { left: w } = g.getBoundingClientRect(), { offsetWidth: y, offsetHeight: _ } = g, C = b.clientX - w, E = a.offsetTop, T = E + a.offsetHeight;
          u.value.innerHTML = `
          <path style="pointer-events: auto;" fill="transparent" d="M${C} ${E} L${y} 0 V${E} Z" />
          <path style="pointer-events: auto;" fill="transparent" d="M${C} ${T} L${y} ${_} V${T} Z" />
        `;
        } else l || (l = window.setTimeout(h, s.config.hoverThreshold));
    }, m = () => {
      l && (clearTimeout(l), l = null);
    }, h = () => {
      u.value && (u.value.innerHTML = "", m());
    };
    return {
      ns: n,
      panel: s,
      hoverZone: u,
      isEmpty: c,
      isLoading: d,
      menuId: f,
      t: o,
      handleExpand: p,
      handleMouseMove: v,
      clearHoverZone: h
    };
  }
});
function tB(e10, t, n, o, r, a) {
  const l = je("el-cascader-node"), s = je("loading"), u = je("el-icon"), c = je("el-scrollbar");
  return k(), ae(c, {
    key: e10.menuId,
    tag: "ul",
    role: "menu",
    class: I(e10.ns.b()),
    "wrap-class": e10.ns.e("wrap"),
    "view-class": [e10.ns.e("list"), e10.ns.is("empty", e10.isEmpty)],
    onMousemove: e10.handleMouseMove,
    onMouseleave: e10.clearHoverZone
  }, {
    default: H(() => {
      var d;
      return [
        (k(true), x(Ie, null, st(e10.nodes, (f) => (k(), ae(l, {
          key: f.uid,
          node: f,
          "menu-id": e10.menuId,
          onExpand: e10.handleExpand
        }, null, 8, ["node", "menu-id", "onExpand"]))), 128)),
        e10.isLoading ? (k(), x("div", {
          key: 0,
          class: I(e10.ns.e("empty-text"))
        }, [
          W(u, {
            size: "14",
            class: I(e10.ns.is("loading"))
          }, {
            default: H(() => [
              W(s)
            ]),
            _: 1
          }, 8, ["class"]),
          Ze(" " + _e(e10.t("el.cascader.loading")), 1)
        ], 2)) : e10.isEmpty ? (k(), x("div", {
          key: 1,
          class: I(e10.ns.e("empty-text"))
        }, [
          J(e10.$slots, "empty", {}, () => [
            Ze(_e(e10.t("el.cascader.noData")), 1)
          ])
        ], 2)) : (d = e10.panel) != null && d.isHoverMenu ? (k(), x(Ie, { key: 2 }, [
          ee(" eslint-disable-next-line vue/html-self-closing "),
          (k(), x("svg", {
            ref: "hoverZone",
            class: I(e10.ns.e("hover-zone"))
          }, null, 2))
        ], 2112)) : ee("v-if", true)
      ];
    }),
    _: 3
  }, 8, ["class", "wrap-class", "view-class", "onMousemove", "onMouseleave"]);
}
var nB = /* @__PURE__ */ $e(eB, [["render", tB], ["__file", "menu.vue"]]);
const Eg = (e10 = "") => e10.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d"), xr = (e10) => rl(e10);
let oB = 0;
const rB = (e10) => {
  const t = [e10];
  let { parent: n } = e10;
  for (; n; )
    t.unshift(n), n = n.parent;
  return t;
};
let nh = class oh {
  constructor(t, n, o, r = false) {
    this.data = t, this.config = n, this.parent = o, this.root = r, this.uid = oB++, this.checked = false, this.indeterminate = false, this.loading = false;
    const { value: a, label: l, children: s } = n, u = t[s], c = rB(this);
    this.level = r ? 0 : o ? o.level + 1 : 1, this.value = t[a], this.label = t[l], this.pathNodes = c, this.pathValues = c.map((d) => d.value), this.pathLabels = c.map((d) => d.label), this.childrenData = u, this.children = (u || []).map((d) => new oh(d, n, this)), this.loaded = !n.lazy || this.isLeaf || !Ro(u);
  }
  get isDisabled() {
    const { data: t, parent: n, config: o } = this, { disabled: r, checkStrictly: a } = o;
    return (Fe(r) ? r(t, this) : !!t[r]) || !a && (n == null ? void 0 : n.isDisabled);
  }
  get isLeaf() {
    const { data: t, config: n, childrenData: o, loaded: r } = this, { lazy: a, leaf: l } = n, s = Fe(l) ? l(t, this) : t[l];
    return St(s) ? a && !r ? false : !(Se(o) && o.length) : !!s;
  }
  get valueByOption() {
    return this.config.emitPath ? this.pathValues : this.value;
  }
  appendChild(t) {
    const { childrenData: n, children: o } = this, r = new oh(t, this.config, this);
    return Se(n) ? n.push(t) : this.childrenData = [t], o.push(r), r;
  }
  calcText(t, n) {
    const o = t ? this.pathLabels.join(n) : this.label;
    return this.text = o, o;
  }
  broadcast(t, ...n) {
    const o = `onParent${xr(t)}`;
    this.children.forEach((r) => {
      r && (r.broadcast(t, ...n), r[o] && r[o](...n));
    });
  }
  emit(t, ...n) {
    const { parent: o } = this, r = `onChild${xr(t)}`;
    o && (o[r] && o[r](...n), o.emit(t, ...n));
  }
  onParentCheck(t) {
    this.isDisabled || this.setCheckState(t);
  }
  onChildCheck() {
    const { children: t } = this, n = t.filter((r) => !r.isDisabled), o = n.length ? n.every((r) => r.checked) : false;
    this.setCheckState(o);
  }
  setCheckState(t) {
    const n = this.children.length, o = this.children.reduce((r, a) => {
      const l = a.checked ? 1 : a.indeterminate ? 0.5 : 0;
      return r + l;
    }, 0);
    this.checked = this.loaded && this.children.filter((r) => !r.isDisabled).every((r) => r.loaded && r.checked) && t, this.indeterminate = this.loaded && o !== n && o > 0;
  }
  doCheck(t) {
    if (this.checked === t)
      return;
    const { checkStrictly: n, multiple: o } = this.config;
    n || !o ? this.checked = t : (this.broadcast("check", t), this.setCheckState(t), this.emit("check"));
  }
};
const rh = (e10, t) => e10.reduce((n, o) => (o.isLeaf ? n.push(o) : (!t && n.push(o), n = n.concat(rh(o.children, t))), n), []);
class h1 {
  constructor(t, n) {
    this.config = n;
    const o = (t || []).map((r) => new nh(r, this.config));
    this.nodes = o, this.allNodes = rh(o, false), this.leafNodes = rh(o, true);
  }
  getNodes() {
    return this.nodes;
  }
  getFlattedNodes(t) {
    return t ? this.leafNodes : this.allNodes;
  }
  appendNode(t, n) {
    const o = n ? n.appendChild(t) : new nh(t, this.config);
    n || this.nodes.push(o), this.appendAllNodesAndLeafNodes(o);
  }
  appendNodes(t, n) {
    t.forEach((o) => this.appendNode(o, n));
  }
  appendAllNodesAndLeafNodes(t) {
    this.allNodes.push(t), t.isLeaf && this.leafNodes.push(t), t.children && t.children.forEach((n) => {
      this.appendAllNodesAndLeafNodes(n);
    });
  }
  getNodeByValue(t, n = false) {
    return So(t) ? null : this.getFlattedNodes(n).find((r) => In(r.value, t) || In(r.pathValues, t)) || null;
  }
  getSameNode(t) {
    return t && this.getFlattedNodes(false).find(({ value: o, level: r }) => In(t.value, o) && t.level === r) || null;
  }
}
const H2 = Oe({
  modelValue: {
    type: ne([Number, String, Array])
  },
  options: {
    type: ne(Array),
    default: () => []
  },
  props: {
    type: ne(Object),
    default: () => ({})
  }
}), aB = {
  expandTrigger: "click",
  multiple: false,
  checkStrictly: false,
  emitPath: true,
  lazy: false,
  lazyLoad: Mt,
  value: "value",
  label: "label",
  children: "children",
  leaf: "leaf",
  disabled: "disabled",
  hoverThreshold: 500
}, lB = (e10) => S(() => ({
  ...aB,
  ...e10.props
})), m1 = (e10) => {
  if (!e10)
    return 0;
  const t = e10.id.split("-");
  return Number(t[t.length - 2]);
}, sB = (e10) => {
  if (!e10)
    return;
  const t = e10.querySelector("input");
  t ? t.click() : US(e10) && e10.click();
}, iB = (e10, t) => {
  const n = t.slice(0), o = n.map((a) => a.uid), r = e10.reduce((a, l) => {
    const s = o.indexOf(l.uid);
    return s > -1 && (a.push(l), n.splice(s, 1), o.splice(s, 1)), a;
  }, []);
  return r.push(...n), r;
}, g1 = (e10) => [...new Set(e10)], po = (e10) => !e10 && e10 !== 0 ? [] : Se(e10) ? e10 : [e10], uB = /* @__PURE__ */ j({
  name: "ElCascaderPanel",
  components: {
    ElCascaderMenu: nB
  },
  props: {
    ...H2,
    border: {
      type: Boolean,
      default: true
    },
    renderLabel: Function
  },
  emits: [nt, gt, "close", "expand-change"],
  setup(e10, { emit: t, slots: n }) {
    let o = false;
    const r = we("cascader"), a = lB(e10);
    let l = null;
    const s = L(true), u = L([]), c = L(null), d = L([]), f = L(null), p = L([]), v = S(() => a.value.expandTrigger === "hover"), m = S(() => e10.renderLabel || n.default), h = () => {
      const { options: P } = e10, z = a.value;
      o = false, l = new h1(P, z), d.value = [l.getNodes()], z.lazy && Ro(e10.options) ? (s.value = false, b(void 0, (Y) => {
        Y && (l = new h1(Y, z), d.value = [l.getNodes()]), s.value = true, O(false, true);
      })) : O(false, true);
    }, b = (P, z) => {
      const Y = a.value;
      P = P || new nh({}, Y, void 0, true), P.loading = true;
      const D = (M) => {
        const F = P, A = F.root ? null : F;
        M && (l == null || l.appendNodes(M, A)), F.loading = false, F.loaded = true, F.childrenData = F.childrenData || [], z && z(M);
      };
      Y.lazyLoad(P, D);
    }, g = (P, z) => {
      var Y;
      const { level: D } = P, M = d.value.slice(0, D);
      let F;
      P.isLeaf ? F = P.pathNodes[D - 2] : (F = P, M.push(P.children)), ((Y = f.value) == null ? void 0 : Y.uid) !== (F == null ? void 0 : F.uid) && (f.value = P, d.value = M, !z && t("expand-change", (P == null ? void 0 : P.pathValues) || []));
    }, w = (P, z, Y = true) => {
      const { checkStrictly: D, multiple: M } = a.value, F = p.value[0];
      o = true, !M && (F == null || F.doCheck(false)), P.doCheck(z), T(), Y && !M && !D && t("close"), !Y && !M && !D && y(P);
    }, y = (P) => {
      P && (P = P.parent, y(P), P && g(P));
    }, _ = (P) => l == null ? void 0 : l.getFlattedNodes(P), C = (P) => {
      var z;
      return (z = _(P)) == null ? void 0 : z.filter((Y) => Y.checked !== false);
    }, E = () => {
      p.value.forEach((P) => P.doCheck(false)), T(), d.value = d.value.slice(0, 1), f.value = null, t("expand-change", []);
    }, T = () => {
      var P;
      const { checkStrictly: z, multiple: Y } = a.value, D = p.value, M = C(!z), F = iB(D, M), A = F.map((V) => V.valueByOption);
      p.value = F, c.value = Y ? A : (P = A[0]) != null ? P : null;
    }, O = (P = false, z = false) => {
      const { modelValue: Y } = e10, { lazy: D, multiple: M, checkStrictly: F } = a.value, A = !F;
      if (!(!s.value || o || !z && In(Y, c.value)))
        if (D && !P) {
          const Z = g1(iL(po(Y))).map((G) => l == null ? void 0 : l.getNodeByValue(G)).filter((G) => !!G && !G.loaded && !G.loading);
          Z.length ? Z.forEach((G) => {
            b(G, () => O(false, z));
          }) : O(true, z);
        } else {
          const V = M ? po(Y) : [Y], Z = g1(V.map((G) => l == null ? void 0 : l.getNodeByValue(G, A)));
          N(Z, z), c.value = Jd(Y);
        }
    }, N = (P, z = true) => {
      const { checkStrictly: Y } = a.value, D = p.value, M = P.filter((V) => !!V && (Y || V.isLeaf)), F = l == null ? void 0 : l.getSameNode(f.value), A = z && F || M[0];
      A ? A.pathNodes.forEach((V) => g(V, true)) : f.value = null, D.forEach((V) => V.doCheck(false)), It(M).forEach((V) => V.doCheck(true)), p.value = M, He($);
    }, $ = () => {
      Et && u.value.forEach((P) => {
        const z = P == null ? void 0 : P.$el;
        if (z) {
          const Y = z.querySelector(`.${r.namespace.value}-scrollbar__wrap`), D = z.querySelector(`.${r.b("node")}.${r.is("active")}:last-child`) || z.querySelector(`.${r.b("node")}.in-active-path`);
          ng(Y, D);
        }
      });
    }, R = (P) => {
      const z = P.target, { code: Y } = P;
      switch (Y) {
        case xe.up:
        case xe.down: {
          P.preventDefault();
          const D = Y === xe.up ? -1 : 1;
          ld(YS(z, D, `.${r.b("node")}[tabindex="-1"]`));
          break;
        }
        case xe.left: {
          P.preventDefault();
          const D = u.value[m1(z) - 1], M = D == null ? void 0 : D.$el.querySelector(`.${r.b("node")}[aria-expanded="true"]`);
          ld(M);
          break;
        }
        case xe.right: {
          P.preventDefault();
          const D = u.value[m1(z) + 1], M = D == null ? void 0 : D.$el.querySelector(`.${r.b("node")}[tabindex="-1"]`);
          ld(M);
          break;
        }
        case xe.enter:
        case xe.numpadEnter:
          sB(z);
          break;
      }
    };
    return yt(Cg, It({
      config: a,
      expandingNode: f,
      checkedNodes: p,
      isHoverMenu: v,
      initialLoaded: s,
      renderLabelFn: m,
      lazyLoad: b,
      expandNode: g,
      handleCheckChange: w
    })), ge([a, () => e10.options], h, {
      deep: true,
      immediate: true
    }), ge(() => e10.modelValue, () => {
      o = false, O();
    }, {
      deep: true
    }), ge(() => c.value, (P) => {
      In(P, e10.modelValue) || (t(nt, P), t(gt, P));
    }), RC(() => u.value = []), dt(() => !Ro(e10.modelValue) && O()), {
      ns: r,
      menuList: u,
      menus: d,
      checkedNodes: p,
      handleKeyDown: R,
      handleCheckChange: w,
      getFlattedNodes: _,
      getCheckedNodes: C,
      clearCheckedNodes: E,
      calculateCheckedValue: T,
      scrollToExpandingNode: $
    };
  }
});
function cB(e10, t, n, o, r, a) {
  const l = je("el-cascader-menu");
  return k(), x("div", {
    class: I([e10.ns.b("panel"), e10.ns.is("bordered", e10.border)]),
    onKeydown: e10.handleKeyDown
  }, [
    (k(true), x(Ie, null, st(e10.menus, (s, u) => (k(), ae(l, {
      key: u,
      ref_for: true,
      ref: (c) => e10.menuList[u] = c,
      index: u,
      nodes: [...s]
    }, {
      empty: H(() => [
        J(e10.$slots, "empty")
      ]),
      _: 2
    }, 1032, ["index", "nodes"]))), 128))
  ], 42, ["onKeydown"]);
}
var dB = /* @__PURE__ */ $e(uB, [["render", cB], ["__file", "index.vue"]]);
const z2 = ut(dB), Ea = Oe({
  type: {
    type: String,
    values: ["primary", "success", "info", "warning", "danger"],
    default: "primary"
  },
  closable: Boolean,
  disableTransitions: Boolean,
  hit: Boolean,
  color: String,
  size: {
    type: String,
    values: Qr
  },
  effect: {
    type: String,
    values: ["dark", "light", "plain"],
    default: "light"
  },
  round: Boolean
}), fB = {
  close: (e10) => e10 instanceof MouseEvent,
  click: (e10) => e10 instanceof MouseEvent
}, pB = /* @__PURE__ */ j({
  name: "ElTag"
}), vB = /* @__PURE__ */ j({
  ...pB,
  props: Ea,
  emits: fB,
  setup(e10, { emit: t }) {
    const n = e10, o = yn(), r = we("tag"), a = S(() => {
      const { type: c, hit: d, effect: f, closable: p, round: v } = n;
      return [
        r.b(),
        r.is("closable", p),
        r.m(c || "primary"),
        r.m(o.value),
        r.m(f),
        r.is("hit", d),
        r.is("round", v)
      ];
    }), l = (c) => {
      t("close", c);
    }, s = (c) => {
      t("click", c);
    }, u = (c) => {
      var d, f, p;
      (p = (f = (d = c == null ? void 0 : c.component) == null ? void 0 : d.subTree) == null ? void 0 : f.component) != null && p.bum && (c.component.subTree.component.bum = null);
    };
    return (c, d) => c.disableTransitions ? (k(), x("span", {
      key: 0,
      class: I(i(a)),
      style: ze({ backgroundColor: c.color }),
      onClick: s
    }, [
      B("span", {
        class: I(i(r).e("content"))
      }, [
        J(c.$slots, "default")
      ], 2),
      c.closable ? (k(), ae(i(Be), {
        key: 0,
        class: I(i(r).e("close")),
        onClick: Xe(l, ["stop"])
      }, {
        default: H(() => [
          W(i(Jo))
        ]),
        _: 1
      }, 8, ["class", "onClick"])) : ee("v-if", true)
    ], 6)) : (k(), ae(Rn, {
      key: 1,
      name: `${i(r).namespace.value}-zoom-in-center`,
      appear: "",
      onVnodeMounted: u
    }, {
      default: H(() => [
        B("span", {
          class: I(i(a)),
          style: ze({ backgroundColor: c.color }),
          onClick: s
        }, [
          B("span", {
            class: I(i(r).e("content"))
          }, [
            J(c.$slots, "default")
          ], 2),
          c.closable ? (k(), ae(i(Be), {
            key: 0,
            class: I(i(r).e("close")),
            onClick: Xe(l, ["stop"])
          }, {
            default: H(() => [
              W(i(Jo))
            ]),
            _: 1
          }, 8, ["class", "onClick"])) : ee("v-if", true)
        ], 6)
      ]),
      _: 3
    }, 8, ["name"]));
  }
});
var hB = /* @__PURE__ */ $e(vB, [["__file", "tag.vue"]]);
const ai = ut(hB), mB = Oe({
  ...H2,
  size: _n,
  placeholder: String,
  disabled: Boolean,
  clearable: Boolean,
  filterable: Boolean,
  filterMethod: {
    type: ne(Function),
    default: (e10, t) => e10.text.includes(t)
  },
  separator: {
    type: String,
    default: " / "
  },
  showAllLevels: {
    type: Boolean,
    default: true
  },
  collapseTags: Boolean,
  maxCollapseTags: {
    type: Number,
    default: 1
  },
  collapseTagsTooltip: {
    type: Boolean,
    default: false
  },
  debounce: {
    type: Number,
    default: 300
  },
  beforeFilter: {
    type: ne(Function),
    default: () => true
  },
  placement: {
    type: ne(String),
    values: Pa,
    default: "bottom-start"
  },
  fallbackPlacements: {
    type: ne(Array),
    default: ["bottom-start", "bottom", "top-start", "top", "right", "left"]
  },
  popperClass: {
    type: String,
    default: ""
  },
  teleported: vn.teleported,
  tagType: { ...Ea.type, default: "info" },
  tagEffect: { ...Ea.effect, default: "light" },
  validateEvent: {
    type: Boolean,
    default: true
  },
  persistent: {
    type: Boolean,
    default: true
  },
  ...ki
}), gB = {
  [nt]: (e10) => true,
  [gt]: (e10) => true,
  focus: (e10) => e10 instanceof FocusEvent,
  blur: (e10) => e10 instanceof FocusEvent,
  clear: () => true,
  visibleChange: (e10) => Vt(e10),
  expandChange: (e10) => !!e10,
  removeTag: (e10) => !!e10
}, Wa = /* @__PURE__ */ new Map();
if (Et) {
  let e10;
  document.addEventListener("mousedown", (t) => e10 = t), document.addEventListener("mouseup", (t) => {
    if (e10) {
      for (const n of Wa.values())
        for (const { documentHandler: o } of n)
          o(t, e10);
      e10 = void 0;
    }
  });
}
function y1(e10, t) {
  let n = [];
  return Se(t.arg) ? n = t.arg : to(t.arg) && n.push(t.arg), function(o, r) {
    const a = t.instance.popperRef, l = o.target, s = r == null ? void 0 : r.target, u = !t || !t.instance, c = !l || !s, d = e10.contains(l) || e10.contains(s), f = e10 === l, p = n.length && n.some((m) => m == null ? void 0 : m.contains(l)) || n.length && n.includes(s), v = a && (a.contains(l) || a.contains(s));
    u || c || d || f || p || v || t.value(o, r);
  };
}
const Sa = {
  beforeMount(e10, t) {
    Wa.has(e10) || Wa.set(e10, []), Wa.get(e10).push({
      documentHandler: y1(e10, t),
      bindingFn: t.value
    });
  },
  updated(e10, t) {
    Wa.has(e10) || Wa.set(e10, []);
    const n = Wa.get(e10), o = n.findIndex((a) => a.bindingFn === t.oldValue), r = {
      documentHandler: y1(e10, t),
      bindingFn: t.value
    };
    o >= 0 ? n.splice(o, 1, r) : n.push(r);
  },
  unmounted(e10) {
    Wa.delete(e10);
  }
}, yB = "ElCascader", bB = /* @__PURE__ */ j({
  name: yB
}), _B = /* @__PURE__ */ j({
  ...bB,
  props: mB,
  emits: gB,
  setup(e10, { expose: t, emit: n }) {
    const o = e10, r = {
      modifiers: [
        {
          name: "arrowPosition",
          enabled: true,
          phase: "main",
          fn: ({ state: oe }) => {
            const { modifiersData: Ne, placement: Q } = oe;
            ["right", "left", "bottom", "top"].includes(Q) || Ne.arrow && (Ne.arrow.x = 35);
          },
          requires: ["arrow"]
        }
      ]
    }, a = Ta();
    let l = 0, s = 0;
    const u = we("cascader"), c = we("input"), { t: d } = kt(), { form: f, formItem: p } = Yn(), { valueOnClear: v } = Xf(o), { isComposing: m, handleComposition: h } = uc({
      afterComposition(oe) {
        var Ne;
        const Q = (Ne = oe.target) == null ? void 0 : Ne.value;
        We(Q);
      }
    }), b = L(null), g = L(null), w = L(null), y = L(null), _ = L(null), C = L(false), E = L(false), T = L(false), O = L(false), N = L(""), $ = L(""), R = L([]), P = L([]), z = L([]), Y = S(() => a.style), D = S(() => o.disabled || (f == null ? void 0 : f.disabled)), M = S(() => {
      var oe;
      return (oe = o.placeholder) != null ? oe : d("el.cascader.placeholder");
    }), F = S(() => $.value || R.value.length > 0 || m.value ? "" : M.value), A = yn(), V = S(() => A.value === "small" ? "small" : "default"), Z = S(() => !!o.props.multiple), G = S(() => !o.filterable || Z.value), le = S(() => Z.value ? $.value : N.value), X = S(() => {
      var oe;
      return ((oe = y.value) == null ? void 0 : oe.checkedNodes) || [];
    }), te = S(() => !o.clearable || D.value || T.value || !E.value ? false : !!X.value.length), ce = S(() => {
      const { showAllLevels: oe, separator: Ne } = o, Q = X.value;
      return Q.length ? Z.value ? "" : Q[0].calcText(oe, Ne) : "";
    }), pe = S(() => (p == null ? void 0 : p.validateState) || ""), se = S({
      get() {
        return Jd(o.modelValue);
      },
      set(oe) {
        const Ne = oe != null ? oe : v.value;
        n(nt, Ne), n(gt, Ne), o.validateEvent && (p == null || p.validate("change").catch((Q) => _t(Q)));
      }
    }), ve = S(() => [
      u.b(),
      u.m(A.value),
      u.is("disabled", D.value),
      a.class
    ]), me = S(() => [
      c.e("icon"),
      "icon-arrow-down",
      u.is("reverse", C.value)
    ]), De = S(() => u.is("focus", C.value || O.value)), Te = S(() => {
      var oe, Ne;
      return (Ne = (oe = b.value) == null ? void 0 : oe.popperRef) == null ? void 0 : Ne.contentRef;
    }), de = (oe) => {
      var Ne, Q, Me;
      D.value || (oe = oe != null ? oe : !C.value, oe !== C.value && (C.value = oe, (Q = (Ne = g.value) == null ? void 0 : Ne.input) == null || Q.setAttribute("aria-expanded", `${oe}`), oe ? (U(), He((Me = y.value) == null ? void 0 : Me.scrollToExpandingNode)) : o.filterable && ie(), n("visibleChange", oe)));
    }, U = () => {
      He(() => {
        var oe;
        (oe = b.value) == null || oe.updatePopper();
      });
    }, re = () => {
      T.value = false;
    }, he = (oe) => {
      const { showAllLevels: Ne, separator: Q } = o;
      return {
        node: oe,
        key: oe.uid,
        text: oe.calcText(Ne, Q),
        hitState: false,
        closable: !D.value && !oe.isDisabled,
        isCollapseTag: false
      };
    }, Ee = (oe) => {
      var Ne;
      const Q = oe.node;
      Q.doCheck(false), (Ne = y.value) == null || Ne.calculateCheckedValue(), n("removeTag", Q.valueByOption);
    }, ye = () => {
      if (!Z.value)
        return;
      const oe = X.value, Ne = [], Q = [];
      if (oe.forEach((Me) => Q.push(he(Me))), P.value = Q, oe.length) {
        oe.slice(0, o.maxCollapseTags).forEach((Ct) => Ne.push(he(Ct)));
        const Me = oe.slice(o.maxCollapseTags), Qe = Me.length;
        Qe && (o.collapseTags ? Ne.push({
          key: -1,
          text: `+ ${Qe}`,
          closable: false,
          isCollapseTag: true
        }) : Me.forEach((Ct) => Ne.push(he(Ct))));
      }
      R.value = Ne;
    }, K = () => {
      var oe, Ne;
      const { filterMethod: Q, showAllLevels: Me, separator: Qe } = o, Ct = (Ne = (oe = y.value) == null ? void 0 : oe.getFlattedNodes(!o.props.checkStrictly)) == null ? void 0 : Ne.filter((Kt) => Kt.isDisabled ? false : (Kt.calcText(Me, Qe), Q(Kt, le.value)));
      Z.value && (R.value.forEach((Kt) => {
        Kt.hitState = false;
      }), P.value.forEach((Kt) => {
        Kt.hitState = false;
      })), T.value = true, z.value = Ct, U();
    }, q = () => {
      var oe;
      let Ne;
      T.value && _.value ? Ne = _.value.$el.querySelector(`.${u.e("suggestion-item")}`) : Ne = (oe = y.value) == null ? void 0 : oe.$el.querySelector(`.${u.b("node")}[tabindex="-1"]`), Ne && (Ne.focus(), !T.value && Ne.click());
    }, ue = () => {
      var oe, Ne;
      const Q = (oe = g.value) == null ? void 0 : oe.input, Me = w.value, Qe = (Ne = _.value) == null ? void 0 : Ne.$el;
      if (!(!Et || !Q)) {
        if (Qe) {
          const Ct = Qe.querySelector(`.${u.e("suggestion-list")}`);
          Ct.style.minWidth = `${Q.offsetWidth}px`;
        }
        if (Me) {
          const { offsetHeight: Ct } = Me, Kt = R.value.length > 0 ? `${Math.max(Ct, l) - 2}px` : `${l}px`;
          Q.style.height = Kt, U();
        }
      }
    }, be = (oe) => {
      var Ne;
      return (Ne = y.value) == null ? void 0 : Ne.getCheckedNodes(oe);
    }, ke = (oe) => {
      U(), n("expandChange", oe);
    }, Ae = (oe) => {
      if (!m.value)
        switch (oe.code) {
          case xe.enter:
          case xe.numpadEnter:
            de();
            break;
          case xe.down:
            de(true), He(q), oe.preventDefault();
            break;
          case xe.esc:
            C.value === true && (oe.preventDefault(), oe.stopPropagation(), de(false));
            break;
          case xe.tab:
            de(false);
            break;
        }
    }, fe = () => {
      var oe;
      (oe = y.value) == null || oe.clearCheckedNodes(), !C.value && o.filterable && ie(), de(false), n("clear");
    }, ie = () => {
      const { value: oe } = ce;
      N.value = oe, $.value = oe;
    }, Ce = (oe) => {
      var Ne, Q;
      const { checked: Me } = oe;
      Z.value ? (Ne = y.value) == null || Ne.handleCheckChange(oe, !Me, false) : (!Me && ((Q = y.value) == null || Q.handleCheckChange(oe, true, false)), de(false));
    }, qe = (oe) => {
      const Ne = oe.target, { code: Q } = oe;
      switch (Q) {
        case xe.up:
        case xe.down: {
          oe.preventDefault();
          const Me = Q === xe.up ? -1 : 1;
          ld(YS(Ne, Me, `.${u.e("suggestion-item")}[tabindex="-1"]`));
          break;
        }
        case xe.enter:
        case xe.numpadEnter:
          Ne.click();
          break;
      }
    }, et = () => {
      const oe = R.value, Ne = oe[oe.length - 1];
      s = $.value ? 0 : s + 1, !(!Ne || !s || o.collapseTags && oe.length > 1) && (Ne.hitState ? Ee(Ne) : Ne.hitState = true);
    }, ft = (oe) => {
      const Ne = oe.target, Q = u.e("search-input");
      Ne.className === Q && (O.value = true), n("focus", oe);
    }, bt = (oe) => {
      O.value = false, n("blur", oe);
    }, zt = Oo(() => {
      const { value: oe } = le;
      if (!oe)
        return;
      const Ne = o.beforeFilter(oe);
      ol(Ne) ? Ne.then(K).catch(() => {
      }) : Ne !== false ? K() : re();
    }, o.debounce), We = (oe, Ne) => {
      !C.value && de(true), !(Ne != null && Ne.isComposing) && (oe ? zt() : re());
    }, ct = (oe) => Number.parseFloat(WL(c.cssVarName("input-height"), oe).value) - 2;
    return ge(T, U), ge([X, D, () => o.collapseTags], ye), ge(R, () => {
      He(() => ue());
    }), ge(A, async () => {
      await He();
      const oe = g.value.input;
      l = ct(oe) || l, ue();
    }), ge(ce, ie, { immediate: true }), dt(() => {
      const oe = g.value.input, Ne = ct(oe);
      l = oe.offsetHeight || Ne, en(oe, ue);
    }), t({
      getCheckedNodes: be,
      cascaderPanelRef: y,
      togglePopperVisible: de,
      contentRef: Te,
      presentText: ce
    }), (oe, Ne) => (k(), ae(i(Un), {
      ref_key: "tooltipRef",
      ref: b,
      visible: C.value,
      teleported: oe.teleported,
      "popper-class": [i(u).e("dropdown"), oe.popperClass],
      "popper-options": r,
      "fallback-placements": oe.fallbackPlacements,
      "stop-popper-mouse-event": false,
      "gpu-acceleration": false,
      placement: oe.placement,
      transition: `${i(u).namespace.value}-zoom-in-top`,
      effect: "light",
      pure: "",
      persistent: oe.persistent,
      onHide: re
    }, {
      default: H(() => [
        lt((k(), x("div", {
          class: I(i(ve)),
          style: ze(i(Y)),
          onClick: () => de(i(G) ? void 0 : true),
          onKeydown: Ae,
          onMouseenter: (Q) => E.value = true,
          onMouseleave: (Q) => E.value = false
        }, [
          W(i(eo), {
            ref_key: "input",
            ref: g,
            modelValue: N.value,
            "onUpdate:modelValue": (Q) => N.value = Q,
            placeholder: i(F),
            readonly: i(G),
            disabled: i(D),
            "validate-event": false,
            size: i(A),
            class: I(i(De)),
            tabindex: i(Z) && oe.filterable && !i(D) ? -1 : void 0,
            onCompositionstart: i(h),
            onCompositionupdate: i(h),
            onCompositionend: i(h),
            onFocus: ft,
            onBlur: bt,
            onInput: We
          }, ro({
            suffix: H(() => [
              i(te) ? (k(), ae(i(Be), {
                key: "clear",
                class: I([i(c).e("icon"), "icon-circle-close"]),
                onClick: Xe(fe, ["stop"])
              }, {
                default: H(() => [
                  W(i(Ma))
                ]),
                _: 1
              }, 8, ["class", "onClick"])) : (k(), ae(i(Be), {
                key: "arrow-down",
                class: I(i(me)),
                onClick: Xe((Q) => de(), ["stop"])
              }, {
                default: H(() => [
                  W(i(ea))
                ]),
                _: 1
              }, 8, ["class", "onClick"]))
            ]),
            _: 2
          }, [
            oe.$slots.prefix ? {
              name: "prefix",
              fn: H(() => [
                J(oe.$slots, "prefix")
              ])
            } : void 0
          ]), 1032, ["modelValue", "onUpdate:modelValue", "placeholder", "readonly", "disabled", "size", "class", "tabindex", "onCompositionstart", "onCompositionupdate", "onCompositionend"]),
          i(Z) ? (k(), x("div", {
            key: 0,
            ref_key: "tagWrapper",
            ref: w,
            class: I([
              i(u).e("tags"),
              i(u).is("validate", !!i(pe))
            ])
          }, [
            (k(true), x(Ie, null, st(R.value, (Q) => (k(), ae(i(ai), {
              key: Q.key,
              type: oe.tagType,
              size: i(V),
              effect: oe.tagEffect,
              hit: Q.hitState,
              closable: Q.closable,
              "disable-transitions": "",
              onClose: (Me) => Ee(Q)
            }, {
              default: H(() => [
                Q.isCollapseTag === false ? (k(), x("span", { key: 0 }, _e(Q.text), 1)) : (k(), ae(i(Un), {
                  key: 1,
                  disabled: C.value || !oe.collapseTagsTooltip,
                  "fallback-placements": ["bottom", "top", "right", "left"],
                  placement: "bottom",
                  effect: "light"
                }, {
                  default: H(() => [
                    B("span", null, _e(Q.text), 1)
                  ]),
                  content: H(() => [
                    B("div", {
                      class: I(i(u).e("collapse-tags"))
                    }, [
                      (k(true), x(Ie, null, st(P.value.slice(oe.maxCollapseTags), (Me, Qe) => (k(), x("div", {
                        key: Qe,
                        class: I(i(u).e("collapse-tag"))
                      }, [
                        (k(), ae(i(ai), {
                          key: Me.key,
                          class: "in-tooltip",
                          type: oe.tagType,
                          size: i(V),
                          effect: oe.tagEffect,
                          hit: Me.hitState,
                          closable: Me.closable,
                          "disable-transitions": "",
                          onClose: (Ct) => Ee(Me)
                        }, {
                          default: H(() => [
                            B("span", null, _e(Me.text), 1)
                          ]),
                          _: 2
                        }, 1032, ["type", "size", "effect", "hit", "closable", "onClose"]))
                      ], 2))), 128))
                    ], 2)
                  ]),
                  _: 2
                }, 1032, ["disabled"]))
              ]),
              _: 2
            }, 1032, ["type", "size", "effect", "hit", "closable", "onClose"]))), 128)),
            oe.filterable && !i(D) ? lt((k(), x("input", {
              key: 0,
              "onUpdate:modelValue": (Q) => $.value = Q,
              type: "text",
              class: I(i(u).e("search-input")),
              placeholder: i(ce) ? "" : i(M),
              onInput: (Q) => We($.value, Q),
              onClick: Xe((Q) => de(true), ["stop"]),
              onKeydown: Bt(et, ["delete"]),
              onCompositionstart: i(h),
              onCompositionupdate: i(h),
              onCompositionend: i(h),
              onFocus: ft,
              onBlur: bt
            }, null, 42, ["onUpdate:modelValue", "placeholder", "onInput", "onClick", "onKeydown", "onCompositionstart", "onCompositionupdate", "onCompositionend"])), [
              [Qu, $.value]
            ]) : ee("v-if", true)
          ], 2)) : ee("v-if", true)
        ], 46, ["onClick", "onMouseenter", "onMouseleave"])), [
          [i(Sa), () => de(false), i(Te)]
        ])
      ]),
      content: H(() => [
        lt(W(i(z2), {
          ref_key: "cascaderPanelRef",
          ref: y,
          modelValue: i(se),
          "onUpdate:modelValue": (Q) => Ot(se) ? se.value = Q : null,
          options: oe.options,
          props: o.props,
          border: false,
          "render-label": oe.$slots.default,
          onExpandChange: ke,
          onClose: (Q) => oe.$nextTick(() => de(false))
        }, {
          empty: H(() => [
            J(oe.$slots, "empty")
          ]),
          _: 3
        }, 8, ["modelValue", "onUpdate:modelValue", "options", "props", "render-label", "onClose"]), [
          [Nt, !T.value]
        ]),
        oe.filterable ? lt((k(), ae(i(ta), {
          key: 0,
          ref_key: "suggestionPanel",
          ref: _,
          tag: "ul",
          class: I(i(u).e("suggestion-panel")),
          "view-class": i(u).e("suggestion-list"),
          onKeydown: qe
        }, {
          default: H(() => [
            z.value.length ? (k(true), x(Ie, { key: 0 }, st(z.value, (Q) => (k(), x("li", {
              key: Q.uid,
              class: I([
                i(u).e("suggestion-item"),
                i(u).is("checked", Q.checked)
              ]),
              tabindex: -1,
              onClick: (Me) => Ce(Q)
            }, [
              J(oe.$slots, "suggestion-item", { item: Q }, () => [
                B("span", null, _e(Q.text), 1),
                Q.checked ? (k(), ae(i(Be), { key: 0 }, {
                  default: H(() => [
                    W(i(sc))
                  ]),
                  _: 1
                })) : ee("v-if", true)
              ])
            ], 10, ["onClick"]))), 128)) : J(oe.$slots, "empty", { key: 1 }, () => [
              B("li", {
                class: I(i(u).e("empty-text"))
              }, _e(i(d)("el.cascader.noMatch")), 3)
            ])
          ]),
          _: 3
        }, 8, ["class", "view-class"])), [
          [Nt, T.value]
        ]) : ee("v-if", true)
      ]),
      _: 3
    }, 8, ["visible", "teleported", "popper-class", "fallback-placements", "placement", "transition", "persistent"]));
  }
});
var wB = /* @__PURE__ */ $e(_B, [["__file", "cascader.vue"]]);
const CB = ut(wB), EB = Oe({
  checked: Boolean,
  disabled: Boolean,
  type: {
    type: String,
    values: ["primary", "success", "info", "warning", "danger"],
    default: "primary"
  }
}), SB = {
  "update:checked": (e10) => Vt(e10),
  [gt]: (e10) => Vt(e10)
}, kB = /* @__PURE__ */ j({
  name: "ElCheckTag"
}), NB = /* @__PURE__ */ j({
  ...kB,
  props: EB,
  emits: SB,
  setup(e10, { emit: t }) {
    const n = e10, o = we("check-tag"), r = S(() => n.disabled), a = S(() => [
      o.b(),
      o.is("checked", n.checked),
      o.is("disabled", r.value),
      o.m(n.type || "primary")
    ]), l = () => {
      if (r.value)
        return;
      const s = !n.checked;
      t(gt, s), t("update:checked", s);
    };
    return (s, u) => (k(), x("span", {
      class: I(i(a)),
      onClick: l
    }, [
      J(s.$slots, "default")
    ], 2));
  }
});
var TB = /* @__PURE__ */ $e(NB, [["__file", "check-tag.vue"]]);
const OB = ut(TB), $B = Oe({
  tag: {
    type: String,
    default: "div"
  },
  span: {
    type: Number,
    default: 24
  },
  offset: {
    type: Number,
    default: 0
  },
  pull: {
    type: Number,
    default: 0
  },
  push: {
    type: Number,
    default: 0
  },
  xs: {
    type: ne([Number, Object]),
    default: () => rn({})
  },
  sm: {
    type: ne([Number, Object]),
    default: () => rn({})
  },
  md: {
    type: ne([Number, Object]),
    default: () => rn({})
  },
  lg: {
    type: ne([Number, Object]),
    default: () => rn({})
  },
  xl: {
    type: ne([Number, Object]),
    default: () => rn({})
  }
}), K2 = Symbol("rowContextKey"), IB = /* @__PURE__ */ j({
  name: "ElCol"
}), MB = /* @__PURE__ */ j({
  ...IB,
  props: $B,
  setup(e10) {
    const t = e10, { gutter: n } = Le(K2, { gutter: S(() => 0) }), o = we("col"), r = S(() => {
      const l = {};
      return n.value && (l.paddingLeft = l.paddingRight = `${n.value / 2}px`), l;
    }), a = S(() => {
      const l = [];
      return ["span", "offset", "pull", "push"].forEach((c) => {
        const d = t[c];
        Ye(d) && (c === "span" ? l.push(o.b(`${t[c]}`)) : d > 0 && l.push(o.b(`${c}-${t[c]}`)));
      }), ["xs", "sm", "md", "lg", "xl"].forEach((c) => {
        Ye(t[c]) ? l.push(o.b(`${c}-${t[c]}`)) : at(t[c]) && Object.entries(t[c]).forEach(([d, f]) => {
          l.push(d !== "span" ? o.b(`${c}-${d}-${f}`) : o.b(`${c}-${f}`));
        });
      }), n.value && l.push(o.is("guttered")), [o.b(), l];
    });
    return (l, s) => (k(), ae(ht(l.tag), {
      class: I(i(a)),
      style: ze(i(r))
    }, {
      default: H(() => [
        J(l.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "style"]));
  }
});
var PB = /* @__PURE__ */ $e(MB, [["__file", "col.vue"]]);
const RB = ut(PB), b1 = (e10) => Ye(e10) || Ve(e10) || Se(e10), AB = Oe({
  accordion: Boolean,
  modelValue: {
    type: ne([Array, String, Number]),
    default: () => rn([])
  },
  expandIconPosition: {
    type: ne([String]),
    default: "right"
  },
  beforeCollapse: {
    type: ne(Function)
  }
}), LB = {
  [nt]: b1,
  [gt]: b1
}, W2 = Symbol("collapseContextKey"), _1 = "ElCollapse", xB = (e10, t) => {
  const n = L(Zn(e10.modelValue)), o = (l) => {
    n.value = l;
    const s = e10.accordion ? n.value[0] : n.value;
    t(nt, s), t(gt, s);
  }, r = (l) => {
    if (e10.accordion)
      o([n.value[0] === l ? "" : l]);
    else {
      const s = [...n.value], u = s.indexOf(l);
      u > -1 ? s.splice(u, 1) : s.push(l), o(s);
    }
  }, a = async (l) => {
    const { beforeCollapse: s } = e10;
    if (!s) {
      r(l);
      return;
    }
    const u = s(l);
    [
      ol(u),
      Vt(u)
    ].includes(true) || Qt(_1, "beforeCollapse must return type `Promise<boolean>` or `boolean`"), ol(u) ? u.then((d) => {
      d !== false && r(l);
    }).catch((d) => {
      _t(_1, `some error occurred: ${d}`);
    }) : u && r(l);
  };
  return ge(() => e10.modelValue, () => n.value = Zn(e10.modelValue), { deep: true }), yt(W2, {
    activeNames: n,
    handleItemClick: a
  }), {
    activeNames: n,
    setActiveNames: o
  };
}, DB = (e10) => {
  const t = we("collapse");
  return {
    rootKls: S(() => [
      t.b(),
      t.b(`icon-position-${e10.expandIconPosition}`)
    ])
  };
}, VB = /* @__PURE__ */ j({
  name: "ElCollapse"
}), FB = /* @__PURE__ */ j({
  ...VB,
  props: AB,
  emits: LB,
  setup(e10, { expose: t, emit: n }) {
    const o = e10, { activeNames: r, setActiveNames: a } = xB(o, n), { rootKls: l } = DB(o);
    return t({
      activeNames: r,
      setActiveNames: a
    }), (s, u) => (k(), x("div", {
      class: I(i(l))
    }, [
      J(s.$slots, "default")
    ], 2));
  }
});
var BB = /* @__PURE__ */ $e(FB, [["__file", "collapse.vue"]]);
const HB = /* @__PURE__ */ j({
  name: "ElCollapseTransition"
}), zB = /* @__PURE__ */ j({
  ...HB,
  setup(e10) {
    const t = we("collapse-transition"), n = (r) => {
      r.style.maxHeight = "", r.style.overflow = r.dataset.oldOverflow, r.style.paddingTop = r.dataset.oldPaddingTop, r.style.paddingBottom = r.dataset.oldPaddingBottom;
    }, o = {
      beforeEnter(r) {
        r.dataset || (r.dataset = {}), r.dataset.oldPaddingTop = r.style.paddingTop, r.dataset.oldPaddingBottom = r.style.paddingBottom, r.style.height && (r.dataset.elExistsHeight = r.style.height), r.style.maxHeight = 0, r.style.paddingTop = 0, r.style.paddingBottom = 0;
      },
      enter(r) {
        requestAnimationFrame(() => {
          r.dataset.oldOverflow = r.style.overflow, r.dataset.elExistsHeight ? r.style.maxHeight = r.dataset.elExistsHeight : r.scrollHeight !== 0 ? r.style.maxHeight = `${r.scrollHeight}px` : r.style.maxHeight = 0, r.style.paddingTop = r.dataset.oldPaddingTop, r.style.paddingBottom = r.dataset.oldPaddingBottom, r.style.overflow = "hidden";
        });
      },
      afterEnter(r) {
        r.style.maxHeight = "", r.style.overflow = r.dataset.oldOverflow;
      },
      enterCancelled(r) {
        n(r);
      },
      beforeLeave(r) {
        r.dataset || (r.dataset = {}), r.dataset.oldPaddingTop = r.style.paddingTop, r.dataset.oldPaddingBottom = r.style.paddingBottom, r.dataset.oldOverflow = r.style.overflow, r.style.maxHeight = `${r.scrollHeight}px`, r.style.overflow = "hidden";
      },
      leave(r) {
        r.scrollHeight !== 0 && (r.style.maxHeight = 0, r.style.paddingTop = 0, r.style.paddingBottom = 0);
      },
      afterLeave(r) {
        n(r);
      },
      leaveCancelled(r) {
        n(r);
      }
    };
    return (r, a) => (k(), ae(Rn, vt({
      name: i(t).b()
    }, yI(o)), {
      default: H(() => [
        J(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["name"]));
  }
});
var KB = /* @__PURE__ */ $e(zB, [["__file", "collapse-transition.vue"]]);
const lp = ut(KB), WB = Oe({
  title: {
    type: String,
    default: ""
  },
  name: {
    type: ne([String, Number]),
    default: void 0
  },
  icon: {
    type: Ht,
    default: oo
  },
  disabled: Boolean
}), jB = (e10) => {
  const t = Le(W2), { namespace: n } = we("collapse"), o = L(false), r = L(false), a = ig(), l = S(() => a.current++), s = S(() => {
    var p;
    return (p = e10.name) != null ? p : `${n.value}-id-${a.prefix}-${i(l)}`;
  }), u = S(() => t == null ? void 0 : t.activeNames.value.includes(i(s)));
  return {
    focusing: o,
    id: l,
    isActive: u,
    handleFocus: () => {
      setTimeout(() => {
        r.value ? r.value = false : o.value = true;
      }, 50);
    },
    handleHeaderClick: (p) => {
      if (e10.disabled)
        return;
      const v = p.target;
      v != null && v.closest("input, textarea, select") || (t == null || t.handleItemClick(i(s)), o.value = false, r.value = true);
    },
    handleEnterClick: (p) => {
      const v = p.target;
      v != null && v.closest("input, textarea, select") || (p.preventDefault(), t == null || t.handleItemClick(i(s)));
    }
  };
}, UB = (e10, { focusing: t, isActive: n, id: o }) => {
  const r = we("collapse"), a = S(() => [
    r.b("item"),
    r.is("active", i(n)),
    r.is("disabled", e10.disabled)
  ]), l = S(() => [
    r.be("item", "header"),
    r.is("active", i(n)),
    { focusing: i(t) && !e10.disabled }
  ]), s = S(() => [
    r.be("item", "arrow"),
    r.is("active", i(n))
  ]), u = S(() => [r.be("item", "title")]), c = S(() => r.be("item", "wrap")), d = S(() => r.be("item", "content")), f = S(() => r.b(`content-${i(o)}`)), p = S(() => r.b(`head-${i(o)}`));
  return {
    itemTitleKls: u,
    arrowKls: s,
    headKls: l,
    rootKls: a,
    itemWrapperKls: c,
    itemContentKls: d,
    scopedContentId: f,
    scopedHeadId: p
  };
}, YB = /* @__PURE__ */ j({
  name: "ElCollapseItem"
}), qB = /* @__PURE__ */ j({
  ...YB,
  props: WB,
  setup(e10, { expose: t }) {
    const n = e10, {
      focusing: o,
      id: r,
      isActive: a,
      handleFocus: l,
      handleHeaderClick: s,
      handleEnterClick: u
    } = jB(n), {
      arrowKls: c,
      headKls: d,
      rootKls: f,
      itemTitleKls: p,
      itemWrapperKls: v,
      itemContentKls: m,
      scopedContentId: h,
      scopedHeadId: b
    } = UB(n, { focusing: o, isActive: a, id: r });
    return t({
      isActive: a
    }), (g, w) => (k(), x("div", {
      class: I(i(f))
    }, [
      B("div", {
        id: i(b),
        class: I(i(d)),
        "aria-expanded": i(a),
        "aria-controls": i(h),
        "aria-describedby": i(h),
        tabindex: g.disabled ? -1 : 0,
        role: "button",
        onClick: i(s),
        onKeydown: Bt(Xe(i(u), ["stop"]), ["space", "enter"]),
        onFocus: i(l),
        onBlur: (y) => o.value = false
      }, [
        B("span", {
          class: I(i(p))
        }, [
          J(g.$slots, "title", { isActive: i(a) }, () => [
            Ze(_e(g.title), 1)
          ])
        ], 2),
        J(g.$slots, "icon", { isActive: i(a) }, () => [
          W(i(Be), {
            class: I(i(c))
          }, {
            default: H(() => [
              (k(), ae(ht(g.icon)))
            ]),
            _: 1
          }, 8, ["class"])
        ])
      ], 42, ["id", "aria-expanded", "aria-controls", "aria-describedby", "tabindex", "onClick", "onKeydown", "onFocus", "onBlur"]),
      W(i(lp), null, {
        default: H(() => [
          lt(B("div", {
            id: i(h),
            role: "region",
            class: I(i(v)),
            "aria-hidden": !i(a),
            "aria-labelledby": i(b)
          }, [
            B("div", {
              class: I(i(m))
            }, [
              J(g.$slots, "default")
            ], 2)
          ], 10, ["id", "aria-hidden", "aria-labelledby"]), [
            [Nt, i(a)]
          ])
        ]),
        _: 3
      })
    ], 2));
  }
});
var j2 = /* @__PURE__ */ $e(qB, [["__file", "collapse-item.vue"]]);
const GB = ut(BB, {
  CollapseItem: j2
}), XB = nn(j2), JB = Oe({
  color: {
    type: ne(Object),
    required: true
  },
  vertical: {
    type: Boolean,
    default: false
  }
});
let av = false;
function Nu(e10, t) {
  if (!Et)
    return;
  const n = function(a) {
    var l;
    (l = t.drag) == null || l.call(t, a);
  }, o = function(a) {
    var l;
    document.removeEventListener("mousemove", n), document.removeEventListener("mouseup", o), document.removeEventListener("touchmove", n), document.removeEventListener("touchend", o), document.onselectstart = null, document.ondragstart = null, av = false, (l = t.end) == null || l.call(t, a);
  }, r = function(a) {
    var l;
    av || (a.preventDefault(), document.onselectstart = () => false, document.ondragstart = () => false, document.addEventListener("mousemove", n), document.addEventListener("mouseup", o), document.addEventListener("touchmove", n), document.addEventListener("touchend", o), av = true, (l = t.start) == null || l.call(t, a));
  };
  e10.addEventListener("mousedown", r), e10.addEventListener("touchstart", r, { passive: false });
}
const ZB = (e10, t) => {
  if (!Et || !e10 || !t)
    return false;
  const n = e10.getBoundingClientRect();
  let o;
  return t instanceof Element ? o = t.getBoundingClientRect() : o = {
    top: 0,
    right: window.innerWidth,
    bottom: window.innerHeight,
    left: 0
  }, n.top < o.bottom && n.bottom > o.top && n.right > o.left && n.left < o.right;
}, w1 = (e10) => {
  let t = 0, n = e10;
  for (; n; )
    t += n.offsetTop, n = n.offsetParent;
  return t;
}, ah = (e10, t) => Math.abs(w1(e10) - w1(t)), Sg = (e10) => {
  let t, n;
  return e10.type === "touchend" ? (n = e10.changedTouches[0].clientY, t = e10.changedTouches[0].clientX) : e10.type.startsWith("touch") ? (n = e10.touches[0].clientY, t = e10.touches[0].clientX) : (n = e10.clientY, t = e10.clientX), {
    clientX: t,
    clientY: n
  };
}, QB = (e10) => {
  const t = it(), { t: n } = kt(), o = qt(), r = qt(), a = S(() => e10.color.get("alpha")), l = S(() => n("el.colorpicker.alphaLabel"));
  function s(f) {
    var p;
    f.target !== o.value && u(f), (p = o.value) == null || p.focus();
  }
  function u(f) {
    if (!r.value || !o.value)
      return;
    const v = t.vnode.el.getBoundingClientRect(), { clientX: m, clientY: h } = Sg(f);
    if (e10.vertical) {
      let b = h - v.top;
      b = Math.max(o.value.offsetHeight / 2, b), b = Math.min(b, v.height - o.value.offsetHeight / 2), e10.color.set("alpha", Math.round((b - o.value.offsetHeight / 2) / (v.height - o.value.offsetHeight) * 100));
    } else {
      let b = m - v.left;
      b = Math.max(o.value.offsetWidth / 2, b), b = Math.min(b, v.width - o.value.offsetWidth / 2), e10.color.set("alpha", Math.round((b - o.value.offsetWidth / 2) / (v.width - o.value.offsetWidth) * 100));
    }
  }
  function c(f) {
    const { code: p, shiftKey: v } = f, m = v ? 10 : 1;
    switch (p) {
      case xe.left:
      case xe.down:
        f.preventDefault(), f.stopPropagation(), d(-m);
        break;
      case xe.right:
      case xe.up:
        f.preventDefault(), f.stopPropagation(), d(m);
        break;
    }
  }
  function d(f) {
    let p = a.value + f;
    p = p < 0 ? 0 : p > 100 ? 100 : p, e10.color.set("alpha", p);
  }
  return {
    thumb: o,
    bar: r,
    alpha: a,
    alphaLabel: l,
    handleDrag: u,
    handleClick: s,
    handleKeydown: c
  };
}, eH = (e10, {
  bar: t,
  thumb: n,
  handleDrag: o
}) => {
  const r = it(), a = we("color-alpha-slider"), l = L(0), s = L(0), u = L();
  function c() {
    if (!n.value || e10.vertical)
      return 0;
    const w = r.vnode.el, y = e10.color.get("alpha");
    return w ? Math.round(y * (w.offsetWidth - n.value.offsetWidth / 2) / 100) : 0;
  }
  function d() {
    if (!n.value)
      return 0;
    const w = r.vnode.el;
    if (!e10.vertical)
      return 0;
    const y = e10.color.get("alpha");
    return w ? Math.round(y * (w.offsetHeight - n.value.offsetHeight / 2) / 100) : 0;
  }
  function f() {
    if (e10.color && e10.color.value) {
      const { r: w, g: y, b: _ } = e10.color.toRgb();
      return `linear-gradient(to right, rgba(${w}, ${y}, ${_}, 0) 0%, rgba(${w}, ${y}, ${_}, 1) 100%)`;
    }
    return "";
  }
  function p() {
    l.value = c(), s.value = d(), u.value = f();
  }
  dt(() => {
    if (!t.value || !n.value)
      return;
    const w = {
      drag: (y) => {
        o(y);
      },
      end: (y) => {
        o(y);
      }
    };
    Nu(t.value, w), Nu(n.value, w), p();
  }), ge(() => e10.color.get("alpha"), () => p()), ge(() => e10.color.value, () => p());
  const v = S(() => [a.b(), a.is("vertical", e10.vertical)]), m = S(() => a.e("bar")), h = S(() => a.e("thumb")), b = S(() => ({ background: u.value })), g = S(() => ({
    left: sn(l.value),
    top: sn(s.value)
  }));
  return { rootKls: v, barKls: m, barStyle: b, thumbKls: h, thumbStyle: g, update: p };
}, tH = "ElColorAlphaSlider", nH = /* @__PURE__ */ j({
  name: tH
}), oH = /* @__PURE__ */ j({
  ...nH,
  props: JB,
  setup(e10, { expose: t }) {
    const n = e10, {
      alpha: o,
      alphaLabel: r,
      bar: a,
      thumb: l,
      handleDrag: s,
      handleClick: u,
      handleKeydown: c
    } = QB(n), { rootKls: d, barKls: f, barStyle: p, thumbKls: v, thumbStyle: m, update: h } = eH(n, {
      bar: a,
      thumb: l,
      handleDrag: s
    });
    return t({
      update: h,
      bar: a,
      thumb: l
    }), (b, g) => (k(), x("div", {
      class: I(i(d))
    }, [
      B("div", {
        ref_key: "bar",
        ref: a,
        class: I(i(f)),
        style: ze(i(p)),
        onClick: i(u)
      }, null, 14, ["onClick"]),
      B("div", {
        ref_key: "thumb",
        ref: l,
        class: I(i(v)),
        style: ze(i(m)),
        "aria-label": i(r),
        "aria-valuenow": i(o),
        "aria-orientation": b.vertical ? "vertical" : "horizontal",
        "aria-valuemin": "0",
        "aria-valuemax": "100",
        role: "slider",
        tabindex: "0",
        onKeydown: i(c)
      }, null, 46, ["aria-label", "aria-valuenow", "aria-orientation", "onKeydown"])
    ], 2));
  }
});
var rH = /* @__PURE__ */ $e(oH, [["__file", "alpha-slider.vue"]]);
const aH = /* @__PURE__ */ j({
  name: "ElColorHueSlider",
  props: {
    color: {
      type: Object,
      required: true
    },
    vertical: Boolean
  },
  setup(e10) {
    const t = we("color-hue-slider"), n = it(), o = L(), r = L(), a = L(0), l = L(0), s = S(() => e10.color.get("hue"));
    ge(() => s.value, () => {
      p();
    });
    function u(v) {
      v.target !== o.value && c(v);
    }
    function c(v) {
      if (!r.value || !o.value)
        return;
      const h = n.vnode.el.getBoundingClientRect(), { clientX: b, clientY: g } = Sg(v);
      let w;
      if (e10.vertical) {
        let y = g - h.top;
        y = Math.min(y, h.height - o.value.offsetHeight / 2), y = Math.max(o.value.offsetHeight / 2, y), w = Math.round((y - o.value.offsetHeight / 2) / (h.height - o.value.offsetHeight) * 360);
      } else {
        let y = b - h.left;
        y = Math.min(y, h.width - o.value.offsetWidth / 2), y = Math.max(o.value.offsetWidth / 2, y), w = Math.round((y - o.value.offsetWidth / 2) / (h.width - o.value.offsetWidth) * 360);
      }
      e10.color.set("hue", w);
    }
    function d() {
      if (!o.value)
        return 0;
      const v = n.vnode.el;
      if (e10.vertical)
        return 0;
      const m = e10.color.get("hue");
      return v ? Math.round(m * (v.offsetWidth - o.value.offsetWidth / 2) / 360) : 0;
    }
    function f() {
      if (!o.value)
        return 0;
      const v = n.vnode.el;
      if (!e10.vertical)
        return 0;
      const m = e10.color.get("hue");
      return v ? Math.round(m * (v.offsetHeight - o.value.offsetHeight / 2) / 360) : 0;
    }
    function p() {
      a.value = d(), l.value = f();
    }
    return dt(() => {
      if (!r.value || !o.value)
        return;
      const v = {
        drag: (m) => {
          c(m);
        },
        end: (m) => {
          c(m);
        }
      };
      Nu(r.value, v), Nu(o.value, v), p();
    }), {
      bar: r,
      thumb: o,
      thumbLeft: a,
      thumbTop: l,
      hueValue: s,
      handleClick: u,
      update: p,
      ns: t
    };
  }
});
function lH(e10, t, n, o, r, a) {
  return k(), x("div", {
    class: I([e10.ns.b(), e10.ns.is("vertical", e10.vertical)])
  }, [
    B("div", {
      ref: "bar",
      class: I(e10.ns.e("bar")),
      onClick: e10.handleClick
    }, null, 10, ["onClick"]),
    B("div", {
      ref: "thumb",
      class: I(e10.ns.e("thumb")),
      style: ze({
        left: e10.thumbLeft + "px",
        top: e10.thumbTop + "px"
      })
    }, null, 6)
  ], 2);
}
var sH = /* @__PURE__ */ $e(aH, [["render", lH], ["__file", "hue-slider.vue"]]);
const iH = Oe({
  modelValue: String,
  id: String,
  showAlpha: Boolean,
  colorFormat: String,
  disabled: Boolean,
  size: _n,
  popperClass: {
    type: String,
    default: ""
  },
  tabindex: {
    type: [String, Number],
    default: 0
  },
  teleported: vn.teleported,
  predefine: {
    type: ne(Array)
  },
  validateEvent: {
    type: Boolean,
    default: true
  },
  ...Bn(["ariaLabel"])
}), uH = {
  [nt]: (e10) => Ve(e10) || Nn(e10),
  [gt]: (e10) => Ve(e10) || Nn(e10),
  activeChange: (e10) => Ve(e10) || Nn(e10),
  focus: (e10) => e10 instanceof FocusEvent,
  blur: (e10) => e10 instanceof FocusEvent
}, U2 = Symbol("colorPickerContextKey");
class of {
  constructor(t = {}) {
    this._hue = 0, this._saturation = 100, this._value = 100, this._alpha = 100, this._tiny = new Is(), this._isValid = false, this.enableAlpha = false, this.format = "", this.value = "";
    for (const n in t)
      Tt(t, n) && (this[n] = t[n]);
    t.value ? this.fromString(t.value) : this.doOnChange();
  }
  set(t, n) {
    if (arguments.length === 1 && typeof t == "object") {
      for (const o in t)
        Tt(t, o) && this.set(o, t[o]);
      return;
    }
    this[`_${t}`] = n, this._isValid = true, this.doOnChange();
  }
  get(t) {
    return ["hue", "saturation", "value", "alpha"].includes(t) ? Math.round(this[`_${t}`]) : this[`_${t}`];
  }
  toRgb() {
    return this._isValid ? this._tiny.toRgb() : { r: 255, g: 255, b: 255, a: 0 };
  }
  fromString(t) {
    const n = new Is(t);
    if (this._isValid = n.isValid, n.isValid) {
      const { h: o, s: r, v: a, a: l } = n.toHsv();
      this._hue = o, this._saturation = r * 100, this._value = a * 100, this._alpha = l * 100;
    } else
      this._hue = 0, this._saturation = 100, this._value = 100, this._alpha = 100;
    this.doOnChange();
  }
  compare(t) {
    const n = new Is({
      h: t._hue,
      s: t._saturation / 100,
      v: t._value / 100,
      a: t._alpha / 100
    });
    return this._tiny.equals(n);
  }
  doOnChange() {
    const { _hue: t, _saturation: n, _value: o, _alpha: r, format: a, enableAlpha: l } = this;
    let s = a || (l ? "rgb" : "hex");
    a === "hex" && l && (s = "hex8"), this._tiny = new Is({
      h: t,
      s: n / 100,
      v: o / 100,
      a: r / 100
    }), this.value = this._isValid ? this._tiny.toString(s) : "";
  }
}
const cH = /* @__PURE__ */ j({
  props: {
    colors: {
      type: Array,
      required: true
    },
    color: {
      type: Object,
      required: true
    },
    enableAlpha: {
      type: Boolean,
      required: true
    }
  },
  setup(e10) {
    const t = we("color-predefine"), { currentColor: n } = Le(U2), o = L(a(e10.colors, e10.color));
    ge(() => n.value, (l) => {
      const s = new of({
        value: l
      });
      o.value.forEach((u) => {
        u.selected = s.compare(u);
      });
    }), Vn(() => {
      o.value = a(e10.colors, e10.color);
    });
    function r(l) {
      e10.color.fromString(e10.colors[l]);
    }
    function a(l, s) {
      return l.map((u) => {
        const c = new of({
          value: u
        });
        return c.selected = c.compare(s), c;
      });
    }
    return {
      rgbaColors: o,
      handleSelect: r,
      ns: t
    };
  }
});
function dH(e10, t, n, o, r, a) {
  return k(), x("div", {
    class: I(e10.ns.b())
  }, [
    B("div", {
      class: I(e10.ns.e("colors"))
    }, [
      (k(true), x(Ie, null, st(e10.rgbaColors, (l, s) => (k(), x("div", {
        key: e10.colors[s],
        class: I([
          e10.ns.e("color-selector"),
          e10.ns.is("alpha", l.get("alpha") < 100),
          { selected: l.selected }
        ]),
        onClick: (u) => e10.handleSelect(s)
      }, [
        B("div", {
          style: ze({ backgroundColor: l.value })
        }, null, 4)
      ], 10, ["onClick"]))), 128))
    ], 2)
  ], 2);
}
var fH = /* @__PURE__ */ $e(cH, [["render", dH], ["__file", "predefine.vue"]]);
const pH = /* @__PURE__ */ j({
  name: "ElSlPanel",
  props: {
    color: {
      type: Object,
      required: true
    }
  },
  setup(e10) {
    const t = we("color-svpanel"), n = it(), o = L(0), r = L(0), a = L("hsl(0, 100%, 50%)"), l = S(() => {
      const c = e10.color.get("hue"), d = e10.color.get("value");
      return { hue: c, value: d };
    });
    function s() {
      const c = e10.color.get("saturation"), d = e10.color.get("value"), f = n.vnode.el, { clientWidth: p, clientHeight: v } = f;
      r.value = c * p / 100, o.value = (100 - d) * v / 100, a.value = `hsl(${e10.color.get("hue")}, 100%, 50%)`;
    }
    function u(c) {
      const f = n.vnode.el.getBoundingClientRect(), { clientX: p, clientY: v } = Sg(c);
      let m = p - f.left, h = v - f.top;
      m = Math.max(0, m), m = Math.min(m, f.width), h = Math.max(0, h), h = Math.min(h, f.height), r.value = m, o.value = h, e10.color.set({
        saturation: m / f.width * 100,
        value: 100 - h / f.height * 100
      });
    }
    return ge(() => l.value, () => {
      s();
    }), dt(() => {
      Nu(n.vnode.el, {
        drag: (c) => {
          u(c);
        },
        end: (c) => {
          u(c);
        }
      }), s();
    }), {
      cursorTop: o,
      cursorLeft: r,
      background: a,
      colorValue: l,
      handleDrag: u,
      update: s,
      ns: t
    };
  }
});
function vH(e10, t, n, o, r, a) {
  return k(), x("div", {
    class: I(e10.ns.b()),
    style: ze({
      backgroundColor: e10.background
    })
  }, [
    B("div", {
      class: I(e10.ns.e("white"))
    }, null, 2),
    B("div", {
      class: I(e10.ns.e("black"))
    }, null, 2),
    B("div", {
      class: I(e10.ns.e("cursor")),
      style: ze({
        top: e10.cursorTop + "px",
        left: e10.cursorLeft + "px"
      })
    }, [
      B("div")
    ], 6)
  ], 6);
}
var hH = /* @__PURE__ */ $e(pH, [["render", vH], ["__file", "sv-panel.vue"]]);
const mH = /* @__PURE__ */ j({
  name: "ElColorPicker"
}), gH = /* @__PURE__ */ j({
  ...mH,
  props: iH,
  emits: uH,
  setup(e10, { expose: t, emit: n }) {
    const o = e10, { t: r } = kt(), a = we("color"), { formItem: l } = Yn(), s = yn(), u = Hn(), { inputId: c, isLabeledByFormItem: d } = tr(o, {
      formItemContext: l
    }), f = L(), p = L(), v = L(), m = L(), h = L(), b = L(), { isFocused: g, handleFocus: w, handleBlur: y } = pl(h, {
      beforeFocus() {
        return u.value;
      },
      beforeBlur(me) {
        var De;
        return (De = m.value) == null ? void 0 : De.isFocusInsideContent(me);
      },
      afterBlur() {
        D(false), V();
      }
    });
    let _ = true;
    const C = It(new of({
      enableAlpha: o.showAlpha,
      format: o.colorFormat || "",
      value: o.modelValue
    })), E = L(false), T = L(false), O = L(""), N = S(() => !o.modelValue && !T.value ? "transparent" : Y(C, o.showAlpha)), $ = S(() => !o.modelValue && !T.value ? "" : C.value), R = S(() => d.value ? void 0 : o.ariaLabel || r("el.colorpicker.defaultLabel")), P = S(() => d.value ? l == null ? void 0 : l.labelId : void 0), z = S(() => [
      a.b("picker"),
      a.is("disabled", u.value),
      a.bm("picker", s.value),
      a.is("focused", g.value)
    ]);
    function Y(me, De) {
      const { r: Te, g: de, b: U, a: re } = me.toRgb();
      return De ? `rgba(${Te}, ${de}, ${U}, ${re})` : `rgb(${Te}, ${de}, ${U})`;
    }
    function D(me) {
      E.value = me;
    }
    const M = Oo(D, 100, { leading: true });
    function F() {
      u.value || D(true);
    }
    function A() {
      M(false), V();
    }
    function V() {
      He(() => {
        o.modelValue ? C.fromString(o.modelValue) : (C.value = "", !$.value && O.value && (O.value = ""), He(() => {
          T.value = false;
        }));
      });
    }
    function Z() {
      u.value || (E.value && V(), M(!E.value));
    }
    function G() {
      C.fromString(O.value), C.value !== O.value && (O.value = C.value);
    }
    function le() {
      const me = C.value;
      n(nt, me), n(gt, me), o.validateEvent && (l == null || l.validate("change").catch((De) => _t(De))), M(false), He(() => {
        const De = new of({
          enableAlpha: o.showAlpha,
          format: o.colorFormat || "",
          value: o.modelValue
        });
        C.compare(De) || V();
      });
    }
    function X() {
      M(false), n(nt, null), n(gt, null), o.modelValue !== null && o.validateEvent && (l == null || l.validate("change").catch((me) => _t(me))), V();
    }
    function te() {
      E.value && (A(), g.value && se());
    }
    function ce(me) {
      me.preventDefault(), me.stopPropagation(), D(false), V();
    }
    function pe(me) {
      switch (me.code) {
        case xe.enter:
        case xe.numpadEnter:
        case xe.space:
          me.preventDefault(), me.stopPropagation(), F(), b.value.focus();
          break;
        case xe.esc:
          ce(me);
          break;
      }
    }
    function se() {
      h.value.focus();
    }
    function ve() {
      h.value.blur();
    }
    return dt(() => {
      o.modelValue && (O.value = $.value);
    }), ge(() => o.modelValue, (me) => {
      me ? me && me !== C.value && (_ = false, C.fromString(me)) : T.value = false;
    }), ge(() => [o.colorFormat, o.showAlpha], () => {
      C.enableAlpha = o.showAlpha, C.format = o.colorFormat || C.format, C.doOnChange(), n(nt, C.value);
    }), ge(() => $.value, (me) => {
      O.value = me, _ && n("activeChange", me), _ = true;
    }), ge(() => C.value, () => {
      !o.modelValue && !T.value && (T.value = true);
    }), ge(() => E.value, () => {
      He(() => {
        var me, De, Te;
        (me = f.value) == null || me.update(), (De = p.value) == null || De.update(), (Te = v.value) == null || Te.update();
      });
    }), yt(U2, {
      currentColor: $
    }), t({
      color: C,
      show: F,
      hide: A,
      focus: se,
      blur: ve
    }), (me, De) => (k(), ae(i(Un), {
      ref_key: "popper",
      ref: m,
      visible: E.value,
      "show-arrow": false,
      "fallback-placements": ["bottom", "top", "right", "left"],
      offset: 0,
      "gpu-acceleration": false,
      "popper-class": [i(a).be("picker", "panel"), i(a).b("dropdown"), me.popperClass],
      "stop-popper-mouse-event": false,
      effect: "light",
      trigger: "click",
      teleported: me.teleported,
      transition: `${i(a).namespace.value}-zoom-in-top`,
      persistent: "",
      onHide: (Te) => D(false)
    }, {
      content: H(() => [
        lt((k(), x("div", {
          onKeydown: Bt(ce, ["esc"])
        }, [
          B("div", {
            class: I(i(a).be("dropdown", "main-wrapper"))
          }, [
            W(sH, {
              ref_key: "hue",
              ref: f,
              class: "hue-slider",
              color: i(C),
              vertical: ""
            }, null, 8, ["color"]),
            W(hH, {
              ref_key: "sv",
              ref: p,
              color: i(C)
            }, null, 8, ["color"])
          ], 2),
          me.showAlpha ? (k(), ae(rH, {
            key: 0,
            ref_key: "alpha",
            ref: v,
            color: i(C)
          }, null, 8, ["color"])) : ee("v-if", true),
          me.predefine ? (k(), ae(fH, {
            key: 1,
            ref: "predefine",
            "enable-alpha": me.showAlpha,
            color: i(C),
            colors: me.predefine
          }, null, 8, ["enable-alpha", "color", "colors"])) : ee("v-if", true),
          B("div", {
            class: I(i(a).be("dropdown", "btns"))
          }, [
            B("span", {
              class: I(i(a).be("dropdown", "value"))
            }, [
              W(i(eo), {
                ref_key: "inputRef",
                ref: b,
                modelValue: O.value,
                "onUpdate:modelValue": (Te) => O.value = Te,
                "validate-event": false,
                size: "small",
                onChange: G
              }, null, 8, ["modelValue", "onUpdate:modelValue"])
            ], 2),
            W(i(Mn), {
              class: I(i(a).be("dropdown", "link-btn")),
              text: "",
              size: "small",
              onClick: X
            }, {
              default: H(() => [
                Ze(_e(i(r)("el.colorpicker.clear")), 1)
              ]),
              _: 1
            }, 8, ["class"]),
            W(i(Mn), {
              plain: "",
              size: "small",
              class: I(i(a).be("dropdown", "btn")),
              onClick: le
            }, {
              default: H(() => [
                Ze(_e(i(r)("el.colorpicker.confirm")), 1)
              ]),
              _: 1
            }, 8, ["class"])
          ], 2)
        ], 40, ["onKeydown"])), [
          [i(Sa), te, h.value]
        ])
      ]),
      default: H(() => [
        B("div", vt({
          id: i(c),
          ref_key: "triggerRef",
          ref: h
        }, me.$attrs, {
          class: i(z),
          role: "button",
          "aria-label": i(R),
          "aria-labelledby": i(P),
          "aria-description": i(r)("el.colorpicker.description", { color: me.modelValue || "" }),
          "aria-disabled": i(u),
          tabindex: i(u) ? void 0 : me.tabindex,
          onKeydown: pe,
          onFocus: i(w),
          onBlur: i(y)
        }), [
          B("div", {
            class: I(i(a).be("picker", "trigger")),
            onClick: Z
          }, [
            B("span", {
              class: I([i(a).be("picker", "color"), i(a).is("alpha", me.showAlpha)])
            }, [
              B("span", {
                class: I(i(a).be("picker", "color-inner")),
                style: ze({
                  backgroundColor: i(N)
                })
              }, [
                lt(W(i(Be), {
                  class: I([i(a).be("picker", "icon"), i(a).is("icon-arrow-down")])
                }, {
                  default: H(() => [
                    W(i(ea))
                  ]),
                  _: 1
                }, 8, ["class"]), [
                  [Nt, me.modelValue || T.value]
                ]),
                lt(W(i(Be), {
                  class: I([i(a).be("picker", "empty"), i(a).is("icon-close")])
                }, {
                  default: H(() => [
                    W(i(Jo))
                  ]),
                  _: 1
                }, 8, ["class"]), [
                  [Nt, !me.modelValue && !T.value]
                ])
              ], 6)
            ], 2)
          ], 2)
        ], 16, ["id", "aria-label", "aria-labelledby", "aria-description", "aria-disabled", "tabindex", "onFocus", "onBlur"])
      ]),
      _: 1
    }, 8, ["visible", "popper-class", "teleported", "transition", "onHide"]));
  }
});
var yH = /* @__PURE__ */ $e(gH, [["__file", "color-picker.vue"]]);
const bH = ut(yH), _H = Oe({
  a11y: {
    type: Boolean,
    default: true
  },
  locale: {
    type: ne(Object)
  },
  size: _n,
  button: {
    type: ne(Object)
  },
  link: {
    type: ne(Object)
  },
  experimentalFeatures: {
    type: ne(Object)
  },
  keyboardNavigation: {
    type: Boolean,
    default: true
  },
  message: {
    type: ne(Object)
  },
  zIndex: Number,
  namespace: {
    type: String,
    default: "el"
  },
  ...ki
}), Po = {}, wH = /* @__PURE__ */ j({
  name: "ElConfigProvider",
  props: _H,
  setup(e10, { slots: t }) {
    const n = eg(e10);
    return ge(() => e10.message, (o) => {
      var r, a;
      Object.assign(Po, (a = (r = n == null ? void 0 : n.value) == null ? void 0 : r.message) != null ? a : {}, o != null ? o : {});
    }, { immediate: true, deep: true }), () => J(t, "default", { config: n == null ? void 0 : n.value });
  }
}), CH = ut(wH), EH = /* @__PURE__ */ j({
  name: "ElContainer"
}), SH = /* @__PURE__ */ j({
  ...EH,
  props: {
    direction: {
      type: String
    }
  },
  setup(e10) {
    const t = e10, n = En(), o = we("container"), r = S(() => t.direction === "vertical" ? true : t.direction === "horizontal" ? false : n && n.default ? n.default().some((l) => {
      const s = l.type.name;
      return s === "ElHeader" || s === "ElFooter";
    }) : false);
    return (a, l) => (k(), x("section", {
      class: I([i(o).b(), i(o).is("vertical", i(r))])
    }, [
      J(a.$slots, "default")
    ], 2));
  }
});
var kH = /* @__PURE__ */ $e(SH, [["__file", "container.vue"]]);
const NH = /* @__PURE__ */ j({
  name: "ElAside"
}), TH = /* @__PURE__ */ j({
  ...NH,
  props: {
    width: {
      type: String,
      default: null
    }
  },
  setup(e10) {
    const t = e10, n = we("aside"), o = S(() => t.width ? n.cssVarBlock({ width: t.width }) : {});
    return (r, a) => (k(), x("aside", {
      class: I(i(n).b()),
      style: ze(i(o))
    }, [
      J(r.$slots, "default")
    ], 6));
  }
});
var Y2 = /* @__PURE__ */ $e(TH, [["__file", "aside.vue"]]);
const OH = /* @__PURE__ */ j({
  name: "ElFooter"
}), $H = /* @__PURE__ */ j({
  ...OH,
  props: {
    height: {
      type: String,
      default: null
    }
  },
  setup(e10) {
    const t = e10, n = we("footer"), o = S(() => t.height ? n.cssVarBlock({ height: t.height }) : {});
    return (r, a) => (k(), x("footer", {
      class: I(i(n).b()),
      style: ze(i(o))
    }, [
      J(r.$slots, "default")
    ], 6));
  }
});
var q2 = /* @__PURE__ */ $e($H, [["__file", "footer.vue"]]);
const IH = /* @__PURE__ */ j({
  name: "ElHeader"
}), MH = /* @__PURE__ */ j({
  ...IH,
  props: {
    height: {
      type: String,
      default: null
    }
  },
  setup(e10) {
    const t = e10, n = we("header"), o = S(() => t.height ? n.cssVarBlock({
      height: t.height
    }) : {});
    return (r, a) => (k(), x("header", {
      class: I(i(n).b()),
      style: ze(i(o))
    }, [
      J(r.$slots, "default")
    ], 6));
  }
});
var G2 = /* @__PURE__ */ $e(MH, [["__file", "header.vue"]]);
const PH = /* @__PURE__ */ j({
  name: "ElMain"
}), RH = /* @__PURE__ */ j({
  ...PH,
  setup(e10) {
    const t = we("main");
    return (n, o) => (k(), x("main", {
      class: I(i(t).b())
    }, [
      J(n.$slots, "default")
    ], 2));
  }
});
var X2 = /* @__PURE__ */ $e(RH, [["__file", "main.vue"]]);
const AH = ut(kH, {
  Aside: Y2,
  Footer: q2,
  Header: G2,
  Main: X2
}), LH = nn(Y2), xH = nn(q2), DH = nn(G2), VH = nn(X2);
var cd = { exports: {} }, FH = cd.exports, C1;
function BH() {
  return C1 || (C1 = 1, function(e10, t) {
    (function(n, o) {
      e10.exports = o();
    })(FH, function() {
      var n = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, o = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, r = /\d/, a = /\d\d/, l = /\d\d?/, s = /\d*[^-_:/,()\s\d]+/, u = {}, c = function(b) {
        return (b = +b) + (b > 68 ? 1900 : 2e3);
      }, d = function(b) {
        return function(g) {
          this[b] = +g;
        };
      }, f = [/[+-]\d\d:?(\d\d)?|Z/, function(b) {
        (this.zone || (this.zone = {})).offset = function(g) {
          if (!g || g === "Z") return 0;
          var w = g.match(/([+-]|\d\d)/g), y = 60 * w[1] + (+w[2] || 0);
          return y === 0 ? 0 : w[0] === "+" ? -y : y;
        }(b);
      }], p = function(b) {
        var g = u[b];
        return g && (g.indexOf ? g : g.s.concat(g.f));
      }, v = function(b, g) {
        var w, y = u.meridiem;
        if (y) {
          for (var _ = 1; _ <= 24; _ += 1) if (b.indexOf(y(_, 0, g)) > -1) {
            w = _ > 12;
            break;
          }
        } else w = b === (g ? "pm" : "PM");
        return w;
      }, m = { A: [s, function(b) {
        this.afternoon = v(b, false);
      }], a: [s, function(b) {
        this.afternoon = v(b, true);
      }], Q: [r, function(b) {
        this.month = 3 * (b - 1) + 1;
      }], S: [r, function(b) {
        this.milliseconds = 100 * +b;
      }], SS: [a, function(b) {
        this.milliseconds = 10 * +b;
      }], SSS: [/\d{3}/, function(b) {
        this.milliseconds = +b;
      }], s: [l, d("seconds")], ss: [l, d("seconds")], m: [l, d("minutes")], mm: [l, d("minutes")], H: [l, d("hours")], h: [l, d("hours")], HH: [l, d("hours")], hh: [l, d("hours")], D: [l, d("day")], DD: [a, d("day")], Do: [s, function(b) {
        var g = u.ordinal, w = b.match(/\d+/);
        if (this.day = w[0], g) for (var y = 1; y <= 31; y += 1) g(y).replace(/\[|\]/g, "") === b && (this.day = y);
      }], w: [l, d("week")], ww: [a, d("week")], M: [l, d("month")], MM: [a, d("month")], MMM: [s, function(b) {
        var g = p("months"), w = (p("monthsShort") || g.map(function(y) {
          return y.slice(0, 3);
        })).indexOf(b) + 1;
        if (w < 1) throw new Error();
        this.month = w % 12 || w;
      }], MMMM: [s, function(b) {
        var g = p("months").indexOf(b) + 1;
        if (g < 1) throw new Error();
        this.month = g % 12 || g;
      }], Y: [/[+-]?\d+/, d("year")], YY: [a, function(b) {
        this.year = c(b);
      }], YYYY: [/\d{4}/, d("year")], Z: f, ZZ: f };
      function h(b) {
        var g, w;
        g = b, w = u && u.formats;
        for (var y = (b = g.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function($, R, P) {
          var z = P && P.toUpperCase();
          return R || w[P] || n[P] || w[z].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(Y, D, M) {
            return D || M.slice(1);
          });
        })).match(o), _ = y.length, C = 0; C < _; C += 1) {
          var E = y[C], T = m[E], O = T && T[0], N = T && T[1];
          y[C] = N ? { regex: O, parser: N } : E.replace(/^\[|\]$/g, "");
        }
        return function($) {
          for (var R = {}, P = 0, z = 0; P < _; P += 1) {
            var Y = y[P];
            if (typeof Y == "string") z += Y.length;
            else {
              var D = Y.regex, M = Y.parser, F = $.slice(z), A = D.exec(F)[0];
              M.call(R, A), $ = $.replace(A, "");
            }
          }
          return function(V) {
            var Z = V.afternoon;
            if (Z !== void 0) {
              var G = V.hours;
              Z ? G < 12 && (V.hours += 12) : G === 12 && (V.hours = 0), delete V.afternoon;
            }
          }(R), R;
        };
      }
      return function(b, g, w) {
        w.p.customParseFormat = true, b && b.parseTwoDigitYear && (c = b.parseTwoDigitYear);
        var y = g.prototype, _ = y.parse;
        y.parse = function(C) {
          var E = C.date, T = C.utc, O = C.args;
          this.$u = T;
          var N = O[1];
          if (typeof N == "string") {
            var $ = O[2] === true, R = O[3] === true, P = $ || R, z = O[2];
            R && (z = O[2]), u = this.$locale(), !$ && z && (u = w.Ls[z]), this.$d = function(F, A, V, Z) {
              try {
                if (["x", "X"].indexOf(A) > -1) return new Date((A === "X" ? 1e3 : 1) * F);
                var G = h(A)(F), le = G.year, X = G.month, te = G.day, ce = G.hours, pe = G.minutes, se = G.seconds, ve = G.milliseconds, me = G.zone, De = G.week, Te = /* @__PURE__ */ new Date(), de = te || (le || X ? 1 : Te.getDate()), U = le || Te.getFullYear(), re = 0;
                le && !X || (re = X > 0 ? X - 1 : Te.getMonth());
                var he, Ee = ce || 0, ye = pe || 0, K = se || 0, q = ve || 0;
                return me ? new Date(Date.UTC(U, re, de, Ee, ye, K, q + 60 * me.offset * 1e3)) : V ? new Date(Date.UTC(U, re, de, Ee, ye, K, q)) : (he = new Date(U, re, de, Ee, ye, K, q), De && (he = Z(he).week(De).toDate()), he);
              } catch {
                return /* @__PURE__ */ new Date("");
              }
            }(E, N, T, w), this.init(), z && z !== true && (this.$L = this.locale(z).$L), P && E != this.format(N) && (this.$d = /* @__PURE__ */ new Date("")), u = {};
          } else if (N instanceof Array) for (var Y = N.length, D = 1; D <= Y; D += 1) {
            O[1] = N[D - 1];
            var M = w.apply(this, O);
            if (M.isValid()) {
              this.$d = M.$d, this.$L = M.$L, this.init();
              break;
            }
            D === Y && (this.$d = /* @__PURE__ */ new Date(""));
          }
          else _.call(this, C);
        };
      };
    });
  }(cd)), cd.exports;
}
var HH = BH();
const kg = /* @__PURE__ */ Ra(HH);
var dd = { exports: {} }, zH = dd.exports, E1;
function KH() {
  return E1 || (E1 = 1, function(e10, t) {
    (function(n, o) {
      e10.exports = o();
    })(zH, function() {
      return function(n, o) {
        var r = o.prototype, a = r.format;
        r.format = function(l) {
          var s = this, u = this.$locale();
          if (!this.isValid()) return a.bind(this)(l);
          var c = this.$utils(), d = (l || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(f) {
            switch (f) {
              case "Q":
                return Math.ceil((s.$M + 1) / 3);
              case "Do":
                return u.ordinal(s.$D);
              case "gggg":
                return s.weekYear();
              case "GGGG":
                return s.isoWeekYear();
              case "wo":
                return u.ordinal(s.week(), "W");
              case "w":
              case "ww":
                return c.s(s.week(), f === "w" ? 1 : 2, "0");
              case "W":
              case "WW":
                return c.s(s.isoWeek(), f === "W" ? 1 : 2, "0");
              case "k":
              case "kk":
                return c.s(String(s.$H === 0 ? 24 : s.$H), f === "k" ? 1 : 2, "0");
              case "X":
                return Math.floor(s.$d.getTime() / 1e3);
              case "x":
                return s.$d.getTime();
              case "z":
                return "[" + s.offsetName() + "]";
              case "zzz":
                return "[" + s.offsetName("long") + "]";
              default:
                return f;
            }
          });
          return a.bind(this)(d);
        };
      };
    });
  }(dd)), dd.exports;
}
var WH = KH();
const jH = /* @__PURE__ */ Ra(WH);
var fd = { exports: {} }, UH = fd.exports, S1;
function YH() {
  return S1 || (S1 = 1, function(e10, t) {
    (function(n, o) {
      e10.exports = o();
    })(UH, function() {
      var n = "week", o = "year";
      return function(r, a, l) {
        var s = a.prototype;
        s.week = function(u) {
          if (u === void 0 && (u = null), u !== null) return this.add(7 * (u - this.week()), "day");
          var c = this.$locale().yearStart || 1;
          if (this.month() === 11 && this.date() > 25) {
            var d = l(this).startOf(o).add(1, o).date(c), f = l(this).endOf(n);
            if (d.isBefore(f)) return 1;
          }
          var p = l(this).startOf(o).date(c).startOf(n).subtract(1, "millisecond"), v = this.diff(p, n, true);
          return v < 0 ? l(this).startOf("week").week() : Math.ceil(v);
        }, s.weeks = function(u) {
          return u === void 0 && (u = null), this.week(u);
        };
      };
    });
  }(fd)), fd.exports;
}
var qH = YH();
const GH = /* @__PURE__ */ Ra(qH);
var pd = { exports: {} }, XH = pd.exports, k1;
function JH() {
  return k1 || (k1 = 1, function(e10, t) {
    (function(n, o) {
      e10.exports = o();
    })(XH, function() {
      return function(n, o) {
        o.prototype.weekYear = function() {
          var r = this.month(), a = this.week(), l = this.year();
          return a === 1 && r === 11 ? l + 1 : r === 0 && a >= 52 ? l - 1 : l;
        };
      };
    });
  }(pd)), pd.exports;
}
var ZH = JH();
const QH = /* @__PURE__ */ Ra(ZH);
var vd = { exports: {} }, ez = vd.exports, N1;
function tz() {
  return N1 || (N1 = 1, function(e10, t) {
    (function(n, o) {
      e10.exports = o();
    })(ez, function() {
      return function(n, o, r) {
        o.prototype.dayOfYear = function(a) {
          var l = Math.round((r(this).startOf("day") - r(this).startOf("year")) / 864e5) + 1;
          return a == null ? l : this.add(a - l, "day");
        };
      };
    });
  }(vd)), vd.exports;
}
var nz = tz();
const oz = /* @__PURE__ */ Ra(nz);
var hd = { exports: {} }, rz = hd.exports, T1;
function az() {
  return T1 || (T1 = 1, function(e10, t) {
    (function(n, o) {
      e10.exports = o();
    })(rz, function() {
      return function(n, o) {
        o.prototype.isSameOrAfter = function(r, a) {
          return this.isSame(r, a) || this.isAfter(r, a);
        };
      };
    });
  }(hd)), hd.exports;
}
var lz = az();
const sz = /* @__PURE__ */ Ra(lz);
var md = { exports: {} }, iz = md.exports, O1;
function uz() {
  return O1 || (O1 = 1, function(e10, t) {
    (function(n, o) {
      e10.exports = o();
    })(iz, function() {
      return function(n, o) {
        o.prototype.isSameOrBefore = function(r, a) {
          return this.isSame(r, a) || this.isBefore(r, a);
        };
      };
    });
  }(md)), md.exports;
}
var cz = uz();
const dz = /* @__PURE__ */ Ra(cz), $1 = ["hours", "minutes", "seconds"], Aa = "EP_PICKER_BASE", Ng = "ElPopperOptions", rf = "HH:mm:ss", Ns = "YYYY-MM-DD", fz = {
  date: Ns,
  dates: Ns,
  week: "gggg[w]ww",
  year: "YYYY",
  years: "YYYY",
  month: "YYYY-MM",
  months: "YYYY-MM",
  datetime: `${Ns} ${rf}`,
  monthrange: "YYYY-MM",
  yearrange: "YYYY",
  daterange: Ns,
  datetimerange: `${Ns} ${rf}`
}, J2 = Oe({
  disabledHours: {
    type: ne(Function)
  },
  disabledMinutes: {
    type: ne(Function)
  },
  disabledSeconds: {
    type: ne(Function)
  }
}), Z2 = Oe({
  visible: Boolean,
  actualVisible: {
    type: Boolean,
    default: void 0
  },
  format: {
    type: String,
    default: ""
  }
}), Tg = Oe({
  id: {
    type: ne([Array, String])
  },
  name: {
    type: ne([Array, String])
  },
  popperClass: {
    type: String,
    default: ""
  },
  format: String,
  valueFormat: String,
  dateFormat: String,
  timeFormat: String,
  type: {
    type: String,
    default: ""
  },
  clearable: {
    type: Boolean,
    default: true
  },
  clearIcon: {
    type: ne([String, Object]),
    default: Ma
  },
  editable: {
    type: Boolean,
    default: true
  },
  prefixIcon: {
    type: ne([String, Object]),
    default: ""
  },
  size: _n,
  readonly: Boolean,
  disabled: Boolean,
  placeholder: {
    type: String,
    default: ""
  },
  popperOptions: {
    type: ne(Object),
    default: () => ({})
  },
  modelValue: {
    type: ne([Date, Array, String, Number]),
    default: ""
  },
  rangeSeparator: {
    type: String,
    default: "-"
  },
  startPlaceholder: String,
  endPlaceholder: String,
  defaultValue: {
    type: ne([Date, Array])
  },
  defaultTime: {
    type: ne([Date, Array])
  },
  isRange: Boolean,
  ...J2,
  disabledDate: {
    type: Function
  },
  cellClassName: {
    type: Function
  },
  shortcuts: {
    type: Array,
    default: () => []
  },
  arrowControl: Boolean,
  tabindex: {
    type: ne([String, Number]),
    default: 0
  },
  validateEvent: {
    type: Boolean,
    default: true
  },
  unlinkPanels: Boolean,
  placement: {
    type: ne(String),
    values: Pa,
    default: "bottom"
  },
  fallbackPlacements: {
    type: ne(Array),
    default: ["bottom", "top", "right", "left"]
  },
  ...ki,
  ...Bn(["ariaLabel"]),
  showNow: {
    type: Boolean,
    default: true
  }
}), pz = Oe({
  id: {
    type: ne(Array)
  },
  name: {
    type: ne(Array)
  },
  modelValue: {
    type: ne([Array, String])
  },
  startPlaceholder: String,
  endPlaceholder: String,
  disabled: Boolean
}), vz = /* @__PURE__ */ j({
  name: "PickerRangeTrigger",
  inheritAttrs: false
}), hz = /* @__PURE__ */ j({
  ...vz,
  props: pz,
  emits: [
    "mouseenter",
    "mouseleave",
    "click",
    "touchstart",
    "focus",
    "blur",
    "startInput",
    "endInput",
    "startChange",
    "endChange"
  ],
  setup(e10, { expose: t, emit: n }) {
    const o = ic(), r = we("date"), a = we("range"), l = L(), s = L(), { wrapperRef: u, isFocused: c } = pl(l), d = (_) => {
      n("click", _);
    }, f = (_) => {
      n("mouseenter", _);
    }, p = (_) => {
      n("mouseleave", _);
    }, v = (_) => {
      n("mouseenter", _);
    }, m = (_) => {
      n("startInput", _);
    }, h = (_) => {
      n("endInput", _);
    }, b = (_) => {
      n("startChange", _);
    }, g = (_) => {
      n("endChange", _);
    };
    return t({
      focus: () => {
        var _;
        (_ = l.value) == null || _.focus();
      },
      blur: () => {
        var _, C;
        (_ = l.value) == null || _.blur(), (C = s.value) == null || C.blur();
      }
    }), (_, C) => (k(), x("div", {
      ref_key: "wrapperRef",
      ref: u,
      class: I([i(r).is("active", i(c)), _.$attrs.class]),
      style: ze(_.$attrs.style),
      onClick: d,
      onMouseenter: f,
      onMouseleave: p,
      onTouchstartPassive: v
    }, [
      J(_.$slots, "prefix"),
      B("input", vt(i(o), {
        id: _.id && _.id[0],
        ref_key: "inputRef",
        ref: l,
        name: _.name && _.name[0],
        placeholder: _.startPlaceholder,
        value: _.modelValue && _.modelValue[0],
        class: i(a).b("input"),
        disabled: _.disabled,
        onInput: m,
        onChange: b
      }), null, 16, ["id", "name", "placeholder", "value", "disabled"]),
      J(_.$slots, "range-separator"),
      B("input", vt(i(o), {
        id: _.id && _.id[1],
        ref_key: "endInputRef",
        ref: s,
        name: _.name && _.name[1],
        placeholder: _.endPlaceholder,
        value: _.modelValue && _.modelValue[1],
        class: i(a).b("input"),
        disabled: _.disabled,
        onInput: h,
        onChange: g
      }), null, 16, ["id", "name", "placeholder", "value", "disabled"]),
      J(_.$slots, "suffix")
    ], 38));
  }
});
var mz = /* @__PURE__ */ $e(hz, [["__file", "picker-range-trigger.vue"]]);
const gz = /* @__PURE__ */ j({
  name: "Picker"
}), yz = /* @__PURE__ */ j({
  ...gz,
  props: Tg,
  emits: [
    nt,
    gt,
    "focus",
    "blur",
    "clear",
    "calendar-change",
    "panel-change",
    "visible-change",
    "keydown"
  ],
  setup(e10, { expose: t, emit: n }) {
    const o = e10, r = Ta(), { lang: a } = kt(), l = we("date"), s = we("input"), u = we("range"), { form: c, formItem: d } = Yn(), f = Le(Ng, {}), { valueOnClear: p } = Xf(o, null), v = L(), m = L(), h = L(false), b = L(false), g = L(null);
    let w = false;
    const { isFocused: y, handleFocus: _, handleBlur: C } = pl(m, {
      beforeFocus() {
        return o.readonly || V.value;
      },
      afterFocus() {
        h.value = true;
      },
      beforeBlur(Q) {
        var Me;
        return !w && ((Me = v.value) == null ? void 0 : Me.isFocusInsideContent(Q));
      },
      afterBlur() {
        ue(), h.value = false, w = false, o.validateEvent && (d == null || d.validate("blur").catch((Q) => _t(Q)));
      }
    }), E = S(() => [
      l.b("editor"),
      l.bm("editor", o.type),
      s.e("wrapper"),
      l.is("disabled", V.value),
      l.is("active", h.value),
      u.b("editor"),
      Ee ? u.bm("editor", Ee.value) : "",
      r.class
    ]), T = S(() => [
      s.e("icon"),
      u.e("close-icon"),
      ve.value ? "" : u.e("close-icon--hidden")
    ]);
    ge(h, (Q) => {
      Q ? He(() => {
        Q && (g.value = o.modelValue);
      }) : (q.value = null, He(() => {
        O(o.modelValue);
      }));
    });
    const O = (Q, Me) => {
      (Me || !u1(Q, g.value)) && (n(gt, Q), Me && (g.value = Q), o.validateEvent && (d == null || d.validate("change").catch((Qe) => _t(Qe))));
    }, N = (Q) => {
      if (!u1(o.modelValue, Q)) {
        let Me;
        Se(Q) ? Me = Q.map((Qe) => d1(Qe, o.valueFormat, a.value)) : Q && (Me = d1(Q, o.valueFormat, a.value)), n(nt, Q && Me, a.value);
      }
    }, $ = (Q) => {
      n("keydown", Q);
    }, R = S(() => m.value ? Array.from(m.value.$el.querySelectorAll("input")) : []), P = (Q, Me, Qe) => {
      const Ct = R.value;
      Ct.length && (!Qe || Qe === "min" ? (Ct[0].setSelectionRange(Q, Me), Ct[0].focus()) : Qe === "max" && (Ct[1].setSelectionRange(Q, Me), Ct[1].focus()));
    }, z = (Q = "", Me = false) => {
      h.value = Me;
      let Qe;
      Se(Q) ? Qe = Q.map((Ct) => Ct.toDate()) : Qe = Q && Q.toDate(), q.value = null, N(Qe);
    }, Y = () => {
      b.value = true;
    }, D = () => {
      n("visible-change", true);
    }, M = () => {
      b.value = false, h.value = false, n("visible-change", false);
    }, F = () => {
      h.value = true;
    }, A = () => {
      h.value = false;
    }, V = S(() => o.disabled || (c == null ? void 0 : c.disabled)), Z = S(() => {
      let Q;
      if (De.value ? bt.value.getDefaultValue && (Q = bt.value.getDefaultValue()) : Se(o.modelValue) ? Q = o.modelValue.map((Me) => c1(Me, o.valueFormat, a.value)) : Q = c1(o.modelValue, o.valueFormat, a.value), bt.value.getRangeAvailableTime) {
        const Me = bt.value.getRangeAvailableTime(Q);
        In(Me, Q) || (Q = Me, De.value || N(Bc(Q)));
      }
      return Se(Q) && Q.some((Me) => !Me) && (Q = []), Q;
    }), G = S(() => {
      if (!bt.value.panelReady)
        return "";
      const Q = ke(Z.value);
      return Se(q.value) ? [
        q.value[0] || Q && Q[0] || "",
        q.value[1] || Q && Q[1] || ""
      ] : q.value !== null ? q.value : !X.value && De.value || !h.value && De.value ? "" : Q ? te.value || ce.value || pe.value ? Q.join(", ") : Q : "";
    }), le = S(() => o.type.includes("time")), X = S(() => o.type.startsWith("time")), te = S(() => o.type === "dates"), ce = S(() => o.type === "months"), pe = S(() => o.type === "years"), se = S(() => o.prefixIcon || (le.value ? PS : Vx)), ve = L(false), me = (Q) => {
      o.readonly || V.value || (ve.value && (Q.stopPropagation(), bt.value.handleClear ? bt.value.handleClear() : N(p.value), O(p.value, true), ve.value = false, M()), n("clear"));
    }, De = S(() => {
      const { modelValue: Q } = o;
      return !Q || Se(Q) && !Q.filter(Boolean).length;
    }), Te = async (Q) => {
      var Me;
      o.readonly || V.value || (((Me = Q.target) == null ? void 0 : Me.tagName) !== "INPUT" || y.value) && (h.value = true);
    }, de = () => {
      o.readonly || V.value || !De.value && o.clearable && (ve.value = true);
    }, U = () => {
      ve.value = false;
    }, re = (Q) => {
      var Me;
      o.readonly || V.value || (((Me = Q.touches[0].target) == null ? void 0 : Me.tagName) !== "INPUT" || y.value) && (h.value = true);
    }, he = S(() => o.type.includes("range")), Ee = yn(), ye = S(() => {
      var Q, Me;
      return (Me = (Q = i(v)) == null ? void 0 : Q.popperRef) == null ? void 0 : Me.contentRef;
    }), K = Qm(m, (Q) => {
      const Me = i(ye), Qe = xn(m);
      Me && (Q.target === Me || Q.composedPath().includes(Me)) || Q.target === Qe || Qe && Q.composedPath().includes(Qe) || (h.value = false);
    });
    jt(() => {
      K == null || K();
    });
    const q = L(null), ue = () => {
      if (q.value) {
        const Q = be(G.value);
        Q && Ae(Q) && (N(Bc(Q)), q.value = null);
      }
      q.value === "" && (N(p.value), O(p.value, true), q.value = null);
    }, be = (Q) => Q ? bt.value.parseUserInput(Q) : null, ke = (Q) => Q ? bt.value.formatToString(Q) : null, Ae = (Q) => bt.value.isValidValue(Q), fe = async (Q) => {
      if (o.readonly || V.value)
        return;
      const { code: Me } = Q;
      if ($(Q), Me === xe.esc) {
        h.value === true && (h.value = false, Q.preventDefault(), Q.stopPropagation());
        return;
      }
      if (Me === xe.down && (bt.value.handleFocusPicker && (Q.preventDefault(), Q.stopPropagation()), h.value === false && (h.value = true, await He()), bt.value.handleFocusPicker)) {
        bt.value.handleFocusPicker();
        return;
      }
      if (Me === xe.tab) {
        w = true;
        return;
      }
      if (Me === xe.enter || Me === xe.numpadEnter) {
        (q.value === null || q.value === "" || Ae(be(G.value))) && (ue(), h.value = false), Q.stopPropagation();
        return;
      }
      if (q.value) {
        Q.stopPropagation();
        return;
      }
      bt.value.handleKeydownInput && bt.value.handleKeydownInput(Q);
    }, ie = (Q) => {
      q.value = Q, h.value || (h.value = true);
    }, Ce = (Q) => {
      const Me = Q.target;
      q.value ? q.value = [Me.value, q.value[1]] : q.value = [Me.value, null];
    }, qe = (Q) => {
      const Me = Q.target;
      q.value ? q.value = [q.value[0], Me.value] : q.value = [null, Me.value];
    }, et = () => {
      var Q;
      const Me = q.value, Qe = be(Me && Me[0]), Ct = i(Z);
      if (Qe && Qe.isValid()) {
        q.value = [
          ke(Qe),
          ((Q = G.value) == null ? void 0 : Q[1]) || null
        ];
        const Kt = [Qe, Ct && (Ct[1] || null)];
        Ae(Kt) && (N(Bc(Kt)), q.value = null);
      }
    }, ft = () => {
      var Q;
      const Me = i(q), Qe = be(Me && Me[1]), Ct = i(Z);
      if (Qe && Qe.isValid()) {
        q.value = [
          ((Q = i(G)) == null ? void 0 : Q[0]) || null,
          ke(Qe)
        ];
        const Kt = [Ct && Ct[0], Qe];
        Ae(Kt) && (N(Bc(Kt)), q.value = null);
      }
    }, bt = L({}), zt = (Q) => {
      bt.value[Q[0]] = Q[1], bt.value.panelReady = true;
    }, We = (Q) => {
      n("calendar-change", Q);
    }, ct = (Q, Me, Qe) => {
      n("panel-change", Q, Me, Qe);
    }, oe = () => {
      var Q;
      (Q = m.value) == null || Q.focus();
    }, Ne = () => {
      var Q;
      (Q = m.value) == null || Q.blur();
    };
    return yt(Aa, {
      props: o
    }), t({
      focus: oe,
      blur: Ne,
      handleOpen: F,
      handleClose: A,
      onPick: z
    }), (Q, Me) => (k(), ae(i(Un), vt({
      ref_key: "refPopper",
      ref: v,
      visible: h.value,
      effect: "light",
      pure: "",
      trigger: "click"
    }, Q.$attrs, {
      role: "dialog",
      teleported: "",
      transition: `${i(l).namespace.value}-zoom-in-top`,
      "popper-class": [`${i(l).namespace.value}-picker__popper`, Q.popperClass],
      "popper-options": i(f),
      "fallback-placements": Q.fallbackPlacements,
      "gpu-acceleration": false,
      placement: Q.placement,
      "stop-popper-mouse-event": false,
      "hide-after": 0,
      persistent: "",
      onBeforeShow: Y,
      onShow: D,
      onHide: M
    }), {
      default: H(() => [
        i(he) ? (k(), ae(mz, {
          key: 1,
          id: Q.id,
          ref_key: "inputRef",
          ref: m,
          "model-value": i(G),
          name: Q.name,
          disabled: i(V),
          readonly: !Q.editable || Q.readonly,
          "start-placeholder": Q.startPlaceholder,
          "end-placeholder": Q.endPlaceholder,
          class: I(i(E)),
          style: ze(Q.$attrs.style),
          "aria-label": Q.ariaLabel,
          tabindex: Q.tabindex,
          autocomplete: "off",
          role: "combobox",
          onClick: Te,
          onFocus: i(_),
          onBlur: i(C),
          onStartInput: Ce,
          onStartChange: et,
          onEndInput: qe,
          onEndChange: ft,
          onMousedown: Te,
          onMouseenter: de,
          onMouseleave: U,
          onTouchstartPassive: re,
          onKeydown: fe
        }, {
          prefix: H(() => [
            i(se) ? (k(), ae(i(Be), {
              key: 0,
              class: I([i(s).e("icon"), i(u).e("icon")])
            }, {
              default: H(() => [
                (k(), ae(ht(i(se))))
              ]),
              _: 1
            }, 8, ["class"])) : ee("v-if", true)
          ]),
          "range-separator": H(() => [
            J(Q.$slots, "range-separator", {}, () => [
              B("span", {
                class: I(i(u).b("separator"))
              }, _e(Q.rangeSeparator), 3)
            ])
          ]),
          suffix: H(() => [
            Q.clearIcon ? (k(), ae(i(Be), {
              key: 0,
              class: I(i(T)),
              onMousedown: Xe(i(Mt), ["prevent"]),
              onClick: me
            }, {
              default: H(() => [
                (k(), ae(ht(Q.clearIcon)))
              ]),
              _: 1
            }, 8, ["class", "onMousedown"])) : ee("v-if", true)
          ]),
          _: 3
        }, 8, ["id", "model-value", "name", "disabled", "readonly", "start-placeholder", "end-placeholder", "class", "style", "aria-label", "tabindex", "onFocus", "onBlur"])) : (k(), ae(i(eo), {
          key: 0,
          id: Q.id,
          ref_key: "inputRef",
          ref: m,
          "container-role": "combobox",
          "model-value": i(G),
          name: Q.name,
          size: i(Ee),
          disabled: i(V),
          placeholder: Q.placeholder,
          class: I([i(l).b("editor"), i(l).bm("editor", Q.type), Q.$attrs.class]),
          style: ze(Q.$attrs.style),
          readonly: !Q.editable || Q.readonly || i(te) || i(ce) || i(pe) || Q.type === "week",
          "aria-label": Q.ariaLabel,
          tabindex: Q.tabindex,
          "validate-event": false,
          onInput: ie,
          onFocus: i(_),
          onBlur: i(C),
          onKeydown: fe,
          onChange: ue,
          onMousedown: Te,
          onMouseenter: de,
          onMouseleave: U,
          onTouchstartPassive: re,
          onClick: Xe(() => {
          }, ["stop"])
        }, {
          prefix: H(() => [
            i(se) ? (k(), ae(i(Be), {
              key: 0,
              class: I(i(s).e("icon")),
              onMousedown: Xe(Te, ["prevent"]),
              onTouchstartPassive: re
            }, {
              default: H(() => [
                (k(), ae(ht(i(se))))
              ]),
              _: 1
            }, 8, ["class", "onMousedown"])) : ee("v-if", true)
          ]),
          suffix: H(() => [
            ve.value && Q.clearIcon ? (k(), ae(i(Be), {
              key: 0,
              class: I(`${i(s).e("icon")} clear-icon`),
              onMousedown: Xe(i(Mt), ["prevent"]),
              onClick: me
            }, {
              default: H(() => [
                (k(), ae(ht(Q.clearIcon)))
              ]),
              _: 1
            }, 8, ["class", "onMousedown"])) : ee("v-if", true)
          ]),
          _: 1
        }, 8, ["id", "model-value", "name", "size", "disabled", "placeholder", "class", "style", "readonly", "aria-label", "tabindex", "onFocus", "onBlur", "onClick"]))
      ]),
      content: H(() => [
        J(Q.$slots, "default", {
          visible: h.value,
          actualVisible: b.value,
          parsedValue: i(Z),
          format: Q.format,
          dateFormat: Q.dateFormat,
          timeFormat: Q.timeFormat,
          unlinkPanels: Q.unlinkPanels,
          type: Q.type,
          defaultValue: Q.defaultValue,
          showNow: Q.showNow,
          onPick: z,
          onSelectRange: P,
          onSetPickerOption: zt,
          onCalendarChange: We,
          onPanelChange: ct,
          onMousedown: Xe(() => {
          }, ["stop"])
        })
      ]),
      _: 3
    }, 16, ["visible", "transition", "popper-class", "popper-options", "fallback-placements", "placement"]));
  }
});
var Q2 = /* @__PURE__ */ $e(yz, [["__file", "picker.vue"]]);
const bz = Oe({
  ...Z2,
  datetimeRole: String,
  parsedValue: {
    type: ne(Object)
  }
}), ek = ({
  getAvailableHours: e10,
  getAvailableMinutes: t,
  getAvailableSeconds: n
}) => {
  const o = (l, s, u, c) => {
    const d = {
      hour: e10,
      minute: t,
      second: n
    };
    let f = l;
    return ["hour", "minute", "second"].forEach((p) => {
      if (d[p]) {
        let v;
        const m = d[p];
        switch (p) {
          case "minute": {
            v = m(f.hour(), s, c);
            break;
          }
          case "second": {
            v = m(f.hour(), f.minute(), s, c);
            break;
          }
          default: {
            v = m(s, c);
            break;
          }
        }
        if (v != null && v.length && !v.includes(f[p]())) {
          const h = u ? 0 : v.length - 1;
          f = f[p](v[h]);
        }
      }
    }), f;
  }, r = {};
  return {
    timePickerOptions: r,
    getAvailableTime: o,
    onSetOption: ([l, s]) => {
      r[l] = s;
    }
  };
}, lv = (e10) => {
  const t = (o, r) => o || r, n = (o) => o !== true;
  return e10.map(t).filter(n);
}, tk = (e10, t, n) => ({
  getHoursList: (l, s) => ov(24, e10 && (() => e10 == null ? void 0 : e10(l, s))),
  getMinutesList: (l, s, u) => ov(60, t && (() => t == null ? void 0 : t(l, s, u))),
  getSecondsList: (l, s, u, c) => ov(60, n && (() => n == null ? void 0 : n(l, s, u, c)))
}), nk = (e10, t, n) => {
  const { getHoursList: o, getMinutesList: r, getSecondsList: a } = tk(e10, t, n);
  return {
    getAvailableHours: (c, d) => lv(o(c, d)),
    getAvailableMinutes: (c, d, f) => lv(r(c, d, f)),
    getAvailableSeconds: (c, d, f, p) => lv(a(c, d, f, p))
  };
}, ok = (e10) => {
  const t = L(e10.parsedValue);
  return ge(() => e10.visible, (n) => {
    n || (t.value = e10.parsedValue);
  }), t;
}, _z = Oe({
  role: {
    type: String,
    required: true
  },
  spinnerDate: {
    type: ne(Object),
    required: true
  },
  showSeconds: {
    type: Boolean,
    default: true
  },
  arrowControl: Boolean,
  amPmMode: {
    type: ne(String),
    default: ""
  },
  ...J2
}), wz = 100, Cz = 600, af = {
  beforeMount(e10, t) {
    const n = t.value, { interval: o = wz, delay: r = Cz } = Fe(n) ? {} : n;
    let a, l;
    const s = () => Fe(n) ? n() : n.handler(), u = () => {
      l && (clearTimeout(l), l = void 0), a && (clearInterval(a), a = void 0);
    };
    e10.addEventListener("mousedown", (c) => {
      c.button === 0 && (u(), s(), document.addEventListener("mouseup", () => u(), {
        once: true
      }), l = setTimeout(() => {
        a = setInterval(() => {
          s();
        }, o);
      }, r));
    });
  }
}, Ez = /* @__PURE__ */ j({
  __name: "basic-time-spinner",
  props: _z,
  emits: [gt, "select-range", "set-option"],
  setup(e10, { emit: t }) {
    const n = e10, o = Le(Aa), { isRange: r, format: a } = o.props, l = we("time"), { getHoursList: s, getMinutesList: u, getSecondsList: c } = tk(n.disabledHours, n.disabledMinutes, n.disabledSeconds);
    let d = false;
    const f = L(), p = L(), v = L(), m = L(), h = {
      hours: p,
      minutes: v,
      seconds: m
    }, b = S(() => n.showSeconds ? $1 : $1.slice(0, 2)), g = S(() => {
      const { spinnerDate: le } = n, X = le.hour(), te = le.minute(), ce = le.second();
      return { hours: X, minutes: te, seconds: ce };
    }), w = S(() => {
      const { hours: le, minutes: X } = i(g), { role: te, spinnerDate: ce } = n, pe = r ? void 0 : ce;
      return {
        hours: s(te, pe),
        minutes: u(le, te, pe),
        seconds: c(le, X, te, pe)
      };
    }), y = S(() => {
      const { hours: le, minutes: X, seconds: te } = i(g);
      return {
        hours: nv(le, 23),
        minutes: nv(X, 59),
        seconds: nv(te, 59)
      };
    }), _ = Oo((le) => {
      d = false, T(le);
    }, 200), C = (le) => {
      if (!!!n.amPmMode)
        return "";
      const te = n.amPmMode === "A";
      let ce = le < 12 ? " am" : " pm";
      return te && (ce = ce.toUpperCase()), ce;
    }, E = (le) => {
      let X = [0, 0];
      if (!a || a === rf)
        switch (le) {
          case "hours":
            X = [0, 2];
            break;
          case "minutes":
            X = [3, 5];
            break;
          case "seconds":
            X = [6, 8];
            break;
        }
      const [te, ce] = X;
      t("select-range", te, ce), f.value = le;
    }, T = (le) => {
      $(le, i(g)[le]);
    }, O = () => {
      T("hours"), T("minutes"), T("seconds");
    }, N = (le) => le.querySelector(`.${l.namespace.value}-scrollbar__wrap`), $ = (le, X) => {
      if (n.arrowControl)
        return;
      const te = i(h[le]);
      te && te.$el && (N(te.$el).scrollTop = Math.max(0, X * R(le)));
    }, R = (le) => {
      const X = i(h[le]), te = X == null ? void 0 : X.$el.querySelector("li");
      return te && Number.parseFloat(ha(te, "height")) || 0;
    }, P = () => {
      Y(1);
    }, z = () => {
      Y(-1);
    }, Y = (le) => {
      f.value || E("hours");
      const X = f.value, te = i(g)[X], ce = f.value === "hours" ? 24 : 60, pe = D(X, te, le, ce);
      M(X, pe), $(X, pe), He(() => E(X));
    }, D = (le, X, te, ce) => {
      let pe = (X + te + ce) % ce;
      const se = i(w)[le];
      for (; se[pe] && pe !== X; )
        pe = (pe + te + ce) % ce;
      return pe;
    }, M = (le, X) => {
      if (i(w)[le][X])
        return;
      const { hours: pe, minutes: se, seconds: ve } = i(g);
      let me;
      switch (le) {
        case "hours":
          me = n.spinnerDate.hour(X).minute(se).second(ve);
          break;
        case "minutes":
          me = n.spinnerDate.hour(pe).minute(X).second(ve);
          break;
        case "seconds":
          me = n.spinnerDate.hour(pe).minute(se).second(X);
          break;
      }
      t(gt, me);
    }, F = (le, { value: X, disabled: te }) => {
      te || (M(le, X), E(le), $(le, X));
    }, A = (le) => {
      const X = i(h[le]);
      if (!X)
        return;
      d = true, _(le);
      const te = Math.min(Math.round((N(X.$el).scrollTop - (V(le) * 0.5 - 10) / R(le) + 3) / R(le)), le === "hours" ? 23 : 59);
      M(le, te);
    }, V = (le) => i(h[le]).$el.offsetHeight, Z = () => {
      const le = (X) => {
        const te = i(h[X]);
        te && te.$el && (N(te.$el).onscroll = () => {
          A(X);
        });
      };
      le("hours"), le("minutes"), le("seconds");
    };
    dt(() => {
      He(() => {
        !n.arrowControl && Z(), O(), n.role === "start" && E("hours");
      });
    });
    const G = (le, X) => {
      h[X].value = le != null ? le : void 0;
    };
    return t("set-option", [`${n.role}_scrollDown`, Y]), t("set-option", [`${n.role}_emitSelectRange`, E]), ge(() => n.spinnerDate, () => {
      d || O();
    }), (le, X) => (k(), x("div", {
      class: I([i(l).b("spinner"), { "has-seconds": le.showSeconds }])
    }, [
      le.arrowControl ? ee("v-if", true) : (k(true), x(Ie, { key: 0 }, st(i(b), (te) => (k(), ae(i(ta), {
        key: te,
        ref_for: true,
        ref: (ce) => G(ce, te),
        class: I(i(l).be("spinner", "wrapper")),
        "wrap-style": "max-height: inherit;",
        "view-class": i(l).be("spinner", "list"),
        noresize: "",
        tag: "ul",
        onMouseenter: (ce) => E(te),
        onMousemove: (ce) => T(te)
      }, {
        default: H(() => [
          (k(true), x(Ie, null, st(i(w)[te], (ce, pe) => (k(), x("li", {
            key: pe,
            class: I([
              i(l).be("spinner", "item"),
              i(l).is("active", pe === i(g)[te]),
              i(l).is("disabled", ce)
            ]),
            onClick: (se) => F(te, { value: pe, disabled: ce })
          }, [
            te === "hours" ? (k(), x(Ie, { key: 0 }, [
              Ze(_e(("0" + (le.amPmMode ? pe % 12 || 12 : pe)).slice(-2)) + _e(C(pe)), 1)
            ], 64)) : (k(), x(Ie, { key: 1 }, [
              Ze(_e(("0" + pe).slice(-2)), 1)
            ], 64))
          ], 10, ["onClick"]))), 128))
        ]),
        _: 2
      }, 1032, ["class", "view-class", "onMouseenter", "onMousemove"]))), 128)),
      le.arrowControl ? (k(true), x(Ie, { key: 1 }, st(i(b), (te) => (k(), x("div", {
        key: te,
        class: I([i(l).be("spinner", "wrapper"), i(l).is("arrow")]),
        onMouseenter: (ce) => E(te)
      }, [
        lt((k(), ae(i(Be), {
          class: I(["arrow-up", i(l).be("spinner", "arrow")])
        }, {
          default: H(() => [
            W(i(Zf))
          ]),
          _: 1
        }, 8, ["class"])), [
          [i(af), z]
        ]),
        lt((k(), ae(i(Be), {
          class: I(["arrow-down", i(l).be("spinner", "arrow")])
        }, {
          default: H(() => [
            W(i(ea))
          ]),
          _: 1
        }, 8, ["class"])), [
          [i(af), P]
        ]),
        B("ul", {
          class: I(i(l).be("spinner", "list"))
        }, [
          (k(true), x(Ie, null, st(i(y)[te], (ce, pe) => (k(), x("li", {
            key: pe,
            class: I([
              i(l).be("spinner", "item"),
              i(l).is("active", ce === i(g)[te]),
              i(l).is("disabled", i(w)[te][ce])
            ])
          }, [
            i(Ye)(ce) ? (k(), x(Ie, { key: 0 }, [
              te === "hours" ? (k(), x(Ie, { key: 0 }, [
                Ze(_e(("0" + (le.amPmMode ? ce % 12 || 12 : ce)).slice(-2)) + _e(C(ce)), 1)
              ], 64)) : (k(), x(Ie, { key: 1 }, [
                Ze(_e(("0" + ce).slice(-2)), 1)
              ], 64))
            ], 64)) : ee("v-if", true)
          ], 2))), 128))
        ], 2)
      ], 42, ["onMouseenter"]))), 128)) : ee("v-if", true)
    ], 2));
  }
});
var lh = /* @__PURE__ */ $e(Ez, [["__file", "basic-time-spinner.vue"]]);
const Sz = /* @__PURE__ */ j({
  __name: "panel-time-pick",
  props: bz,
  emits: ["pick", "select-range", "set-picker-option"],
  setup(e10, { emit: t }) {
    const n = e10, o = Le(Aa), {
      arrowControl: r,
      disabledHours: a,
      disabledMinutes: l,
      disabledSeconds: s,
      defaultValue: u
    } = o.props, { getAvailableHours: c, getAvailableMinutes: d, getAvailableSeconds: f } = nk(a, l, s), p = we("time"), { t: v, lang: m } = kt(), h = L([0, 2]), b = ok(n), g = S(() => St(n.actualVisible) ? `${p.namespace.value}-zoom-in-top` : ""), w = S(() => n.format.includes("ss")), y = S(() => n.format.includes("A") ? "A" : n.format.includes("a") ? "a" : ""), _ = (A) => {
      const V = rt(A).locale(m.value), Z = Y(V);
      return V.isSame(Z);
    }, C = () => {
      t("pick", b.value, false);
    }, E = (A = false, V = false) => {
      V || t("pick", n.parsedValue, A);
    }, T = (A) => {
      if (!n.visible)
        return;
      const V = Y(A).millisecond(0);
      t("pick", V, true);
    }, O = (A, V) => {
      t("select-range", A, V), h.value = [A, V];
    }, N = (A) => {
      const V = [0, 3].concat(w.value ? [6] : []), Z = ["hours", "minutes"].concat(w.value ? ["seconds"] : []), le = (V.indexOf(h.value[0]) + A + V.length) % V.length;
      R.start_emitSelectRange(Z[le]);
    }, $ = (A) => {
      const V = A.code, { left: Z, right: G, up: le, down: X } = xe;
      if ([Z, G].includes(V)) {
        N(V === Z ? -1 : 1), A.preventDefault();
        return;
      }
      if ([le, X].includes(V)) {
        const te = V === le ? -1 : 1;
        R.start_scrollDown(te), A.preventDefault();
        return;
      }
    }, { timePickerOptions: R, onSetOption: P, getAvailableTime: z } = ek({
      getAvailableHours: c,
      getAvailableMinutes: d,
      getAvailableSeconds: f
    }), Y = (A) => z(A, n.datetimeRole || "", true), D = (A) => A ? rt(A, n.format).locale(m.value) : null, M = (A) => A ? A.format(n.format) : null, F = () => rt(u).locale(m.value);
    return t("set-picker-option", ["isValidValue", _]), t("set-picker-option", ["formatToString", M]), t("set-picker-option", ["parseUserInput", D]), t("set-picker-option", ["handleKeydownInput", $]), t("set-picker-option", ["getRangeAvailableTime", Y]), t("set-picker-option", ["getDefaultValue", F]), (A, V) => (k(), ae(Rn, { name: i(g) }, {
      default: H(() => [
        A.actualVisible || A.visible ? (k(), x("div", {
          key: 0,
          class: I(i(p).b("panel"))
        }, [
          B("div", {
            class: I([i(p).be("panel", "content"), { "has-seconds": i(w) }])
          }, [
            W(lh, {
              ref: "spinner",
              role: A.datetimeRole || "start",
              "arrow-control": i(r),
              "show-seconds": i(w),
              "am-pm-mode": i(y),
              "spinner-date": A.parsedValue,
              "disabled-hours": i(a),
              "disabled-minutes": i(l),
              "disabled-seconds": i(s),
              onChange: T,
              onSetOption: i(P),
              onSelectRange: O
            }, null, 8, ["role", "arrow-control", "show-seconds", "am-pm-mode", "spinner-date", "disabled-hours", "disabled-minutes", "disabled-seconds", "onSetOption"])
          ], 2),
          B("div", {
            class: I(i(p).be("panel", "footer"))
          }, [
            B("button", {
              type: "button",
              class: I([i(p).be("panel", "btn"), "cancel"]),
              onClick: C
            }, _e(i(v)("el.datepicker.cancel")), 3),
            B("button", {
              type: "button",
              class: I([i(p).be("panel", "btn"), "confirm"]),
              onClick: (Z) => E()
            }, _e(i(v)("el.datepicker.confirm")), 11, ["onClick"])
          ], 2)
        ], 2)) : ee("v-if", true)
      ]),
      _: 1
    }, 8, ["name"]));
  }
});
var lf = /* @__PURE__ */ $e(Sz, [["__file", "panel-time-pick.vue"]]);
const kz = Oe({
  ...Z2,
  parsedValue: {
    type: ne(Array)
  }
}), Nz = /* @__PURE__ */ j({
  __name: "panel-time-range",
  props: kz,
  emits: ["pick", "select-range", "set-picker-option"],
  setup(e10, { emit: t }) {
    const n = e10, o = (Te, de) => {
      const U = [];
      for (let re = Te; re <= de; re++)
        U.push(re);
      return U;
    }, { t: r, lang: a } = kt(), l = we("time"), s = we("picker"), u = Le(Aa), {
      arrowControl: c,
      disabledHours: d,
      disabledMinutes: f,
      disabledSeconds: p,
      defaultValue: v
    } = u.props, m = S(() => [
      l.be("range-picker", "body"),
      l.be("panel", "content"),
      l.is("arrow", c),
      _.value ? "has-seconds" : ""
    ]), h = S(() => [
      l.be("range-picker", "body"),
      l.be("panel", "content"),
      l.is("arrow", c),
      _.value ? "has-seconds" : ""
    ]), b = S(() => n.parsedValue[0]), g = S(() => n.parsedValue[1]), w = ok(n), y = () => {
      t("pick", w.value, false);
    }, _ = S(() => n.format.includes("ss")), C = S(() => n.format.includes("A") ? "A" : n.format.includes("a") ? "a" : ""), E = (Te = false) => {
      t("pick", [b.value, g.value], Te);
    }, T = (Te) => {
      $(Te.millisecond(0), g.value);
    }, O = (Te) => {
      $(b.value, Te.millisecond(0));
    }, N = (Te) => {
      const de = Te.map((re) => rt(re).locale(a.value)), U = G(de);
      return de[0].isSame(U[0]) && de[1].isSame(U[1]);
    }, $ = (Te, de) => {
      n.visible && t("pick", [Te, de], true);
    }, R = S(() => b.value > g.value), P = L([0, 2]), z = (Te, de) => {
      t("select-range", Te, de, "min"), P.value = [Te, de];
    }, Y = S(() => _.value ? 11 : 8), D = (Te, de) => {
      t("select-range", Te, de, "max");
      const U = i(Y);
      P.value = [Te + U, de + U];
    }, M = (Te) => {
      const de = _.value ? [0, 3, 6, 11, 14, 17] : [0, 3, 8, 11], U = ["hours", "minutes"].concat(_.value ? ["seconds"] : []), he = (de.indexOf(P.value[0]) + Te + de.length) % de.length, Ee = de.length / 2;
      he < Ee ? ce.start_emitSelectRange(U[he]) : ce.end_emitSelectRange(U[he - Ee]);
    }, F = (Te) => {
      const de = Te.code, { left: U, right: re, up: he, down: Ee } = xe;
      if ([U, re].includes(de)) {
        M(de === U ? -1 : 1), Te.preventDefault();
        return;
      }
      if ([he, Ee].includes(de)) {
        const ye = de === he ? -1 : 1, K = P.value[0] < Y.value ? "start" : "end";
        ce[`${K}_scrollDown`](ye), Te.preventDefault();
        return;
      }
    }, A = (Te, de) => {
      const U = d ? d(Te) : [], re = Te === "start", Ee = (de || (re ? g.value : b.value)).hour(), ye = re ? o(Ee + 1, 23) : o(0, Ee - 1);
      return Gp(U, ye);
    }, V = (Te, de, U) => {
      const re = f ? f(Te, de) : [], he = de === "start", Ee = U || (he ? g.value : b.value), ye = Ee.hour();
      if (Te !== ye)
        return re;
      const K = Ee.minute(), q = he ? o(K + 1, 59) : o(0, K - 1);
      return Gp(re, q);
    }, Z = (Te, de, U, re) => {
      const he = p ? p(Te, de, U) : [], Ee = U === "start", ye = re || (Ee ? g.value : b.value), K = ye.hour(), q = ye.minute();
      if (Te !== K || de !== q)
        return he;
      const ue = ye.second(), be = Ee ? o(ue + 1, 59) : o(0, ue - 1);
      return Gp(he, be);
    }, G = ([Te, de]) => [
      pe(Te, "start", true, de),
      pe(de, "end", false, Te)
    ], { getAvailableHours: le, getAvailableMinutes: X, getAvailableSeconds: te } = nk(A, V, Z), {
      timePickerOptions: ce,
      getAvailableTime: pe,
      onSetOption: se
    } = ek({
      getAvailableHours: le,
      getAvailableMinutes: X,
      getAvailableSeconds: te
    }), ve = (Te) => Te ? Se(Te) ? Te.map((de) => rt(de, n.format).locale(a.value)) : rt(Te, n.format).locale(a.value) : null, me = (Te) => Te ? Se(Te) ? Te.map((de) => de.format(n.format)) : Te.format(n.format) : null, De = () => {
      if (Se(v))
        return v.map((de) => rt(de).locale(a.value));
      const Te = rt(v).locale(a.value);
      return [Te, Te.add(60, "m")];
    };
    return t("set-picker-option", ["formatToString", me]), t("set-picker-option", ["parseUserInput", ve]), t("set-picker-option", ["isValidValue", N]), t("set-picker-option", ["handleKeydownInput", F]), t("set-picker-option", ["getDefaultValue", De]), t("set-picker-option", ["getRangeAvailableTime", G]), (Te, de) => Te.actualVisible ? (k(), x("div", {
      key: 0,
      class: I([i(l).b("range-picker"), i(s).b("panel")])
    }, [
      B("div", {
        class: I(i(l).be("range-picker", "content"))
      }, [
        B("div", {
          class: I(i(l).be("range-picker", "cell"))
        }, [
          B("div", {
            class: I(i(l).be("range-picker", "header"))
          }, _e(i(r)("el.datepicker.startTime")), 3),
          B("div", {
            class: I(i(m))
          }, [
            W(lh, {
              ref: "minSpinner",
              role: "start",
              "show-seconds": i(_),
              "am-pm-mode": i(C),
              "arrow-control": i(c),
              "spinner-date": i(b),
              "disabled-hours": A,
              "disabled-minutes": V,
              "disabled-seconds": Z,
              onChange: T,
              onSetOption: i(se),
              onSelectRange: z
            }, null, 8, ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "onSetOption"])
          ], 2)
        ], 2),
        B("div", {
          class: I(i(l).be("range-picker", "cell"))
        }, [
          B("div", {
            class: I(i(l).be("range-picker", "header"))
          }, _e(i(r)("el.datepicker.endTime")), 3),
          B("div", {
            class: I(i(h))
          }, [
            W(lh, {
              ref: "maxSpinner",
              role: "end",
              "show-seconds": i(_),
              "am-pm-mode": i(C),
              "arrow-control": i(c),
              "spinner-date": i(g),
              "disabled-hours": A,
              "disabled-minutes": V,
              "disabled-seconds": Z,
              onChange: O,
              onSetOption: i(se),
              onSelectRange: D
            }, null, 8, ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "onSetOption"])
          ], 2)
        ], 2)
      ], 2),
      B("div", {
        class: I(i(l).be("panel", "footer"))
      }, [
        B("button", {
          type: "button",
          class: I([i(l).be("panel", "btn"), "cancel"]),
          onClick: (U) => y()
        }, _e(i(r)("el.datepicker.cancel")), 11, ["onClick"]),
        B("button", {
          type: "button",
          class: I([i(l).be("panel", "btn"), "confirm"]),
          disabled: i(R),
          onClick: (U) => E()
        }, _e(i(r)("el.datepicker.confirm")), 11, ["disabled", "onClick"])
      ], 2)
    ], 2)) : ee("v-if", true);
  }
});
var Tz = /* @__PURE__ */ $e(Nz, [["__file", "panel-time-range.vue"]]);
rt.extend(kg);
var Oz = /* @__PURE__ */ j({
  name: "ElTimePicker",
  install: null,
  props: {
    ...Tg,
    isRange: {
      type: Boolean,
      default: false
    }
  },
  emits: [nt],
  setup(e10, t) {
    const n = L(), [o, r] = e10.isRange ? ["timerange", Tz] : ["time", lf], a = (l) => t.emit(nt, l);
    return yt(Ng, e10.popperOptions), t.expose({
      focus: () => {
        var l;
        (l = n.value) == null || l.focus();
      },
      blur: () => {
        var l;
        (l = n.value) == null || l.blur();
      },
      handleOpen: () => {
        var l;
        (l = n.value) == null || l.handleOpen();
      },
      handleClose: () => {
        var l;
        (l = n.value) == null || l.handleClose();
      }
    }), () => {
      var l;
      const s = (l = e10.format) != null ? l : rf;
      return W(Q2, vt(e10, {
        ref: n,
        type: o,
        format: s,
        "onUpdate:modelValue": a
      }), {
        default: (u) => W(r, u, null)
      });
    };
  }
});
const $z = ut(Oz), sp = Symbol(), fc = "ElIsDefaultFormat", Iz = Oe({
  ...Tg,
  type: {
    type: ne(String),
    default: "date"
  }
}), Mz = [
  "date",
  "dates",
  "year",
  "years",
  "month",
  "months",
  "week",
  "range"
], Og = Oe({
  disabledDate: {
    type: ne(Function)
  },
  date: {
    type: ne(Object),
    required: true
  },
  minDate: {
    type: ne(Object)
  },
  maxDate: {
    type: ne(Object)
  },
  parsedValue: {
    type: ne([Object, Array])
  },
  rangeState: {
    type: ne(Object),
    default: () => ({
      endDate: null,
      selecting: false
    })
  }
}), rk = Oe({
  type: {
    type: ne(String),
    required: true,
    values: FF
  },
  dateFormat: String,
  timeFormat: String,
  showNow: {
    type: Boolean,
    default: true
  }
}), $g = Oe({
  unlinkPanels: Boolean,
  parsedValue: {
    type: ne(Array)
  }
}), Ig = (e10) => ({
  type: String,
  values: Mz,
  default: e10
}), Pz = Oe({
  ...rk,
  parsedValue: {
    type: ne([Object, Array])
  },
  visible: {
    type: Boolean
  },
  format: {
    type: String,
    default: ""
  }
}), li = (e10) => {
  if (!Se(e10))
    return false;
  const [t, n] = e10;
  return rt.isDayjs(t) && rt.isDayjs(n) && rt(t).isValid() && rt(n).isValid() && t.isSameOrBefore(n);
}, Mg = (e10, { lang: t, unit: n, unlinkPanels: o }) => {
  let r;
  if (Se(e10)) {
    let [a, l] = e10.map((s) => rt(s).locale(t));
    return o || (l = a.add(1, n)), [a, l];
  } else e10 ? r = rt(e10) : r = rt();
  return r = r.locale(t), [r, r.add(1, n)];
}, Rz = (e10, t, {
  columnIndexOffset: n,
  startDate: o,
  nextEndDate: r,
  now: a,
  unit: l,
  relativeDateGetter: s,
  setCellMetadata: u,
  setRowMetadata: c
}) => {
  for (let d = 0; d < e10.row; d++) {
    const f = t[d];
    for (let p = 0; p < e10.column; p++) {
      let v = f[p + n];
      v || (v = {
        row: d,
        column: p,
        type: "normal",
        inRange: false,
        start: false,
        end: false
      });
      const m = d * e10.column + p, h = s(m);
      v.dayjs = h, v.date = h.toDate(), v.timestamp = h.valueOf(), v.type = "normal", v.inRange = !!(o && h.isSameOrAfter(o, l) && r && h.isSameOrBefore(r, l)) || !!(o && h.isSameOrBefore(o, l) && r && h.isSameOrAfter(r, l)), o != null && o.isSameOrAfter(r) ? (v.start = !!r && h.isSame(r, l), v.end = o && h.isSame(o, l)) : (v.start = !!o && h.isSame(o, l), v.end = !!r && h.isSame(r, l)), h.isSame(a, l) && (v.type = "today"), u == null || u(v, { rowIndex: d, columnIndex: p }), f[p + n] = v;
    }
    c == null || c(f);
  }
}, sf = (e10, t, n, o) => {
  const r = rt(e10).locale(o).month(n).year(t), a = r.daysInMonth();
  return tl(a).map((l) => r.add(l, "day").toDate());
}, si = (e10, t, n, o, r) => {
  const a = rt(e10).year(t).month(n), l = sf(e10, t, n, o).find((s) => !(r != null && r(s)));
  return l ? rt(l).locale(o) : a.locale(o);
}, uf = (e10, t, n) => {
  const o = e10.year();
  if (!(n != null && n(e10.toDate())))
    return e10.locale(t);
  const r = e10.month();
  if (!sf(e10, o, r, t).every(n))
    return si(e10, o, r, t, n);
  for (let a = 0; a < 12; a++)
    if (!sf(e10, o, a, t).every(n))
      return si(e10, o, a, t, n);
  return e10;
}, ii = (e10, t, n, o) => {
  if (Se(e10))
    return e10.map((r) => ii(r, t, n, o));
  if (Ve(e10)) {
    const r = o.value ? rt(e10) : rt(e10, t);
    if (!r.isValid())
      return r;
  }
  return rt(e10, t).locale(n);
}, Az = Oe({
  ...Og,
  cellClassName: {
    type: ne(Function)
  },
  showWeekNumber: Boolean,
  selectionMode: Ig("date")
}), Lz = ["changerange", "pick", "select"], sh = (e10 = "") => ["normal", "today"].includes(e10), xz = (e10, t) => {
  const { lang: n } = kt(), o = L(), r = L(), a = L(), l = L(), s = L([[], [], [], [], [], []]);
  let u = false;
  const c = e10.date.$locale().weekStart || 7, d = e10.date.locale("en").localeData().weekdaysShort().map((V) => V.toLowerCase()), f = S(() => c > 3 ? 7 - c : -c), p = S(() => {
    const V = e10.date.startOf("month");
    return V.subtract(V.day() || 7, "day");
  }), v = S(() => d.concat(d).slice(c, c + 7)), m = S(() => DE(i(_)).some((V) => V.isCurrent)), h = S(() => {
    const V = e10.date.startOf("month"), Z = V.day() || 7, G = V.daysInMonth(), le = V.subtract(1, "month").daysInMonth();
    return {
      startOfMonthDay: Z,
      dateCountOfMonth: G,
      dateCountOfLastMonth: le
    };
  }), b = S(() => e10.selectionMode === "dates" ? po(e10.parsedValue) : []), g = (V, { count: Z, rowIndex: G, columnIndex: le }) => {
    const { startOfMonthDay: X, dateCountOfMonth: te, dateCountOfLastMonth: ce } = i(h), pe = i(f);
    if (G >= 0 && G <= 1) {
      const se = X + pe < 0 ? 7 + X + pe : X + pe;
      if (le + G * 7 >= se)
        return V.text = Z, true;
      V.text = ce - (se - le % 7) + 1 + G * 7, V.type = "prev-month";
    } else
      return Z <= te ? V.text = Z : (V.text = Z - te, V.type = "next-month"), true;
    return false;
  }, w = (V, { columnIndex: Z, rowIndex: G }, le) => {
    const { disabledDate: X, cellClassName: te } = e10, ce = i(b), pe = g(V, { count: le, rowIndex: G, columnIndex: Z }), se = V.dayjs.toDate();
    return V.selected = ce.find((ve) => ve.isSame(V.dayjs, "day")), V.isSelected = !!V.selected, V.isCurrent = E(V), V.disabled = X == null ? void 0 : X(se), V.customClass = te == null ? void 0 : te(se), pe;
  }, y = (V) => {
    if (e10.selectionMode === "week") {
      const [Z, G] = e10.showWeekNumber ? [1, 7] : [0, 6], le = A(V[Z + 1]);
      V[Z].inRange = le, V[Z].start = le, V[G].inRange = le, V[G].end = le;
    }
  }, _ = S(() => {
    const { minDate: V, maxDate: Z, rangeState: G, showWeekNumber: le } = e10, X = i(f), te = i(s), ce = "day";
    let pe = 1;
    if (le)
      for (let se = 0; se < 6; se++)
        te[se][0] || (te[se][0] = {
          type: "week",
          text: i(p).add(se * 7 + 1, ce).week()
        });
    return Rz({ row: 6, column: 7 }, te, {
      startDate: V,
      columnIndexOffset: le ? 1 : 0,
      nextEndDate: G.endDate || Z || G.selecting && V || null,
      now: rt().locale(i(n)).startOf(ce),
      unit: ce,
      relativeDateGetter: (se) => i(p).add(se - X, ce),
      setCellMetadata: (...se) => {
        w(...se, pe) && (pe += 1);
      },
      setRowMetadata: y
    }), te;
  });
  ge(() => e10.date, async () => {
    var V;
    (V = i(o)) != null && V.contains(document.activeElement) && (await He(), await C());
  });
  const C = async () => {
    var V;
    return (V = i(r)) == null ? void 0 : V.focus();
  }, E = (V) => e10.selectionMode === "date" && sh(V.type) && T(V, e10.parsedValue), T = (V, Z) => Z ? rt(Z).locale(i(n)).isSame(e10.date.date(Number(V.text)), "day") : false, O = (V, Z) => {
    const G = V * 7 + (Z - (e10.showWeekNumber ? 1 : 0)) - i(f);
    return i(p).add(G, "day");
  }, N = (V) => {
    var Z;
    if (!e10.rangeState.selecting)
      return;
    let G = V.target;
    if (G.tagName === "SPAN" && (G = (Z = G.parentNode) == null ? void 0 : Z.parentNode), G.tagName === "DIV" && (G = G.parentNode), G.tagName !== "TD")
      return;
    const le = G.parentNode.rowIndex - 1, X = G.cellIndex;
    i(_)[le][X].disabled || (le !== i(a) || X !== i(l)) && (a.value = le, l.value = X, t("changerange", {
      selecting: true,
      endDate: O(le, X)
    }));
  }, $ = (V) => !i(m) && (V == null ? void 0 : V.text) === 1 && V.type === "normal" || V.isCurrent, R = (V) => {
    u || i(m) || e10.selectionMode !== "date" || F(V, true);
  }, P = (V) => {
    V.target.closest("td") && (u = true);
  }, z = (V) => {
    V.target.closest("td") && (u = false);
  }, Y = (V) => {
    !e10.rangeState.selecting || !e10.minDate ? (t("pick", { minDate: V, maxDate: null }), t("select", true)) : (V >= e10.minDate ? t("pick", { minDate: e10.minDate, maxDate: V }) : t("pick", { minDate: V, maxDate: e10.minDate }), t("select", false));
  }, D = (V) => {
    const Z = V.week(), G = `${V.year()}w${Z}`;
    t("pick", {
      year: V.year(),
      week: Z,
      value: G,
      date: V.startOf("week")
    });
  }, M = (V, Z) => {
    const G = Z ? po(e10.parsedValue).filter((le) => (le == null ? void 0 : le.valueOf()) !== V.valueOf()) : po(e10.parsedValue).concat([V]);
    t("pick", G);
  }, F = (V, Z = false) => {
    const G = V.target.closest("td");
    if (!G)
      return;
    const le = G.parentNode.rowIndex - 1, X = G.cellIndex, te = i(_)[le][X];
    if (te.disabled || te.type === "week")
      return;
    const ce = O(le, X);
    switch (e10.selectionMode) {
      case "range": {
        Y(ce);
        break;
      }
      case "date": {
        t("pick", ce, Z);
        break;
      }
      case "week": {
        D(ce);
        break;
      }
      case "dates": {
        M(ce, !!te.selected);
        break;
      }
    }
  }, A = (V) => {
    if (e10.selectionMode !== "week")
      return false;
    let Z = e10.date.startOf("day");
    if (V.type === "prev-month" && (Z = Z.subtract(1, "month")), V.type === "next-month" && (Z = Z.add(1, "month")), Z = Z.date(Number.parseInt(V.text, 10)), e10.parsedValue && !Se(e10.parsedValue)) {
      const G = (e10.parsedValue.day() - c + 7) % 7 - 1;
      return e10.parsedValue.subtract(G, "day").isSame(Z, "day");
    }
    return false;
  };
  return {
    WEEKS: v,
    rows: _,
    tbodyRef: o,
    currentCellRef: r,
    focus: C,
    isCurrent: E,
    isWeekActive: A,
    isSelectedCell: $,
    handlePickDate: F,
    handleMouseUp: z,
    handleMouseDown: P,
    handleMouseMove: N,
    handleFocus: R
  };
}, Dz = (e10, {
  isCurrent: t,
  isWeekActive: n
}) => {
  const o = we("date-table"), { t: r } = kt(), a = S(() => [
    o.b(),
    { "is-week-mode": e10.selectionMode === "week" }
  ]), l = S(() => r("el.datepicker.dateTablePrompt")), s = S(() => r("el.datepicker.week"));
  return {
    tableKls: a,
    tableLabel: l,
    weekLabel: s,
    getCellClasses: (d) => {
      const f = [];
      return sh(d.type) && !d.disabled ? (f.push("available"), d.type === "today" && f.push("today")) : f.push(d.type), t(d) && f.push("current"), d.inRange && (sh(d.type) || e10.selectionMode === "week") && (f.push("in-range"), d.start && f.push("start-date"), d.end && f.push("end-date")), d.disabled && f.push("disabled"), d.selected && f.push("selected"), d.customClass && f.push(d.customClass), f.join(" ");
    },
    getRowKls: (d) => [
      o.e("row"),
      { current: n(d) }
    ],
    t: r
  };
}, Vz = Oe({
  cell: {
    type: ne(Object)
  }
});
var Pg = /* @__PURE__ */ j({
  name: "ElDatePickerCell",
  props: Vz,
  setup(e10) {
    const t = we("date-table-cell"), {
      slots: n
    } = Le(sp);
    return () => {
      const {
        cell: o
      } = e10;
      return J(n, "default", {
        ...o
      }, () => {
        var r;
        return [W("div", {
          class: t.b()
        }, [W("span", {
          class: t.e("text")
        }, [(r = o == null ? void 0 : o.renderText) != null ? r : o == null ? void 0 : o.text])])];
      });
    };
  }
});
const Fz = /* @__PURE__ */ j({
  __name: "basic-date-table",
  props: Az,
  emits: Lz,
  setup(e10, { expose: t, emit: n }) {
    const o = e10, {
      WEEKS: r,
      rows: a,
      tbodyRef: l,
      currentCellRef: s,
      focus: u,
      isCurrent: c,
      isWeekActive: d,
      isSelectedCell: f,
      handlePickDate: p,
      handleMouseUp: v,
      handleMouseDown: m,
      handleMouseMove: h,
      handleFocus: b
    } = xz(o, n), { tableLabel: g, tableKls: w, weekLabel: y, getCellClasses: _, getRowKls: C, t: E } = Dz(o, {
      isCurrent: c,
      isWeekActive: d
    });
    let T = false;
    return jt(() => {
      T = true;
    }), t({
      focus: u
    }), (O, N) => (k(), x("table", {
      "aria-label": i(g),
      class: I(i(w)),
      cellspacing: "0",
      cellpadding: "0",
      role: "grid",
      onClick: i(p),
      onMousemove: i(h),
      onMousedown: Xe(i(m), ["prevent"]),
      onMouseup: i(v)
    }, [
      B("tbody", {
        ref_key: "tbodyRef",
        ref: l
      }, [
        B("tr", null, [
          O.showWeekNumber ? (k(), x("th", {
            key: 0,
            scope: "col"
          }, _e(i(y)), 1)) : ee("v-if", true),
          (k(true), x(Ie, null, st(i(r), ($, R) => (k(), x("th", {
            key: R,
            "aria-label": i(E)("el.datepicker.weeksFull." + $),
            scope: "col"
          }, _e(i(E)("el.datepicker.weeks." + $)), 9, ["aria-label"]))), 128))
        ]),
        (k(true), x(Ie, null, st(i(a), ($, R) => (k(), x("tr", {
          key: R,
          class: I(i(C)($[1]))
        }, [
          (k(true), x(Ie, null, st($, (P, z) => (k(), x("td", {
            key: `${R}.${z}`,
            ref_for: true,
            ref: (Y) => !i(T) && i(f)(P) && (s.value = Y),
            class: I(i(_)(P)),
            "aria-current": P.isCurrent ? "date" : void 0,
            "aria-selected": P.isCurrent,
            tabindex: i(f)(P) ? 0 : -1,
            onFocus: i(b)
          }, [
            W(i(Pg), { cell: P }, null, 8, ["cell"])
          ], 42, ["aria-current", "aria-selected", "tabindex", "onFocus"]))), 128))
        ], 2))), 128))
      ], 512)
    ], 42, ["aria-label", "onClick", "onMousemove", "onMousedown", "onMouseup"]));
  }
});
var ih = /* @__PURE__ */ $e(Fz, [["__file", "basic-date-table.vue"]]);
const Bz = Oe({
  ...Og,
  selectionMode: Ig("month")
}), Hz = /* @__PURE__ */ j({
  __name: "basic-month-table",
  props: Bz,
  emits: ["changerange", "pick", "select"],
  setup(e10, { expose: t, emit: n }) {
    const o = e10, r = we("month-table"), { t: a, lang: l } = kt(), s = L(), u = L(), c = L(o.date.locale("en").localeData().monthsShort().map((y) => y.toLowerCase())), d = L([
      [],
      [],
      []
    ]), f = L(), p = L(), v = S(() => {
      var y, _;
      const C = d.value, E = rt().locale(l.value).startOf("month");
      for (let T = 0; T < 3; T++) {
        const O = C[T];
        for (let N = 0; N < 4; N++) {
          const $ = O[N] || (O[N] = {
            row: T,
            column: N,
            type: "normal",
            inRange: false,
            start: false,
            end: false,
            text: -1,
            disabled: false
          });
          $.type = "normal";
          const R = T * 4 + N, P = o.date.startOf("year").month(R), z = o.rangeState.endDate || o.maxDate || o.rangeState.selecting && o.minDate || null;
          $.inRange = !!(o.minDate && P.isSameOrAfter(o.minDate, "month") && z && P.isSameOrBefore(z, "month")) || !!(o.minDate && P.isSameOrBefore(o.minDate, "month") && z && P.isSameOrAfter(z, "month")), (y = o.minDate) != null && y.isSameOrAfter(z) ? ($.start = !!(z && P.isSame(z, "month")), $.end = o.minDate && P.isSame(o.minDate, "month")) : ($.start = !!(o.minDate && P.isSame(o.minDate, "month")), $.end = !!(z && P.isSame(z, "month"))), E.isSame(P) && ($.type = "today"), $.text = R, $.disabled = ((_ = o.disabledDate) == null ? void 0 : _.call(o, P.toDate())) || false;
        }
      }
      return C;
    }), m = () => {
      var y;
      (y = u.value) == null || y.focus();
    }, h = (y) => {
      const _ = {}, C = o.date.year(), E = /* @__PURE__ */ new Date(), T = y.text;
      return _.disabled = o.disabledDate ? sf(o.date, C, T, l.value).every(o.disabledDate) : false, _.current = po(o.parsedValue).findIndex((O) => rt.isDayjs(O) && O.year() === C && O.month() === T) >= 0, _.today = E.getFullYear() === C && E.getMonth() === T, y.inRange && (_["in-range"] = true, y.start && (_["start-date"] = true), y.end && (_["end-date"] = true)), _;
    }, b = (y) => {
      const _ = o.date.year(), C = y.text;
      return po(o.date).findIndex((E) => E.year() === _ && E.month() === C) >= 0;
    }, g = (y) => {
      var _;
      if (!o.rangeState.selecting)
        return;
      let C = y.target;
      if (C.tagName === "SPAN" && (C = (_ = C.parentNode) == null ? void 0 : _.parentNode), C.tagName === "DIV" && (C = C.parentNode), C.tagName !== "TD")
        return;
      const E = C.parentNode.rowIndex, T = C.cellIndex;
      v.value[E][T].disabled || (E !== f.value || T !== p.value) && (f.value = E, p.value = T, n("changerange", {
        selecting: true,
        endDate: o.date.startOf("year").month(E * 4 + T)
      }));
    }, w = (y) => {
      var _;
      const C = (_ = y.target) == null ? void 0 : _.closest("td");
      if ((C == null ? void 0 : C.tagName) !== "TD" || Eo(C, "disabled"))
        return;
      const E = C.cellIndex, O = C.parentNode.rowIndex * 4 + E, N = o.date.startOf("year").month(O);
      if (o.selectionMode === "months") {
        if (y.type === "keydown") {
          n("pick", po(o.parsedValue), false);
          return;
        }
        const $ = si(o.date, o.date.year(), O, l.value, o.disabledDate), R = Eo(C, "current") ? po(o.parsedValue).filter((P) => (P == null ? void 0 : P.year()) !== $.year() || (P == null ? void 0 : P.month()) !== $.month()) : po(o.parsedValue).concat([rt($)]);
        n("pick", R);
      } else o.selectionMode === "range" ? o.rangeState.selecting ? (o.minDate && N >= o.minDate ? n("pick", { minDate: o.minDate, maxDate: N }) : n("pick", { minDate: N, maxDate: o.minDate }), n("select", false)) : (n("pick", { minDate: N, maxDate: null }), n("select", true)) : n("pick", O);
    };
    return ge(() => o.date, async () => {
      var y, _;
      (y = s.value) != null && y.contains(document.activeElement) && (await He(), (_ = u.value) == null || _.focus());
    }), t({
      focus: m
    }), (y, _) => (k(), x("table", {
      role: "grid",
      "aria-label": i(a)("el.datepicker.monthTablePrompt"),
      class: I(i(r).b()),
      onClick: w,
      onMousemove: g
    }, [
      B("tbody", {
        ref_key: "tbodyRef",
        ref: s
      }, [
        (k(true), x(Ie, null, st(i(v), (C, E) => (k(), x("tr", { key: E }, [
          (k(true), x(Ie, null, st(C, (T, O) => (k(), x("td", {
            key: O,
            ref_for: true,
            ref: (N) => b(T) && (u.value = N),
            class: I(h(T)),
            "aria-selected": `${b(T)}`,
            "aria-label": i(a)(`el.datepicker.month${+T.text + 1}`),
            tabindex: b(T) ? 0 : -1,
            onKeydown: [
              Bt(Xe(w, ["prevent", "stop"]), ["space"]),
              Bt(Xe(w, ["prevent", "stop"]), ["enter"])
            ]
          }, [
            W(i(Pg), {
              cell: {
                ...T,
                renderText: i(a)("el.datepicker.months." + c.value[T.text])
              }
            }, null, 8, ["cell"])
          ], 42, ["aria-selected", "aria-label", "tabindex", "onKeydown"]))), 128))
        ]))), 128))
      ], 512)
    ], 42, ["aria-label"]));
  }
});
var Tu = /* @__PURE__ */ $e(Hz, [["__file", "basic-month-table.vue"]]);
const zz = Oe({
  ...Og,
  selectionMode: Ig("year")
}), Kz = /* @__PURE__ */ j({
  __name: "basic-year-table",
  props: zz,
  emits: ["changerange", "pick", "select"],
  setup(e10, { expose: t, emit: n }) {
    const o = e10, r = (_, C) => {
      const E = rt(String(_)).locale(C).startOf("year"), O = E.endOf("year").dayOfYear();
      return tl(O).map((N) => E.add(N, "day").toDate());
    }, a = we("year-table"), { t: l, lang: s } = kt(), u = L(), c = L(), d = S(() => Math.floor(o.date.year() / 10) * 10), f = L([[], [], []]), p = L(), v = L(), m = S(() => {
      var _;
      const C = f.value, E = rt().locale(s.value).startOf("year");
      for (let T = 0; T < 3; T++) {
        const O = C[T];
        for (let N = 0; N < 4 && !(T * 4 + N >= 10); N++) {
          let $ = O[N];
          $ || ($ = {
            row: T,
            column: N,
            type: "normal",
            inRange: false,
            start: false,
            end: false,
            text: -1,
            disabled: false
          }), $.type = "normal";
          const R = T * 4 + N + d.value, P = rt().year(R), z = o.rangeState.endDate || o.maxDate || o.rangeState.selecting && o.minDate || null;
          $.inRange = !!(o.minDate && P.isSameOrAfter(o.minDate, "year") && z && P.isSameOrBefore(z, "year")) || !!(o.minDate && P.isSameOrBefore(o.minDate, "year") && z && P.isSameOrAfter(z, "year")), (_ = o.minDate) != null && _.isSameOrAfter(z) ? ($.start = !!(z && P.isSame(z, "year")), $.end = !!(o.minDate && P.isSame(o.minDate, "year"))) : ($.start = !!(o.minDate && P.isSame(o.minDate, "year")), $.end = !!(z && P.isSame(z, "year"))), E.isSame(P) && ($.type = "today"), $.text = R;
          const D = P.toDate();
          $.disabled = o.disabledDate && o.disabledDate(D) || false, O[N] = $;
        }
      }
      return C;
    }), h = () => {
      var _;
      (_ = c.value) == null || _.focus();
    }, b = (_) => {
      const C = {}, E = rt().locale(s.value), T = _.text;
      return C.disabled = o.disabledDate ? r(T, s.value).every(o.disabledDate) : false, C.today = E.year() === T, C.current = po(o.parsedValue).findIndex((O) => O.year() === T) >= 0, _.inRange && (C["in-range"] = true, _.start && (C["start-date"] = true), _.end && (C["end-date"] = true)), C;
    }, g = (_) => {
      const C = _.text;
      return po(o.date).findIndex((E) => E.year() === C) >= 0;
    }, w = (_) => {
      var C;
      const E = (C = _.target) == null ? void 0 : C.closest("td");
      if (!E || !E.textContent || Eo(E, "disabled"))
        return;
      const T = E.cellIndex, N = E.parentNode.rowIndex * 4 + T + d.value, $ = rt().year(N);
      if (o.selectionMode === "range")
        o.rangeState.selecting ? (o.minDate && $ >= o.minDate ? n("pick", { minDate: o.minDate, maxDate: $ }) : n("pick", { minDate: $, maxDate: o.minDate }), n("select", false)) : (n("pick", { minDate: $, maxDate: null }), n("select", true));
      else if (o.selectionMode === "years") {
        if (_.type === "keydown") {
          n("pick", po(o.parsedValue), false);
          return;
        }
        const R = uf($.startOf("year"), s.value, o.disabledDate), P = Eo(E, "current") ? po(o.parsedValue).filter((z) => (z == null ? void 0 : z.year()) !== N) : po(o.parsedValue).concat([R]);
        n("pick", P);
      } else
        n("pick", N);
    }, y = (_) => {
      var C;
      if (!o.rangeState.selecting)
        return;
      const E = (C = _.target) == null ? void 0 : C.closest("td");
      if (!E)
        return;
      const T = E.parentNode.rowIndex, O = E.cellIndex;
      m.value[T][O].disabled || (T !== p.value || O !== v.value) && (p.value = T, v.value = O, n("changerange", {
        selecting: true,
        endDate: rt().year(d.value).add(T * 4 + O, "year")
      }));
    };
    return ge(() => o.date, async () => {
      var _, C;
      (_ = u.value) != null && _.contains(document.activeElement) && (await He(), (C = c.value) == null || C.focus());
    }), t({
      focus: h
    }), (_, C) => (k(), x("table", {
      role: "grid",
      "aria-label": i(l)("el.datepicker.yearTablePrompt"),
      class: I(i(a).b()),
      onClick: w,
      onMousemove: y
    }, [
      B("tbody", {
        ref_key: "tbodyRef",
        ref: u
      }, [
        (k(true), x(Ie, null, st(i(m), (E, T) => (k(), x("tr", { key: T }, [
          (k(true), x(Ie, null, st(E, (O, N) => (k(), x("td", {
            key: `${T}_${N}`,
            ref_for: true,
            ref: ($) => g(O) && (c.value = $),
            class: I(["available", b(O)]),
            "aria-selected": g(O),
            "aria-label": String(O.text),
            tabindex: g(O) ? 0 : -1,
            onKeydown: [
              Bt(Xe(w, ["prevent", "stop"]), ["space"]),
              Bt(Xe(w, ["prevent", "stop"]), ["enter"])
            ]
          }, [
            W(i(Pg), { cell: O }, null, 8, ["cell"])
          ], 42, ["aria-selected", "aria-label", "tabindex", "onKeydown"]))), 128))
        ]))), 128))
      ], 512)
    ], 42, ["aria-label"]));
  }
});
var Ou = /* @__PURE__ */ $e(Kz, [["__file", "basic-year-table.vue"]]);
const Wz = /* @__PURE__ */ j({
  __name: "panel-date-pick",
  props: Pz,
  emits: ["pick", "set-picker-option", "panel-change"],
  setup(e10, { emit: t }) {
    const n = e10, o = (oe, Ne, Q) => true, r = we("picker-panel"), a = we("date-picker"), l = Ta(), s = En(), { t: u, lang: c } = kt(), d = Le(Aa), f = Le(fc), p = Le(op), { shortcuts: v, disabledDate: m, cellClassName: h, defaultTime: b } = d.props, g = Lt(d.props, "defaultValue"), w = L(), y = L(rt().locale(c.value)), _ = L(false);
    let C = false;
    const E = S(() => rt(b).locale(c.value)), T = S(() => y.value.month()), O = S(() => y.value.year()), N = L([]), $ = L(null), R = L(null), P = (oe) => N.value.length > 0 ? o(oe, N.value, n.format || "HH:mm:ss") : true, z = (oe) => b && !Ee.value && !_.value && !C ? E.value.year(oe.year()).month(oe.month()).date(oe.date()) : ve.value ? oe.millisecond(0) : oe.startOf("day"), Y = (oe, ...Ne) => {
      if (!oe)
        t("pick", oe, ...Ne);
      else if (Se(oe)) {
        const Q = oe.map(z);
        t("pick", Q, ...Ne);
      } else
        t("pick", z(oe), ...Ne);
      $.value = null, R.value = null, _.value = false, C = false;
    }, D = async (oe, Ne) => {
      if (G.value === "date") {
        oe = oe;
        let Q = n.parsedValue ? n.parsedValue.year(oe.year()).month(oe.month()).date(oe.date()) : oe;
        P(Q) || (Q = N.value[0][0].year(oe.year()).month(oe.month()).date(oe.date())), y.value = Q, Y(Q, ve.value || Ne), n.type === "datetime" && (await He(), ft());
      } else G.value === "week" ? Y(oe.date) : G.value === "dates" && Y(oe, true);
    }, M = (oe) => {
      const Ne = oe ? "add" : "subtract";
      y.value = y.value[Ne](1, "month"), ct("month");
    }, F = (oe) => {
      const Ne = y.value, Q = oe ? "add" : "subtract";
      y.value = A.value === "year" ? Ne[Q](10, "year") : Ne[Q](1, "year"), ct("year");
    }, A = L("date"), V = S(() => {
      const oe = u("el.datepicker.year");
      if (A.value === "year") {
        const Ne = Math.floor(O.value / 10) * 10;
        return oe ? `${Ne} ${oe} - ${Ne + 9} ${oe}` : `${Ne} - ${Ne + 9}`;
      }
      return `${O.value} ${oe}`;
    }), Z = (oe) => {
      const Ne = Fe(oe.value) ? oe.value() : oe.value;
      if (Ne) {
        C = true, Y(rt(Ne).locale(c.value));
        return;
      }
      oe.onClick && oe.onClick({
        attrs: l,
        slots: s,
        emit: t
      });
    }, G = S(() => {
      const { type: oe } = n;
      return ["week", "month", "months", "year", "years", "dates"].includes(oe) ? oe : "date";
    }), le = S(() => G.value === "dates" || G.value === "months" || G.value === "years"), X = S(() => G.value === "date" ? A.value : G.value), te = S(() => !!v.length), ce = async (oe, Ne) => {
      G.value === "month" ? (y.value = si(y.value, y.value.year(), oe, c.value, m), Y(y.value, false)) : G.value === "months" ? Y(oe, Ne != null ? Ne : true) : (y.value = si(y.value, y.value.year(), oe, c.value, m), A.value = "date", ["month", "year", "date", "week"].includes(G.value) && (Y(y.value, true), await He(), ft())), ct("month");
    }, pe = async (oe, Ne) => {
      if (G.value === "year") {
        const Q = y.value.startOf("year").year(oe);
        y.value = uf(Q, c.value, m), Y(y.value, false);
      } else if (G.value === "years")
        Y(oe, Ne != null ? Ne : true);
      else {
        const Q = y.value.year(oe);
        y.value = uf(Q, c.value, m), A.value = "month", ["month", "year", "date", "week"].includes(G.value) && (Y(y.value, true), await He(), ft());
      }
      ct("year");
    }, se = async (oe) => {
      A.value = oe, await He(), ft();
    }, ve = S(() => n.type === "datetime" || n.type === "datetimerange"), me = S(() => {
      const oe = ve.value || G.value === "dates", Ne = G.value === "years", Q = G.value === "months", Me = A.value === "date", Qe = A.value === "year", Ct = A.value === "month";
      return oe && Me || Ne && Qe || Q && Ct;
    }), De = S(() => m ? n.parsedValue ? Se(n.parsedValue) ? m(n.parsedValue[0].toDate()) : m(n.parsedValue.toDate()) : true : false), Te = () => {
      if (le.value)
        Y(n.parsedValue);
      else {
        let oe = n.parsedValue;
        if (!oe) {
          const Ne = rt(b).locale(c.value), Q = et();
          oe = Ne.year(Q.year()).month(Q.month()).date(Q.date());
        }
        y.value = oe, Y(oe);
      }
    }, de = S(() => m ? m(rt().locale(c.value).toDate()) : false), U = () => {
      const Ne = rt().locale(c.value).toDate();
      _.value = true, (!m || !m(Ne)) && P(Ne) && (y.value = rt().locale(c.value), Y(y.value));
    }, re = S(() => n.timeFormat || C2(n.format)), he = S(() => n.dateFormat || w2(n.format)), Ee = S(() => {
      if (R.value)
        return R.value;
      if (!(!n.parsedValue && !g.value))
        return (n.parsedValue || y.value).format(re.value);
    }), ye = S(() => {
      if ($.value)
        return $.value;
      if (!(!n.parsedValue && !g.value))
        return (n.parsedValue || y.value).format(he.value);
    }), K = L(false), q = () => {
      K.value = true;
    }, ue = () => {
      K.value = false;
    }, be = (oe) => ({
      hour: oe.hour(),
      minute: oe.minute(),
      second: oe.second(),
      year: oe.year(),
      month: oe.month(),
      date: oe.date()
    }), ke = (oe, Ne, Q) => {
      const { hour: Me, minute: Qe, second: Ct } = be(oe), Kt = n.parsedValue ? n.parsedValue.hour(Me).minute(Qe).second(Ct) : oe;
      y.value = Kt, Y(y.value, true), Q || (K.value = Ne);
    }, Ae = (oe) => {
      const Ne = rt(oe, re.value).locale(c.value);
      if (Ne.isValid() && P(Ne)) {
        const { year: Q, month: Me, date: Qe } = be(y.value);
        y.value = Ne.year(Q).month(Me).date(Qe), R.value = null, K.value = false, Y(y.value, true);
      }
    }, fe = (oe) => {
      const Ne = ii(oe, he.value, c.value, f);
      if (Ne.isValid()) {
        if (m && m(Ne.toDate()))
          return;
        const { hour: Q, minute: Me, second: Qe } = be(y.value);
        y.value = Ne.hour(Q).minute(Me).second(Qe), $.value = null, Y(y.value, true);
      }
    }, ie = (oe) => rt.isDayjs(oe) && oe.isValid() && (m ? !m(oe.toDate()) : true), Ce = (oe) => Se(oe) ? oe.map((Ne) => Ne.format(n.format)) : oe.format(n.format), qe = (oe) => ii(oe, n.format, c.value, f), et = () => {
      const oe = rt(g.value).locale(c.value);
      if (!g.value) {
        const Ne = E.value;
        return rt().hour(Ne.hour()).minute(Ne.minute()).second(Ne.second()).locale(c.value);
      }
      return oe;
    }, ft = () => {
      var oe;
      ["week", "month", "year", "date"].includes(G.value) && ((oe = w.value) == null || oe.focus());
    }, bt = () => {
      ft(), G.value === "week" && We(xe.down);
    }, zt = (oe) => {
      const { code: Ne } = oe;
      [
        xe.up,
        xe.down,
        xe.left,
        xe.right,
        xe.home,
        xe.end,
        xe.pageUp,
        xe.pageDown
      ].includes(Ne) && (We(Ne), oe.stopPropagation(), oe.preventDefault()), [xe.enter, xe.space, xe.numpadEnter].includes(Ne) && $.value === null && R.value === null && (oe.preventDefault(), Y(y.value, false));
    }, We = (oe) => {
      var Ne;
      const { up: Q, down: Me, left: Qe, right: Ct, home: Kt, end: pn, pageUp: on, pageDown: aa } = xe, Sn = {
        year: {
          [Q]: -4,
          [Me]: 4,
          [Qe]: -1,
          [Ct]: 1,
          offset: (Ge, $t) => Ge.setFullYear(Ge.getFullYear() + $t)
        },
        month: {
          [Q]: -4,
          [Me]: 4,
          [Qe]: -1,
          [Ct]: 1,
          offset: (Ge, $t) => Ge.setMonth(Ge.getMonth() + $t)
        },
        week: {
          [Q]: -1,
          [Me]: 1,
          [Qe]: -1,
          [Ct]: 1,
          offset: (Ge, $t) => Ge.setDate(Ge.getDate() + $t * 7)
        },
        date: {
          [Q]: -7,
          [Me]: 7,
          [Qe]: -1,
          [Ct]: 1,
          [Kt]: (Ge) => -Ge.getDay(),
          [pn]: (Ge) => -Ge.getDay() + 6,
          [on]: (Ge) => -new Date(Ge.getFullYear(), Ge.getMonth(), 0).getDate(),
          [aa]: (Ge) => new Date(Ge.getFullYear(), Ge.getMonth() + 1, 0).getDate(),
          offset: (Ge, $t) => Ge.setDate(Ge.getDate() + $t)
        }
      }, Bo = y.value.toDate();
      for (; Math.abs(y.value.diff(Bo, "year", true)) < 1; ) {
        const Ge = Sn[X.value];
        if (!Ge)
          return;
        if (Ge.offset(Bo, Fe(Ge[oe]) ? Ge[oe](Bo) : (Ne = Ge[oe]) != null ? Ne : 0), m && m(Bo))
          break;
        const $t = rt(Bo).locale(c.value);
        y.value = $t, t("pick", $t, true);
        break;
      }
    }, ct = (oe) => {
      t("panel-change", y.value.toDate(), oe, A.value);
    };
    return ge(() => G.value, (oe) => {
      if (["month", "year"].includes(oe)) {
        A.value = oe;
        return;
      } else if (oe === "years") {
        A.value = "year";
        return;
      } else if (oe === "months") {
        A.value = "month";
        return;
      }
      A.value = "date";
    }, { immediate: true }), ge(() => A.value, () => {
      p == null || p.updatePopper();
    }), ge(() => g.value, (oe) => {
      oe && (y.value = et());
    }, { immediate: true }), ge(() => n.parsedValue, (oe) => {
      if (oe) {
        if (le.value || Se(oe))
          return;
        y.value = oe;
      } else
        y.value = et();
    }, { immediate: true }), t("set-picker-option", ["isValidValue", ie]), t("set-picker-option", ["formatToString", Ce]), t("set-picker-option", ["parseUserInput", qe]), t("set-picker-option", ["handleFocusPicker", bt]), (oe, Ne) => (k(), x("div", {
      class: I([
        i(r).b(),
        i(a).b(),
        {
          "has-sidebar": oe.$slots.sidebar || i(te),
          "has-time": i(ve)
        }
      ])
    }, [
      B("div", {
        class: I(i(r).e("body-wrapper"))
      }, [
        J(oe.$slots, "sidebar", {
          class: I(i(r).e("sidebar"))
        }),
        i(te) ? (k(), x("div", {
          key: 0,
          class: I(i(r).e("sidebar"))
        }, [
          (k(true), x(Ie, null, st(i(v), (Q, Me) => (k(), x("button", {
            key: Me,
            type: "button",
            class: I(i(r).e("shortcut")),
            onClick: (Qe) => Z(Q)
          }, _e(Q.text), 11, ["onClick"]))), 128))
        ], 2)) : ee("v-if", true),
        B("div", {
          class: I(i(r).e("body"))
        }, [
          i(ve) ? (k(), x("div", {
            key: 0,
            class: I(i(a).e("time-header"))
          }, [
            B("span", {
              class: I(i(a).e("editor-wrap"))
            }, [
              W(i(eo), {
                placeholder: i(u)("el.datepicker.selectDate"),
                "model-value": i(ye),
                size: "small",
                "validate-event": false,
                onInput: (Q) => $.value = Q,
                onChange: fe
              }, null, 8, ["placeholder", "model-value", "onInput"])
            ], 2),
            lt((k(), x("span", {
              class: I(i(a).e("editor-wrap"))
            }, [
              W(i(eo), {
                placeholder: i(u)("el.datepicker.selectTime"),
                "model-value": i(Ee),
                size: "small",
                "validate-event": false,
                onFocus: q,
                onInput: (Q) => R.value = Q,
                onChange: Ae
              }, null, 8, ["placeholder", "model-value", "onInput"]),
              W(i(lf), {
                visible: K.value,
                format: i(re),
                "parsed-value": y.value,
                onPick: ke
              }, null, 8, ["visible", "format", "parsed-value"])
            ], 2)), [
              [i(Sa), ue]
            ])
          ], 2)) : ee("v-if", true),
          lt(B("div", {
            class: I([
              i(a).e("header"),
              (A.value === "year" || A.value === "month") && i(a).e("header--bordered")
            ])
          }, [
            B("span", {
              class: I(i(a).e("prev-btn"))
            }, [
              B("button", {
                type: "button",
                "aria-label": i(u)("el.datepicker.prevYear"),
                class: I(["d-arrow-left", i(r).e("icon-btn")]),
                onClick: (Q) => F(false)
              }, [
                J(oe.$slots, "prev-year", {}, () => [
                  W(i(Be), null, {
                    default: H(() => [
                      W(i(il))
                    ]),
                    _: 1
                  })
                ])
              ], 10, ["aria-label", "onClick"]),
              lt(B("button", {
                type: "button",
                "aria-label": i(u)("el.datepicker.prevMonth"),
                class: I([i(r).e("icon-btn"), "arrow-left"]),
                onClick: (Q) => M(false)
              }, [
                J(oe.$slots, "prev-month", {}, () => [
                  W(i(Be), null, {
                    default: H(() => [
                      W(i(wa))
                    ]),
                    _: 1
                  })
                ])
              ], 10, ["aria-label", "onClick"]), [
                [Nt, A.value === "date"]
              ])
            ], 2),
            B("span", {
              role: "button",
              class: I(i(a).e("header-label")),
              "aria-live": "polite",
              tabindex: "0",
              onKeydown: Bt((Q) => se("year"), ["enter"]),
              onClick: (Q) => se("year")
            }, _e(i(V)), 43, ["onKeydown", "onClick"]),
            lt(B("span", {
              role: "button",
              "aria-live": "polite",
              tabindex: "0",
              class: I([
                i(a).e("header-label"),
                { active: A.value === "month" }
              ]),
              onKeydown: Bt((Q) => se("month"), ["enter"]),
              onClick: (Q) => se("month")
            }, _e(i(u)(`el.datepicker.month${i(T) + 1}`)), 43, ["onKeydown", "onClick"]), [
              [Nt, A.value === "date"]
            ]),
            B("span", {
              class: I(i(a).e("next-btn"))
            }, [
              lt(B("button", {
                type: "button",
                "aria-label": i(u)("el.datepicker.nextMonth"),
                class: I([i(r).e("icon-btn"), "arrow-right"]),
                onClick: (Q) => M(true)
              }, [
                J(oe.$slots, "next-month", {}, () => [
                  W(i(Be), null, {
                    default: H(() => [
                      W(i(oo))
                    ]),
                    _: 1
                  })
                ])
              ], 10, ["aria-label", "onClick"]), [
                [Nt, A.value === "date"]
              ]),
              B("button", {
                type: "button",
                "aria-label": i(u)("el.datepicker.nextYear"),
                class: I([i(r).e("icon-btn"), "d-arrow-right"]),
                onClick: (Q) => F(true)
              }, [
                J(oe.$slots, "next-year", {}, () => [
                  W(i(Be), null, {
                    default: H(() => [
                      W(i(ul))
                    ]),
                    _: 1
                  })
                ])
              ], 10, ["aria-label", "onClick"])
            ], 2)
          ], 2), [
            [Nt, A.value !== "time"]
          ]),
          B("div", {
            class: I(i(r).e("content")),
            onKeydown: zt
          }, [
            A.value === "date" ? (k(), ae(ih, {
              key: 0,
              ref_key: "currentViewRef",
              ref: w,
              "selection-mode": i(G),
              date: y.value,
              "parsed-value": oe.parsedValue,
              "disabled-date": i(m),
              "cell-class-name": i(h),
              onPick: D
            }, null, 8, ["selection-mode", "date", "parsed-value", "disabled-date", "cell-class-name"])) : ee("v-if", true),
            A.value === "year" ? (k(), ae(Ou, {
              key: 1,
              ref_key: "currentViewRef",
              ref: w,
              "selection-mode": i(G),
              date: y.value,
              "disabled-date": i(m),
              "parsed-value": oe.parsedValue,
              onPick: pe
            }, null, 8, ["selection-mode", "date", "disabled-date", "parsed-value"])) : ee("v-if", true),
            A.value === "month" ? (k(), ae(Tu, {
              key: 2,
              ref_key: "currentViewRef",
              ref: w,
              "selection-mode": i(G),
              date: y.value,
              "parsed-value": oe.parsedValue,
              "disabled-date": i(m),
              onPick: ce
            }, null, 8, ["selection-mode", "date", "parsed-value", "disabled-date"])) : ee("v-if", true)
          ], 34)
        ], 2)
      ], 2),
      lt(B("div", {
        class: I(i(r).e("footer"))
      }, [
        lt(W(i(Mn), {
          text: "",
          size: "small",
          class: I(i(r).e("link-btn")),
          disabled: i(de),
          onClick: U
        }, {
          default: H(() => [
            Ze(_e(i(u)("el.datepicker.now")), 1)
          ]),
          _: 1
        }, 8, ["class", "disabled"]), [
          [Nt, !i(le) && oe.showNow]
        ]),
        W(i(Mn), {
          plain: "",
          size: "small",
          class: I(i(r).e("link-btn")),
          disabled: i(De),
          onClick: Te
        }, {
          default: H(() => [
            Ze(_e(i(u)("el.datepicker.confirm")), 1)
          ]),
          _: 1
        }, 8, ["class", "disabled"])
      ], 2), [
        [Nt, i(me)]
      ])
    ], 2));
  }
});
var jz = /* @__PURE__ */ $e(Wz, [["__file", "panel-date-pick.vue"]]);
const Uz = Oe({
  ...rk,
  ...$g,
  visible: Boolean
}), ak = (e10) => {
  const { emit: t } = it(), n = Ta(), o = En();
  return (a) => {
    const l = Fe(a.value) ? a.value() : a.value;
    if (l) {
      t("pick", [
        rt(l[0]).locale(e10.value),
        rt(l[1]).locale(e10.value)
      ]);
      return;
    }
    a.onClick && a.onClick({
      attrs: n,
      slots: o,
      emit: t
    });
  };
}, lk = (e10, {
  defaultValue: t,
  defaultTime: n,
  leftDate: o,
  rightDate: r,
  unit: a,
  onParsedValueChanged: l
}) => {
  const { emit: s } = it(), { pickerNs: u } = Le(sp), c = we("date-range-picker"), { t: d, lang: f } = kt(), p = ak(f), v = L(), m = L(), h = L({
    endDate: null,
    selecting: false
  }), b = (C) => {
    h.value = C;
  }, g = (C = false) => {
    const E = i(v), T = i(m);
    li([E, T]) && s("pick", [E, T], C);
  }, w = (C) => {
    h.value.selecting = C, C || (h.value.endDate = null);
  }, y = (C) => {
    if (Se(C) && C.length === 2) {
      const [E, T] = C;
      v.value = E, o.value = E, m.value = T, l(i(v), i(m));
    } else
      _();
  }, _ = () => {
    let [C, E] = Mg(i(t), {
      lang: i(f),
      unit: a,
      unlinkPanels: e10.unlinkPanels
    });
    const T = (N) => N.diff(N.startOf("d"), "ms"), O = i(n);
    if (O) {
      let N = 0, $ = 0;
      if (Se(O)) {
        const [R, P] = O.map(rt);
        N = T(R), $ = T(P);
      } else {
        const R = T(rt(O));
        N = R, $ = R;
      }
      C = C.startOf("d").add(N, "ms"), E = E.startOf("d").add($, "ms");
    }
    v.value = void 0, m.value = void 0, o.value = C, r.value = E;
  };
  return ge(t, (C) => {
    C && _();
  }, { immediate: true }), ge(() => e10.parsedValue, y, { immediate: true }), {
    minDate: v,
    maxDate: m,
    rangeState: h,
    lang: f,
    ppNs: u,
    drpNs: c,
    handleChangeRange: b,
    handleRangeConfirm: g,
    handleShortcutClick: p,
    onSelect: w,
    onReset: y,
    t: d
  };
}, Yz = (e10, t, n, o) => {
  const r = L("date"), a = L(), l = L("date"), s = L(), u = Le(Aa), { disabledDate: c } = u.props, { t: d, lang: f } = kt(), p = S(() => n.value.year()), v = S(() => n.value.month()), m = S(() => o.value.year()), h = S(() => o.value.month());
  function b(E, T) {
    const O = d("el.datepicker.year");
    if (E.value === "year") {
      const N = Math.floor(T.value / 10) * 10;
      return O ? `${N} ${O} - ${N + 9} ${O}` : `${N} - ${N + 9}`;
    }
    return `${T.value} ${O}`;
  }
  function g(E) {
    E == null || E.focus();
  }
  async function w(E, T) {
    const O = E === "left" ? r : l, N = E === "left" ? a : s;
    O.value = T, await He(), g(N.value);
  }
  async function y(E, T, O) {
    const N = T === "left", $ = N ? n : o, R = N ? o : n, P = N ? r : l, z = N ? a : s;
    if (E === "year") {
      const Y = $.value.year(O);
      $.value = uf(Y, f.value, c);
    }
    E === "month" && ($.value = si($.value, $.value.year(), O, f.value, c)), e10.unlinkPanels || (R.value = T === "left" ? $.value.add(1, "month") : $.value.subtract(1, "month")), P.value = E === "year" ? "month" : "date", await He(), g(z.value), _(E);
  }
  function _(E) {
    t("panel-change", [n.value.toDate(), o.value.toDate()], E);
  }
  function C(E, T, O) {
    const N = O ? "add" : "subtract";
    return E === "year" ? T[N](10, "year") : T[N](1, "year");
  }
  return {
    leftCurrentView: r,
    rightCurrentView: l,
    leftCurrentViewRef: a,
    rightCurrentViewRef: s,
    leftYear: p,
    rightYear: m,
    leftMonth: v,
    rightMonth: h,
    leftYearLabel: S(() => b(r, p)),
    rightYearLabel: S(() => b(l, m)),
    showLeftPicker: (E) => w("left", E),
    showRightPicker: (E) => w("right", E),
    handleLeftYearPick: (E) => y("year", "left", E),
    handleRightYearPick: (E) => y("year", "right", E),
    handleLeftMonthPick: (E) => y("month", "left", E),
    handleRightMonthPick: (E) => y("month", "right", E),
    handlePanelChange: _,
    adjustDateByView: C
  };
}, Hc = "month", qz = /* @__PURE__ */ j({
  __name: "panel-date-range",
  props: Uz,
  emits: [
    "pick",
    "set-picker-option",
    "calendar-change",
    "panel-change"
  ],
  setup(e10, { emit: t }) {
    const n = e10, o = Le(Aa), r = Le(fc), { disabledDate: a, cellClassName: l, defaultTime: s, clearable: u } = o.props, c = Lt(o.props, "format"), d = Lt(o.props, "shortcuts"), f = Lt(o.props, "defaultValue"), { lang: p } = kt(), v = L(rt().locale(p.value)), m = L(rt().locale(p.value).add(1, Hc)), {
      minDate: h,
      maxDate: b,
      rangeState: g,
      ppNs: w,
      drpNs: y,
      handleChangeRange: _,
      handleRangeConfirm: C,
      handleShortcutClick: E,
      onSelect: T,
      onReset: O,
      t: N
    } = lk(n, {
      defaultValue: f,
      defaultTime: s,
      leftDate: v,
      rightDate: m,
      unit: Hc,
      onParsedValueChanged: Bo
    });
    ge(() => n.visible, (Ge) => {
      !Ge && g.value.selecting && (O(n.parsedValue), T(false));
    });
    const $ = L({
      min: null,
      max: null
    }), R = L({
      min: null,
      max: null
    }), {
      leftCurrentView: P,
      rightCurrentView: z,
      leftCurrentViewRef: Y,
      rightCurrentViewRef: D,
      leftYear: M,
      rightYear: F,
      leftMonth: A,
      rightMonth: V,
      leftYearLabel: Z,
      rightYearLabel: G,
      showLeftPicker: le,
      showRightPicker: X,
      handleLeftYearPick: te,
      handleRightYearPick: ce,
      handleLeftMonthPick: pe,
      handleRightMonthPick: se,
      handlePanelChange: ve,
      adjustDateByView: me
    } = Yz(n, t, v, m), De = S(() => !!d.value.length), Te = S(() => $.value.min !== null ? $.value.min : h.value ? h.value.format(Ee.value) : ""), de = S(() => $.value.max !== null ? $.value.max : b.value || h.value ? (b.value || h.value).format(Ee.value) : ""), U = S(() => R.value.min !== null ? R.value.min : h.value ? h.value.format(he.value) : ""), re = S(() => R.value.max !== null ? R.value.max : b.value || h.value ? (b.value || h.value).format(he.value) : ""), he = S(() => n.timeFormat || C2(c.value)), Ee = S(() => n.dateFormat || w2(c.value)), ye = (Ge) => li(Ge) && (a ? !a(Ge[0].toDate()) && !a(Ge[1].toDate()) : true), K = () => {
      v.value = me(P.value, v.value, false), n.unlinkPanels || (m.value = v.value.add(1, "month")), ve("year");
    }, q = () => {
      v.value = v.value.subtract(1, "month"), n.unlinkPanels || (m.value = v.value.add(1, "month")), ve("month");
    }, ue = () => {
      n.unlinkPanels ? m.value = me(z.value, m.value, true) : (v.value = me(z.value, v.value, true), m.value = v.value.add(1, "month")), ve("year");
    }, be = () => {
      n.unlinkPanels ? m.value = m.value.add(1, "month") : (v.value = v.value.add(1, "month"), m.value = v.value.add(1, "month")), ve("month");
    }, ke = () => {
      v.value = me(P.value, v.value, true), ve("year");
    }, Ae = () => {
      v.value = v.value.add(1, "month"), ve("month");
    }, fe = () => {
      m.value = me(z.value, m.value, false), ve("year");
    }, ie = () => {
      m.value = m.value.subtract(1, "month"), ve("month");
    }, Ce = S(() => {
      const Ge = (A.value + 1) % 12, $t = A.value + 1 >= 12 ? 1 : 0;
      return n.unlinkPanels && new Date(M.value + $t, Ge) < new Date(F.value, V.value);
    }), qe = S(() => n.unlinkPanels && F.value * 12 + V.value - (M.value * 12 + A.value + 1) >= 12), et = S(() => !(h.value && b.value && !g.value.selecting && li([h.value, b.value]))), ft = S(() => n.type === "datetime" || n.type === "datetimerange"), bt = (Ge, $t) => {
      if (Ge)
        return s ? rt(s[$t] || s).locale(p.value).year(Ge.year()).month(Ge.month()).date(Ge.date()) : Ge;
    }, zt = (Ge, $t = true) => {
      const mt = Ge.minDate, ao = Ge.maxDate, $r = bt(mt, 0), xa = bt(ao, 1);
      b.value === xa && h.value === $r || (t("calendar-change", [mt.toDate(), ao && ao.toDate()]), b.value = xa, h.value = $r, !(!$t || ft.value) && C());
    }, We = L(false), ct = L(false), oe = () => {
      We.value = false;
    }, Ne = () => {
      ct.value = false;
    }, Q = (Ge, $t) => {
      $.value[$t] = Ge;
      const mt = rt(Ge, Ee.value).locale(p.value);
      if (mt.isValid()) {
        if (a && a(mt.toDate()))
          return;
        $t === "min" ? (v.value = mt, h.value = (h.value || v.value).year(mt.year()).month(mt.month()).date(mt.date()), !n.unlinkPanels && (!b.value || b.value.isBefore(h.value)) && (m.value = mt.add(1, "month"), b.value = h.value.add(1, "month"))) : (m.value = mt, b.value = (b.value || m.value).year(mt.year()).month(mt.month()).date(mt.date()), !n.unlinkPanels && (!h.value || h.value.isAfter(b.value)) && (v.value = mt.subtract(1, "month"), h.value = b.value.subtract(1, "month")));
      }
    }, Me = (Ge, $t) => {
      $.value[$t] = null;
    }, Qe = (Ge, $t) => {
      R.value[$t] = Ge;
      const mt = rt(Ge, he.value).locale(p.value);
      mt.isValid() && ($t === "min" ? (We.value = true, h.value = (h.value || v.value).hour(mt.hour()).minute(mt.minute()).second(mt.second())) : (ct.value = true, b.value = (b.value || m.value).hour(mt.hour()).minute(mt.minute()).second(mt.second()), m.value = b.value));
    }, Ct = (Ge, $t) => {
      R.value[$t] = null, $t === "min" ? (v.value = h.value, We.value = false, (!b.value || b.value.isBefore(h.value)) && (b.value = h.value)) : (m.value = b.value, ct.value = false, b.value && b.value.isBefore(h.value) && (h.value = b.value));
    }, Kt = (Ge, $t, mt) => {
      R.value.min || (Ge && (v.value = Ge, h.value = (h.value || v.value).hour(Ge.hour()).minute(Ge.minute()).second(Ge.second())), mt || (We.value = $t), (!b.value || b.value.isBefore(h.value)) && (b.value = h.value, m.value = Ge));
    }, pn = (Ge, $t, mt) => {
      R.value.max || (Ge && (m.value = Ge, b.value = (b.value || m.value).hour(Ge.hour()).minute(Ge.minute()).second(Ge.second())), mt || (ct.value = $t), b.value && b.value.isBefore(h.value) && (h.value = b.value));
    }, on = () => {
      v.value = Mg(i(f), {
        lang: i(p),
        unit: "month",
        unlinkPanels: n.unlinkPanels
      })[0], m.value = v.value.add(1, "month"), b.value = void 0, h.value = void 0, t("pick", null);
    }, aa = (Ge) => Se(Ge) ? Ge.map(($t) => $t.format(c.value)) : Ge.format(c.value), Sn = (Ge) => ii(Ge, c.value, p.value, r);
    function Bo(Ge, $t) {
      if (n.unlinkPanels && $t) {
        const mt = (Ge == null ? void 0 : Ge.year()) || 0, ao = (Ge == null ? void 0 : Ge.month()) || 0, $r = $t.year(), xa = $t.month();
        m.value = mt === $r && ao === xa ? $t.add(1, Hc) : $t;
      } else
        m.value = v.value.add(1, Hc), $t && (m.value = m.value.hour($t.hour()).minute($t.minute()).second($t.second()));
    }
    return t("set-picker-option", ["isValidValue", ye]), t("set-picker-option", ["parseUserInput", Sn]), t("set-picker-option", ["formatToString", aa]), t("set-picker-option", ["handleClear", on]), (Ge, $t) => (k(), x("div", {
      class: I([
        i(w).b(),
        i(y).b(),
        {
          "has-sidebar": Ge.$slots.sidebar || i(De),
          "has-time": i(ft)
        }
      ])
    }, [
      B("div", {
        class: I(i(w).e("body-wrapper"))
      }, [
        J(Ge.$slots, "sidebar", {
          class: I(i(w).e("sidebar"))
        }),
        i(De) ? (k(), x("div", {
          key: 0,
          class: I(i(w).e("sidebar"))
        }, [
          (k(true), x(Ie, null, st(i(d), (mt, ao) => (k(), x("button", {
            key: ao,
            type: "button",
            class: I(i(w).e("shortcut")),
            onClick: ($r) => i(E)(mt)
          }, _e(mt.text), 11, ["onClick"]))), 128))
        ], 2)) : ee("v-if", true),
        B("div", {
          class: I(i(w).e("body"))
        }, [
          i(ft) ? (k(), x("div", {
            key: 0,
            class: I(i(y).e("time-header"))
          }, [
            B("span", {
              class: I(i(y).e("editors-wrap"))
            }, [
              B("span", {
                class: I(i(y).e("time-picker-wrap"))
              }, [
                W(i(eo), {
                  size: "small",
                  disabled: i(g).selecting,
                  placeholder: i(N)("el.datepicker.startDate"),
                  class: I(i(y).e("editor")),
                  "model-value": i(Te),
                  "validate-event": false,
                  onInput: (mt) => Q(mt, "min"),
                  onChange: (mt) => Me(mt, "min")
                }, null, 8, ["disabled", "placeholder", "class", "model-value", "onInput", "onChange"])
              ], 2),
              lt((k(), x("span", {
                class: I(i(y).e("time-picker-wrap"))
              }, [
                W(i(eo), {
                  size: "small",
                  class: I(i(y).e("editor")),
                  disabled: i(g).selecting,
                  placeholder: i(N)("el.datepicker.startTime"),
                  "model-value": i(U),
                  "validate-event": false,
                  onFocus: (mt) => We.value = true,
                  onInput: (mt) => Qe(mt, "min"),
                  onChange: (mt) => Ct(mt, "min")
                }, null, 8, ["class", "disabled", "placeholder", "model-value", "onFocus", "onInput", "onChange"]),
                W(i(lf), {
                  visible: We.value,
                  format: i(he),
                  "datetime-role": "start",
                  "parsed-value": v.value,
                  onPick: Kt
                }, null, 8, ["visible", "format", "parsed-value"])
              ], 2)), [
                [i(Sa), oe]
              ])
            ], 2),
            B("span", null, [
              W(i(Be), null, {
                default: H(() => [
                  W(i(oo))
                ]),
                _: 1
              })
            ]),
            B("span", {
              class: I([i(y).e("editors-wrap"), "is-right"])
            }, [
              B("span", {
                class: I(i(y).e("time-picker-wrap"))
              }, [
                W(i(eo), {
                  size: "small",
                  class: I(i(y).e("editor")),
                  disabled: i(g).selecting,
                  placeholder: i(N)("el.datepicker.endDate"),
                  "model-value": i(de),
                  readonly: !i(h),
                  "validate-event": false,
                  onInput: (mt) => Q(mt, "max"),
                  onChange: (mt) => Me(mt, "max")
                }, null, 8, ["class", "disabled", "placeholder", "model-value", "readonly", "onInput", "onChange"])
              ], 2),
              lt((k(), x("span", {
                class: I(i(y).e("time-picker-wrap"))
              }, [
                W(i(eo), {
                  size: "small",
                  class: I(i(y).e("editor")),
                  disabled: i(g).selecting,
                  placeholder: i(N)("el.datepicker.endTime"),
                  "model-value": i(re),
                  readonly: !i(h),
                  "validate-event": false,
                  onFocus: (mt) => i(h) && (ct.value = true),
                  onInput: (mt) => Qe(mt, "max"),
                  onChange: (mt) => Ct(mt, "max")
                }, null, 8, ["class", "disabled", "placeholder", "model-value", "readonly", "onFocus", "onInput", "onChange"]),
                W(i(lf), {
                  "datetime-role": "end",
                  visible: ct.value,
                  format: i(he),
                  "parsed-value": m.value,
                  onPick: pn
                }, null, 8, ["visible", "format", "parsed-value"])
              ], 2)), [
                [i(Sa), Ne]
              ])
            ], 2)
          ], 2)) : ee("v-if", true),
          B("div", {
            class: I([[i(w).e("content"), i(y).e("content")], "is-left"])
          }, [
            B("div", {
              class: I(i(y).e("header"))
            }, [
              B("button", {
                type: "button",
                class: I([i(w).e("icon-btn"), "d-arrow-left"]),
                "aria-label": i(N)("el.datepicker.prevYear"),
                onClick: K
              }, [
                J(Ge.$slots, "prev-year", {}, () => [
                  W(i(Be), null, {
                    default: H(() => [
                      W(i(il))
                    ]),
                    _: 1
                  })
                ])
              ], 10, ["aria-label"]),
              lt(B("button", {
                type: "button",
                class: I([i(w).e("icon-btn"), "arrow-left"]),
                "aria-label": i(N)("el.datepicker.prevMonth"),
                onClick: q
              }, [
                J(Ge.$slots, "prev-month", {}, () => [
                  W(i(Be), null, {
                    default: H(() => [
                      W(i(wa))
                    ]),
                    _: 1
                  })
                ])
              ], 10, ["aria-label"]), [
                [Nt, i(P) === "date"]
              ]),
              Ge.unlinkPanels ? (k(), x("button", {
                key: 0,
                type: "button",
                disabled: !i(qe),
                class: I([[i(w).e("icon-btn"), { "is-disabled": !i(qe) }], "d-arrow-right"]),
                "aria-label": i(N)("el.datepicker.nextYear"),
                onClick: ke
              }, [
                J(Ge.$slots, "next-year", {}, () => [
                  W(i(Be), null, {
                    default: H(() => [
                      W(i(ul))
                    ]),
                    _: 1
                  })
                ])
              ], 10, ["disabled", "aria-label"])) : ee("v-if", true),
              Ge.unlinkPanels && i(P) === "date" ? (k(), x("button", {
                key: 1,
                type: "button",
                disabled: !i(Ce),
                class: I([[
                  i(w).e("icon-btn"),
                  { "is-disabled": !i(Ce) }
                ], "arrow-right"]),
                "aria-label": i(N)("el.datepicker.nextMonth"),
                onClick: Ae
              }, [
                J(Ge.$slots, "next-month", {}, () => [
                  W(i(Be), null, {
                    default: H(() => [
                      W(i(oo))
                    ]),
                    _: 1
                  })
                ])
              ], 10, ["disabled", "aria-label"])) : ee("v-if", true),
              B("div", null, [
                B("span", {
                  role: "button",
                  class: I(i(y).e("header-label")),
                  "aria-live": "polite",
                  tabindex: "0",
                  onKeydown: Bt((mt) => i(le)("year"), ["enter"]),
                  onClick: (mt) => i(le)("year")
                }, _e(i(Z)), 43, ["onKeydown", "onClick"]),
                lt(B("span", {
                  role: "button",
                  "aria-live": "polite",
                  tabindex: "0",
                  class: I([
                    i(y).e("header-label"),
                    { active: i(P) === "month" }
                  ]),
                  onKeydown: Bt((mt) => i(le)("month"), ["enter"]),
                  onClick: (mt) => i(le)("month")
                }, _e(i(N)(`el.datepicker.month${v.value.month() + 1}`)), 43, ["onKeydown", "onClick"]), [
                  [Nt, i(P) === "date"]
                ])
              ])
            ], 2),
            i(P) === "date" ? (k(), ae(ih, {
              key: 0,
              ref_key: "leftCurrentViewRef",
              ref: Y,
              "selection-mode": "range",
              date: v.value,
              "min-date": i(h),
              "max-date": i(b),
              "range-state": i(g),
              "disabled-date": i(a),
              "cell-class-name": i(l),
              onChangerange: i(_),
              onPick: zt,
              onSelect: i(T)
            }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "onChangerange", "onSelect"])) : ee("v-if", true),
            i(P) === "year" ? (k(), ae(Ou, {
              key: 1,
              ref_key: "leftCurrentViewRef",
              ref: Y,
              "selection-mode": "year",
              date: v.value,
              "disabled-date": i(a),
              "parsed-value": Ge.parsedValue,
              onPick: i(te)
            }, null, 8, ["date", "disabled-date", "parsed-value", "onPick"])) : ee("v-if", true),
            i(P) === "month" ? (k(), ae(Tu, {
              key: 2,
              ref_key: "leftCurrentViewRef",
              ref: Y,
              "selection-mode": "month",
              date: v.value,
              "parsed-value": Ge.parsedValue,
              "disabled-date": i(a),
              onPick: i(pe)
            }, null, 8, ["date", "parsed-value", "disabled-date", "onPick"])) : ee("v-if", true)
          ], 2),
          B("div", {
            class: I([[i(w).e("content"), i(y).e("content")], "is-right"])
          }, [
            B("div", {
              class: I(i(y).e("header"))
            }, [
              Ge.unlinkPanels ? (k(), x("button", {
                key: 0,
                type: "button",
                disabled: !i(qe),
                class: I([[i(w).e("icon-btn"), { "is-disabled": !i(qe) }], "d-arrow-left"]),
                "aria-label": i(N)("el.datepicker.prevYear"),
                onClick: fe
              }, [
                J(Ge.$slots, "prev-year", {}, () => [
                  W(i(Be), null, {
                    default: H(() => [
                      W(i(il))
                    ]),
                    _: 1
                  })
                ])
              ], 10, ["disabled", "aria-label"])) : ee("v-if", true),
              Ge.unlinkPanels && i(z) === "date" ? (k(), x("button", {
                key: 1,
                type: "button",
                disabled: !i(Ce),
                class: I([[
                  i(w).e("icon-btn"),
                  { "is-disabled": !i(Ce) }
                ], "arrow-left"]),
                "aria-label": i(N)("el.datepicker.prevMonth"),
                onClick: ie
              }, [
                J(Ge.$slots, "prev-month", {}, () => [
                  W(i(Be), null, {
                    default: H(() => [
                      W(i(wa))
                    ]),
                    _: 1
                  })
                ])
              ], 10, ["disabled", "aria-label"])) : ee("v-if", true),
              B("button", {
                type: "button",
                "aria-label": i(N)("el.datepicker.nextYear"),
                class: I([i(w).e("icon-btn"), "d-arrow-right"]),
                onClick: ue
              }, [
                J(Ge.$slots, "next-year", {}, () => [
                  W(i(Be), null, {
                    default: H(() => [
                      W(i(ul))
                    ]),
                    _: 1
                  })
                ])
              ], 10, ["aria-label"]),
              lt(B("button", {
                type: "button",
                class: I([i(w).e("icon-btn"), "arrow-right"]),
                "aria-label": i(N)("el.datepicker.nextMonth"),
                onClick: be
              }, [
                J(Ge.$slots, "next-month", {}, () => [
                  W(i(Be), null, {
                    default: H(() => [
                      W(i(oo))
                    ]),
                    _: 1
                  })
                ])
              ], 10, ["aria-label"]), [
                [Nt, i(z) === "date"]
              ]),
              B("div", null, [
                B("span", {
                  role: "button",
                  class: I(i(y).e("header-label")),
                  "aria-live": "polite",
                  tabindex: "0",
                  onKeydown: Bt((mt) => i(X)("year"), ["enter"]),
                  onClick: (mt) => i(X)("year")
                }, _e(i(G)), 43, ["onKeydown", "onClick"]),
                lt(B("span", {
                  role: "button",
                  "aria-live": "polite",
                  tabindex: "0",
                  class: I([
                    i(y).e("header-label"),
                    { active: i(z) === "month" }
                  ]),
                  onKeydown: Bt((mt) => i(X)("month"), ["enter"]),
                  onClick: (mt) => i(X)("month")
                }, _e(i(N)(`el.datepicker.month${m.value.month() + 1}`)), 43, ["onKeydown", "onClick"]), [
                  [Nt, i(z) === "date"]
                ])
              ])
            ], 2),
            i(z) === "date" ? (k(), ae(ih, {
              key: 0,
              ref_key: "rightCurrentViewRef",
              ref: D,
              "selection-mode": "range",
              date: m.value,
              "min-date": i(h),
              "max-date": i(b),
              "range-state": i(g),
              "disabled-date": i(a),
              "cell-class-name": i(l),
              onChangerange: i(_),
              onPick: zt,
              onSelect: i(T)
            }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "onChangerange", "onSelect"])) : ee("v-if", true),
            i(z) === "year" ? (k(), ae(Ou, {
              key: 1,
              ref_key: "rightCurrentViewRef",
              ref: D,
              "selection-mode": "year",
              date: m.value,
              "disabled-date": i(a),
              "parsed-value": Ge.parsedValue,
              onPick: i(ce)
            }, null, 8, ["date", "disabled-date", "parsed-value", "onPick"])) : ee("v-if", true),
            i(z) === "month" ? (k(), ae(Tu, {
              key: 2,
              ref_key: "rightCurrentViewRef",
              ref: D,
              "selection-mode": "month",
              date: m.value,
              "parsed-value": Ge.parsedValue,
              "disabled-date": i(a),
              onPick: i(se)
            }, null, 8, ["date", "parsed-value", "disabled-date", "onPick"])) : ee("v-if", true)
          ], 2)
        ], 2)
      ], 2),
      i(ft) ? (k(), x("div", {
        key: 0,
        class: I(i(w).e("footer"))
      }, [
        i(u) ? (k(), ae(i(Mn), {
          key: 0,
          text: "",
          size: "small",
          class: I(i(w).e("link-btn")),
          onClick: on
        }, {
          default: H(() => [
            Ze(_e(i(N)("el.datepicker.clear")), 1)
          ]),
          _: 1
        }, 8, ["class"])) : ee("v-if", true),
        W(i(Mn), {
          plain: "",
          size: "small",
          class: I(i(w).e("link-btn")),
          disabled: i(et),
          onClick: (mt) => i(C)(false)
        }, {
          default: H(() => [
            Ze(_e(i(N)("el.datepicker.confirm")), 1)
          ]),
          _: 1
        }, 8, ["class", "disabled", "onClick"])
      ], 2)) : ee("v-if", true)
    ], 2));
  }
});
var Gz = /* @__PURE__ */ $e(qz, [["__file", "panel-date-range.vue"]]);
const Xz = Oe({
  ...$g
}), Jz = [
  "pick",
  "set-picker-option",
  "calendar-change"
], Zz = ({
  unlinkPanels: e10,
  leftDate: t,
  rightDate: n
}) => {
  const { t: o } = kt(), r = () => {
    t.value = t.value.subtract(1, "year"), e10.value || (n.value = n.value.subtract(1, "year"));
  }, a = () => {
    e10.value || (t.value = t.value.add(1, "year")), n.value = n.value.add(1, "year");
  }, l = () => {
    t.value = t.value.add(1, "year");
  }, s = () => {
    n.value = n.value.subtract(1, "year");
  }, u = S(() => `${t.value.year()} ${o("el.datepicker.year")}`), c = S(() => `${n.value.year()} ${o("el.datepicker.year")}`), d = S(() => t.value.year()), f = S(() => n.value.year() === t.value.year() ? t.value.year() + 1 : n.value.year());
  return {
    leftPrevYear: r,
    rightNextYear: a,
    leftNextYear: l,
    rightPrevYear: s,
    leftLabel: u,
    rightLabel: c,
    leftYear: d,
    rightYear: f
  };
}, zc = "year", Qz = /* @__PURE__ */ j({
  name: "DatePickerMonthRange"
}), e9 = /* @__PURE__ */ j({
  ...Qz,
  props: Xz,
  emits: Jz,
  setup(e10, { emit: t }) {
    const n = e10, { lang: o } = kt(), r = Le(Aa), a = Le(fc), { shortcuts: l, disabledDate: s } = r.props, u = Lt(r.props, "format"), c = Lt(r.props, "defaultValue"), d = L(rt().locale(o.value)), f = L(rt().locale(o.value).add(1, zc)), {
      minDate: p,
      maxDate: v,
      rangeState: m,
      ppNs: h,
      drpNs: b,
      handleChangeRange: g,
      handleRangeConfirm: w,
      handleShortcutClick: y,
      onSelect: _
    } = lk(n, {
      defaultValue: c,
      leftDate: d,
      rightDate: f,
      unit: zc,
      onParsedValueChanged: V
    }), C = S(() => !!l.length), {
      leftPrevYear: E,
      rightNextYear: T,
      leftNextYear: O,
      rightPrevYear: N,
      leftLabel: $,
      rightLabel: R,
      leftYear: P,
      rightYear: z
    } = Zz({
      unlinkPanels: Lt(n, "unlinkPanels"),
      leftDate: d,
      rightDate: f
    }), Y = S(() => n.unlinkPanels && z.value > P.value + 1), D = (Z, G = true) => {
      const le = Z.minDate, X = Z.maxDate;
      v.value === X && p.value === le || (t("calendar-change", [le.toDate(), X && X.toDate()]), v.value = X, p.value = le, G && w());
    }, M = () => {
      d.value = Mg(i(c), {
        lang: i(o),
        unit: "year",
        unlinkPanels: n.unlinkPanels
      })[0], f.value = d.value.add(1, "year"), t("pick", null);
    }, F = (Z) => Se(Z) ? Z.map((G) => G.format(u.value)) : Z.format(u.value), A = (Z) => ii(Z, u.value, o.value, a);
    function V(Z, G) {
      if (n.unlinkPanels && G) {
        const le = (Z == null ? void 0 : Z.year()) || 0, X = G.year();
        f.value = le === X ? G.add(1, zc) : G;
      } else
        f.value = d.value.add(1, zc);
    }
    return t("set-picker-option", ["isValidValue", li]), t("set-picker-option", ["formatToString", F]), t("set-picker-option", ["parseUserInput", A]), t("set-picker-option", ["handleClear", M]), (Z, G) => (k(), x("div", {
      class: I([
        i(h).b(),
        i(b).b(),
        {
          "has-sidebar": !!Z.$slots.sidebar || i(C)
        }
      ])
    }, [
      B("div", {
        class: I(i(h).e("body-wrapper"))
      }, [
        J(Z.$slots, "sidebar", {
          class: I(i(h).e("sidebar"))
        }),
        i(C) ? (k(), x("div", {
          key: 0,
          class: I(i(h).e("sidebar"))
        }, [
          (k(true), x(Ie, null, st(i(l), (le, X) => (k(), x("button", {
            key: X,
            type: "button",
            class: I(i(h).e("shortcut")),
            onClick: (te) => i(y)(le)
          }, _e(le.text), 11, ["onClick"]))), 128))
        ], 2)) : ee("v-if", true),
        B("div", {
          class: I(i(h).e("body"))
        }, [
          B("div", {
            class: I([[i(h).e("content"), i(b).e("content")], "is-left"])
          }, [
            B("div", {
              class: I(i(b).e("header"))
            }, [
              B("button", {
                type: "button",
                class: I([i(h).e("icon-btn"), "d-arrow-left"]),
                onClick: i(E)
              }, [
                J(Z.$slots, "prev-year", {}, () => [
                  W(i(Be), null, {
                    default: H(() => [
                      W(i(il))
                    ]),
                    _: 1
                  })
                ])
              ], 10, ["onClick"]),
              Z.unlinkPanels ? (k(), x("button", {
                key: 0,
                type: "button",
                disabled: !i(Y),
                class: I([[
                  i(h).e("icon-btn"),
                  { [i(h).is("disabled")]: !i(Y) }
                ], "d-arrow-right"]),
                onClick: i(O)
              }, [
                J(Z.$slots, "next-year", {}, () => [
                  W(i(Be), null, {
                    default: H(() => [
                      W(i(ul))
                    ]),
                    _: 1
                  })
                ])
              ], 10, ["disabled", "onClick"])) : ee("v-if", true),
              B("div", null, _e(i($)), 1)
            ], 2),
            W(Tu, {
              "selection-mode": "range",
              date: d.value,
              "min-date": i(p),
              "max-date": i(v),
              "range-state": i(m),
              "disabled-date": i(s),
              onChangerange: i(g),
              onPick: D,
              onSelect: i(_)
            }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onSelect"])
          ], 2),
          B("div", {
            class: I([[i(h).e("content"), i(b).e("content")], "is-right"])
          }, [
            B("div", {
              class: I(i(b).e("header"))
            }, [
              Z.unlinkPanels ? (k(), x("button", {
                key: 0,
                type: "button",
                disabled: !i(Y),
                class: I([[i(h).e("icon-btn"), { "is-disabled": !i(Y) }], "d-arrow-left"]),
                onClick: i(N)
              }, [
                J(Z.$slots, "prev-year", {}, () => [
                  W(i(Be), null, {
                    default: H(() => [
                      W(i(il))
                    ]),
                    _: 1
                  })
                ])
              ], 10, ["disabled", "onClick"])) : ee("v-if", true),
              B("button", {
                type: "button",
                class: I([i(h).e("icon-btn"), "d-arrow-right"]),
                onClick: i(T)
              }, [
                J(Z.$slots, "next-year", {}, () => [
                  W(i(Be), null, {
                    default: H(() => [
                      W(i(ul))
                    ]),
                    _: 1
                  })
                ])
              ], 10, ["onClick"]),
              B("div", null, _e(i(R)), 1)
            ], 2),
            W(Tu, {
              "selection-mode": "range",
              date: f.value,
              "min-date": i(p),
              "max-date": i(v),
              "range-state": i(m),
              "disabled-date": i(s),
              onChangerange: i(g),
              onPick: D,
              onSelect: i(_)
            }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onSelect"])
          ], 2)
        ], 2)
      ], 2)
    ], 2));
  }
});
var t9 = /* @__PURE__ */ $e(e9, [["__file", "panel-month-range.vue"]]);
const n9 = Oe({
  ...$g
}), o9 = [
  "pick",
  "set-picker-option",
  "calendar-change"
], r9 = ({
  unlinkPanels: e10,
  leftDate: t,
  rightDate: n
}) => {
  const o = () => {
    t.value = t.value.subtract(10, "year"), e10.value || (n.value = n.value.subtract(10, "year"));
  }, r = () => {
    e10.value || (t.value = t.value.add(10, "year")), n.value = n.value.add(10, "year");
  }, a = () => {
    t.value = t.value.add(10, "year");
  }, l = () => {
    n.value = n.value.subtract(10, "year");
  }, s = S(() => {
    const f = Math.floor(t.value.year() / 10) * 10;
    return `${f}-${f + 9}`;
  }), u = S(() => {
    const f = Math.floor(n.value.year() / 10) * 10;
    return `${f}-${f + 9}`;
  }), c = S(() => Math.floor(t.value.year() / 10) * 10 + 9), d = S(() => Math.floor(n.value.year() / 10) * 10);
  return {
    leftPrevYear: o,
    rightNextYear: r,
    leftNextYear: a,
    rightPrevYear: l,
    leftLabel: s,
    rightLabel: u,
    leftYear: c,
    rightYear: d
  };
}, I1 = "year", a9 = /* @__PURE__ */ j({
  name: "DatePickerYearRange"
}), l9 = /* @__PURE__ */ j({
  ...a9,
  props: n9,
  emits: o9,
  setup(e10, { emit: t }) {
    const n = e10, { lang: o } = kt(), r = L(rt().locale(o.value)), a = L(r.value.add(10, "year")), { pickerNs: l } = Le(sp), s = we("date-range-picker"), u = Le(fc), c = S(() => !!D.length), d = S(() => [
      l.b(),
      s.b(),
      {
        "has-sidebar": !!En().sidebar || c.value
      }
    ]), f = S(() => ({
      content: [l.e("content"), s.e("content"), "is-left"],
      arrowLeftBtn: [l.e("icon-btn"), "d-arrow-left"],
      arrowRightBtn: [
        l.e("icon-btn"),
        { [l.is("disabled")]: !E.value },
        "d-arrow-right"
      ]
    })), p = S(() => ({
      content: [l.e("content"), s.e("content"), "is-right"],
      arrowLeftBtn: [
        l.e("icon-btn"),
        { "is-disabled": !E.value },
        "d-arrow-left"
      ],
      arrowRightBtn: [l.e("icon-btn"), "d-arrow-right"]
    })), v = ak(o), {
      leftPrevYear: m,
      rightNextYear: h,
      leftNextYear: b,
      rightPrevYear: g,
      leftLabel: w,
      rightLabel: y,
      leftYear: _,
      rightYear: C
    } = r9({
      unlinkPanels: Lt(n, "unlinkPanels"),
      leftDate: r,
      rightDate: a
    }), E = S(() => n.unlinkPanels && C.value > _.value + 1), T = L(), O = L(), N = L({
      endDate: null,
      selecting: false
    }), $ = (te) => {
      N.value = te;
    }, R = (te, ce = true) => {
      const pe = te.minDate, se = te.maxDate;
      O.value === se && T.value === pe || (t("calendar-change", [pe.toDate(), se && se.toDate()]), O.value = se, T.value = pe, ce && P());
    }, P = (te = false) => {
      li([T.value, O.value]) && t("pick", [T.value, O.value], te);
    }, z = (te) => {
      N.value.selecting = te, te || (N.value.endDate = null);
    }, Y = Le(Aa), { shortcuts: D, disabledDate: M } = Y.props, F = Lt(Y.props, "format"), A = Lt(Y.props, "defaultValue"), V = () => {
      let te;
      if (Se(A.value)) {
        const ce = rt(A.value[0]);
        let pe = rt(A.value[1]);
        return n.unlinkPanels || (pe = ce.add(10, I1)), [ce, pe];
      } else A.value ? te = rt(A.value) : te = rt();
      return te = te.locale(o.value), [te, te.add(10, I1)];
    };
    ge(() => A.value, (te) => {
      if (te) {
        const ce = V();
        r.value = ce[0], a.value = ce[1];
      }
    }, { immediate: true }), ge(() => n.parsedValue, (te) => {
      if (te && te.length === 2)
        if (T.value = te[0], O.value = te[1], r.value = T.value, n.unlinkPanels && O.value) {
          const ce = T.value.year(), pe = O.value.year();
          a.value = ce === pe ? O.value.add(10, "year") : O.value;
        } else
          a.value = r.value.add(10, "year");
      else {
        const ce = V();
        T.value = void 0, O.value = void 0, r.value = ce[0], a.value = ce[1];
      }
    }, { immediate: true });
    const Z = (te) => ii(te, F.value, o.value, u), G = (te) => Se(te) ? te.map((ce) => ce.format(F.value)) : te.format(F.value), le = (te) => li(te) && (M ? !M(te[0].toDate()) && !M(te[1].toDate()) : true), X = () => {
      const te = V();
      r.value = te[0], a.value = te[1], O.value = void 0, T.value = void 0, t("pick", null);
    };
    return t("set-picker-option", ["isValidValue", le]), t("set-picker-option", ["parseUserInput", Z]), t("set-picker-option", ["formatToString", G]), t("set-picker-option", ["handleClear", X]), (te, ce) => (k(), x("div", {
      class: I(i(d))
    }, [
      B("div", {
        class: I(i(l).e("body-wrapper"))
      }, [
        J(te.$slots, "sidebar", {
          class: I(i(l).e("sidebar"))
        }),
        i(c) ? (k(), x("div", {
          key: 0,
          class: I(i(l).e("sidebar"))
        }, [
          (k(true), x(Ie, null, st(i(D), (pe, se) => (k(), x("button", {
            key: se,
            type: "button",
            class: I(i(l).e("shortcut")),
            onClick: (ve) => i(v)(pe)
          }, _e(pe.text), 11, ["onClick"]))), 128))
        ], 2)) : ee("v-if", true),
        B("div", {
          class: I(i(l).e("body"))
        }, [
          B("div", {
            class: I(i(f).content)
          }, [
            B("div", {
              class: I(i(s).e("header"))
            }, [
              B("button", {
                type: "button",
                class: I(i(f).arrowLeftBtn),
                onClick: i(m)
              }, [
                J(te.$slots, "prev-year", {}, () => [
                  W(i(Be), null, {
                    default: H(() => [
                      W(i(il))
                    ]),
                    _: 1
                  })
                ])
              ], 10, ["onClick"]),
              te.unlinkPanels ? (k(), x("button", {
                key: 0,
                type: "button",
                disabled: !i(E),
                class: I(i(f).arrowRightBtn),
                onClick: i(b)
              }, [
                J(te.$slots, "next-year", {}, () => [
                  W(i(Be), null, {
                    default: H(() => [
                      W(i(ul))
                    ]),
                    _: 1
                  })
                ])
              ], 10, ["disabled", "onClick"])) : ee("v-if", true),
              B("div", null, _e(i(w)), 1)
            ], 2),
            W(Ou, {
              "selection-mode": "range",
              date: r.value,
              "min-date": T.value,
              "max-date": O.value,
              "range-state": N.value,
              "disabled-date": i(M),
              onChangerange: $,
              onPick: R,
              onSelect: z
            }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date"])
          ], 2),
          B("div", {
            class: I(i(p).content)
          }, [
            B("div", {
              class: I(i(s).e("header"))
            }, [
              te.unlinkPanels ? (k(), x("button", {
                key: 0,
                type: "button",
                disabled: !i(E),
                class: I(i(p).arrowLeftBtn),
                onClick: i(g)
              }, [
                J(te.$slots, "prev-year", {}, () => [
                  W(i(Be), null, {
                    default: H(() => [
                      W(i(il))
                    ]),
                    _: 1
                  })
                ])
              ], 10, ["disabled", "onClick"])) : ee("v-if", true),
              B("button", {
                type: "button",
                class: I(i(p).arrowRightBtn),
                onClick: i(h)
              }, [
                J(te.$slots, "next-year", {}, () => [
                  W(i(Be), null, {
                    default: H(() => [
                      W(i(ul))
                    ]),
                    _: 1
                  })
                ])
              ], 10, ["onClick"]),
              B("div", null, _e(i(y)), 1)
            ], 2),
            W(Ou, {
              "selection-mode": "range",
              date: a.value,
              "min-date": T.value,
              "max-date": O.value,
              "range-state": N.value,
              "disabled-date": i(M),
              onChangerange: $,
              onPick: R,
              onSelect: z
            }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date"])
          ], 2)
        ], 2)
      ], 2)
    ], 2));
  }
});
var s9 = /* @__PURE__ */ $e(l9, [["__file", "panel-year-range.vue"]]);
const i9 = function(e10) {
  switch (e10) {
    case "daterange":
    case "datetimerange":
      return Gz;
    case "monthrange":
      return t9;
    case "yearrange":
      return s9;
    default:
      return jz;
  }
};
rt.extend(E2);
rt.extend(jH);
rt.extend(kg);
rt.extend(GH);
rt.extend(QH);
rt.extend(oz);
rt.extend(sz);
rt.extend(dz);
var u9 = /* @__PURE__ */ j({
  name: "ElDatePicker",
  install: null,
  props: Iz,
  emits: [nt],
  setup(e10, {
    expose: t,
    emit: n,
    slots: o
  }) {
    const r = we("picker-panel"), a = S(() => !e10.format);
    yt(fc, a), yt(Ng, It(Lt(e10, "popperOptions"))), yt(sp, {
      slots: o,
      pickerNs: r
    });
    const l = L();
    t({
      focus: () => {
        var c;
        (c = l.value) == null || c.focus();
      },
      blur: () => {
        var c;
        (c = l.value) == null || c.blur();
      },
      handleOpen: () => {
        var c;
        (c = l.value) == null || c.handleOpen();
      },
      handleClose: () => {
        var c;
        (c = l.value) == null || c.handleClose();
      }
    });
    const u = (c) => {
      n(nt, c);
    };
    return () => {
      var c;
      const d = (c = e10.format) != null ? c : fz[e10.type] || Ns, f = i9(e10.type);
      return W(Q2, vt(e10, {
        format: d,
        type: e10.type,
        ref: l,
        "onUpdate:modelValue": u
      }), {
        default: (p) => W(f, p, {
          "prev-month": o["prev-month"],
          "next-month": o["next-month"],
          "prev-year": o["prev-year"],
          "next-year": o["next-year"]
        }),
        "range-separator": o["range-separator"]
      });
    };
  }
});
const c9 = ut(u9), Rg = Symbol("elDescriptions");
var Hi = /* @__PURE__ */ j({
  name: "ElDescriptionsCell",
  props: {
    cell: {
      type: Object
    },
    tag: {
      type: String,
      default: "td"
    },
    type: {
      type: String
    }
  },
  setup() {
    return {
      descriptions: Le(Rg, {})
    };
  },
  render() {
    var e10;
    const t = u5(this.cell), n = (((e10 = this.cell) == null ? void 0 : e10.dirs) || []).map((g) => {
      const { dir: w, arg: y, modifiers: _, value: C } = g;
      return [w, C, y, _];
    }), { border: o, direction: r } = this.descriptions, a = r === "vertical", l = () => {
      var g, w, y;
      return ((y = (w = (g = this.cell) == null ? void 0 : g.children) == null ? void 0 : w.label) == null ? void 0 : y.call(w)) || t.label;
    }, s = () => {
      var g, w, y;
      return (y = (w = (g = this.cell) == null ? void 0 : g.children) == null ? void 0 : w.default) == null ? void 0 : y.call(w);
    }, u = t.span, c = t.rowspan, d = t.align ? `is-${t.align}` : "", f = t.labelAlign ? `is-${t.labelAlign}` : d, p = t.className, v = t.labelClassName, m = this.type === "label" && (t.labelWidth || this.descriptions.labelWidth) || t.width, h = {
      width: sn(m),
      minWidth: sn(t.minWidth)
    }, b = we("descriptions");
    switch (this.type) {
      case "label":
        return lt(Ke(this.tag, {
          style: h,
          class: [
            b.e("cell"),
            b.e("label"),
            b.is("bordered-label", o),
            b.is("vertical-label", a),
            f,
            v
          ],
          colSpan: a ? u : 1,
          rowspan: a ? 1 : c
        }, l()), n);
      case "content":
        return lt(Ke(this.tag, {
          style: h,
          class: [
            b.e("cell"),
            b.e("content"),
            b.is("bordered-content", o),
            b.is("vertical-content", a),
            d,
            p
          ],
          colSpan: a ? u : u * 2 - 1,
          rowspan: a ? c * 2 - 1 : c
        }, s()), n);
      default: {
        const g = l(), w = {}, y = sn(t.labelWidth || this.descriptions.labelWidth);
        return y && (w.width = y, w.display = "inline-block"), lt(Ke("td", {
          style: h,
          class: [b.e("cell"), d],
          colSpan: u,
          rowspan: c
        }, [
          Nn(g) ? void 0 : Ke("span", {
            style: w,
            class: [b.e("label"), v]
          }, g),
          Ke("span", {
            class: [b.e("content"), p]
          }, s())
        ]), n);
      }
    }
  }
});
const d9 = Oe({
  row: {
    type: ne(Array),
    default: () => []
  }
}), f9 = /* @__PURE__ */ j({
  name: "ElDescriptionsRow"
}), p9 = /* @__PURE__ */ j({
  ...f9,
  props: d9,
  setup(e10) {
    const t = Le(Rg, {});
    return (n, o) => i(t).direction === "vertical" ? (k(), x(Ie, { key: 0 }, [
      B("tr", null, [
        (k(true), x(Ie, null, st(n.row, (r, a) => (k(), ae(i(Hi), {
          key: `tr1-${a}`,
          cell: r,
          tag: "th",
          type: "label"
        }, null, 8, ["cell"]))), 128))
      ]),
      B("tr", null, [
        (k(true), x(Ie, null, st(n.row, (r, a) => (k(), ae(i(Hi), {
          key: `tr2-${a}`,
          cell: r,
          tag: "td",
          type: "content"
        }, null, 8, ["cell"]))), 128))
      ])
    ], 64)) : (k(), x("tr", { key: 1 }, [
      (k(true), x(Ie, null, st(n.row, (r, a) => (k(), x(Ie, {
        key: `tr3-${a}`
      }, [
        i(t).border ? (k(), x(Ie, { key: 0 }, [
          W(i(Hi), {
            cell: r,
            tag: "td",
            type: "label"
          }, null, 8, ["cell"]),
          W(i(Hi), {
            cell: r,
            tag: "td",
            type: "content"
          }, null, 8, ["cell"])
        ], 64)) : (k(), ae(i(Hi), {
          key: 1,
          cell: r,
          tag: "td",
          type: "both"
        }, null, 8, ["cell"]))
      ], 64))), 128))
    ]));
  }
});
var v9 = /* @__PURE__ */ $e(p9, [["__file", "descriptions-row.vue"]]);
const h9 = Oe({
  border: Boolean,
  column: {
    type: Number,
    default: 3
  },
  direction: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "horizontal"
  },
  size: _n,
  title: {
    type: String,
    default: ""
  },
  extra: {
    type: String,
    default: ""
  },
  labelWidth: {
    type: [String, Number],
    default: ""
  }
}), sk = "ElDescriptionsItem", m9 = /* @__PURE__ */ j({
  name: "ElDescriptions"
}), g9 = /* @__PURE__ */ j({
  ...m9,
  props: h9,
  setup(e10) {
    const t = e10, n = we("descriptions"), o = yn(), r = En();
    yt(Rg, t);
    const a = S(() => [n.b(), n.m(o.value)]), l = (u, c, d, f = false) => (u.props || (u.props = {}), c > d && (u.props.span = d), f && (u.props.span = c), u), s = () => {
      if (!r.default)
        return [];
      const u = Fr(r.default()).filter((m) => {
        var h;
        return ((h = m == null ? void 0 : m.type) == null ? void 0 : h.name) === sk;
      }), c = [];
      let d = [], f = t.column, p = 0;
      const v = [];
      return u.forEach((m, h) => {
        var b, g, w;
        const y = ((b = m.props) == null ? void 0 : b.span) || 1, _ = ((g = m.props) == null ? void 0 : g.rowspan) || 1, C = c.length;
        if (v[C] || (v[C] = 0), _ > 1)
          for (let E = 1; E < _; E++)
            v[w = C + E] || (v[w] = 0), v[C + E]++, p++;
        if (v[C] > 0 && (f -= v[C], v[C] = 0), h < u.length - 1 && (p += y > f ? f : y), h === u.length - 1) {
          const E = t.column - p % t.column;
          d.push(l(m, E, f, true)), c.push(d);
          return;
        }
        y < f ? (f -= y, d.push(m)) : (d.push(l(m, y, f)), c.push(d), f = t.column, d = []);
      }), c;
    };
    return (u, c) => (k(), x("div", {
      class: I(i(a))
    }, [
      u.title || u.extra || u.$slots.title || u.$slots.extra ? (k(), x("div", {
        key: 0,
        class: I(i(n).e("header"))
      }, [
        B("div", {
          class: I(i(n).e("title"))
        }, [
          J(u.$slots, "title", {}, () => [
            Ze(_e(u.title), 1)
          ])
        ], 2),
        B("div", {
          class: I(i(n).e("extra"))
        }, [
          J(u.$slots, "extra", {}, () => [
            Ze(_e(u.extra), 1)
          ])
        ], 2)
      ], 2)) : ee("v-if", true),
      B("div", {
        class: I(i(n).e("body"))
      }, [
        B("table", {
          class: I([i(n).e("table"), i(n).is("bordered", u.border)])
        }, [
          B("tbody", null, [
            (k(true), x(Ie, null, st(s(), (d, f) => (k(), ae(v9, {
              key: f,
              row: d
            }, null, 8, ["row"]))), 128))
          ])
        ], 2)
      ], 2)
    ], 2));
  }
});
var y9 = /* @__PURE__ */ $e(g9, [["__file", "description.vue"]]);
const M1 = ["left", "center", "right"], b9 = Oe({
  label: {
    type: String,
    default: ""
  },
  span: {
    type: Number,
    default: 1
  },
  rowspan: {
    type: Number,
    default: 1
  },
  width: {
    type: [String, Number],
    default: ""
  },
  minWidth: {
    type: [String, Number],
    default: ""
  },
  labelWidth: {
    type: [String, Number],
    default: ""
  },
  align: {
    type: String,
    values: M1,
    default: "left"
  },
  labelAlign: {
    type: String,
    values: M1
  },
  className: {
    type: String,
    default: ""
  },
  labelClassName: {
    type: String,
    default: ""
  }
}), ik = /* @__PURE__ */ j({
  name: sk,
  props: b9
}), _9 = ut(y9, {
  DescriptionsItem: ik
}), w9 = nn(ik), Ag = (e10) => {
  if (!e10)
    return { onClick: Mt, onMousedown: Mt, onMouseup: Mt };
  let t = false, n = false;
  return { onClick: (l) => {
    t && n && e10(l), t = n = false;
  }, onMousedown: (l) => {
    t = l.target === l.currentTarget;
  }, onMouseup: (l) => {
    n = l.target === l.currentTarget;
  } };
}, C9 = Oe({
  mask: {
    type: Boolean,
    default: true
  },
  customMaskEvent: Boolean,
  overlayClass: {
    type: ne([
      String,
      Array,
      Object
    ])
  },
  zIndex: {
    type: ne([String, Number])
  }
}), E9 = {
  click: (e10) => e10 instanceof MouseEvent
}, S9 = "overlay";
var k9 = /* @__PURE__ */ j({
  name: "ElOverlay",
  props: C9,
  emits: E9,
  setup(e10, { slots: t, emit: n }) {
    const o = we(S9), r = (u) => {
      n("click", u);
    }, { onClick: a, onMousedown: l, onMouseup: s } = Ag(e10.customMaskEvent ? void 0 : r);
    return () => e10.mask ? W("div", {
      class: [o.b(), e10.overlayClass],
      style: {
        zIndex: e10.zIndex
      },
      onClick: a,
      onMousedown: l,
      onMouseup: s
    }, [J(t, "default")], zo.STYLE | zo.CLASS | zo.PROPS, ["onClick", "onMouseup", "onMousedown"]) : Ke("div", {
      class: e10.overlayClass,
      style: {
        zIndex: e10.zIndex,
        position: "fixed",
        top: "0px",
        right: "0px",
        bottom: "0px",
        left: "0px"
      }
    }, [J(t, "default")]);
  }
});
const Lg = k9, uk = Symbol("dialogInjectionKey"), ck = Oe({
  center: Boolean,
  alignCenter: Boolean,
  closeIcon: {
    type: Ht
  },
  draggable: Boolean,
  overflow: Boolean,
  fullscreen: Boolean,
  headerClass: String,
  bodyClass: String,
  footerClass: String,
  showClose: {
    type: Boolean,
    default: true
  },
  title: {
    type: String,
    default: ""
  },
  ariaLevel: {
    type: String,
    default: "2"
  }
}), N9 = {
  close: () => true
}, dk = (e10, t, n, o) => {
  const r = {
    offsetX: 0,
    offsetY: 0
  }, a = (f, p) => {
    if (e10.value) {
      const { offsetX: v, offsetY: m } = r, h = e10.value.getBoundingClientRect(), b = h.left, g = h.top, w = h.width, y = h.height, _ = document.documentElement.clientWidth, C = document.documentElement.clientHeight, E = -b + v, T = -g + m, O = _ - b - w + v, N = C - g - (y < C ? y : 0) + m;
      o != null && o.value || (f = Math.min(Math.max(f, E), O), p = Math.min(Math.max(p, T), N)), r.offsetX = f, r.offsetY = p, e10.value.style.transform = `translate(${sn(f)}, ${sn(p)})`;
    }
  }, l = (f) => {
    const p = f.clientX, v = f.clientY, { offsetX: m, offsetY: h } = r, b = (w) => {
      const y = m + w.clientX - p, _ = h + w.clientY - v;
      a(y, _);
    }, g = () => {
      document.removeEventListener("mousemove", b), document.removeEventListener("mouseup", g);
    };
    document.addEventListener("mousemove", b), document.addEventListener("mouseup", g);
  }, s = () => {
    t.value && e10.value && (t.value.addEventListener("mousedown", l), window.addEventListener("resize", d));
  }, u = () => {
    t.value && e10.value && (t.value.removeEventListener("mousedown", l), window.removeEventListener("resize", d));
  }, c = () => {
    r.offsetX = 0, r.offsetY = 0, e10.value && (e10.value.style.transform = "");
  }, d = () => {
    const { offsetX: f, offsetY: p } = r;
    a(f, p);
  };
  return dt(() => {
    Vn(() => {
      n.value ? s() : u();
    });
  }), jt(() => {
    u();
  }), {
    resetPosition: c,
    updatePosition: d
  };
}, ip = (...e10) => (t) => {
  e10.forEach((n) => {
    Fe(n) ? n(t) : n.value = t;
  });
}, T9 = /* @__PURE__ */ j({ name: "ElDialogContent" }), O9 = /* @__PURE__ */ j({
  ...T9,
  props: ck,
  emits: N9,
  setup(e10, { expose: t }) {
    const n = e10, { t: o } = kt(), { Close: r } = xS, { dialogRef: a, headerRef: l, bodyId: s, ns: u, style: c } = Le(uk), { focusTrapRef: d } = Le(dg), f = S(() => [
      u.b(),
      u.is("fullscreen", n.fullscreen),
      u.is("draggable", n.draggable),
      u.is("align-center", n.alignCenter),
      { [u.m("center")]: n.center }
    ]), p = ip(d, a), v = S(() => n.draggable), m = S(() => n.overflow), { resetPosition: h, updatePosition: b } = dk(a, l, v, m);
    return t({
      resetPosition: h,
      updatePosition: b
    }), (g, w) => (k(), x("div", {
      ref: i(p),
      class: I(i(f)),
      style: ze(i(c)),
      tabindex: "-1"
    }, [
      B("header", {
        ref_key: "headerRef",
        ref: l,
        class: I([i(u).e("header"), g.headerClass, { "show-close": g.showClose }])
      }, [
        J(g.$slots, "header", {}, () => [
          B("span", {
            role: "heading",
            "aria-level": g.ariaLevel,
            class: I(i(u).e("title"))
          }, _e(g.title), 11, ["aria-level"])
        ]),
        g.showClose ? (k(), x("button", {
          key: 0,
          "aria-label": i(o)("el.dialog.close"),
          class: I(i(u).e("headerbtn")),
          type: "button",
          onClick: (y) => g.$emit("close")
        }, [
          W(i(Be), {
            class: I(i(u).e("close"))
          }, {
            default: H(() => [
              (k(), ae(ht(g.closeIcon || i(r))))
            ]),
            _: 1
          }, 8, ["class"])
        ], 10, ["aria-label", "onClick"])) : ee("v-if", true)
      ], 2),
      B("div", {
        id: i(s),
        class: I([i(u).e("body"), g.bodyClass])
      }, [
        J(g.$slots, "default")
      ], 10, ["id"]),
      g.$slots.footer ? (k(), x("footer", {
        key: 0,
        class: I([i(u).e("footer"), g.footerClass])
      }, [
        J(g.$slots, "footer")
      ], 2)) : ee("v-if", true)
    ], 6));
  }
});
var $9 = /* @__PURE__ */ $e(O9, [["__file", "dialog-content.vue"]]);
const fk = Oe({
  ...ck,
  appendToBody: Boolean,
  appendTo: {
    type: rp.to.type,
    default: "body"
  },
  beforeClose: {
    type: ne(Function)
  },
  destroyOnClose: Boolean,
  closeOnClickModal: {
    type: Boolean,
    default: true
  },
  closeOnPressEscape: {
    type: Boolean,
    default: true
  },
  lockScroll: {
    type: Boolean,
    default: true
  },
  modal: {
    type: Boolean,
    default: true
  },
  openDelay: {
    type: Number,
    default: 0
  },
  closeDelay: {
    type: Number,
    default: 0
  },
  top: {
    type: String
  },
  modelValue: Boolean,
  modalClass: String,
  headerClass: String,
  bodyClass: String,
  footerClass: String,
  width: {
    type: [String, Number]
  },
  zIndex: {
    type: Number
  },
  trapFocus: Boolean,
  headerAriaLevel: {
    type: String,
    default: "2"
  }
}), pk = {
  open: () => true,
  opened: () => true,
  close: () => true,
  closed: () => true,
  [nt]: (e10) => Vt(e10),
  openAutoFocus: () => true,
  closeAutoFocus: () => true
}, xg = (e10, t = {}) => {
  Ot(e10) || Qt("[useLockscreen]", "You need to pass a ref param to this function");
  const n = t.ns || we("popup"), o = S(() => n.bm("parent", "hidden"));
  if (!Et || Eo(document.body, o.value))
    return;
  let r = 0, a = false, l = "0";
  const s = () => {
    setTimeout(() => {
      typeof document > "u" || a && document && (document.body.style.width = l, no(document.body, o.value));
    }, 200);
  };
  ge(e10, (u) => {
    if (!u) {
      s();
      return;
    }
    a = !Eo(document.body, o.value), a && (l = document.body.style.width, jo(document.body, o.value)), r = NS(n.namespace.value);
    const c = document.documentElement.clientHeight < document.body.scrollHeight, d = ha(document.body, "overflowY");
    r > 0 && (c || d === "scroll") && a && (document.body.style.width = `calc(100% - ${r}px)`);
  }), zw(() => s());
}, vk = (e10, t) => {
  var n;
  const r = it().emit, { nextZIndex: a } = Si();
  let l = "";
  const s = Fn(), u = Fn(), c = L(false), d = L(false), f = L(false), p = L((n = e10.zIndex) != null ? n : a());
  let v, m;
  const h = lc("namespace", eu), b = S(() => {
    const D = {}, M = `--${h.value}-dialog`;
    return e10.fullscreen || (e10.top && (D[`${M}-margin-top`] = e10.top), e10.width && (D[`${M}-width`] = sn(e10.width))), D;
  }), g = S(() => e10.alignCenter ? { display: "flex" } : {});
  function w() {
    r("opened");
  }
  function y() {
    r("closed"), r(nt, false), e10.destroyOnClose && (f.value = false);
  }
  function _() {
    r("close");
  }
  function C() {
    m == null || m(), v == null || v(), e10.openDelay && e10.openDelay > 0 ? { stop: v } = Xl(() => N(), e10.openDelay) : N();
  }
  function E() {
    v == null || v(), m == null || m(), e10.closeDelay && e10.closeDelay > 0 ? { stop: m } = Xl(() => $(), e10.closeDelay) : $();
  }
  function T() {
    function D(M) {
      M || (d.value = true, c.value = false);
    }
    e10.beforeClose ? e10.beforeClose(D) : E();
  }
  function O() {
    e10.closeOnClickModal && T();
  }
  function N() {
    Et && (c.value = true);
  }
  function $() {
    c.value = false;
  }
  function R() {
    r("openAutoFocus");
  }
  function P() {
    r("closeAutoFocus");
  }
  function z(D) {
    var M;
    ((M = D.detail) == null ? void 0 : M.focusReason) === "pointer" && D.preventDefault();
  }
  e10.lockScroll && xg(c);
  function Y() {
    e10.closeOnPressEscape && T();
  }
  return ge(() => e10.zIndex, () => {
    var D;
    p.value = (D = e10.zIndex) != null ? D : a();
  }), ge(() => e10.modelValue, (D) => {
    var M;
    D ? (d.value = false, C(), f.value = true, p.value = (M = e10.zIndex) != null ? M : a(), He(() => {
      r("open"), t.value && (t.value.parentElement.scrollTop = 0, t.value.parentElement.scrollLeft = 0, t.value.scrollTop = 0);
    })) : c.value && E();
  }), ge(() => e10.fullscreen, (D) => {
    t.value && (D ? (l = t.value.style.transform, t.value.style.transform = "") : t.value.style.transform = l);
  }), dt(() => {
    e10.modelValue && (c.value = true, f.value = true, C());
  }), {
    afterEnter: w,
    afterLeave: y,
    beforeLeave: _,
    handleClose: T,
    onModalClick: O,
    close: E,
    doClose: $,
    onOpenAutoFocus: R,
    onCloseAutoFocus: P,
    onCloseRequested: Y,
    onFocusoutPrevented: z,
    titleId: s,
    bodyId: u,
    closed: d,
    style: b,
    overlayDialogStyle: g,
    rendered: f,
    visible: c,
    zIndex: p
  };
}, I9 = /* @__PURE__ */ j({
  name: "ElDialog",
  inheritAttrs: false
}), M9 = /* @__PURE__ */ j({
  ...I9,
  props: fk,
  emits: pk,
  setup(e10, { expose: t }) {
    const n = e10, o = En();
    _a({
      scope: "el-dialog",
      from: "the title slot",
      replacement: "the header slot",
      version: "3.0.0",
      ref: "https://element-plus.org/en-US/component/dialog.html#slots"
    }, S(() => !!o.title));
    const r = we("dialog"), a = L(), l = L(), s = L(), {
      visible: u,
      titleId: c,
      bodyId: d,
      style: f,
      overlayDialogStyle: p,
      rendered: v,
      zIndex: m,
      afterEnter: h,
      afterLeave: b,
      beforeLeave: g,
      handleClose: w,
      onModalClick: y,
      onOpenAutoFocus: _,
      onCloseAutoFocus: C,
      onCloseRequested: E,
      onFocusoutPrevented: T
    } = vk(n, a);
    yt(uk, {
      dialogRef: a,
      headerRef: l,
      bodyId: d,
      ns: r,
      rendered: v,
      style: f
    });
    const O = Ag(y), N = S(() => n.draggable && !n.fullscreen);
    return t({
      visible: u,
      dialogContentRef: s,
      resetPosition: () => {
        var R;
        (R = s.value) == null || R.resetPosition();
      },
      handleClose: w
    }), (R, P) => (k(), ae(i(Ti), {
      to: R.appendTo,
      disabled: R.appendTo !== "body" ? false : !R.appendToBody
    }, {
      default: H(() => [
        W(Rn, {
          name: "dialog-fade",
          onAfterEnter: i(h),
          onAfterLeave: i(b),
          onBeforeLeave: i(g),
          persisted: ""
        }, {
          default: H(() => [
            lt(W(i(Lg), {
              "custom-mask-event": "",
              mask: R.modal,
              "overlay-class": R.modalClass,
              "z-index": i(m)
            }, {
              default: H(() => [
                B("div", {
                  role: "dialog",
                  "aria-modal": "true",
                  "aria-label": R.title || void 0,
                  "aria-labelledby": R.title ? void 0 : i(c),
                  "aria-describedby": i(d),
                  class: I(`${i(r).namespace.value}-overlay-dialog`),
                  style: ze(i(p)),
                  onClick: i(O).onClick,
                  onMousedown: i(O).onMousedown,
                  onMouseup: i(O).onMouseup
                }, [
                  W(i(Ni), {
                    loop: "",
                    trapped: i(u),
                    "focus-start-el": "container",
                    onFocusAfterTrapped: i(_),
                    onFocusAfterReleased: i(C),
                    onFocusoutPrevented: i(T),
                    onReleaseRequested: i(E)
                  }, {
                    default: H(() => [
                      i(v) ? (k(), ae($9, vt({
                        key: 0,
                        ref_key: "dialogContentRef",
                        ref: s
                      }, R.$attrs, {
                        center: R.center,
                        "align-center": R.alignCenter,
                        "close-icon": R.closeIcon,
                        draggable: i(N),
                        overflow: R.overflow,
                        fullscreen: R.fullscreen,
                        "header-class": R.headerClass,
                        "body-class": R.bodyClass,
                        "footer-class": R.footerClass,
                        "show-close": R.showClose,
                        title: R.title,
                        "aria-level": R.headerAriaLevel,
                        onClose: i(w)
                      }), ro({
                        header: H(() => [
                          R.$slots.title ? J(R.$slots, "title", { key: 1 }) : J(R.$slots, "header", {
                            key: 0,
                            close: i(w),
                            titleId: i(c),
                            titleClass: i(r).e("title")
                          })
                        ]),
                        default: H(() => [
                          J(R.$slots, "default")
                        ]),
                        _: 2
                      }, [
                        R.$slots.footer ? {
                          name: "footer",
                          fn: H(() => [
                            J(R.$slots, "footer")
                          ])
                        } : void 0
                      ]), 1040, ["center", "align-center", "close-icon", "draggable", "overflow", "fullscreen", "header-class", "body-class", "footer-class", "show-close", "title", "aria-level", "onClose"])) : ee("v-if", true)
                    ]),
                    _: 3
                  }, 8, ["trapped", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])
                ], 46, ["aria-label", "aria-labelledby", "aria-describedby", "onClick", "onMousedown", "onMouseup"])
              ]),
              _: 3
            }, 8, ["mask", "overlay-class", "z-index"]), [
              [Nt, i(u)]
            ])
          ]),
          _: 3
        }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])
      ]),
      _: 3
    }, 8, ["to", "disabled"]));
  }
});
var P9 = /* @__PURE__ */ $e(M9, [["__file", "dialog.vue"]]);
const R9 = ut(P9), A9 = Oe({
  direction: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "horizontal"
  },
  contentPosition: {
    type: String,
    values: ["left", "center", "right"],
    default: "center"
  },
  borderStyle: {
    type: ne(String),
    default: "solid"
  }
}), L9 = /* @__PURE__ */ j({
  name: "ElDivider"
}), x9 = /* @__PURE__ */ j({
  ...L9,
  props: A9,
  setup(e10) {
    const t = e10, n = we("divider"), o = S(() => n.cssVar({
      "border-style": t.borderStyle
    }));
    return (r, a) => (k(), x("div", {
      class: I([i(n).b(), i(n).m(r.direction)]),
      style: ze(i(o)),
      role: "separator"
    }, [
      r.$slots.default && r.direction !== "vertical" ? (k(), x("div", {
        key: 0,
        class: I([i(n).e("text"), i(n).is(r.contentPosition)])
      }, [
        J(r.$slots, "default")
      ], 2)) : ee("v-if", true)
    ], 6));
  }
});
var D9 = /* @__PURE__ */ $e(x9, [["__file", "divider.vue"]]);
const hk = ut(D9), V9 = Oe({
  ...fk,
  direction: {
    type: String,
    default: "rtl",
    values: ["ltr", "rtl", "ttb", "btt"]
  },
  size: {
    type: [String, Number],
    default: "30%"
  },
  withHeader: {
    type: Boolean,
    default: true
  },
  modalFade: {
    type: Boolean,
    default: true
  },
  headerAriaLevel: {
    type: String,
    default: "2"
  }
}), F9 = pk, B9 = /* @__PURE__ */ j({
  name: "ElDrawer",
  inheritAttrs: false
}), H9 = /* @__PURE__ */ j({
  ...B9,
  props: V9,
  emits: F9,
  setup(e10, { expose: t }) {
    const n = e10, o = En();
    _a({
      scope: "el-drawer",
      from: "the title slot",
      replacement: "the header slot",
      version: "3.0.0",
      ref: "https://element-plus.org/en-US/component/drawer.html#slots"
    }, S(() => !!o.title));
    const r = L(), a = L(), l = we("drawer"), { t: s } = kt(), {
      afterEnter: u,
      afterLeave: c,
      beforeLeave: d,
      visible: f,
      rendered: p,
      titleId: v,
      bodyId: m,
      zIndex: h,
      onModalClick: b,
      onOpenAutoFocus: g,
      onCloseAutoFocus: w,
      onFocusoutPrevented: y,
      onCloseRequested: _,
      handleClose: C
    } = vk(n, r), E = S(() => n.direction === "rtl" || n.direction === "ltr"), T = S(() => sn(n.size));
    return t({
      handleClose: C,
      afterEnter: u,
      afterLeave: c
    }), (O, N) => (k(), ae(i(Ti), {
      to: O.appendTo,
      disabled: O.appendTo !== "body" ? false : !O.appendToBody
    }, {
      default: H(() => [
        W(Rn, {
          name: i(l).b("fade"),
          onAfterEnter: i(u),
          onAfterLeave: i(c),
          onBeforeLeave: i(d),
          persisted: ""
        }, {
          default: H(() => [
            lt(W(i(Lg), {
              mask: O.modal,
              "overlay-class": O.modalClass,
              "z-index": i(h),
              onClick: i(b)
            }, {
              default: H(() => [
                W(i(Ni), {
                  loop: "",
                  trapped: i(f),
                  "focus-trap-el": r.value,
                  "focus-start-el": a.value,
                  onFocusAfterTrapped: i(g),
                  onFocusAfterReleased: i(w),
                  onFocusoutPrevented: i(y),
                  onReleaseRequested: i(_)
                }, {
                  default: H(() => [
                    B("div", vt({
                      ref_key: "drawerRef",
                      ref: r,
                      "aria-modal": "true",
                      "aria-label": O.title || void 0,
                      "aria-labelledby": O.title ? void 0 : i(v),
                      "aria-describedby": i(m)
                    }, O.$attrs, {
                      class: [i(l).b(), O.direction, i(f) && "open"],
                      style: i(E) ? "width: " + i(T) : "height: " + i(T),
                      role: "dialog",
                      onClick: Xe(() => {
                      }, ["stop"])
                    }), [
                      B("span", {
                        ref_key: "focusStartRef",
                        ref: a,
                        class: I(i(l).e("sr-focus")),
                        tabindex: "-1"
                      }, null, 2),
                      O.withHeader ? (k(), x("header", {
                        key: 0,
                        class: I([i(l).e("header"), O.headerClass])
                      }, [
                        O.$slots.title ? J(O.$slots, "title", { key: 1 }, () => [
                          ee(" DEPRECATED SLOT ")
                        ]) : J(O.$slots, "header", {
                          key: 0,
                          close: i(C),
                          titleId: i(v),
                          titleClass: i(l).e("title")
                        }, () => [
                          O.$slots.title ? ee("v-if", true) : (k(), x("span", {
                            key: 0,
                            id: i(v),
                            role: "heading",
                            "aria-level": O.headerAriaLevel,
                            class: I(i(l).e("title"))
                          }, _e(O.title), 11, ["id", "aria-level"]))
                        ]),
                        O.showClose ? (k(), x("button", {
                          key: 2,
                          "aria-label": i(s)("el.drawer.close"),
                          class: I(i(l).e("close-btn")),
                          type: "button",
                          onClick: i(C)
                        }, [
                          W(i(Be), {
                            class: I(i(l).e("close"))
                          }, {
                            default: H(() => [
                              W(i(Jo))
                            ]),
                            _: 1
                          }, 8, ["class"])
                        ], 10, ["aria-label", "onClick"])) : ee("v-if", true)
                      ], 2)) : ee("v-if", true),
                      i(p) ? (k(), x("div", {
                        key: 1,
                        id: i(m),
                        class: I([i(l).e("body"), O.bodyClass])
                      }, [
                        J(O.$slots, "default")
                      ], 10, ["id"])) : ee("v-if", true),
                      O.$slots.footer ? (k(), x("div", {
                        key: 2,
                        class: I([i(l).e("footer"), O.footerClass])
                      }, [
                        J(O.$slots, "footer")
                      ], 2)) : ee("v-if", true)
                    ], 16, ["aria-label", "aria-labelledby", "aria-describedby", "onClick"])
                  ]),
                  _: 3
                }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])
              ]),
              _: 3
            }, 8, ["mask", "overlay-class", "z-index", "onClick"]), [
              [Nt, i(f)]
            ])
          ]),
          _: 3
        }, 8, ["name", "onAfterEnter", "onAfterLeave", "onBeforeLeave"])
      ]),
      _: 3
    }, 8, ["to", "disabled"]));
  }
});
var z9 = /* @__PURE__ */ $e(H9, [["__file", "drawer.vue"]]);
const K9 = ut(z9), W9 = /* @__PURE__ */ j({
  inheritAttrs: false
});
function j9(e10, t, n, o, r, a) {
  return J(e10.$slots, "default");
}
var U9 = /* @__PURE__ */ $e(W9, [["render", j9], ["__file", "collection.vue"]]);
const Y9 = /* @__PURE__ */ j({
  name: "ElCollectionItem",
  inheritAttrs: false
});
function q9(e10, t, n, o, r, a) {
  return J(e10.$slots, "default");
}
var G9 = /* @__PURE__ */ $e(Y9, [["render", q9], ["__file", "collection-item.vue"]]);
const mk = "data-el-collection-item", gk = (e10) => {
  const t = `El${e10}Collection`, n = `${t}Item`, o = Symbol(t), r = Symbol(n), a = {
    ...U9,
    name: t,
    setup() {
      const s = L(), u = /* @__PURE__ */ new Map();
      yt(o, {
        itemMap: u,
        getItems: () => {
          const d = i(s);
          if (!d)
            return [];
          const f = Array.from(d.querySelectorAll(`[${mk}]`));
          return [...u.values()].sort((v, m) => f.indexOf(v.ref) - f.indexOf(m.ref));
        },
        collectionRef: s
      });
    }
  }, l = {
    ...G9,
    name: n,
    setup(s, { attrs: u }) {
      const c = L(), d = Le(o, void 0);
      yt(r, {
        collectionItemRef: c
      }), dt(() => {
        const f = i(c);
        f && d.itemMap.set(f, {
          ref: f,
          ...u
        });
      }), jt(() => {
        const f = i(c);
        d.itemMap.delete(f);
      });
    }
  };
  return {
    COLLECTION_INJECTION_KEY: o,
    COLLECTION_ITEM_INJECTION_KEY: r,
    ElCollection: a,
    ElCollectionItem: l
  };
}, X9 = Oe({
  style: { type: ne([String, Array, Object]) },
  currentTabId: {
    type: ne(String)
  },
  defaultCurrentTabId: String,
  loop: Boolean,
  dir: {
    type: String,
    values: ["ltr", "rtl"],
    default: "ltr"
  },
  orientation: {
    type: ne(String)
  },
  onBlur: Function,
  onFocus: Function,
  onMousedown: Function
}), {
  ElCollection: J9,
  ElCollectionItem: Z9,
  COLLECTION_INJECTION_KEY: Dg,
  COLLECTION_ITEM_INJECTION_KEY: Q9
} = gk("RovingFocusGroup"), Vg = Symbol("elRovingFocusGroup"), yk = Symbol("elRovingFocusGroupItem"), e7 = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
}, t7 = (e10, t) => e10, n7 = (e10, t, n) => {
  const o = t7(e10.code);
  return e7[o];
}, o7 = (e10, t) => e10.map((n, o) => e10[(o + t) % e10.length]), Fg = (e10) => {
  const { activeElement: t } = document;
  for (const n of e10)
    if (n === t || (n.focus(), t !== document.activeElement))
      return;
}, P1 = "currentTabIdChange", R1 = "rovingFocusGroup.entryFocus", r7 = { bubbles: false, cancelable: true }, a7 = /* @__PURE__ */ j({
  name: "ElRovingFocusGroupImpl",
  inheritAttrs: false,
  props: X9,
  emits: [P1, "entryFocus"],
  setup(e10, { emit: t }) {
    var n;
    const o = L((n = e10.currentTabId || e10.defaultCurrentTabId) != null ? n : null), r = L(false), a = L(false), l = L(), { getItems: s } = Le(Dg, void 0), u = S(() => [
      {
        outline: "none"
      },
      e10.style
    ]), c = (h) => {
      t(P1, h);
    }, d = () => {
      r.value = true;
    }, f = dn((h) => {
      var b;
      (b = e10.onMousedown) == null || b.call(e10, h);
    }, () => {
      a.value = true;
    }), p = dn((h) => {
      var b;
      (b = e10.onFocus) == null || b.call(e10, h);
    }, (h) => {
      const b = !i(a), { target: g, currentTarget: w } = h;
      if (g === w && b && !i(r)) {
        const y = new Event(R1, r7);
        if (w == null || w.dispatchEvent(y), !y.defaultPrevented) {
          const _ = s().filter((N) => N.focusable), C = _.find((N) => N.active), E = _.find((N) => N.id === i(o)), O = [C, E, ..._].filter(Boolean).map((N) => N.ref);
          Fg(O);
        }
      }
      a.value = false;
    }), v = dn((h) => {
      var b;
      (b = e10.onBlur) == null || b.call(e10, h);
    }, () => {
      r.value = false;
    }), m = (...h) => {
      t("entryFocus", ...h);
    };
    yt(Vg, {
      currentTabbedId: yi(o),
      loop: Lt(e10, "loop"),
      tabIndex: S(() => i(r) ? -1 : 0),
      rovingFocusGroupRef: l,
      rovingFocusGroupRootStyle: u,
      orientation: Lt(e10, "orientation"),
      dir: Lt(e10, "dir"),
      onItemFocus: c,
      onItemShiftTab: d,
      onBlur: v,
      onFocus: p,
      onMousedown: f
    }), ge(() => e10.currentTabId, (h) => {
      o.value = h != null ? h : null;
    }), Ft(l, R1, m);
  }
});
function l7(e10, t, n, o, r, a) {
  return J(e10.$slots, "default");
}
var s7 = /* @__PURE__ */ $e(a7, [["render", l7], ["__file", "roving-focus-group-impl.vue"]]);
const i7 = /* @__PURE__ */ j({
  name: "ElRovingFocusGroup",
  components: {
    ElFocusGroupCollection: J9,
    ElRovingFocusGroupImpl: s7
  }
});
function u7(e10, t, n, o, r, a) {
  const l = je("el-roving-focus-group-impl"), s = je("el-focus-group-collection");
  return k(), ae(s, null, {
    default: H(() => [
      W(l, Ao(jr(e10.$attrs)), {
        default: H(() => [
          J(e10.$slots, "default")
        ]),
        _: 3
      }, 16)
    ]),
    _: 3
  });
}
var c7 = /* @__PURE__ */ $e(i7, [["render", u7], ["__file", "roving-focus-group.vue"]]);
const gd = Oe({
  trigger: Bs.trigger,
  triggerKeys: {
    type: ne(Array),
    default: () => [
      xe.enter,
      xe.numpadEnter,
      xe.space,
      xe.down
    ]
  },
  effect: {
    ...vn.effect,
    default: "light"
  },
  type: {
    type: ne(String)
  },
  placement: {
    type: ne(String),
    default: "bottom"
  },
  popperOptions: {
    type: ne(Object),
    default: () => ({})
  },
  id: String,
  size: {
    type: String,
    default: ""
  },
  splitButton: Boolean,
  hideOnClick: {
    type: Boolean,
    default: true
  },
  loop: {
    type: Boolean,
    default: true
  },
  showTimeout: {
    type: Number,
    default: 150
  },
  hideTimeout: {
    type: Number,
    default: 150
  },
  tabindex: {
    type: ne([Number, String]),
    default: 0
  },
  maxHeight: {
    type: ne([Number, String]),
    default: ""
  },
  popperClass: {
    type: String,
    default: ""
  },
  disabled: Boolean,
  role: {
    type: String,
    values: zS,
    default: "menu"
  },
  buttonProps: {
    type: ne(Object)
  },
  teleported: vn.teleported,
  persistent: {
    type: Boolean,
    default: true
  }
}), bk = Oe({
  command: {
    type: [Object, String, Number],
    default: () => ({})
  },
  disabled: Boolean,
  divided: Boolean,
  textValue: String,
  icon: {
    type: Ht
  }
}), d7 = Oe({
  onKeydown: { type: ne(Function) }
}), f7 = [
  xe.down,
  xe.pageDown,
  xe.home
], _k = [xe.up, xe.pageUp, xe.end], p7 = [...f7, ..._k], {
  ElCollection: v7,
  ElCollectionItem: h7,
  COLLECTION_INJECTION_KEY: m7,
  COLLECTION_ITEM_INJECTION_KEY: g7
} = gk("Dropdown"), up = Symbol("elDropdown"), wk = "elDropdown", { ButtonGroup: y7 } = Mn, b7 = /* @__PURE__ */ j({
  name: "ElDropdown",
  components: {
    ElButton: Mn,
    ElButtonGroup: y7,
    ElScrollbar: ta,
    ElDropdownCollection: v7,
    ElTooltip: Un,
    ElRovingFocusGroup: c7,
    ElOnlyChild: qS,
    ElIcon: Be,
    ArrowDown: ea
  },
  props: gd,
  emits: ["visible-change", "click", "command"],
  setup(e10, { emit: t }) {
    const n = it(), o = we("dropdown"), { t: r } = kt(), a = L(), l = L(), s = L(), u = L(), c = L(null), d = L(null), f = L(false), p = S(() => ({
      maxHeight: sn(e10.maxHeight)
    })), v = S(() => [o.m(_.value)]), m = S(() => Zn(e10.trigger)), h = Fn().value, b = S(() => e10.id || h);
    ge([a, m], ([M, F], [A]) => {
      var V, Z, G;
      (V = A == null ? void 0 : A.$el) != null && V.removeEventListener && A.$el.removeEventListener("pointerenter", E), (Z = M == null ? void 0 : M.$el) != null && Z.removeEventListener && M.$el.removeEventListener("pointerenter", E), (G = M == null ? void 0 : M.$el) != null && G.addEventListener && F.includes("hover") && M.$el.addEventListener("pointerenter", E);
    }, { immediate: true }), jt(() => {
      var M, F;
      (F = (M = a.value) == null ? void 0 : M.$el) != null && F.removeEventListener && a.value.$el.removeEventListener("pointerenter", E);
    });
    function g() {
      w();
    }
    function w() {
      var M;
      (M = s.value) == null || M.onClose();
    }
    function y() {
      var M;
      (M = s.value) == null || M.onOpen();
    }
    const _ = yn();
    function C(...M) {
      t("command", ...M);
    }
    function E() {
      var M, F;
      (F = (M = a.value) == null ? void 0 : M.$el) == null || F.focus();
    }
    function T() {
    }
    function O() {
      const M = i(u);
      m.value.includes("hover") && (M == null || M.focus()), d.value = null;
    }
    function N(M) {
      d.value = M;
    }
    function $(M) {
      f.value || (M.preventDefault(), M.stopImmediatePropagation());
    }
    function R() {
      t("visible-change", true);
    }
    function P(M) {
      var F;
      (M == null ? void 0 : M.type) === "keydown" && ((F = u.value) == null || F.focus());
    }
    function z() {
      t("visible-change", false);
    }
    return yt(up, {
      contentRef: u,
      role: S(() => e10.role),
      triggerId: b,
      isUsingKeyboard: f,
      onItemEnter: T,
      onItemLeave: O
    }), yt(wk, {
      instance: n,
      dropdownSize: _,
      handleClick: g,
      commandHandler: C,
      trigger: Lt(e10, "trigger"),
      hideOnClick: Lt(e10, "hideOnClick")
    }), {
      t: r,
      ns: o,
      scrollbar: c,
      wrapStyle: p,
      dropdownTriggerKls: v,
      dropdownSize: _,
      triggerId: b,
      currentTabId: d,
      handleCurrentTabIdChange: N,
      handlerMainButtonClick: (M) => {
        t("click", M);
      },
      handleEntryFocus: $,
      handleClose: w,
      handleOpen: y,
      handleBeforeShowTooltip: R,
      handleShowTooltip: P,
      handleBeforeHideTooltip: z,
      onFocusAfterTrapped: (M) => {
        var F, A;
        M.preventDefault(), (A = (F = u.value) == null ? void 0 : F.focus) == null || A.call(F, {
          preventScroll: true
        });
      },
      popperRef: s,
      contentRef: u,
      triggeringElementRef: a,
      referenceElementRef: l
    };
  }
});
function _7(e10, t, n, o, r, a) {
  var l;
  const s = je("el-dropdown-collection"), u = je("el-roving-focus-group"), c = je("el-scrollbar"), d = je("el-only-child"), f = je("el-tooltip"), p = je("el-button"), v = je("arrow-down"), m = je("el-icon"), h = je("el-button-group");
  return k(), x("div", {
    class: I([e10.ns.b(), e10.ns.is("disabled", e10.disabled)])
  }, [
    W(f, {
      ref: "popperRef",
      role: e10.role,
      effect: e10.effect,
      "fallback-placements": ["bottom", "top"],
      "popper-options": e10.popperOptions,
      "gpu-acceleration": false,
      "hide-after": e10.trigger === "hover" ? e10.hideTimeout : 0,
      "manual-mode": true,
      placement: e10.placement,
      "popper-class": [e10.ns.e("popper"), e10.popperClass],
      "reference-element": (l = e10.referenceElementRef) == null ? void 0 : l.$el,
      trigger: e10.trigger,
      "trigger-keys": e10.triggerKeys,
      "trigger-target-el": e10.contentRef,
      "show-after": e10.trigger === "hover" ? e10.showTimeout : 0,
      "stop-popper-mouse-event": false,
      "virtual-ref": e10.triggeringElementRef,
      "virtual-triggering": e10.splitButton,
      disabled: e10.disabled,
      transition: `${e10.ns.namespace.value}-zoom-in-top`,
      teleported: e10.teleported,
      pure: "",
      persistent: e10.persistent,
      onBeforeShow: e10.handleBeforeShowTooltip,
      onShow: e10.handleShowTooltip,
      onBeforeHide: e10.handleBeforeHideTooltip
    }, ro({
      content: H(() => [
        W(c, {
          ref: "scrollbar",
          "wrap-style": e10.wrapStyle,
          tag: "div",
          "view-class": e10.ns.e("list")
        }, {
          default: H(() => [
            W(u, {
              loop: e10.loop,
              "current-tab-id": e10.currentTabId,
              orientation: "horizontal",
              onCurrentTabIdChange: e10.handleCurrentTabIdChange,
              onEntryFocus: e10.handleEntryFocus
            }, {
              default: H(() => [
                W(s, null, {
                  default: H(() => [
                    J(e10.$slots, "dropdown")
                  ]),
                  _: 3
                })
              ]),
              _: 3
            }, 8, ["loop", "current-tab-id", "onCurrentTabIdChange", "onEntryFocus"])
          ]),
          _: 3
        }, 8, ["wrap-style", "view-class"])
      ]),
      _: 2
    }, [
      e10.splitButton ? void 0 : {
        name: "default",
        fn: H(() => [
          W(d, {
            id: e10.triggerId,
            ref: "triggeringElementRef",
            role: "button",
            tabindex: e10.tabindex
          }, {
            default: H(() => [
              J(e10.$slots, "default")
            ]),
            _: 3
          }, 8, ["id", "tabindex"])
        ])
      }
    ]), 1032, ["role", "effect", "popper-options", "hide-after", "placement", "popper-class", "reference-element", "trigger", "trigger-keys", "trigger-target-el", "show-after", "virtual-ref", "virtual-triggering", "disabled", "transition", "teleported", "persistent", "onBeforeShow", "onShow", "onBeforeHide"]),
    e10.splitButton ? (k(), ae(h, { key: 0 }, {
      default: H(() => [
        W(p, vt({ ref: "referenceElementRef" }, e10.buttonProps, {
          size: e10.dropdownSize,
          type: e10.type,
          disabled: e10.disabled,
          tabindex: e10.tabindex,
          onClick: e10.handlerMainButtonClick
        }), {
          default: H(() => [
            J(e10.$slots, "default")
          ]),
          _: 3
        }, 16, ["size", "type", "disabled", "tabindex", "onClick"]),
        W(p, vt({
          id: e10.triggerId,
          ref: "triggeringElementRef"
        }, e10.buttonProps, {
          role: "button",
          size: e10.dropdownSize,
          type: e10.type,
          class: e10.ns.e("caret-button"),
          disabled: e10.disabled,
          tabindex: e10.tabindex,
          "aria-label": e10.t("el.dropdown.toggleDropdown")
        }), {
          default: H(() => [
            W(m, {
              class: I(e10.ns.e("icon"))
            }, {
              default: H(() => [
                W(v)
              ]),
              _: 1
            }, 8, ["class"])
          ]),
          _: 1
        }, 16, ["id", "size", "type", "class", "disabled", "tabindex", "aria-label"])
      ]),
      _: 3
    })) : ee("v-if", true)
  ], 2);
}
var w7 = /* @__PURE__ */ $e(b7, [["render", _7], ["__file", "dropdown.vue"]]);
const C7 = /* @__PURE__ */ j({
  components: {
    ElRovingFocusCollectionItem: Z9
  },
  props: {
    focusable: {
      type: Boolean,
      default: true
    },
    active: {
      type: Boolean,
      default: false
    }
  },
  emits: ["mousedown", "focus", "keydown"],
  setup(e10, { emit: t }) {
    const { currentTabbedId: n, loop: o, onItemFocus: r, onItemShiftTab: a } = Le(Vg, void 0), { getItems: l } = Le(Dg, void 0), s = Fn(), u = L(), c = dn((v) => {
      t("mousedown", v);
    }, (v) => {
      e10.focusable ? r(i(s)) : v.preventDefault();
    }), d = dn((v) => {
      t("focus", v);
    }, () => {
      r(i(s));
    }), f = dn((v) => {
      t("keydown", v);
    }, (v) => {
      const { code: m, shiftKey: h, target: b, currentTarget: g } = v;
      if (m === xe.tab && h) {
        a();
        return;
      }
      if (b !== g)
        return;
      const w = n7(v);
      if (w) {
        v.preventDefault();
        let _ = l().filter((C) => C.focusable).map((C) => C.ref);
        switch (w) {
          case "last": {
            _.reverse();
            break;
          }
          case "prev":
          case "next": {
            w === "prev" && _.reverse();
            const C = _.indexOf(g);
            _ = o.value ? o7(_, C + 1) : _.slice(C + 1);
            break;
          }
        }
        He(() => {
          Fg(_);
        });
      }
    }), p = S(() => n.value === i(s));
    return yt(yk, {
      rovingFocusGroupItemRef: u,
      tabIndex: S(() => i(p) ? 0 : -1),
      handleMousedown: c,
      handleFocus: d,
      handleKeydown: f
    }), {
      id: s,
      handleKeydown: f,
      handleFocus: d,
      handleMousedown: c
    };
  }
});
function E7(e10, t, n, o, r, a) {
  const l = je("el-roving-focus-collection-item");
  return k(), ae(l, {
    id: e10.id,
    focusable: e10.focusable,
    active: e10.active
  }, {
    default: H(() => [
      J(e10.$slots, "default")
    ]),
    _: 3
  }, 8, ["id", "focusable", "active"]);
}
var S7 = /* @__PURE__ */ $e(C7, [["render", E7], ["__file", "roving-focus-item.vue"]]);
const k7 = /* @__PURE__ */ j({
  name: "DropdownItemImpl",
  components: {
    ElIcon: Be
  },
  props: bk,
  emits: ["pointermove", "pointerleave", "click", "clickimpl"],
  setup(e10, { emit: t }) {
    const n = we("dropdown"), { role: o } = Le(up, void 0), { collectionItemRef: r } = Le(g7, void 0), { collectionItemRef: a } = Le(Q9, void 0), {
      rovingFocusGroupItemRef: l,
      tabIndex: s,
      handleFocus: u,
      handleKeydown: c,
      handleMousedown: d
    } = Le(yk, void 0), f = ip(r, a, l), p = S(() => o.value === "menu" ? "menuitem" : o.value === "navigation" ? "link" : "button"), v = dn((m) => {
      if ([xe.enter, xe.numpadEnter, xe.space].includes(m.code))
        return m.preventDefault(), m.stopImmediatePropagation(), t("clickimpl", m), true;
    }, c);
    return {
      ns: n,
      itemRef: f,
      dataset: {
        [mk]: ""
      },
      role: p,
      tabIndex: s,
      handleFocus: u,
      handleKeydown: v,
      handleMousedown: d
    };
  }
});
function N7(e10, t, n, o, r, a) {
  const l = je("el-icon");
  return k(), x(Ie, null, [
    e10.divided ? (k(), x("li", {
      key: 0,
      role: "separator",
      class: I(e10.ns.bem("menu", "item", "divided"))
    }, null, 2)) : ee("v-if", true),
    B("li", vt({ ref: e10.itemRef }, { ...e10.dataset, ...e10.$attrs }, {
      "aria-disabled": e10.disabled,
      class: [e10.ns.be("menu", "item"), e10.ns.is("disabled", e10.disabled)],
      tabindex: e10.tabIndex,
      role: e10.role,
      onClick: (s) => e10.$emit("clickimpl", s),
      onFocus: e10.handleFocus,
      onKeydown: Xe(e10.handleKeydown, ["self"]),
      onMousedown: e10.handleMousedown,
      onPointermove: (s) => e10.$emit("pointermove", s),
      onPointerleave: (s) => e10.$emit("pointerleave", s)
    }), [
      e10.icon ? (k(), ae(l, { key: 0 }, {
        default: H(() => [
          (k(), ae(ht(e10.icon)))
        ]),
        _: 1
      })) : ee("v-if", true),
      J(e10.$slots, "default")
    ], 16, ["aria-disabled", "tabindex", "role", "onClick", "onFocus", "onKeydown", "onMousedown", "onPointermove", "onPointerleave"])
  ], 64);
}
var T7 = /* @__PURE__ */ $e(k7, [["render", N7], ["__file", "dropdown-item-impl.vue"]]);
const Ck = () => {
  const e10 = Le(wk, {}), t = S(() => e10 == null ? void 0 : e10.dropdownSize);
  return {
    elDropdown: e10,
    _elDropdownSize: t
  };
}, O7 = /* @__PURE__ */ j({
  name: "ElDropdownItem",
  components: {
    ElDropdownCollectionItem: h7,
    ElRovingFocusItem: S7,
    ElDropdownItemImpl: T7
  },
  inheritAttrs: false,
  props: bk,
  emits: ["pointermove", "pointerleave", "click"],
  setup(e10, { emit: t, attrs: n }) {
    const { elDropdown: o } = Ck(), r = it(), a = L(null), l = S(() => {
      var v, m;
      return (m = (v = i(a)) == null ? void 0 : v.textContent) != null ? m : "";
    }), { onItemEnter: s, onItemLeave: u } = Le(up, void 0), c = dn((v) => (t("pointermove", v), v.defaultPrevented), n1((v) => {
      if (e10.disabled) {
        u(v);
        return;
      }
      const m = v.currentTarget;
      m === document.activeElement || m.contains(document.activeElement) || (s(v), v.defaultPrevented || m == null || m.focus());
    })), d = dn((v) => (t("pointerleave", v), v.defaultPrevented), n1(u)), f = dn((v) => {
      if (!e10.disabled)
        return t("click", v), v.type !== "keydown" && v.defaultPrevented;
    }, (v) => {
      var m, h, b;
      if (e10.disabled) {
        v.stopImmediatePropagation();
        return;
      }
      (m = o == null ? void 0 : o.hideOnClick) != null && m.value && ((h = o.handleClick) == null || h.call(o)), (b = o.commandHandler) == null || b.call(o, e10.command, r, v);
    }), p = S(() => ({ ...e10, ...n }));
    return {
      handleClick: f,
      handlePointerMove: c,
      handlePointerLeave: d,
      textContent: l,
      propsAndAttrs: p
    };
  }
});
function $7(e10, t, n, o, r, a) {
  var l;
  const s = je("el-dropdown-item-impl"), u = je("el-roving-focus-item"), c = je("el-dropdown-collection-item");
  return k(), ae(c, {
    disabled: e10.disabled,
    "text-value": (l = e10.textValue) != null ? l : e10.textContent
  }, {
    default: H(() => [
      W(u, {
        focusable: !e10.disabled
      }, {
        default: H(() => [
          W(s, vt(e10.propsAndAttrs, {
            onPointerleave: e10.handlePointerLeave,
            onPointermove: e10.handlePointerMove,
            onClickimpl: e10.handleClick
          }), {
            default: H(() => [
              J(e10.$slots, "default")
            ]),
            _: 3
          }, 16, ["onPointerleave", "onPointermove", "onClickimpl"])
        ]),
        _: 3
      }, 8, ["focusable"])
    ]),
    _: 3
  }, 8, ["disabled", "text-value"]);
}
var Ek = /* @__PURE__ */ $e(O7, [["render", $7], ["__file", "dropdown-item.vue"]]);
const I7 = /* @__PURE__ */ j({
  name: "ElDropdownMenu",
  props: d7,
  setup(e10) {
    const t = we("dropdown"), { _elDropdownSize: n } = Ck(), o = n.value, { focusTrapRef: r, onKeydown: a } = Le(dg, void 0), { contentRef: l, role: s, triggerId: u } = Le(up, void 0), { collectionRef: c, getItems: d } = Le(m7, void 0), {
      rovingFocusGroupRef: f,
      rovingFocusGroupRootStyle: p,
      tabIndex: v,
      onBlur: m,
      onFocus: h,
      onMousedown: b
    } = Le(Vg, void 0), { collectionRef: g } = Le(Dg, void 0), w = S(() => [t.b("menu"), t.bm("menu", o == null ? void 0 : o.value)]), y = ip(l, c, r, f, g), _ = dn((E) => {
      var T;
      (T = e10.onKeydown) == null || T.call(e10, E);
    }, (E) => {
      const { currentTarget: T, code: O, target: N } = E;
      if (T.contains(N), xe.tab === O && E.stopImmediatePropagation(), E.preventDefault(), N !== i(l) || !p7.includes(O))
        return;
      const R = d().filter((P) => !P.disabled).map((P) => P.ref);
      _k.includes(O) && R.reverse(), Fg(R);
    });
    return {
      size: o,
      rovingFocusGroupRootStyle: p,
      tabIndex: v,
      dropdownKls: w,
      role: s,
      triggerId: u,
      dropdownListWrapperRef: y,
      handleKeydown: (E) => {
        _(E), a(E);
      },
      onBlur: m,
      onFocus: h,
      onMousedown: b
    };
  }
});
function M7(e10, t, n, o, r, a) {
  return k(), x("ul", {
    ref: e10.dropdownListWrapperRef,
    class: I(e10.dropdownKls),
    style: ze(e10.rovingFocusGroupRootStyle),
    tabindex: -1,
    role: e10.role,
    "aria-labelledby": e10.triggerId,
    onBlur: e10.onBlur,
    onFocus: e10.onFocus,
    onKeydown: Xe(e10.handleKeydown, ["self"]),
    onMousedown: Xe(e10.onMousedown, ["self"])
  }, [
    J(e10.$slots, "default")
  ], 46, ["role", "aria-labelledby", "onBlur", "onFocus", "onKeydown", "onMousedown"]);
}
var Sk = /* @__PURE__ */ $e(I7, [["render", M7], ["__file", "dropdown-menu.vue"]]);
const P7 = ut(w7, {
  DropdownItem: Ek,
  DropdownMenu: Sk
}), R7 = nn(Ek), A7 = nn(Sk), L7 = /* @__PURE__ */ j({
  name: "ImgEmpty"
}), x7 = /* @__PURE__ */ j({
  ...L7,
  setup(e10) {
    const t = we("empty"), n = Fn();
    return (o, r) => (k(), x("svg", {
      viewBox: "0 0 79 86",
      version: "1.1",
      xmlns: "http://www.w3.org/2000/svg",
      "xmlns:xlink": "http://www.w3.org/1999/xlink"
    }, [
      B("defs", null, [
        B("linearGradient", {
          id: `linearGradient-1-${i(n)}`,
          x1: "38.8503086%",
          y1: "0%",
          x2: "61.1496914%",
          y2: "100%"
        }, [
          B("stop", {
            "stop-color": `var(${i(t).cssVarBlockName("fill-color-1")})`,
            offset: "0%"
          }, null, 8, ["stop-color"]),
          B("stop", {
            "stop-color": `var(${i(t).cssVarBlockName("fill-color-4")})`,
            offset: "100%"
          }, null, 8, ["stop-color"])
        ], 8, ["id"]),
        B("linearGradient", {
          id: `linearGradient-2-${i(n)}`,
          x1: "0%",
          y1: "9.5%",
          x2: "100%",
          y2: "90.5%"
        }, [
          B("stop", {
            "stop-color": `var(${i(t).cssVarBlockName("fill-color-1")})`,
            offset: "0%"
          }, null, 8, ["stop-color"]),
          B("stop", {
            "stop-color": `var(${i(t).cssVarBlockName("fill-color-6")})`,
            offset: "100%"
          }, null, 8, ["stop-color"])
        ], 8, ["id"]),
        B("rect", {
          id: `path-3-${i(n)}`,
          x: "0",
          y: "0",
          width: "17",
          height: "36"
        }, null, 8, ["id"])
      ]),
      B("g", {
        stroke: "none",
        "stroke-width": "1",
        fill: "none",
        "fill-rule": "evenodd"
      }, [
        B("g", { transform: "translate(-1268.000000, -535.000000)" }, [
          B("g", { transform: "translate(1268.000000, 535.000000)" }, [
            B("path", {
              d: "M39.5,86 C61.3152476,86 79,83.9106622 79,81.3333333 C79,78.7560045 57.3152476,78 35.5,78 C13.6847524,78 0,78.7560045 0,81.3333333 C0,83.9106622 17.6847524,86 39.5,86 Z",
              fill: `var(${i(t).cssVarBlockName("fill-color-3")})`
            }, null, 8, ["fill"]),
            B("polygon", {
              fill: `var(${i(t).cssVarBlockName("fill-color-7")})`,
              transform: "translate(27.500000, 51.500000) scale(1, -1) translate(-27.500000, -51.500000) ",
              points: "13 58 53 58 42 45 2 45"
            }, null, 8, ["fill"]),
            B("g", { transform: "translate(34.500000, 31.500000) scale(-1, 1) rotate(-25.000000) translate(-34.500000, -31.500000) translate(7.000000, 10.000000)" }, [
              B("polygon", {
                fill: `var(${i(t).cssVarBlockName("fill-color-7")})`,
                transform: "translate(11.500000, 5.000000) scale(1, -1) translate(-11.500000, -5.000000) ",
                points: "2.84078316e-14 3 18 3 23 7 5 7"
              }, null, 8, ["fill"]),
              B("polygon", {
                fill: `var(${i(t).cssVarBlockName("fill-color-5")})`,
                points: "-3.69149156e-15 7 38 7 38 43 -3.69149156e-15 43"
              }, null, 8, ["fill"]),
              B("rect", {
                fill: `url(#linearGradient-1-${i(n)})`,
                transform: "translate(46.500000, 25.000000) scale(-1, 1) translate(-46.500000, -25.000000) ",
                x: "38",
                y: "7",
                width: "17",
                height: "36"
              }, null, 8, ["fill"]),
              B("polygon", {
                fill: `var(${i(t).cssVarBlockName("fill-color-2")})`,
                transform: "translate(39.500000, 3.500000) scale(-1, 1) translate(-39.500000, -3.500000) ",
                points: "24 7 41 7 55 -3.63806207e-12 38 -3.63806207e-12"
              }, null, 8, ["fill"])
            ]),
            B("rect", {
              fill: `url(#linearGradient-2-${i(n)})`,
              x: "13",
              y: "45",
              width: "40",
              height: "36"
            }, null, 8, ["fill"]),
            B("g", { transform: "translate(53.000000, 45.000000)" }, [
              B("use", {
                fill: `var(${i(t).cssVarBlockName("fill-color-8")})`,
                transform: "translate(8.500000, 18.000000) scale(-1, 1) translate(-8.500000, -18.000000) ",
                "xlink:href": `#path-3-${i(n)}`
              }, null, 8, ["fill", "xlink:href"]),
              B("polygon", {
                fill: `var(${i(t).cssVarBlockName("fill-color-9")})`,
                mask: `url(#mask-4-${i(n)})`,
                transform: "translate(12.000000, 9.000000) scale(-1, 1) translate(-12.000000, -9.000000) ",
                points: "7 0 24 0 20 18 7 16.5"
              }, null, 8, ["fill", "mask"])
            ]),
            B("polygon", {
              fill: `var(${i(t).cssVarBlockName("fill-color-2")})`,
              transform: "translate(66.000000, 51.500000) scale(-1, 1) translate(-66.000000, -51.500000) ",
              points: "62 45 79 45 70 58 53 58"
            }, null, 8, ["fill"])
          ])
        ])
      ])
    ]));
  }
});
var D7 = /* @__PURE__ */ $e(x7, [["__file", "img-empty.vue"]]);
const V7 = Oe({
  image: {
    type: String,
    default: ""
  },
  imageSize: Number,
  description: {
    type: String,
    default: ""
  }
}), F7 = /* @__PURE__ */ j({
  name: "ElEmpty"
}), B7 = /* @__PURE__ */ j({
  ...F7,
  props: V7,
  setup(e10) {
    const t = e10, { t: n } = kt(), o = we("empty"), r = S(() => t.description || n("el.table.emptyText")), a = S(() => ({
      width: sn(t.imageSize)
    }));
    return (l, s) => (k(), x("div", {
      class: I(i(o).b())
    }, [
      B("div", {
        class: I(i(o).e("image")),
        style: ze(i(a))
      }, [
        l.image ? (k(), x("img", {
          key: 0,
          src: l.image,
          ondragstart: "return false"
        }, null, 8, ["src"])) : J(l.$slots, "image", { key: 1 }, () => [
          W(D7)
        ])
      ], 6),
      B("div", {
        class: I(i(o).e("description"))
      }, [
        l.$slots.description ? J(l.$slots, "description", { key: 0 }) : (k(), x("p", { key: 1 }, _e(i(r)), 1))
      ], 2),
      l.$slots.default ? (k(), x("div", {
        key: 0,
        class: I(i(o).e("bottom"))
      }, [
        J(l.$slots, "default")
      ], 2)) : ee("v-if", true)
    ], 2));
  }
});
var H7 = /* @__PURE__ */ $e(B7, [["__file", "empty.vue"]]);
const kk = ut(H7), z7 = Oe({
  size: {
    type: String,
    values: Qr
  },
  disabled: Boolean
}), K7 = Oe({
  ...z7,
  model: Object,
  rules: {
    type: ne(Object)
  },
  labelPosition: {
    type: String,
    values: ["left", "right", "top"],
    default: "right"
  },
  requireAsteriskPosition: {
    type: String,
    values: ["left", "right"],
    default: "left"
  },
  labelWidth: {
    type: [String, Number],
    default: ""
  },
  labelSuffix: {
    type: String,
    default: ""
  },
  inline: Boolean,
  inlineMessage: Boolean,
  statusIcon: Boolean,
  showMessage: {
    type: Boolean,
    default: true
  },
  validateOnRuleChange: {
    type: Boolean,
    default: true
  },
  hideRequiredAsterisk: Boolean,
  scrollToError: Boolean,
  scrollIntoViewOptions: {
    type: [Object, Boolean],
    default: true
  }
}), W7 = {
  validate: (e10, t, n) => (Se(e10) || Ve(e10)) && Vt(t) && Ve(n)
}, j7 = "ElForm";
function U7() {
  const e10 = L([]), t = S(() => {
    if (!e10.value.length)
      return "0";
    const a = Math.max(...e10.value);
    return a ? `${a}px` : "";
  });
  function n(a) {
    const l = e10.value.indexOf(a);
    return l === -1 && t.value === "0" && _t(j7, `unexpected width ${a}`), l;
  }
  function o(a, l) {
    if (a && l) {
      const s = n(l);
      e10.value.splice(s, 1, a);
    } else a && e10.value.push(a);
  }
  function r(a) {
    const l = n(a);
    l > -1 && e10.value.splice(l, 1);
  }
  return {
    autoLabelWidth: t,
    registerLabelWidth: o,
    deregisterLabelWidth: r
  };
}
const Kc = (e10, t) => {
  const n = Zn(t);
  return n.length > 0 ? e10.filter((o) => o.prop && n.includes(o.prop)) : e10;
}, yd = "ElForm", Y7 = /* @__PURE__ */ j({
  name: yd
}), q7 = /* @__PURE__ */ j({
  ...Y7,
  props: K7,
  emits: W7,
  setup(e10, { expose: t, emit: n }) {
    const o = e10, r = L(), a = It([]), l = yn(), s = we("form"), u = S(() => {
      const { labelPosition: _, inline: C } = o;
      return [
        s.b(),
        s.m(l.value || "default"),
        {
          [s.m(`label-${_}`)]: _,
          [s.m("inline")]: C
        }
      ];
    }), c = (_) => a.find((C) => C.prop === _), d = (_) => {
      a.push(_);
    }, f = (_) => {
      _.prop && a.splice(a.indexOf(_), 1);
    }, p = (_ = []) => {
      if (!o.model) {
        _t(yd, "model is required for resetFields to work.");
        return;
      }
      Kc(a, _).forEach((C) => C.resetField());
    }, v = (_ = []) => {
      Kc(a, _).forEach((C) => C.clearValidate());
    }, m = S(() => {
      const _ = !!o.model;
      return _ || _t(yd, "model is required for validate to work."), _;
    }), h = (_) => {
      if (a.length === 0)
        return [];
      const C = Kc(a, _);
      return C.length ? C : (_t(yd, "please pass correct props!"), []);
    }, b = async (_) => w(void 0, _), g = async (_ = []) => {
      if (!m.value)
        return false;
      const C = h(_);
      if (C.length === 0)
        return true;
      let E = {};
      for (const T of C)
        try {
          await T.validate(""), T.validateState === "error" && T.resetField();
        } catch (O) {
          E = {
            ...E,
            ...O
          };
        }
      return Object.keys(E).length === 0 ? true : Promise.reject(E);
    }, w = async (_ = [], C) => {
      let E = false;
      const T = !Fe(C);
      try {
        return E = await g(_), E === true && await (C == null ? void 0 : C(E)), E;
      } catch (O) {
        if (O instanceof Error)
          throw O;
        const N = O;
        if (o.scrollToError && r.value) {
          const $ = r.value.querySelector(`.${s.b()}-item.is-error`);
          $ == null || $.scrollIntoView(o.scrollIntoViewOptions);
        }
        return !E && await (C == null ? void 0 : C(false, N)), T && Promise.reject(N);
      }
    }, y = (_) => {
      var C;
      const E = Kc(a, _)[0];
      E && ((C = E.$el) == null || C.scrollIntoView(o.scrollIntoViewOptions));
    };
    return ge(() => o.rules, () => {
      o.validateOnRuleChange && b().catch((_) => _t(_));
    }, { deep: true, flush: "post" }), yt(cs, It({
      ...Tn(o),
      emit: n,
      resetFields: p,
      clearValidate: v,
      validateField: w,
      getField: c,
      addField: d,
      removeField: f,
      ...U7()
    })), t({
      validate: b,
      validateField: w,
      resetFields: p,
      clearValidate: v,
      scrollToField: y,
      fields: a
    }), (_, C) => (k(), x("form", {
      ref_key: "formRef",
      ref: r,
      class: I(i(u))
    }, [
      J(_.$slots, "default")
    ], 2));
  }
});
var G7 = /* @__PURE__ */ $e(q7, [["__file", "form.vue"]]);
function Il() {
  return Il = Object.assign ? Object.assign.bind() : function(e10) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (e10[o] = n[o]);
    }
    return e10;
  }, Il.apply(this, arguments);
}
function X7(e10, t) {
  e10.prototype = Object.create(t.prototype), e10.prototype.constructor = e10, $u(e10, t);
}
function uh(e10) {
  return uh = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, uh(e10);
}
function $u(e10, t) {
  return $u = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, r) {
    return o.__proto__ = r, o;
  }, $u(e10, t);
}
function J7() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return false;
  if (typeof Proxy == "function") return true;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), true;
  } catch {
    return false;
  }
}
function bd(e10, t, n) {
  return J7() ? bd = Reflect.construct.bind() : bd = function(r, a, l) {
    var s = [null];
    s.push.apply(s, a);
    var u = Function.bind.apply(r, s), c = new u();
    return l && $u(c, l.prototype), c;
  }, bd.apply(null, arguments);
}
function Z7(e10) {
  return Function.toString.call(e10).indexOf("[native code]") !== -1;
}
function ch(e10) {
  var t = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return ch = function(o) {
    if (o === null || !Z7(o)) return o;
    if (typeof o != "function")
      throw new TypeError("Super expression must either be null or a function");
    if (typeof t < "u") {
      if (t.has(o)) return t.get(o);
      t.set(o, r);
    }
    function r() {
      return bd(o, arguments, uh(this).constructor);
    }
    return r.prototype = Object.create(o.prototype, {
      constructor: {
        value: r,
        enumerable: false,
        writable: true,
        configurable: true
      }
    }), $u(r, o);
  }, ch(e10);
}
var Q7 = /%[sdj%]/g, Nk = function() {
};
typeof process < "u" && process.env && "development" !== "production" && typeof window < "u" && typeof document < "u" && (Nk = function(t, n) {
  typeof console < "u" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING > "u" && n.every(function(o) {
    return typeof o == "string";
  }) && console.warn(t, n);
});
function dh(e10) {
  if (!e10 || !e10.length) return null;
  var t = {};
  return e10.forEach(function(n) {
    var o = n.field;
    t[o] = t[o] || [], t[o].push(n);
  }), t;
}
function xo(e10) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++)
    n[o - 1] = arguments[o];
  var r = 0, a = n.length;
  if (typeof e10 == "function")
    return e10.apply(null, n);
  if (typeof e10 == "string") {
    var l = e10.replace(Q7, function(s) {
      if (s === "%%")
        return "%";
      if (r >= a)
        return s;
      switch (s) {
        case "%s":
          return String(n[r++]);
        case "%d":
          return Number(n[r++]);
        case "%j":
          try {
            return JSON.stringify(n[r++]);
          } catch {
            return "[Circular]";
          }
          // removed by dead control flow
{}
        default:
          return s;
      }
    });
    return l;
  }
  return e10;
}
function eK(e10) {
  return e10 === "string" || e10 === "url" || e10 === "hex" || e10 === "email" || e10 === "date" || e10 === "pattern";
}
function An(e10, t) {
  return !!(e10 == null || t === "array" && Array.isArray(e10) && !e10.length || eK(t) && typeof e10 == "string" && !e10);
}
function tK(e10, t, n) {
  var o = [], r = 0, a = e10.length;
  function l(s) {
    o.push.apply(o, s || []), r++, r === a && n(o);
  }
  e10.forEach(function(s) {
    t(s, l);
  });
}
function A1(e10, t, n) {
  var o = 0, r = e10.length;
  function a(l) {
    if (l && l.length) {
      n(l);
      return;
    }
    var s = o;
    o = o + 1, s < r ? t(e10[s], a) : n([]);
  }
  a([]);
}
function nK(e10) {
  var t = [];
  return Object.keys(e10).forEach(function(n) {
    t.push.apply(t, e10[n] || []);
  }), t;
}
var L1 = /* @__PURE__ */ function(e10) {
  X7(t, e10);
  function t(n, o) {
    var r;
    return r = e10.call(this, "Async Validation Error") || this, r.errors = n, r.fields = o, r;
  }
  return t;
}(/* @__PURE__ */ ch(Error));
function oK(e10, t, n, o, r) {
  if (t.first) {
    var a = new Promise(function(p, v) {
      var m = function(g) {
        return o(g), g.length ? v(new L1(g, dh(g))) : p(r);
      }, h = nK(e10);
      A1(h, n, m);
    });
    return a.catch(function(p) {
      return p;
    }), a;
  }
  var l = t.firstFields === true ? Object.keys(e10) : t.firstFields || [], s = Object.keys(e10), u = s.length, c = 0, d = [], f = new Promise(function(p, v) {
    var m = function(b) {
      if (d.push.apply(d, b), c++, c === u)
        return o(d), d.length ? v(new L1(d, dh(d))) : p(r);
    };
    s.length || (o(d), p(r)), s.forEach(function(h) {
      var b = e10[h];
      l.indexOf(h) !== -1 ? A1(b, n, m) : tK(b, n, m);
    });
  });
  return f.catch(function(p) {
    return p;
  }), f;
}
function rK(e10) {
  return !!(e10 && e10.message !== void 0);
}
function aK(e10, t) {
  for (var n = e10, o = 0; o < t.length; o++) {
    if (n == null)
      return n;
    n = n[t[o]];
  }
  return n;
}
function x1(e10, t) {
  return function(n) {
    var o;
    return e10.fullFields ? o = aK(t, e10.fullFields) : o = t[n.field || e10.fullField], rK(n) ? (n.field = n.field || e10.fullField, n.fieldValue = o, n) : {
      message: typeof n == "function" ? n() : n,
      fieldValue: o,
      field: n.field || e10.fullField
    };
  };
}
function D1(e10, t) {
  if (t) {
    for (var n in t)
      if (t.hasOwnProperty(n)) {
        var o = t[n];
        typeof o == "object" && typeof e10[n] == "object" ? e10[n] = Il({}, e10[n], o) : e10[n] = o;
      }
  }
  return e10;
}
var Tk = function(t, n, o, r, a, l) {
  t.required && (!o.hasOwnProperty(t.field) || An(n, l || t.type)) && r.push(xo(a.messages.required, t.fullField));
}, lK = function(t, n, o, r, a) {
  (/^\s+$/.test(n) || n === "") && r.push(xo(a.messages.whitespace, t.fullField));
}, Wc, sK = function() {
  if (Wc)
    return Wc;
  var e10 = "[a-fA-F\\d:]", t = function(_) {
    return _ && _.includeBoundaries ? "(?:(?<=\\s|^)(?=" + e10 + ")|(?<=" + e10 + ")(?=\\s|$))" : "";
  }, n = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", o = "[a-fA-F\\d]{1,4}", r = (`
(?:
(?:` + o + ":){7}(?:" + o + `|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:` + o + ":){6}(?:" + n + "|:" + o + `|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:` + o + ":){5}(?::" + n + "|(?::" + o + `){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:` + o + ":){4}(?:(?::" + o + "){0,1}:" + n + "|(?::" + o + `){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:` + o + ":){3}(?:(?::" + o + "){0,2}:" + n + "|(?::" + o + `){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:` + o + ":){2}(?:(?::" + o + "){0,3}:" + n + "|(?::" + o + `){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:` + o + ":){1}(?:(?::" + o + "){0,4}:" + n + "|(?::" + o + `){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::` + o + "){0,5}:" + n + "|(?::" + o + `){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`).replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), a = new RegExp("(?:^" + n + "$)|(?:^" + r + "$)"), l = new RegExp("^" + n + "$"), s = new RegExp("^" + r + "$"), u = function(_) {
    return _ && _.exact ? a : new RegExp("(?:" + t(_) + n + t(_) + ")|(?:" + t(_) + r + t(_) + ")", "g");
  };
  u.v4 = function(y) {
    return y && y.exact ? l : new RegExp("" + t(y) + n + t(y), "g");
  }, u.v6 = function(y) {
    return y && y.exact ? s : new RegExp("" + t(y) + r + t(y), "g");
  };
  var c = "(?:(?:[a-z]+:)?//)", d = "(?:\\S+(?::\\S*)?@)?", f = u.v4().source, p = u.v6().source, v = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)", m = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*", h = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))", b = "(?::\\d{2,5})?", g = '(?:[/?#][^\\s"]*)?', w = "(?:" + c + "|www\\.)" + d + "(?:localhost|" + f + "|" + p + "|" + v + m + h + ")" + b + g;
  return Wc = new RegExp("(?:^" + w + "$)", "i"), Wc;
}, V1 = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  // url: new RegExp(
  //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
  //   'i',
  // ),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
}, Ui = {
  integer: function(t) {
    return Ui.number(t) && parseInt(t, 10) === t;
  },
  float: function(t) {
    return Ui.number(t) && !Ui.integer(t);
  },
  array: function(t) {
    return Array.isArray(t);
  },
  regexp: function(t) {
    if (t instanceof RegExp)
      return true;
    try {
      return !!new RegExp(t);
    } catch {
      return false;
    }
  },
  date: function(t) {
    return typeof t.getTime == "function" && typeof t.getMonth == "function" && typeof t.getYear == "function" && !isNaN(t.getTime());
  },
  number: function(t) {
    return isNaN(t) ? false : typeof t == "number";
  },
  object: function(t) {
    return typeof t == "object" && !Ui.array(t);
  },
  method: function(t) {
    return typeof t == "function";
  },
  email: function(t) {
    return typeof t == "string" && t.length <= 320 && !!t.match(V1.email);
  },
  url: function(t) {
    return typeof t == "string" && t.length <= 2048 && !!t.match(sK());
  },
  hex: function(t) {
    return typeof t == "string" && !!t.match(V1.hex);
  }
}, iK = function(t, n, o, r, a) {
  if (t.required && n === void 0) {
    Tk(t, n, o, r, a);
    return;
  }
  var l = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"], s = t.type;
  l.indexOf(s) > -1 ? Ui[s](n) || r.push(xo(a.messages.types[s], t.fullField, t.type)) : s && typeof n !== t.type && r.push(xo(a.messages.types[s], t.fullField, t.type));
}, uK = function(t, n, o, r, a) {
  var l = typeof t.len == "number", s = typeof t.min == "number", u = typeof t.max == "number", c = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, d = n, f = null, p = typeof n == "number", v = typeof n == "string", m = Array.isArray(n);
  if (p ? f = "number" : v ? f = "string" : m && (f = "array"), !f)
    return false;
  m && (d = n.length), v && (d = n.replace(c, "_").length), l ? d !== t.len && r.push(xo(a.messages[f].len, t.fullField, t.len)) : s && !u && d < t.min ? r.push(xo(a.messages[f].min, t.fullField, t.min)) : u && !s && d > t.max ? r.push(xo(a.messages[f].max, t.fullField, t.max)) : s && u && (d < t.min || d > t.max) && r.push(xo(a.messages[f].range, t.fullField, t.min, t.max));
}, ys = "enum", cK = function(t, n, o, r, a) {
  t[ys] = Array.isArray(t[ys]) ? t[ys] : [], t[ys].indexOf(n) === -1 && r.push(xo(a.messages[ys], t.fullField, t[ys].join(", ")));
}, dK = function(t, n, o, r, a) {
  if (t.pattern) {
    if (t.pattern instanceof RegExp)
      t.pattern.lastIndex = 0, t.pattern.test(n) || r.push(xo(a.messages.pattern.mismatch, t.fullField, n, t.pattern));
    else if (typeof t.pattern == "string") {
      var l = new RegExp(t.pattern);
      l.test(n) || r.push(xo(a.messages.pattern.mismatch, t.fullField, n, t.pattern));
    }
  }
}, Yt = {
  required: Tk,
  whitespace: lK,
  type: iK,
  range: uK,
  enum: cK,
  pattern: dK
}, fK = function(t, n, o, r, a) {
  var l = [], s = t.required || !t.required && r.hasOwnProperty(t.field);
  if (s) {
    if (An(n, "string") && !t.required)
      return o();
    Yt.required(t, n, r, l, a, "string"), An(n, "string") || (Yt.type(t, n, r, l, a), Yt.range(t, n, r, l, a), Yt.pattern(t, n, r, l, a), t.whitespace === true && Yt.whitespace(t, n, r, l, a));
  }
  o(l);
}, pK = function(t, n, o, r, a) {
  var l = [], s = t.required || !t.required && r.hasOwnProperty(t.field);
  if (s) {
    if (An(n) && !t.required)
      return o();
    Yt.required(t, n, r, l, a), n !== void 0 && Yt.type(t, n, r, l, a);
  }
  o(l);
}, vK = function(t, n, o, r, a) {
  var l = [], s = t.required || !t.required && r.hasOwnProperty(t.field);
  if (s) {
    if (n === "" && (n = void 0), An(n) && !t.required)
      return o();
    Yt.required(t, n, r, l, a), n !== void 0 && (Yt.type(t, n, r, l, a), Yt.range(t, n, r, l, a));
  }
  o(l);
}, hK = function(t, n, o, r, a) {
  var l = [], s = t.required || !t.required && r.hasOwnProperty(t.field);
  if (s) {
    if (An(n) && !t.required)
      return o();
    Yt.required(t, n, r, l, a), n !== void 0 && Yt.type(t, n, r, l, a);
  }
  o(l);
}, mK = function(t, n, o, r, a) {
  var l = [], s = t.required || !t.required && r.hasOwnProperty(t.field);
  if (s) {
    if (An(n) && !t.required)
      return o();
    Yt.required(t, n, r, l, a), An(n) || Yt.type(t, n, r, l, a);
  }
  o(l);
}, gK = function(t, n, o, r, a) {
  var l = [], s = t.required || !t.required && r.hasOwnProperty(t.field);
  if (s) {
    if (An(n) && !t.required)
      return o();
    Yt.required(t, n, r, l, a), n !== void 0 && (Yt.type(t, n, r, l, a), Yt.range(t, n, r, l, a));
  }
  o(l);
}, yK = function(t, n, o, r, a) {
  var l = [], s = t.required || !t.required && r.hasOwnProperty(t.field);
  if (s) {
    if (An(n) && !t.required)
      return o();
    Yt.required(t, n, r, l, a), n !== void 0 && (Yt.type(t, n, r, l, a), Yt.range(t, n, r, l, a));
  }
  o(l);
}, bK = function(t, n, o, r, a) {
  var l = [], s = t.required || !t.required && r.hasOwnProperty(t.field);
  if (s) {
    if (n == null && !t.required)
      return o();
    Yt.required(t, n, r, l, a, "array"), n != null && (Yt.type(t, n, r, l, a), Yt.range(t, n, r, l, a));
  }
  o(l);
}, _K = function(t, n, o, r, a) {
  var l = [], s = t.required || !t.required && r.hasOwnProperty(t.field);
  if (s) {
    if (An(n) && !t.required)
      return o();
    Yt.required(t, n, r, l, a), n !== void 0 && Yt.type(t, n, r, l, a);
  }
  o(l);
}, wK = "enum", CK = function(t, n, o, r, a) {
  var l = [], s = t.required || !t.required && r.hasOwnProperty(t.field);
  if (s) {
    if (An(n) && !t.required)
      return o();
    Yt.required(t, n, r, l, a), n !== void 0 && Yt[wK](t, n, r, l, a);
  }
  o(l);
}, EK = function(t, n, o, r, a) {
  var l = [], s = t.required || !t.required && r.hasOwnProperty(t.field);
  if (s) {
    if (An(n, "string") && !t.required)
      return o();
    Yt.required(t, n, r, l, a), An(n, "string") || Yt.pattern(t, n, r, l, a);
  }
  o(l);
}, SK = function(t, n, o, r, a) {
  var l = [], s = t.required || !t.required && r.hasOwnProperty(t.field);
  if (s) {
    if (An(n, "date") && !t.required)
      return o();
    if (Yt.required(t, n, r, l, a), !An(n, "date")) {
      var u;
      n instanceof Date ? u = n : u = new Date(n), Yt.type(t, u, r, l, a), u && Yt.range(t, u.getTime(), r, l, a);
    }
  }
  o(l);
}, kK = function(t, n, o, r, a) {
  var l = [], s = Array.isArray(n) ? "array" : typeof n;
  Yt.required(t, n, r, l, a, s), o(l);
}, sv = function(t, n, o, r, a) {
  var l = t.type, s = [], u = t.required || !t.required && r.hasOwnProperty(t.field);
  if (u) {
    if (An(n, l) && !t.required)
      return o();
    Yt.required(t, n, r, s, a, l), An(n, l) || Yt.type(t, n, r, s, a);
  }
  o(s);
}, NK = function(t, n, o, r, a) {
  var l = [], s = t.required || !t.required && r.hasOwnProperty(t.field);
  if (s) {
    if (An(n) && !t.required)
      return o();
    Yt.required(t, n, r, l, a);
  }
  o(l);
}, au = {
  string: fK,
  method: pK,
  number: vK,
  boolean: hK,
  regexp: mK,
  integer: gK,
  float: yK,
  array: bK,
  object: _K,
  enum: CK,
  pattern: EK,
  date: SK,
  url: sv,
  hex: sv,
  email: sv,
  required: kK,
  any: NK
};
function fh() {
  return {
    default: "Validation error on field %s",
    required: "%s is required",
    enum: "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      boolean: "%s is not a %s",
      integer: "%s is not an %s",
      float: "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function() {
      var t = JSON.parse(JSON.stringify(this));
      return t.clone = this.clone, t;
    }
  };
}
var ph = fh(), pc = /* @__PURE__ */ function() {
  function e10(n) {
    this.rules = null, this._messages = ph, this.define(n);
  }
  var t = e10.prototype;
  return t.define = function(o) {
    var r = this;
    if (!o)
      throw new Error("Cannot configure a schema with no rules");
    if (typeof o != "object" || Array.isArray(o))
      throw new Error("Rules must be an object");
    this.rules = {}, Object.keys(o).forEach(function(a) {
      var l = o[a];
      r.rules[a] = Array.isArray(l) ? l : [l];
    });
  }, t.messages = function(o) {
    return o && (this._messages = D1(fh(), o)), this._messages;
  }, t.validate = function(o, r, a) {
    var l = this;
    r === void 0 && (r = {}), a === void 0 && (a = function() {
    });
    var s = o, u = r, c = a;
    if (typeof u == "function" && (c = u, u = {}), !this.rules || Object.keys(this.rules).length === 0)
      return c && c(null, s), Promise.resolve(s);
    function d(h) {
      var b = [], g = {};
      function w(_) {
        if (Array.isArray(_)) {
          var C;
          b = (C = b).concat.apply(C, _);
        } else
          b.push(_);
      }
      for (var y = 0; y < h.length; y++)
        w(h[y]);
      b.length ? (g = dh(b), c(b, g)) : c(null, s);
    }
    if (u.messages) {
      var f = this.messages();
      f === ph && (f = fh()), D1(f, u.messages), u.messages = f;
    } else
      u.messages = this.messages();
    var p = {}, v = u.keys || Object.keys(this.rules);
    v.forEach(function(h) {
      var b = l.rules[h], g = s[h];
      b.forEach(function(w) {
        var y = w;
        typeof y.transform == "function" && (s === o && (s = Il({}, s)), g = s[h] = y.transform(g)), typeof y == "function" ? y = {
          validator: y
        } : y = Il({}, y), y.validator = l.getValidationMethod(y), y.validator && (y.field = h, y.fullField = y.fullField || h, y.type = l.getType(y), p[h] = p[h] || [], p[h].push({
          rule: y,
          value: g,
          source: s,
          field: h
        }));
      });
    });
    var m = {};
    return oK(p, u, function(h, b) {
      var g = h.rule, w = (g.type === "object" || g.type === "array") && (typeof g.fields == "object" || typeof g.defaultField == "object");
      w = w && (g.required || !g.required && h.value), g.field = h.field;
      function y(E, T) {
        return Il({}, T, {
          fullField: g.fullField + "." + E,
          fullFields: g.fullFields ? [].concat(g.fullFields, [E]) : [E]
        });
      }
      function _(E) {
        E === void 0 && (E = []);
        var T = Array.isArray(E) ? E : [E];
        !u.suppressWarning && T.length && e10.warning("async-validator:", T), T.length && g.message !== void 0 && (T = [].concat(g.message));
        var O = T.map(x1(g, s));
        if (u.first && O.length)
          return m[g.field] = 1, b(O);
        if (!w)
          b(O);
        else {
          if (g.required && !h.value)
            return g.message !== void 0 ? O = [].concat(g.message).map(x1(g, s)) : u.error && (O = [u.error(g, xo(u.messages.required, g.field))]), b(O);
          var N = {};
          g.defaultField && Object.keys(h.value).map(function(P) {
            N[P] = g.defaultField;
          }), N = Il({}, N, h.rule.fields);
          var $ = {};
          Object.keys(N).forEach(function(P) {
            var z = N[P], Y = Array.isArray(z) ? z : [z];
            $[P] = Y.map(y.bind(null, P));
          });
          var R = new e10($);
          R.messages(u.messages), h.rule.options && (h.rule.options.messages = u.messages, h.rule.options.error = u.error), R.validate(h.value, h.rule.options || u, function(P) {
            var z = [];
            O && O.length && z.push.apply(z, O), P && P.length && z.push.apply(z, P), b(z.length ? z : null);
          });
        }
      }
      var C;
      if (g.asyncValidator)
        C = g.asyncValidator(g, h.value, _, h.source, u);
      else if (g.validator) {
        try {
          C = g.validator(g, h.value, _, h.source, u);
        } catch (E) {
          console.error == null || console.error(E), u.suppressValidatorError || setTimeout(function() {
            throw E;
          }, 0), _(E.message);
        }
        C === true ? _() : C === false ? _(typeof g.message == "function" ? g.message(g.fullField || g.field) : g.message || (g.fullField || g.field) + " fails") : C instanceof Array ? _(C) : C instanceof Error && _(C.message);
      }
      C && C.then && C.then(function() {
        return _();
      }, function(E) {
        return _(E);
      });
    }, function(h) {
      d(h);
    }, s);
  }, t.getType = function(o) {
    if (o.type === void 0 && o.pattern instanceof RegExp && (o.type = "pattern"), typeof o.validator != "function" && o.type && !au.hasOwnProperty(o.type))
      throw new Error(xo("Unknown rule type %s", o.type));
    return o.type || "string";
  }, t.getValidationMethod = function(o) {
    if (typeof o.validator == "function")
      return o.validator;
    var r = Object.keys(o), a = r.indexOf("message");
    return a !== -1 && r.splice(a, 1), r.length === 1 && r[0] === "required" ? au.required : au[this.getType(o)] || void 0;
  }, e10;
}();
pc.register = function(t, n) {
  if (typeof n != "function")
    throw new Error("Cannot register a validator by type, validator is not a function");
  au[t] = n;
};
pc.warning = Nk;
pc.messages = ph;
pc.validators = au;
const TK = [
  "",
  "error",
  "validating",
  "success"
], OK = Oe({
  label: String,
  labelWidth: {
    type: [String, Number],
    default: ""
  },
  labelPosition: {
    type: String,
    values: ["left", "right", "top", ""],
    default: ""
  },
  prop: {
    type: ne([String, Array])
  },
  required: {
    type: Boolean,
    default: void 0
  },
  rules: {
    type: ne([Object, Array])
  },
  error: String,
  validateStatus: {
    type: String,
    values: TK
  },
  for: String,
  inlineMessage: {
    type: [String, Boolean],
    default: ""
  },
  showMessage: {
    type: Boolean,
    default: true
  },
  size: {
    type: String,
    values: Qr
  }
}), F1 = "ElLabelWrap";
var $K = /* @__PURE__ */ j({
  name: F1,
  props: {
    isAutoWidth: Boolean,
    updateAll: Boolean
  },
  setup(e10, {
    slots: t
  }) {
    const n = Le(cs, void 0), o = Le(qr);
    o || Qt(F1, "usage: <el-form-item><label-wrap /></el-form-item>");
    const r = we("form"), a = L(), l = L(0), s = () => {
      var d;
      if ((d = a.value) != null && d.firstElementChild) {
        const f = window.getComputedStyle(a.value.firstElementChild).width;
        return Math.ceil(Number.parseFloat(f));
      } else
        return 0;
    }, u = (d = "update") => {
      He(() => {
        t.default && e10.isAutoWidth && (d === "update" ? l.value = s() : d === "remove" && (n == null || n.deregisterLabelWidth(l.value)));
      });
    }, c = () => u("update");
    return dt(() => {
      c();
    }), jt(() => {
      u("remove");
    }), wr(() => c()), ge(l, (d, f) => {
      e10.updateAll && (n == null || n.registerLabelWidth(d, f));
    }), en(S(() => {
      var d, f;
      return (f = (d = a.value) == null ? void 0 : d.firstElementChild) != null ? f : null;
    }), c), () => {
      var d, f;
      if (!t)
        return null;
      const {
        isAutoWidth: p
      } = e10;
      if (p) {
        const v = n == null ? void 0 : n.autoLabelWidth, m = o == null ? void 0 : o.hasLabel, h = {};
        if (m && v && v !== "auto") {
          const b = Math.max(0, Number.parseInt(v, 10) - l.value), w = (o.labelPosition || n.labelPosition) === "left" ? "marginRight" : "marginLeft";
          b && (h[w] = `${b}px`);
        }
        return W("div", {
          ref: a,
          class: [r.be("item", "label-wrap")],
          style: h
        }, [(d = t.default) == null ? void 0 : d.call(t)]);
      } else
        return W(Ie, {
          ref: a
        }, [(f = t.default) == null ? void 0 : f.call(t)]);
    };
  }
});
const IK = /* @__PURE__ */ j({
  name: "ElFormItem"
}), MK = /* @__PURE__ */ j({
  ...IK,
  props: OK,
  setup(e10, { expose: t }) {
    const n = e10, o = En(), r = Le(cs, void 0), a = Le(qr, void 0), l = yn(void 0, { formItem: false }), s = we("form-item"), u = Fn().value, c = L([]), d = L(""), f = BL(d, 100), p = L(""), v = L();
    let m, h = false;
    const b = S(() => n.labelPosition || (r == null ? void 0 : r.labelPosition)), g = S(() => {
      if (b.value === "top")
        return {};
      const ve = sn(n.labelWidth || (r == null ? void 0 : r.labelWidth) || "");
      return ve ? { width: ve } : {};
    }), w = S(() => {
      if (b.value === "top" || r != null && r.inline)
        return {};
      if (!n.label && !n.labelWidth && $)
        return {};
      const ve = sn(n.labelWidth || (r == null ? void 0 : r.labelWidth) || "");
      return !n.label && !o.label ? { marginLeft: ve } : {};
    }), y = S(() => [
      s.b(),
      s.m(l.value),
      s.is("error", d.value === "error"),
      s.is("validating", d.value === "validating"),
      s.is("success", d.value === "success"),
      s.is("required", D.value || n.required),
      s.is("no-asterisk", r == null ? void 0 : r.hideRequiredAsterisk),
      (r == null ? void 0 : r.requireAsteriskPosition) === "right" ? "asterisk-right" : "asterisk-left",
      {
        [s.m("feedback")]: r == null ? void 0 : r.statusIcon,
        [s.m(`label-${b.value}`)]: b.value
      }
    ]), _ = S(() => Vt(n.inlineMessage) ? n.inlineMessage : (r == null ? void 0 : r.inlineMessage) || false), C = S(() => [
      s.e("error"),
      { [s.em("error", "inline")]: _.value }
    ]), E = S(() => n.prop ? Ve(n.prop) ? n.prop : n.prop.join(".") : ""), T = S(() => !!(n.label || o.label)), O = S(() => {
      var ve;
      return (ve = n.for) != null ? ve : c.value.length === 1 ? c.value[0] : void 0;
    }), N = S(() => !O.value && T.value), $ = !!a, R = S(() => {
      const ve = r == null ? void 0 : r.model;
      if (!(!ve || !n.prop))
        return nu(ve, n.prop).value;
    }), P = S(() => {
      const { required: ve } = n, me = [];
      n.rules && me.push(...Zn(n.rules));
      const De = r == null ? void 0 : r.rules;
      if (De && n.prop) {
        const Te = nu(De, n.prop).value;
        Te && me.push(...Zn(Te));
      }
      if (ve !== void 0) {
        const Te = me.map((de, U) => [de, U]).filter(([de]) => Object.keys(de).includes("required"));
        if (Te.length > 0)
          for (const [de, U] of Te)
            de.required !== ve && (me[U] = { ...de, required: ve });
        else
          me.push({ required: ve });
      }
      return me;
    }), z = S(() => P.value.length > 0), Y = (ve) => P.value.filter((De) => !De.trigger || !ve ? true : Se(De.trigger) ? De.trigger.includes(ve) : De.trigger === ve).map(({ trigger: De, ...Te }) => Te), D = S(() => P.value.some((ve) => ve.required)), M = S(() => {
      var ve;
      return f.value === "error" && n.showMessage && ((ve = r == null ? void 0 : r.showMessage) != null ? ve : true);
    }), F = S(() => `${n.label || ""}${(r == null ? void 0 : r.labelSuffix) || ""}`), A = (ve) => {
      d.value = ve;
    }, V = (ve) => {
      var me, De;
      const { errors: Te, fields: de } = ve;
      (!Te || !de) && console.error(ve), A("error"), p.value = Te ? (De = (me = Te == null ? void 0 : Te[0]) == null ? void 0 : me.message) != null ? De : `${n.prop} is required` : "", r == null || r.emit("validate", n.prop, false, p.value);
    }, Z = () => {
      A("success"), r == null || r.emit("validate", n.prop, true, "");
    }, G = async (ve) => {
      const me = E.value;
      return new pc({
        [me]: ve
      }).validate({ [me]: R.value }, { firstFields: true }).then(() => (Z(), true)).catch((Te) => (V(Te), Promise.reject(Te)));
    }, le = async (ve, me) => {
      if (h || !n.prop)
        return false;
      const De = Fe(me);
      if (!z.value)
        return me == null || me(false), false;
      const Te = Y(ve);
      return Te.length === 0 ? (me == null || me(true), true) : (A("validating"), G(Te).then(() => (me == null || me(true), true)).catch((de) => {
        const { fields: U } = de;
        return me == null || me(false, U), De ? false : Promise.reject(U);
      }));
    }, X = () => {
      A(""), p.value = "", h = false;
    }, te = async () => {
      const ve = r == null ? void 0 : r.model;
      if (!ve || !n.prop)
        return;
      const me = nu(ve, n.prop);
      h = true, me.value = d0(m), await He(), X(), h = false;
    }, ce = (ve) => {
      c.value.includes(ve) || c.value.push(ve);
    }, pe = (ve) => {
      c.value = c.value.filter((me) => me !== ve);
    };
    ge(() => n.error, (ve) => {
      p.value = ve || "", A(ve ? "error" : "");
    }, { immediate: true }), ge(() => n.validateStatus, (ve) => A(ve || ""));
    const se = It({
      ...Tn(n),
      $el: v,
      size: l,
      validateState: d,
      labelId: u,
      inputIds: c,
      isGroup: N,
      hasLabel: T,
      fieldValue: R,
      addInputId: ce,
      removeInputId: pe,
      resetField: te,
      clearValidate: X,
      validate: le
    });
    return yt(qr, se), dt(() => {
      n.prop && (r == null || r.addField(se), m = d0(R.value));
    }), jt(() => {
      r == null || r.removeField(se);
    }), t({
      size: l,
      validateMessage: p,
      validateState: d,
      validate: le,
      clearValidate: X,
      resetField: te
    }), (ve, me) => {
      var De;
      return k(), x("div", {
        ref_key: "formItemRef",
        ref: v,
        class: I(i(y)),
        role: i(N) ? "group" : void 0,
        "aria-labelledby": i(N) ? i(u) : void 0
      }, [
        W(i($K), {
          "is-auto-width": i(g).width === "auto",
          "update-all": ((De = i(r)) == null ? void 0 : De.labelWidth) === "auto"
        }, {
          default: H(() => [
            i(T) ? (k(), ae(ht(i(O) ? "label" : "div"), {
              key: 0,
              id: i(u),
              for: i(O),
              class: I(i(s).e("label")),
              style: ze(i(g))
            }, {
              default: H(() => [
                J(ve.$slots, "label", { label: i(F) }, () => [
                  Ze(_e(i(F)), 1)
                ])
              ]),
              _: 3
            }, 8, ["id", "for", "class", "style"])) : ee("v-if", true)
          ]),
          _: 3
        }, 8, ["is-auto-width", "update-all"]),
        B("div", {
          class: I(i(s).e("content")),
          style: ze(i(w))
        }, [
          J(ve.$slots, "default"),
          W(mE, {
            name: `${i(s).namespace.value}-zoom-in-top`
          }, {
            default: H(() => [
              i(M) ? J(ve.$slots, "error", {
                key: 0,
                error: p.value
              }, () => [
                B("div", {
                  class: I(i(C))
                }, _e(p.value), 3)
              ]) : ee("v-if", true)
            ]),
            _: 3
          }, 8, ["name"])
        ], 6)
      ], 10, ["role", "aria-labelledby"]);
    };
  }
});
var Ok = /* @__PURE__ */ $e(MK, [["__file", "form-item.vue"]]);
const PK = ut(G7, {
  FormItem: Ok
}), RK = nn(Ok), AK = Oe({
  urlList: {
    type: ne(Array),
    default: () => rn([])
  },
  zIndex: {
    type: Number
  },
  initialIndex: {
    type: Number,
    default: 0
  },
  infinite: {
    type: Boolean,
    default: true
  },
  hideOnClickModal: Boolean,
  teleported: Boolean,
  closeOnPressEscape: {
    type: Boolean,
    default: true
  },
  zoomRate: {
    type: Number,
    default: 1.2
  },
  minScale: {
    type: Number,
    default: 0.2
  },
  maxScale: {
    type: Number,
    default: 7
  },
  showProgress: {
    type: Boolean,
    default: false
  },
  crossorigin: {
    type: ne(String)
  }
}), LK = {
  close: () => true,
  switch: (e10) => Ye(e10),
  rotate: (e10) => Ye(e10)
}, xK = /* @__PURE__ */ j({
  name: "ElImageViewer"
}), DK = /* @__PURE__ */ j({
  ...xK,
  props: AK,
  emits: LK,
  setup(e10, { expose: t, emit: n }) {
    var o;
    const r = e10, a = {
      CONTAIN: {
        name: "contain",
        icon: ya(o8)
      },
      ORIGINAL: {
        name: "original",
        icon: ya(E8)
      }
    };
    let l, s = "";
    const { t: u } = kt(), c = we("image-viewer"), { nextZIndex: d } = Si(), f = L(), p = L([]), v = Bw(), m = L(true), h = L(r.initialIndex), b = qt(a.CONTAIN), g = L({
      scale: 1,
      deg: 0,
      offsetX: 0,
      offsetY: 0,
      enableTransition: false
    }), w = L((o = r.zIndex) != null ? o : d()), y = S(() => {
      const { urlList: pe } = r;
      return pe.length <= 1;
    }), _ = S(() => h.value === 0), C = S(() => h.value === r.urlList.length - 1), E = S(() => r.urlList[h.value]), T = S(() => [
      c.e("btn"),
      c.e("prev"),
      c.is("disabled", !r.infinite && _.value)
    ]), O = S(() => [
      c.e("btn"),
      c.e("next"),
      c.is("disabled", !r.infinite && C.value)
    ]), N = S(() => {
      const { scale: pe, deg: se, offsetX: ve, offsetY: me, enableTransition: De } = g.value;
      let Te = ve / pe, de = me / pe;
      const U = se * Math.PI / 180, re = Math.cos(U), he = Math.sin(U);
      Te = Te * re + de * he, de = de * re - ve / pe * he;
      const Ee = {
        transform: `scale(${pe}) rotate(${se}deg) translate(${Te}px, ${de}px)`,
        transition: De ? "transform .3s" : ""
      };
      return b.value.name === a.CONTAIN.name && (Ee.maxWidth = Ee.maxHeight = "100%"), Ee;
    }), $ = S(() => `${h.value + 1} / ${r.urlList.length}`);
    function R() {
      z(), l == null || l(), document.body.style.overflow = s, n("close");
    }
    function P() {
      const pe = zl((ve) => {
        switch (ve.code) {
          case xe.esc:
            r.closeOnPressEscape && R();
            break;
          case xe.space:
            A();
            break;
          case xe.left:
            Z();
            break;
          case xe.up:
            le("zoomIn");
            break;
          case xe.right:
            G();
            break;
          case xe.down:
            le("zoomOut");
            break;
        }
      }), se = zl((ve) => {
        const me = ve.deltaY || ve.deltaX;
        le(me < 0 ? "zoomIn" : "zoomOut", {
          zoomRate: r.zoomRate,
          enableTransition: false
        });
      });
      v.run(() => {
        Ft(document, "keydown", pe), Ft(document, "wheel", se);
      });
    }
    function z() {
      v.stop();
    }
    function Y() {
      m.value = false;
    }
    function D(pe) {
      m.value = false, pe.target.alt = u("el.image.error");
    }
    function M(pe) {
      if (m.value || pe.button !== 0 || !f.value)
        return;
      g.value.enableTransition = false;
      const { offsetX: se, offsetY: ve } = g.value, me = pe.pageX, De = pe.pageY, Te = zl((U) => {
        g.value = {
          ...g.value,
          offsetX: se + U.pageX - me,
          offsetY: ve + U.pageY - De
        };
      }), de = Ft(document, "mousemove", Te);
      Ft(document, "mouseup", () => {
        de();
      }), pe.preventDefault();
    }
    function F() {
      g.value = {
        scale: 1,
        deg: 0,
        offsetX: 0,
        offsetY: 0,
        enableTransition: false
      };
    }
    function A() {
      if (m.value)
        return;
      const pe = Qs(a), se = Object.values(a), ve = b.value.name, De = (se.findIndex((Te) => Te.name === ve) + 1) % pe.length;
      b.value = a[pe[De]], F();
    }
    function V(pe) {
      const se = r.urlList.length;
      h.value = (pe + se) % se;
    }
    function Z() {
      _.value && !r.infinite || V(h.value - 1);
    }
    function G() {
      C.value && !r.infinite || V(h.value + 1);
    }
    function le(pe, se = {}) {
      if (m.value)
        return;
      const { minScale: ve, maxScale: me } = r, { zoomRate: De, rotateDeg: Te, enableTransition: de } = {
        zoomRate: r.zoomRate,
        rotateDeg: 90,
        enableTransition: true,
        ...se
      };
      switch (pe) {
        case "zoomOut":
          g.value.scale > ve && (g.value.scale = Number.parseFloat((g.value.scale / De).toFixed(3)));
          break;
        case "zoomIn":
          g.value.scale < me && (g.value.scale = Number.parseFloat((g.value.scale * De).toFixed(3)));
          break;
        case "clockwise":
          g.value.deg += Te, n("rotate", g.value.deg);
          break;
        case "anticlockwise":
          g.value.deg -= Te, n("rotate", g.value.deg);
          break;
      }
      g.value.enableTransition = de;
    }
    function X(pe) {
      var se;
      ((se = pe.detail) == null ? void 0 : se.focusReason) === "pointer" && pe.preventDefault();
    }
    function te() {
      r.closeOnPressEscape && R();
    }
    function ce(pe) {
      if (pe.ctrlKey) {
        if (pe.deltaY < 0)
          return pe.preventDefault(), false;
        if (pe.deltaY > 0)
          return pe.preventDefault(), false;
      }
    }
    return ge(E, () => {
      He(() => {
        const pe = p.value[0];
        pe != null && pe.complete || (m.value = true);
      });
    }), ge(h, (pe) => {
      F(), n("switch", pe);
    }), dt(() => {
      P(), l = Ft("wheel", ce, {
        passive: false
      }), s = document.body.style.overflow, document.body.style.overflow = "hidden";
    }), t({
      setActiveItem: V
    }), (pe, se) => (k(), ae(i(Ti), {
      to: "body",
      disabled: !pe.teleported
    }, {
      default: H(() => [
        W(Rn, {
          name: "viewer-fade",
          appear: ""
        }, {
          default: H(() => [
            B("div", {
              ref_key: "wrapper",
              ref: f,
              tabindex: -1,
              class: I(i(c).e("wrapper")),
              style: ze({ zIndex: w.value })
            }, [
              W(i(Ni), {
                loop: "",
                trapped: "",
                "focus-trap-el": f.value,
                "focus-start-el": "container",
                onFocusoutPrevented: X,
                onReleaseRequested: te
              }, {
                default: H(() => [
                  B("div", {
                    class: I(i(c).e("mask")),
                    onClick: Xe((ve) => pe.hideOnClickModal && R(), ["self"])
                  }, null, 10, ["onClick"]),
                  ee(" CLOSE "),
                  B("span", {
                    class: I([i(c).e("btn"), i(c).e("close")]),
                    onClick: R
                  }, [
                    W(i(Be), null, {
                      default: H(() => [
                        W(i(Jo))
                      ]),
                      _: 1
                    })
                  ], 2),
                  ee(" ARROW "),
                  i(y) ? ee("v-if", true) : (k(), x(Ie, { key: 0 }, [
                    B("span", {
                      class: I(i(T)),
                      onClick: Z
                    }, [
                      W(i(Be), null, {
                        default: H(() => [
                          W(i(wa))
                        ]),
                        _: 1
                      })
                    ], 2),
                    B("span", {
                      class: I(i(O)),
                      onClick: G
                    }, [
                      W(i(Be), null, {
                        default: H(() => [
                          W(i(oo))
                        ]),
                        _: 1
                      })
                    ], 2)
                  ], 64)),
                  pe.$slots.progress || pe.showProgress ? (k(), x("div", {
                    key: 1,
                    class: I([i(c).e("btn"), i(c).e("progress")])
                  }, [
                    J(pe.$slots, "progress", {
                      activeIndex: h.value,
                      total: pe.urlList.length
                    }, () => [
                      Ze(_e(i($)), 1)
                    ])
                  ], 2)) : ee("v-if", true),
                  ee(" ACTIONS "),
                  B("div", {
                    class: I([i(c).e("btn"), i(c).e("actions")])
                  }, [
                    B("div", {
                      class: I(i(c).e("actions__inner"))
                    }, [
                      J(pe.$slots, "toolbar", {
                        actions: le,
                        prev: Z,
                        next: G,
                        reset: A,
                        activeIndex: h.value,
                        setActiveItem: V
                      }, () => [
                        W(i(Be), {
                          onClick: (ve) => le("zoomOut")
                        }, {
                          default: H(() => [
                            W(i(F8))
                          ]),
                          _: 1
                        }, 8, ["onClick"]),
                        W(i(Be), {
                          onClick: (ve) => le("zoomIn")
                        }, {
                          default: H(() => [
                            W(i(LS))
                          ]),
                          _: 1
                        }, 8, ["onClick"]),
                        B("i", {
                          class: I(i(c).e("actions__divider"))
                        }, null, 2),
                        W(i(Be), { onClick: A }, {
                          default: H(() => [
                            (k(), ae(ht(i(b).icon)))
                          ]),
                          _: 1
                        }),
                        B("i", {
                          class: I(i(c).e("actions__divider"))
                        }, null, 2),
                        W(i(Be), {
                          onClick: (ve) => le("anticlockwise")
                        }, {
                          default: H(() => [
                            W(i(b8))
                          ]),
                          _: 1
                        }, 8, ["onClick"]),
                        W(i(Be), {
                          onClick: (ve) => le("clockwise")
                        }, {
                          default: H(() => [
                            W(i(w8))
                          ]),
                          _: 1
                        }, 8, ["onClick"])
                      ])
                    ], 2)
                  ], 2),
                  ee(" CANVAS "),
                  B("div", {
                    class: I(i(c).e("canvas"))
                  }, [
                    (k(true), x(Ie, null, st(pe.urlList, (ve, me) => (k(), x(Ie, { key: me }, [
                      me === h.value ? (k(), x("img", {
                        key: 0,
                        ref_for: true,
                        ref: (De) => p.value[me] = De,
                        src: ve,
                        style: ze(i(N)),
                        class: I(i(c).e("img")),
                        crossorigin: pe.crossorigin,
                        onLoad: Y,
                        onError: D,
                        onMousedown: M
                      }, null, 46, ["src", "crossorigin"])) : ee("v-if", true)
                    ], 64))), 128))
                  ], 2),
                  J(pe.$slots, "default")
                ]),
                _: 3
              }, 8, ["focus-trap-el"])
            ], 6)
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 8, ["disabled"]));
  }
});
var VK = /* @__PURE__ */ $e(DK, [["__file", "image-viewer.vue"]]);
const $k = ut(VK), FK = Oe({
  hideOnClickModal: Boolean,
  src: {
    type: String,
    default: ""
  },
  fit: {
    type: String,
    values: ["", "contain", "cover", "fill", "none", "scale-down"],
    default: ""
  },
  loading: {
    type: String,
    values: ["eager", "lazy"]
  },
  lazy: Boolean,
  scrollContainer: {
    type: ne([String, Object])
  },
  previewSrcList: {
    type: ne(Array),
    default: () => rn([])
  },
  previewTeleported: Boolean,
  zIndex: {
    type: Number
  },
  initialIndex: {
    type: Number,
    default: 0
  },
  infinite: {
    type: Boolean,
    default: true
  },
  closeOnPressEscape: {
    type: Boolean,
    default: true
  },
  zoomRate: {
    type: Number,
    default: 1.2
  },
  minScale: {
    type: Number,
    default: 0.2
  },
  maxScale: {
    type: Number,
    default: 7
  },
  showProgress: {
    type: Boolean,
    default: false
  },
  crossorigin: {
    type: ne(String)
  }
}), BK = {
  load: (e10) => e10 instanceof Event,
  error: (e10) => e10 instanceof Event,
  switch: (e10) => Ye(e10),
  close: () => true,
  show: () => true
}, HK = /* @__PURE__ */ j({
  name: "ElImage",
  inheritAttrs: false
}), zK = /* @__PURE__ */ j({
  ...HK,
  props: FK,
  emits: BK,
  setup(e10, { expose: t, emit: n }) {
    const o = e10, { t: r } = kt(), a = we("image"), l = Ta(), s = S(() => wu(Object.entries(l).filter(([M]) => /^(data-|on[A-Z])/i.test(M) || ["id", "style"].includes(M)))), u = ic({
      excludeListeners: true,
      excludeKeys: S(() => Object.keys(s.value))
    }), c = L(), d = L(false), f = L(true), p = L(false), v = L(), m = L(), h = Et && "loading" in HTMLImageElement.prototype;
    let b;
    const g = S(() => [
      a.e("inner"),
      y.value && a.e("preview"),
      f.value && a.is("loading")
    ]), w = S(() => {
      const { fit: M } = o;
      return Et && M ? { objectFit: M } : {};
    }), y = S(() => {
      const { previewSrcList: M } = o;
      return Se(M) && M.length > 0;
    }), _ = S(() => {
      const { previewSrcList: M, initialIndex: F } = o;
      let A = F;
      return F > M.length - 1 && (A = 0), A;
    }), C = S(() => o.loading === "eager" ? false : !h && o.loading === "lazy" || o.lazy), E = () => {
      Et && (f.value = true, d.value = false, c.value = o.src);
    };
    function T(M) {
      f.value = false, d.value = false, n("load", M);
    }
    function O(M) {
      f.value = false, d.value = true, n("error", M);
    }
    function N() {
      ZB(v.value, m.value) && (E(), P());
    }
    const $ = dS(N, 200, true);
    async function R() {
      var M;
      if (!Et)
        return;
      await He();
      const { scrollContainer: F } = o;
      to(F) ? m.value = F : Ve(F) && F !== "" ? m.value = (M = document.querySelector(F)) != null ? M : void 0 : v.value && (m.value = tg(v.value)), m.value && (b = Ft(m, "scroll", $), setTimeout(() => N(), 100));
    }
    function P() {
      !Et || !m.value || !$ || (b == null || b(), m.value = void 0);
    }
    function z() {
      y.value && (p.value = true, n("show"));
    }
    function Y() {
      p.value = false, n("close");
    }
    function D(M) {
      n("switch", M);
    }
    return ge(() => o.src, () => {
      C.value ? (f.value = true, d.value = false, P(), R()) : E();
    }), dt(() => {
      C.value ? R() : E();
    }), t({
      showPreview: z
    }), (M, F) => (k(), x("div", vt({
      ref_key: "container",
      ref: v
    }, i(s), {
      class: [i(a).b(), M.$attrs.class]
    }), [
      d.value ? J(M.$slots, "error", { key: 0 }, () => [
        B("div", {
          class: I(i(a).e("error"))
        }, _e(i(r)("el.image.error")), 3)
      ]) : (k(), x(Ie, { key: 1 }, [
        c.value !== void 0 ? (k(), x("img", vt({ key: 0 }, i(u), {
          src: c.value,
          loading: M.loading,
          style: i(w),
          class: i(g),
          crossorigin: M.crossorigin,
          onClick: z,
          onLoad: T,
          onError: O
        }), null, 16, ["src", "loading", "crossorigin"])) : ee("v-if", true),
        f.value ? (k(), x("div", {
          key: 1,
          class: I(i(a).e("wrapper"))
        }, [
          J(M.$slots, "placeholder", {}, () => [
            B("div", {
              class: I(i(a).e("placeholder"))
            }, null, 2)
          ])
        ], 2)) : ee("v-if", true)
      ], 64)),
      i(y) ? (k(), x(Ie, { key: 2 }, [
        p.value ? (k(), ae(i($k), {
          key: 0,
          "z-index": M.zIndex,
          "initial-index": i(_),
          infinite: M.infinite,
          "zoom-rate": M.zoomRate,
          "min-scale": M.minScale,
          "max-scale": M.maxScale,
          "show-progress": M.showProgress,
          "url-list": M.previewSrcList,
          crossorigin: M.crossorigin,
          "hide-on-click-modal": M.hideOnClickModal,
          teleported: M.previewTeleported,
          "close-on-press-escape": M.closeOnPressEscape,
          onClose: Y,
          onSwitch: D
        }, ro({
          toolbar: H((A) => [
            J(M.$slots, "toolbar", Ao(jr(A)))
          ]),
          default: H(() => [
            M.$slots.viewer ? (k(), x("div", { key: 0 }, [
              J(M.$slots, "viewer")
            ])) : ee("v-if", true)
          ]),
          _: 2
        }, [
          M.$slots.progress ? {
            name: "progress",
            fn: H((A) => [
              J(M.$slots, "progress", Ao(jr(A)))
            ])
          } : void 0
        ]), 1032, ["z-index", "initial-index", "infinite", "zoom-rate", "min-scale", "max-scale", "show-progress", "url-list", "crossorigin", "hide-on-click-modal", "teleported", "close-on-press-escape"])) : ee("v-if", true)
      ], 64)) : ee("v-if", true)
    ], 16));
  }
});
var KK = /* @__PURE__ */ $e(zK, [["__file", "image.vue"]]);
const WK = ut(KK), jK = Oe({
  id: {
    type: String,
    default: void 0
  },
  step: {
    type: Number,
    default: 1
  },
  stepStrictly: Boolean,
  max: {
    type: Number,
    default: Number.POSITIVE_INFINITY
  },
  min: {
    type: Number,
    default: Number.NEGATIVE_INFINITY
  },
  modelValue: {
    type: [Number, null]
  },
  readonly: Boolean,
  disabled: Boolean,
  size: _n,
  controls: {
    type: Boolean,
    default: true
  },
  controlsPosition: {
    type: String,
    default: "",
    values: ["", "right"]
  },
  valueOnClear: {
    type: [String, Number, null],
    validator: (e10) => e10 === null || Ye(e10) || ["min", "max"].includes(e10),
    default: null
  },
  name: String,
  placeholder: String,
  precision: {
    type: Number,
    validator: (e10) => e10 >= 0 && e10 === Number.parseInt(`${e10}`, 10)
  },
  validateEvent: {
    type: Boolean,
    default: true
  },
  ...Bn(["ariaLabel"])
}), UK = {
  [gt]: (e10, t) => t !== e10,
  blur: (e10) => e10 instanceof FocusEvent,
  focus: (e10) => e10 instanceof FocusEvent,
  [bn]: (e10) => Ye(e10) || Nn(e10),
  [nt]: (e10) => Ye(e10) || Nn(e10)
}, YK = /* @__PURE__ */ j({
  name: "ElInputNumber"
}), qK = /* @__PURE__ */ j({
  ...YK,
  props: jK,
  emits: UK,
  setup(e10, { expose: t, emit: n }) {
    const o = e10, { t: r } = kt(), a = we("input-number"), l = L(), s = It({
      currentValue: o.modelValue,
      userInput: null
    }), { formItem: u } = Yn(), c = S(() => Ye(o.modelValue) && o.modelValue <= o.min), d = S(() => Ye(o.modelValue) && o.modelValue >= o.max), f = S(() => {
      const D = g(o.step);
      return St(o.precision) ? Math.max(g(o.modelValue), D) : (D > o.precision && _t("InputNumber", "precision should not be less than the decimal places of step"), o.precision);
    }), p = S(() => o.controls && o.controlsPosition === "right"), v = yn(), m = Hn(), h = S(() => {
      if (s.userInput !== null)
        return s.userInput;
      let D = s.currentValue;
      if (Nn(D))
        return "";
      if (Ye(D)) {
        if (Number.isNaN(D))
          return "";
        St(o.precision) || (D = D.toFixed(o.precision));
      }
      return D;
    }), b = (D, M) => {
      if (St(M) && (M = f.value), M === 0)
        return Math.round(D);
      let F = String(D);
      const A = F.indexOf(".");
      if (A === -1 || !F.replace(".", "").split("")[A + M])
        return D;
      const G = F.length;
      return F.charAt(G - 1) === "5" && (F = `${F.slice(0, Math.max(0, G - 1))}6`), Number.parseFloat(Number(F).toFixed(M));
    }, g = (D) => {
      if (Nn(D))
        return 0;
      const M = D.toString(), F = M.indexOf(".");
      let A = 0;
      return F !== -1 && (A = M.length - F - 1), A;
    }, w = (D, M = 1) => Ye(D) ? b(D + o.step * M) : s.currentValue, y = () => {
      if (o.readonly || m.value || d.value)
        return;
      const D = Number(h.value) || 0, M = w(D);
      E(M), n(bn, s.currentValue), z();
    }, _ = () => {
      if (o.readonly || m.value || c.value)
        return;
      const D = Number(h.value) || 0, M = w(D, -1);
      E(M), n(bn, s.currentValue), z();
    }, C = (D, M) => {
      const { max: F, min: A, step: V, precision: Z, stepStrictly: G, valueOnClear: le } = o;
      F < A && Qt("InputNumber", "min should not be greater than max.");
      let X = Number(D);
      if (Nn(D) || Number.isNaN(X))
        return null;
      if (D === "") {
        if (le === null)
          return null;
        X = Ve(le) ? { min: A, max: F }[le] : le;
      }
      return G && (X = b(Math.round(X / V) * V, Z), X !== D && M && n(nt, X)), St(Z) || (X = b(X, Z)), (X > F || X < A) && (X = X > F ? F : A, M && n(nt, X)), X;
    }, E = (D, M = true) => {
      var F;
      const A = s.currentValue, V = C(D);
      if (!M) {
        n(nt, V);
        return;
      }
      A === V && D || (s.userInput = null, n(nt, V), A !== V && n(gt, V, A), o.validateEvent && ((F = u == null ? void 0 : u.validate) == null || F.call(u, "change").catch((Z) => _t(Z))), s.currentValue = V);
    }, T = (D) => {
      s.userInput = D;
      const M = D === "" ? null : Number(D);
      n(bn, M), E(M, false);
    }, O = (D) => {
      const M = D !== "" ? Number(D) : "";
      (Ye(M) && !Number.isNaN(M) || D === "") && E(M), z(), s.userInput = null;
    }, N = () => {
      var D, M;
      (M = (D = l.value) == null ? void 0 : D.focus) == null || M.call(D);
    }, $ = () => {
      var D, M;
      (M = (D = l.value) == null ? void 0 : D.blur) == null || M.call(D);
    }, R = (D) => {
      n("focus", D);
    }, P = (D) => {
      var M, F;
      s.userInput = null, s.currentValue === null && ((M = l.value) != null && M.input) && (l.value.input.value = ""), n("blur", D), o.validateEvent && ((F = u == null ? void 0 : u.validate) == null || F.call(u, "blur").catch((A) => _t(A)));
    }, z = () => {
      s.currentValue !== o.modelValue && (s.currentValue = o.modelValue);
    }, Y = (D) => {
      document.activeElement === D.target && D.preventDefault();
    };
    return ge(() => o.modelValue, (D, M) => {
      const F = C(D, true);
      s.userInput === null && F !== M && (s.currentValue = F);
    }, { immediate: true }), dt(() => {
      var D;
      const { min: M, max: F, modelValue: A } = o, V = (D = l.value) == null ? void 0 : D.input;
      if (V.setAttribute("role", "spinbutton"), Number.isFinite(F) ? V.setAttribute("aria-valuemax", String(F)) : V.removeAttribute("aria-valuemax"), Number.isFinite(M) ? V.setAttribute("aria-valuemin", String(M)) : V.removeAttribute("aria-valuemin"), V.setAttribute("aria-valuenow", s.currentValue || s.currentValue === 0 ? String(s.currentValue) : ""), V.setAttribute("aria-disabled", String(m.value)), !Ye(A) && A != null) {
        let Z = Number(A);
        Number.isNaN(Z) && (Z = null), n(nt, Z);
      }
      V.addEventListener("wheel", Y, { passive: false });
    }), wr(() => {
      var D, M;
      const F = (D = l.value) == null ? void 0 : D.input;
      F == null || F.setAttribute("aria-valuenow", `${(M = s.currentValue) != null ? M : ""}`);
    }), t({
      focus: N,
      blur: $
    }), (D, M) => (k(), x("div", {
      class: I([
        i(a).b(),
        i(a).m(i(v)),
        i(a).is("disabled", i(m)),
        i(a).is("without-controls", !D.controls),
        i(a).is("controls-right", i(p))
      ]),
      onDragstart: Xe(() => {
      }, ["prevent"])
    }, [
      D.controls ? lt((k(), x("span", {
        key: 0,
        role: "button",
        "aria-label": i(r)("el.inputNumber.decrease"),
        class: I([i(a).e("decrease"), i(a).is("disabled", i(c))]),
        onKeydown: Bt(_, ["enter"])
      }, [
        J(D.$slots, "decrease-icon", {}, () => [
          W(i(Be), null, {
            default: H(() => [
              i(p) ? (k(), ae(i(ea), { key: 0 })) : (k(), ae(i(u8), { key: 1 }))
            ]),
            _: 1
          })
        ])
      ], 42, ["aria-label", "onKeydown"])), [
        [i(af), _]
      ]) : ee("v-if", true),
      D.controls ? lt((k(), x("span", {
        key: 1,
        role: "button",
        "aria-label": i(r)("el.inputNumber.increase"),
        class: I([i(a).e("increase"), i(a).is("disabled", i(d))]),
        onKeydown: Bt(y, ["enter"])
      }, [
        J(D.$slots, "increase-icon", {}, () => [
          W(i(Be), null, {
            default: H(() => [
              i(p) ? (k(), ae(i(Zf), { key: 0 })) : (k(), ae(i(RS), { key: 1 }))
            ]),
            _: 1
          })
        ])
      ], 42, ["aria-label", "onKeydown"])), [
        [i(af), y]
      ]) : ee("v-if", true),
      W(i(eo), {
        id: D.id,
        ref_key: "input",
        ref: l,
        type: "number",
        step: D.step,
        "model-value": i(h),
        placeholder: D.placeholder,
        readonly: D.readonly,
        disabled: i(m),
        size: i(v),
        max: D.max,
        min: D.min,
        name: D.name,
        "aria-label": D.ariaLabel,
        "validate-event": false,
        onKeydown: [
          Bt(Xe(y, ["prevent"]), ["up"]),
          Bt(Xe(_, ["prevent"]), ["down"])
        ],
        onBlur: P,
        onFocus: R,
        onInput: T,
        onChange: O
      }, ro({
        _: 2
      }, [
        D.$slots.prefix ? {
          name: "prefix",
          fn: H(() => [
            J(D.$slots, "prefix")
          ])
        } : void 0,
        D.$slots.suffix ? {
          name: "suffix",
          fn: H(() => [
            J(D.$slots, "suffix")
          ])
        } : void 0
      ]), 1032, ["id", "step", "model-value", "placeholder", "readonly", "disabled", "size", "max", "min", "name", "aria-label", "onKeydown"])
    ], 42, ["onDragstart"]));
  }
});
var GK = /* @__PURE__ */ $e(qK, [["__file", "input-number.vue"]]);
const Ik = ut(GK), XK = Oe({
  modelValue: {
    type: ne(Array)
  },
  max: Number,
  tagType: { ...Ea.type, default: "info" },
  tagEffect: Ea.effect,
  trigger: {
    type: ne(String),
    default: xe.enter
  },
  draggable: {
    type: Boolean,
    default: false
  },
  delimiter: {
    type: [String, RegExp],
    default: ""
  },
  size: _n,
  clearable: Boolean,
  disabled: {
    type: Boolean,
    default: void 0
  },
  validateEvent: {
    type: Boolean,
    default: true
  },
  readonly: Boolean,
  autofocus: Boolean,
  id: {
    type: String,
    default: void 0
  },
  tabindex: {
    type: [String, Number],
    default: 0
  },
  maxlength: {
    type: [String, Number]
  },
  minlength: {
    type: [String, Number]
  },
  placeholder: String,
  autocomplete: {
    type: String,
    default: "off"
  },
  saveOnBlur: {
    type: Boolean,
    default: true
  },
  ariaLabel: String
}), JK = {
  [nt]: (e10) => Se(e10) || St(e10),
  [gt]: (e10) => Se(e10) || St(e10),
  [bn]: (e10) => Ve(e10),
  "add-tag": (e10) => Ve(e10),
  "remove-tag": (e10) => Ve(e10),
  focus: (e10) => e10 instanceof FocusEvent,
  blur: (e10) => e10 instanceof FocusEvent,
  clear: () => true
};
function ZK({ props: e10, emit: t, formItem: n }) {
  const o = Hn(), r = yn(), a = qt(), l = L(), s = S(() => ["small"].includes(r.value) ? "small" : "default"), u = S(() => {
    var N;
    return (N = e10.modelValue) != null && N.length ? void 0 : e10.placeholder;
  }), c = S(() => !(e10.readonly || o.value)), d = S(() => {
    var N, $;
    return St(e10.max) ? false : (($ = (N = e10.modelValue) == null ? void 0 : N.length) != null ? $ : 0) >= e10.max;
  }), f = (N) => {
    var $, R;
    if (d.value) {
      l.value = void 0;
      return;
    }
    if (!C.value) {
      if (e10.delimiter) {
        const P = ($ = l.value) == null ? void 0 : $.replace(e10.delimiter, "");
        (P == null ? void 0 : P.length) !== ((R = l.value) == null ? void 0 : R.length) && (l.value = P, v());
      }
      t(bn, N.target.value);
    }
  }, p = (N) => {
    var $;
    if (!C.value)
      switch (N.code) {
        case e10.trigger:
          N.preventDefault(), N.stopPropagation(), v();
          break;
        case xe.numpadEnter:
          e10.trigger === xe.enter && (N.preventDefault(), N.stopPropagation(), v());
          break;
        case xe.backspace:
          !l.value && (($ = e10.modelValue) != null && $.length) && (N.preventDefault(), N.stopPropagation(), m(e10.modelValue.length - 1));
          break;
      }
  }, v = () => {
    var N, $;
    const R = (N = l.value) == null ? void 0 : N.trim();
    if (!R || d.value)
      return;
    const P = [...($ = e10.modelValue) != null ? $ : [], R];
    t(nt, P), t(gt, P), t("add-tag", R), l.value = void 0;
  }, m = (N) => {
    var $;
    const R = (($ = e10.modelValue) != null ? $ : []).slice(), [P] = R.splice(N, 1);
    t(nt, R), t(gt, R), t("remove-tag", P);
  }, h = () => {
    l.value = void 0, t(nt, void 0), t(gt, void 0), t("clear");
  }, b = (N, $, R) => {
    var P;
    const z = ((P = e10.modelValue) != null ? P : []).slice(), [Y] = z.splice(N, 1), D = $ > N && R === "before" ? -1 : $ < N && R === "after" ? 1 : 0;
    z.splice($ + D, 0, Y), t(nt, z), t(gt, z);
  }, g = () => {
    var N;
    (N = a.value) == null || N.focus();
  }, w = () => {
    var N;
    (N = a.value) == null || N.blur();
  }, { wrapperRef: y, isFocused: _ } = pl(a, {
    beforeFocus() {
      return o.value;
    },
    afterBlur() {
      var N;
      e10.saveOnBlur ? v() : l.value = void 0, e10.validateEvent && ((N = n == null ? void 0 : n.validate) == null || N.call(n, "blur").catch(($) => _t($)));
    }
  }), {
    isComposing: C,
    handleCompositionStart: E,
    handleCompositionUpdate: T,
    handleCompositionEnd: O
  } = uc({ afterComposition: f });
  return ge(() => e10.modelValue, () => {
    var N;
    e10.validateEvent && ((N = n == null ? void 0 : n.validate) == null || N.call(n, gt).catch(($) => _t($)));
  }), {
    inputRef: a,
    wrapperRef: y,
    isFocused: _,
    isComposing: C,
    inputValue: l,
    size: r,
    tagSize: s,
    placeholder: u,
    closable: c,
    disabled: o,
    inputLimit: d,
    handleDragged: b,
    handleInput: f,
    handleKeydown: p,
    handleAddTag: v,
    handleRemoveTag: m,
    handleClear: h,
    handleCompositionStart: E,
    handleCompositionUpdate: T,
    handleCompositionEnd: O,
    focus: g,
    blur: w
  };
}
function QK() {
  const e10 = L(false);
  return {
    hovering: e10,
    handleMouseEnter: () => {
      e10.value = true;
    },
    handleMouseLeave: () => {
      e10.value = false;
    }
  };
}
function Bg() {
  const e10 = qt(), t = L(0), n = 11, o = S(() => ({
    minWidth: `${Math.max(t.value, n)}px`
  }));
  return en(e10, () => {
    var a, l;
    t.value = (l = (a = e10.value) == null ? void 0 : a.getBoundingClientRect().width) != null ? l : 0;
  }), {
    calculatorRef: e10,
    calculatorWidth: t,
    inputStyle: o
  };
}
function eW({
  wrapperRef: e10,
  handleDragged: t,
  afterDragged: n
}) {
  const o = we("input-tag"), r = qt(), a = L(false);
  let l, s, u, c;
  function d(m) {
    return `.${o.e("inner")} .${o.namespace.value}-tag:nth-child(${m + 1})`;
  }
  function f(m, h) {
    l = h, s = e10.value.querySelector(d(h)), s && (s.style.opacity = "0.5"), m.dataTransfer.effectAllowed = "move";
  }
  function p(m, h) {
    if (u = h, m.preventDefault(), m.dataTransfer.dropEffect = "move", St(l) || l === h) {
      a.value = false;
      return;
    }
    const b = e10.value.querySelector(d(h)).getBoundingClientRect(), g = l + 1 !== h, w = l - 1 !== h, y = m.clientX - b.left, _ = g ? w ? 0.5 : 1 : -1, C = w ? g ? 0.5 : 0 : 1;
    y <= b.width * _ ? c = "before" : y > b.width * C ? c = "after" : c = void 0;
    const E = e10.value.querySelector(`.${o.e("inner")}`), T = E.getBoundingClientRect(), O = Number.parseFloat(ha(E, "gap")) / 2, N = b.top - T.top;
    let $ = -9999;
    if (c === "before")
      $ = Math.max(b.left - T.left - O, Math.floor(-O / 2));
    else if (c === "after") {
      const R = b.right - T.left;
      $ = R + (T.width === R ? Math.floor(O / 2) : O);
    }
    kS(r.value, {
      top: `${N}px`,
      left: `${$}px`
    }), a.value = !!c;
  }
  function v(m) {
    m.preventDefault(), s && (s.style.opacity = ""), c && !St(l) && !St(u) && l !== u && t(l, u, c), a.value = false, l = void 0, s = null, u = void 0, c = void 0, n == null || n();
  }
  return {
    dropIndicatorRef: r,
    showDropIndicator: a,
    handleDragStart: f,
    handleDragOver: p,
    handleDragEnd: v
  };
}
function tW({
  props: e10,
  isFocused: t,
  hovering: n,
  disabled: o,
  inputValue: r,
  size: a,
  validateState: l,
  validateIcon: s,
  needStatusIcon: u
}) {
  const c = Ta(), d = En(), f = we("input-tag"), p = we("input"), v = S(() => [
    f.b(),
    f.is("focused", t.value),
    f.is("hovering", n.value),
    f.is("disabled", o.value),
    f.m(a.value),
    f.e("wrapper"),
    c.class
  ]), m = S(() => [c.style]), h = S(() => {
    var w, y;
    return [
      f.e("inner"),
      f.is("draggable", e10.draggable),
      f.is("left-space", !((w = e10.modelValue) != null && w.length) && !d.prefix),
      f.is("right-space", !((y = e10.modelValue) != null && y.length) && !g.value)
    ];
  }), b = S(() => {
    var w;
    return e10.clearable && !o.value && !e10.readonly && (((w = e10.modelValue) == null ? void 0 : w.length) || r.value) && (t.value || n.value);
  }), g = S(() => d.suffix || b.value || l.value && s.value && u.value);
  return {
    ns: f,
    nsInput: p,
    containerKls: v,
    containerStyle: m,
    innerKls: h,
    showClear: b,
    showSuffix: g
  };
}
const nW = /* @__PURE__ */ j({
  name: "ElInputTag",
  inheritAttrs: false
}), oW = /* @__PURE__ */ j({
  ...nW,
  props: XK,
  emits: JK,
  setup(e10, { expose: t, emit: n }) {
    const o = e10, r = ic(), a = En(), { form: l, formItem: s } = Yn(), { inputId: u } = tr(o, { formItemContext: s }), c = S(() => {
      var de;
      return (de = l == null ? void 0 : l.statusIcon) != null ? de : false;
    }), d = S(() => (s == null ? void 0 : s.validateState) || ""), f = S(() => d.value && ep[d.value]), {
      inputRef: p,
      wrapperRef: v,
      isFocused: m,
      inputValue: h,
      size: b,
      tagSize: g,
      placeholder: w,
      closable: y,
      disabled: _,
      handleDragged: C,
      handleInput: E,
      handleKeydown: T,
      handleRemoveTag: O,
      handleClear: N,
      handleCompositionStart: $,
      handleCompositionUpdate: R,
      handleCompositionEnd: P,
      focus: z,
      blur: Y
    } = ZK({ props: o, emit: n, formItem: s }), { hovering: D, handleMouseEnter: M, handleMouseLeave: F } = QK(), { calculatorRef: A, inputStyle: V } = Bg(), {
      dropIndicatorRef: Z,
      showDropIndicator: G,
      handleDragStart: le,
      handleDragOver: X,
      handleDragEnd: te
    } = eW({ wrapperRef: v, handleDragged: C, afterDragged: z }), {
      ns: ce,
      nsInput: pe,
      containerKls: se,
      containerStyle: ve,
      innerKls: me,
      showClear: De,
      showSuffix: Te
    } = tW({
      props: o,
      hovering: D,
      isFocused: m,
      inputValue: h,
      disabled: _,
      size: b,
      validateState: d,
      validateIcon: f,
      needStatusIcon: c
    });
    return t({
      focus: z,
      blur: Y
    }), (de, U) => (k(), x("div", {
      ref_key: "wrapperRef",
      ref: v,
      class: I(i(se)),
      style: ze(i(ve)),
      onMouseenter: i(M),
      onMouseleave: i(F)
    }, [
      i(a).prefix ? (k(), x("div", {
        key: 0,
        class: I(i(ce).e("prefix"))
      }, [
        J(de.$slots, "prefix")
      ], 2)) : ee("v-if", true),
      B("div", {
        class: I(i(me))
      }, [
        (k(true), x(Ie, null, st(de.modelValue, (re, he) => (k(), ae(i(ai), {
          key: he,
          size: i(g),
          closable: i(y),
          type: de.tagType,
          effect: de.tagEffect,
          draggable: i(y) && de.draggable,
          "disable-transitions": "",
          onClose: (Ee) => i(O)(he),
          onDragstart: (Ee) => i(le)(Ee, he),
          onDragover: (Ee) => i(X)(Ee, he),
          onDragend: i(te),
          onDrop: Xe(() => {
          }, ["stop"])
        }, {
          default: H(() => [
            J(de.$slots, "tag", {
              value: re,
              index: he
            }, () => [
              Ze(_e(re), 1)
            ])
          ]),
          _: 2
        }, 1032, ["size", "closable", "type", "effect", "draggable", "onClose", "onDragstart", "onDragover", "onDragend", "onDrop"]))), 128)),
        B("div", {
          class: I(i(ce).e("input-wrapper"))
        }, [
          lt(B("input", vt({
            id: i(u),
            ref_key: "inputRef",
            ref: p,
            "onUpdate:modelValue": (re) => Ot(h) ? h.value = re : null
          }, i(r), {
            type: "text",
            minlength: de.minlength,
            maxlength: de.maxlength,
            disabled: i(_),
            readonly: de.readonly,
            autocomplete: de.autocomplete,
            tabindex: de.tabindex,
            placeholder: i(w),
            autofocus: de.autofocus,
            ariaLabel: de.ariaLabel,
            class: i(ce).e("input"),
            style: i(V),
            onCompositionstart: i($),
            onCompositionupdate: i(R),
            onCompositionend: i(P),
            onInput: i(E),
            onKeydown: i(T)
          }), null, 16, ["id", "onUpdate:modelValue", "minlength", "maxlength", "disabled", "readonly", "autocomplete", "tabindex", "placeholder", "autofocus", "ariaLabel", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onInput", "onKeydown"]), [
            [Qu, i(h)]
          ]),
          B("span", {
            ref_key: "calculatorRef",
            ref: A,
            "aria-hidden": "true",
            class: I(i(ce).e("input-calculator")),
            textContent: _e(i(h))
          }, null, 10, ["textContent"])
        ], 2),
        lt(B("div", {
          ref_key: "dropIndicatorRef",
          ref: Z,
          class: I(i(ce).e("drop-indicator"))
        }, null, 2), [
          [Nt, i(G)]
        ])
      ], 2),
      i(Te) ? (k(), x("div", {
        key: 1,
        class: I(i(ce).e("suffix"))
      }, [
        J(de.$slots, "suffix"),
        i(De) ? (k(), ae(i(Be), {
          key: 0,
          class: I([i(ce).e("icon"), i(ce).e("clear")]),
          onMousedown: Xe(i(Mt), ["prevent"]),
          onClick: i(N)
        }, {
          default: H(() => [
            W(i(Ma))
          ]),
          _: 1
        }, 8, ["class", "onMousedown", "onClick"])) : ee("v-if", true),
        i(d) && i(f) && i(c) ? (k(), ae(i(Be), {
          key: 1,
          class: I([
            i(pe).e("icon"),
            i(pe).e("validateIcon"),
            i(pe).is("loading", i(d) === "validating")
          ])
        }, {
          default: H(() => [
            (k(), ae(ht(i(f))))
          ]),
          _: 1
        }, 8, ["class"])) : ee("v-if", true)
      ], 2)) : ee("v-if", true)
    ], 46, ["onMouseenter", "onMouseleave"]));
  }
});
var rW = /* @__PURE__ */ $e(oW, [["__file", "input-tag.vue"]]);
const aW = ut(rW), lW = Oe({
  type: {
    type: String,
    values: ["primary", "success", "warning", "info", "danger", "default"],
    default: void 0
  },
  underline: {
    type: [Boolean, String],
    values: [true, false, "always", "never", "hover"],
    default: void 0
  },
  disabled: Boolean,
  href: { type: String, default: "" },
  target: {
    type: String,
    default: "_self"
  },
  icon: {
    type: Ht
  }
}), sW = {
  click: (e10) => e10 instanceof MouseEvent
}, iW = /* @__PURE__ */ j({
  name: "ElLink"
}), uW = /* @__PURE__ */ j({
  ...iW,
  props: lW,
  emits: sW,
  setup(e10, { emit: t }) {
    const n = e10, o = lc("link");
    _a({
      scope: "el-link",
      from: "The underline option (boolean)",
      replacement: "'always' | 'hover' | 'never'",
      version: "3.0.0",
      ref: "https://element-plus.org/en-US/component/link.html#underline"
    }, S(() => Vt(n.underline)));
    const r = we("link"), a = S(() => {
      var u, c, d;
      return [
        r.b(),
        r.m((d = (c = n.type) != null ? c : (u = o.value) == null ? void 0 : u.type) != null ? d : "default"),
        r.is("disabled", n.disabled),
        r.is("underline", l.value === "always"),
        r.is("hover-underline", l.value === "hover" && !n.disabled)
      ];
    }), l = S(() => {
      var u, c, d;
      return Vt(n.underline) ? n.underline ? "hover" : "never" : (d = (c = n.underline) != null ? c : (u = o.value) == null ? void 0 : u.underline) != null ? d : "hover";
    });
    function s(u) {
      n.disabled || t("click", u);
    }
    return (u, c) => (k(), x("a", {
      class: I(i(a)),
      href: u.disabled || !u.href ? void 0 : u.href,
      target: u.disabled || !u.href ? void 0 : u.target,
      onClick: s
    }, [
      u.icon ? (k(), ae(i(Be), { key: 0 }, {
        default: H(() => [
          (k(), ae(ht(u.icon)))
        ]),
        _: 1
      })) : ee("v-if", true),
      u.$slots.default ? (k(), x("span", {
        key: 1,
        class: I(i(r).e("inner"))
      }, [
        J(u.$slots, "default")
      ], 2)) : ee("v-if", true),
      u.$slots.icon ? J(u.$slots, "icon", { key: 2 }) : ee("v-if", true)
    ], 10, ["href", "target"]));
  }
});
var cW = /* @__PURE__ */ $e(uW, [["__file", "link.vue"]]);
const dW = ut(cW);
let fW = class {
  constructor(t, n) {
    this.parent = t, this.domNode = n, this.subIndex = 0, this.subIndex = 0, this.init();
  }
  init() {
    this.subMenuItems = this.domNode.querySelectorAll("li"), this.addListeners();
  }
  gotoSubIndex(t) {
    t === this.subMenuItems.length ? t = 0 : t < 0 && (t = this.subMenuItems.length - 1), this.subMenuItems[t].focus(), this.subIndex = t;
  }
  addListeners() {
    const t = this.parent.domNode;
    Array.prototype.forEach.call(this.subMenuItems, (n) => {
      n.addEventListener("keydown", (o) => {
        let r = false;
        switch (o.code) {
          case xe.down: {
            this.gotoSubIndex(this.subIndex + 1), r = true;
            break;
          }
          case xe.up: {
            this.gotoSubIndex(this.subIndex - 1), r = true;
            break;
          }
          case xe.tab: {
            ad(t, "mouseleave");
            break;
          }
          case xe.enter:
          case xe.numpadEnter:
          case xe.space: {
            r = true, o.currentTarget.click();
            break;
          }
        }
        return r && (o.preventDefault(), o.stopPropagation()), false;
      });
    });
  }
}, pW = class {
  constructor(t, n) {
    this.domNode = t, this.submenu = null, this.submenu = null, this.init(n);
  }
  init(t) {
    this.domNode.setAttribute("tabindex", "0");
    const n = this.domNode.querySelector(`.${t}-menu`);
    n && (this.submenu = new fW(this, n)), this.addListeners();
  }
  addListeners() {
    this.domNode.addEventListener("keydown", (t) => {
      let n = false;
      switch (t.code) {
        case xe.down: {
          ad(t.currentTarget, "mouseenter"), this.submenu && this.submenu.gotoSubIndex(0), n = true;
          break;
        }
        case xe.up: {
          ad(t.currentTarget, "mouseenter"), this.submenu && this.submenu.gotoSubIndex(this.submenu.subMenuItems.length - 1), n = true;
          break;
        }
        case xe.tab: {
          ad(t.currentTarget, "mouseleave");
          break;
        }
        case xe.enter:
        case xe.numpadEnter:
        case xe.space: {
          n = true, t.currentTarget.click();
          break;
        }
      }
      n && t.preventDefault();
    });
  }
}, vW = class {
  constructor(t, n) {
    this.domNode = t, this.init(n);
  }
  init(t) {
    const n = this.domNode.childNodes;
    Array.from(n).forEach((o) => {
      o.nodeType === 1 && new pW(o, t);
    });
  }
};
const hW = /* @__PURE__ */ j({
  name: "ElMenuCollapseTransition"
}), mW = /* @__PURE__ */ j({
  ...hW,
  setup(e10) {
    const t = we("menu"), n = {
      onBeforeEnter: (o) => o.style.opacity = "0.2",
      onEnter(o, r) {
        jo(o, `${t.namespace.value}-opacity-transition`), o.style.opacity = "1", r();
      },
      onAfterEnter(o) {
        no(o, `${t.namespace.value}-opacity-transition`), o.style.opacity = "";
      },
      onBeforeLeave(o) {
        o.dataset || (o.dataset = {}), Eo(o, t.m("collapse")) ? (no(o, t.m("collapse")), o.dataset.oldOverflow = o.style.overflow, o.dataset.scrollWidth = o.clientWidth.toString(), jo(o, t.m("collapse"))) : (jo(o, t.m("collapse")), o.dataset.oldOverflow = o.style.overflow, o.dataset.scrollWidth = o.clientWidth.toString(), no(o, t.m("collapse"))), o.style.width = `${o.scrollWidth}px`, o.style.overflow = "hidden";
      },
      onLeave(o) {
        jo(o, "horizontal-collapse-transition"), o.style.width = `${o.dataset.scrollWidth}px`;
      }
    };
    return (o, r) => (k(), ae(Rn, vt({ mode: "out-in" }, i(n)), {
      default: H(() => [
        J(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var gW = /* @__PURE__ */ $e(mW, [["__file", "menu-collapse-transition.vue"]]);
function Mk(e10, t) {
  const n = S(() => {
    let r = e10.parent;
    const a = [t.value];
    for (; r.type.name !== "ElMenu"; )
      r.props.index && a.unshift(r.props.index), r = r.parent;
    return a;
  });
  return {
    parentMenu: S(() => {
      let r = e10.parent;
      for (; r && !["ElMenu", "ElSubMenu"].includes(r.type.name); )
        r = r.parent;
      return r;
    }),
    indexPath: n
  };
}
function yW(e10) {
  return S(() => {
    const n = e10.backgroundColor;
    return n ? new Is(n).shade(20).toString() : "";
  });
}
const Pk = (e10, t) => {
  const n = we("menu");
  return S(() => n.cssVarBlock({
    "text-color": e10.textColor || "",
    "hover-text-color": e10.textColor || "",
    "bg-color": e10.backgroundColor || "",
    "hover-bg-color": yW(e10).value || "",
    "active-color": e10.activeTextColor || "",
    level: `${t}`
  }));
}, Hg = "rootMenu", cf = "subMenu:", bW = Oe({
  index: {
    type: String,
    required: true
  },
  showTimeout: Number,
  hideTimeout: Number,
  popperClass: String,
  disabled: Boolean,
  teleported: {
    type: Boolean,
    default: void 0
  },
  popperOffset: Number,
  expandCloseIcon: {
    type: Ht
  },
  expandOpenIcon: {
    type: Ht
  },
  collapseCloseIcon: {
    type: Ht
  },
  collapseOpenIcon: {
    type: Ht
  }
}), iv = "ElSubMenu";
var zg = /* @__PURE__ */ j({
  name: iv,
  props: bW,
  setup(e10, { slots: t, expose: n }) {
    const o = it(), { indexPath: r, parentMenu: a } = Mk(o, S(() => e10.index)), l = we("menu"), s = we("sub-menu"), u = Le(Hg);
    u || Qt(iv, "can not inject root menu");
    const c = Le(`${cf}${a.value.uid}`);
    c || Qt(iv, "can not inject sub menu");
    const d = L({}), f = L({});
    let p;
    const v = L(false), m = L(), h = L(), b = S(() => O.value === "horizontal" && w.value ? "bottom-start" : "right-start"), g = S(() => O.value === "horizontal" && w.value || O.value === "vertical" && !u.props.collapse ? e10.expandCloseIcon && e10.expandOpenIcon ? E.value ? e10.expandOpenIcon : e10.expandCloseIcon : ea : e10.collapseCloseIcon && e10.collapseOpenIcon ? E.value ? e10.collapseOpenIcon : e10.collapseCloseIcon : oo), w = S(() => c.level === 0), y = S(() => {
      const G = e10.teleported;
      return St(G) ? w.value : G;
    }), _ = S(() => u.props.collapse ? `${l.namespace.value}-zoom-in-left` : `${l.namespace.value}-zoom-in-top`), C = S(() => O.value === "horizontal" && w.value ? [
      "bottom-start",
      "bottom-end",
      "top-start",
      "top-end",
      "right-start",
      "left-start"
    ] : [
      "right-start",
      "right",
      "right-end",
      "left-start",
      "bottom-start",
      "bottom-end",
      "top-start",
      "top-end"
    ]), E = S(() => u.openedMenus.includes(e10.index)), T = S(() => [...Object.values(d.value), ...Object.values(f.value)].some(({ active: G }) => G)), O = S(() => u.props.mode), N = S(() => u.props.persistent), $ = It({
      index: e10.index,
      indexPath: r,
      active: T
    }), R = Pk(u.props, c.level + 1), P = S(() => {
      var G;
      return (G = e10.popperOffset) != null ? G : u.props.popperOffset;
    }), z = S(() => {
      var G;
      return (G = e10.popperClass) != null ? G : u.props.popperClass;
    }), Y = S(() => {
      var G;
      return (G = e10.showTimeout) != null ? G : u.props.showTimeout;
    }), D = S(() => {
      var G;
      return (G = e10.hideTimeout) != null ? G : u.props.hideTimeout;
    }), M = () => {
      var G, le, X;
      return (X = (le = (G = h.value) == null ? void 0 : G.popperRef) == null ? void 0 : le.popperInstanceRef) == null ? void 0 : X.destroy();
    }, F = (G) => {
      G || M();
    }, A = () => {
      u.props.menuTrigger === "hover" && u.props.mode === "horizontal" || u.props.collapse && u.props.mode === "vertical" || e10.disabled || u.handleSubMenuClick({
        index: e10.index,
        indexPath: r.value,
        active: T.value
      });
    }, V = (G, le = Y.value) => {
      var X;
      if (G.type !== "focus") {
        if (u.props.menuTrigger === "click" && u.props.mode === "horizontal" || !u.props.collapse && u.props.mode === "vertical" || e10.disabled) {
          c.mouseInChild.value = true;
          return;
        }
        c.mouseInChild.value = true, p == null || p(), { stop: p } = Xl(() => {
          u.openMenu(e10.index, r.value);
        }, le), y.value && ((X = a.value.vnode.el) == null || X.dispatchEvent(new MouseEvent("mouseenter")));
      }
    }, Z = (G = false) => {
      var le;
      if (u.props.menuTrigger === "click" && u.props.mode === "horizontal" || !u.props.collapse && u.props.mode === "vertical") {
        c.mouseInChild.value = false;
        return;
      }
      p == null || p(), c.mouseInChild.value = false, { stop: p } = Xl(() => !v.value && u.closeMenu(e10.index, r.value), D.value), y.value && G && ((le = c.handleMouseleave) == null || le.call(c, true));
    };
    ge(() => u.props.collapse, (G) => F(!!G));
    {
      const G = (X) => {
        f.value[X.index] = X;
      }, le = (X) => {
        delete f.value[X.index];
      };
      yt(`${cf}${o.uid}`, {
        addSubMenu: G,
        removeSubMenu: le,
        handleMouseleave: Z,
        mouseInChild: v,
        level: c.level + 1
      });
    }
    return n({
      opened: E
    }), dt(() => {
      u.addSubMenu($), c.addSubMenu($);
    }), jt(() => {
      c.removeSubMenu($), u.removeSubMenu($);
    }), () => {
      var G;
      const le = [
        (G = t.title) == null ? void 0 : G.call(t),
        Ke(Be, {
          class: s.e("icon-arrow"),
          style: {
            transform: E.value ? e10.expandCloseIcon && e10.expandOpenIcon || e10.collapseCloseIcon && e10.collapseOpenIcon && u.props.collapse ? "none" : "rotateZ(180deg)" : "none"
          }
        }, {
          default: () => Ve(g.value) ? Ke(o.appContext.components[g.value]) : Ke(g.value)
        })
      ], X = u.isMenuPopup ? Ke(Un, {
        ref: h,
        visible: E.value,
        effect: "light",
        pure: true,
        offset: P.value,
        showArrow: false,
        persistent: N.value,
        popperClass: z.value,
        placement: b.value,
        teleported: y.value,
        fallbackPlacements: C.value,
        transition: _.value,
        gpuAcceleration: false
      }, {
        content: () => {
          var te;
          return Ke("div", {
            class: [
              l.m(O.value),
              l.m("popup-container"),
              z.value
            ],
            onMouseenter: (ce) => V(ce, 100),
            onMouseleave: () => Z(true),
            onFocus: (ce) => V(ce, 100)
          }, [
            Ke("ul", {
              class: [
                l.b(),
                l.m("popup"),
                l.m(`popup-${b.value}`)
              ],
              style: R.value
            }, [(te = t.default) == null ? void 0 : te.call(t)])
          ]);
        },
        default: () => Ke("div", {
          class: s.e("title"),
          onClick: A
        }, le)
      }) : Ke(Ie, {}, [
        Ke("div", {
          class: s.e("title"),
          ref: m,
          onClick: A
        }, le),
        Ke(lp, {}, {
          default: () => {
            var te;
            return lt(Ke("ul", {
              role: "menu",
              class: [l.b(), l.m("inline")],
              style: R.value
            }, [(te = t.default) == null ? void 0 : te.call(t)]), [[Nt, E.value]]);
          }
        })
      ]);
      return Ke("li", {
        class: [
          s.b(),
          s.is("active", T.value),
          s.is("opened", E.value),
          s.is("disabled", e10.disabled)
        ],
        role: "menuitem",
        ariaHaspopup: true,
        ariaExpanded: E.value,
        onMouseenter: V,
        onMouseleave: () => Z(),
        onFocus: V
      }, [X]);
    };
  }
});
const _W = Oe({
  mode: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "vertical"
  },
  defaultActive: {
    type: String,
    default: ""
  },
  defaultOpeneds: {
    type: ne(Array),
    default: () => rn([])
  },
  uniqueOpened: Boolean,
  router: Boolean,
  menuTrigger: {
    type: String,
    values: ["hover", "click"],
    default: "hover"
  },
  collapse: Boolean,
  backgroundColor: String,
  textColor: String,
  activeTextColor: String,
  closeOnClickOutside: Boolean,
  collapseTransition: {
    type: Boolean,
    default: true
  },
  ellipsis: {
    type: Boolean,
    default: true
  },
  popperOffset: {
    type: Number,
    default: 6
  },
  ellipsisIcon: {
    type: Ht,
    default: () => f8
  },
  popperEffect: {
    type: ne(String),
    default: "dark"
  },
  popperClass: String,
  showTimeout: {
    type: Number,
    default: 300
  },
  hideTimeout: {
    type: Number,
    default: 300
  },
  persistent: {
    type: Boolean,
    default: true
  }
}), uv = (e10) => Se(e10) && e10.every((t) => Ve(t)), wW = {
  close: (e10, t) => Ve(e10) && uv(t),
  open: (e10, t) => Ve(e10) && uv(t),
  select: (e10, t, n, o) => Ve(e10) && uv(t) && at(n) && (St(o) || o instanceof Promise)
};
var CW = /* @__PURE__ */ j({
  name: "ElMenu",
  props: _W,
  emits: wW,
  setup(e10, { emit: t, slots: n, expose: o }) {
    const r = it(), a = r.appContext.config.globalProperties.$router, l = L(), s = we("menu"), u = we("sub-menu"), c = L(-1), d = L(e10.defaultOpeneds && !e10.collapse ? e10.defaultOpeneds.slice(0) : []), f = L(e10.defaultActive), p = L({}), v = L({}), m = S(() => e10.mode === "horizontal" || e10.mode === "vertical" && e10.collapse), h = () => {
      const D = f.value && p.value[f.value];
      if (!D || e10.mode === "horizontal" || e10.collapse)
        return;
      D.indexPath.forEach((F) => {
        const A = v.value[F];
        A && b(F, A.indexPath);
      });
    }, b = (D, M) => {
      d.value.includes(D) || (e10.uniqueOpened && (d.value = d.value.filter((F) => M.includes(F))), d.value.push(D), t("open", D, M));
    }, g = (D) => {
      const M = d.value.indexOf(D);
      M !== -1 && d.value.splice(M, 1);
    }, w = (D, M) => {
      g(D), t("close", D, M);
    }, y = ({
      index: D,
      indexPath: M
    }) => {
      d.value.includes(D) ? w(D, M) : b(D, M);
    }, _ = (D) => {
      (e10.mode === "horizontal" || e10.collapse) && (d.value = []);
      const { index: M, indexPath: F } = D;
      if (!(Nn(M) || Nn(F)))
        if (e10.router && a) {
          const A = D.route || M, V = a.push(A).then((Z) => (Z || (f.value = M), Z));
          t("select", M, F, { index: M, indexPath: F, route: A }, V);
        } else
          f.value = M, t("select", M, F, { index: M, indexPath: F });
    }, C = (D) => {
      var M;
      const F = p.value, A = F[D] || f.value && F[f.value] || F[e10.defaultActive];
      f.value = (M = A == null ? void 0 : A.index) != null ? M : D;
    }, E = (D) => {
      const M = getComputedStyle(D), F = Number.parseInt(M.marginLeft, 10), A = Number.parseInt(M.marginRight, 10);
      return D.offsetWidth + F + A || 0;
    }, T = () => {
      var D, M;
      if (!l.value)
        return -1;
      const F = Array.from((M = (D = l.value) == null ? void 0 : D.childNodes) != null ? M : []).filter((ce) => ce.nodeName !== "#text" || ce.nodeValue), A = 64, V = getComputedStyle(l.value), Z = Number.parseInt(V.paddingLeft, 10), G = Number.parseInt(V.paddingRight, 10), le = l.value.clientWidth - Z - G;
      let X = 0, te = 0;
      return F.forEach((ce, pe) => {
        ce.nodeName !== "#comment" && (X += E(ce), X <= le - A && (te = pe + 1));
      }), te === F.length ? -1 : te;
    }, O = (D) => v.value[D].indexPath, N = (D, M = 33.34) => {
      let F;
      return () => {
        F && clearTimeout(F), F = setTimeout(() => {
          D();
        }, M);
      };
    };
    let $ = true;
    const R = () => {
      if (c.value === T())
        return;
      const D = () => {
        c.value = -1, He(() => {
          c.value = T();
        });
      };
      $ ? D() : N(D)(), $ = false;
    };
    ge(() => e10.defaultActive, (D) => {
      p.value[D] || (f.value = ""), C(D);
    }), ge(() => e10.collapse, (D) => {
      D && (d.value = []);
    }), ge(p.value, h);
    let P;
    Vn(() => {
      e10.mode === "horizontal" && e10.ellipsis ? P = en(l, R).stop : P == null || P();
    });
    const z = L(false);
    {
      const D = (V) => {
        v.value[V.index] = V;
      }, M = (V) => {
        delete v.value[V.index];
      };
      yt(Hg, It({
        props: e10,
        openedMenus: d,
        items: p,
        subMenus: v,
        activeIndex: f,
        isMenuPopup: m,
        addMenuItem: (V) => {
          p.value[V.index] = V;
        },
        removeMenuItem: (V) => {
          delete p.value[V.index];
        },
        addSubMenu: D,
        removeSubMenu: M,
        openMenu: b,
        closeMenu: w,
        handleMenuItemClick: _,
        handleSubMenuClick: y
      })), yt(`${cf}${r.uid}`, {
        addSubMenu: D,
        removeSubMenu: M,
        mouseInChild: z,
        level: 0
      });
    }
    dt(() => {
      e10.mode === "horizontal" && new vW(r.vnode.el, s.namespace.value);
    }), o({
      open: (M) => {
        const { indexPath: F } = v.value[M];
        F.forEach((A) => b(A, F));
      },
      close: g,
      updateActiveIndex: C,
      handleResize: R
    });
    const Y = Pk(e10, 0);
    return () => {
      var D, M;
      let F = (M = (D = n.default) == null ? void 0 : D.call(n)) != null ? M : [];
      const A = [];
      if (e10.mode === "horizontal" && l.value) {
        const G = Fr(F), le = c.value === -1 ? G : G.slice(0, c.value), X = c.value === -1 ? [] : G.slice(c.value);
        X != null && X.length && e10.ellipsis && (F = le, A.push(Ke(zg, {
          index: "sub-menu-more",
          class: u.e("hide-arrow"),
          popperOffset: e10.popperOffset
        }, {
          title: () => Ke(Be, {
            class: u.e("icon-more")
          }, {
            default: () => Ke(e10.ellipsisIcon)
          }),
          default: () => X
        })));
      }
      const V = e10.closeOnClickOutside ? [
        [
          Sa,
          () => {
            d.value.length && (z.value || (d.value.forEach((G) => t("close", G, O(G))), d.value = []));
          }
        ]
      ] : [], Z = lt(Ke("ul", {
        key: String(e10.collapse),
        role: "menubar",
        ref: l,
        style: Y.value,
        class: {
          [s.b()]: true,
          [s.m(e10.mode)]: true,
          [s.m("collapse")]: e10.collapse
        }
      }, [...F, ...A]), V);
      return e10.collapseTransition && e10.mode === "vertical" ? Ke(gW, () => Z) : Z;
    };
  }
});
const EW = Oe({
  index: {
    type: ne([String, null]),
    default: null
  },
  route: {
    type: ne([String, Object])
  },
  disabled: Boolean
}), SW = {
  click: (e10) => Ve(e10.index) && Se(e10.indexPath)
}, _d = "ElMenuItem", kW = /* @__PURE__ */ j({
  name: _d
}), NW = /* @__PURE__ */ j({
  ...kW,
  props: EW,
  emits: SW,
  setup(e10, { expose: t, emit: n }) {
    const o = e10;
    So(o.index) && _t(_d, 'Missing required prop: "index"');
    const r = it(), a = Le(Hg), l = we("menu"), s = we("menu-item");
    a || Qt(_d, "can not inject root menu");
    const { parentMenu: u, indexPath: c } = Mk(r, Lt(o, "index")), d = Le(`${cf}${u.value.uid}`);
    d || Qt(_d, "can not inject sub menu");
    const f = S(() => o.index === a.activeIndex), p = It({
      index: o.index,
      indexPath: c,
      active: f
    }), v = () => {
      o.disabled || (a.handleMenuItemClick({
        index: o.index,
        indexPath: c.value,
        route: o.route
      }), n("click", p));
    };
    return dt(() => {
      d.addSubMenu(p), a.addMenuItem(p);
    }), jt(() => {
      d.removeSubMenu(p), a.removeMenuItem(p);
    }), t({
      parentMenu: u,
      rootMenu: a,
      active: f,
      nsMenu: l,
      nsMenuItem: s,
      handleClick: v
    }), (m, h) => (k(), x("li", {
      class: I([
        i(s).b(),
        i(s).is("active", i(f)),
        i(s).is("disabled", m.disabled)
      ]),
      role: "menuitem",
      tabindex: "-1",
      onClick: v
    }, [
      i(u).type.name === "ElMenu" && i(a).props.collapse && m.$slots.title ? (k(), ae(i(Un), {
        key: 0,
        effect: i(a).props.popperEffect,
        placement: "right",
        "fallback-placements": ["left"],
        persistent: i(a).props.persistent
      }, {
        content: H(() => [
          J(m.$slots, "title")
        ]),
        default: H(() => [
          B("div", {
            class: I(i(l).be("tooltip", "trigger"))
          }, [
            J(m.$slots, "default")
          ], 2)
        ]),
        _: 3
      }, 8, ["effect", "persistent"])) : (k(), x(Ie, { key: 1 }, [
        J(m.$slots, "default"),
        J(m.$slots, "title")
      ], 64))
    ], 2));
  }
});
var Rk = /* @__PURE__ */ $e(NW, [["__file", "menu-item.vue"]]);
const TW = {
  title: String
}, OW = /* @__PURE__ */ j({
  name: "ElMenuItemGroup"
}), $W = /* @__PURE__ */ j({
  ...OW,
  props: TW,
  setup(e10) {
    const t = we("menu-item-group");
    return (n, o) => (k(), x("li", {
      class: I(i(t).b())
    }, [
      B("div", {
        class: I(i(t).e("title"))
      }, [
        n.$slots.title ? J(n.$slots, "title", { key: 1 }) : (k(), x(Ie, { key: 0 }, [
          Ze(_e(n.title), 1)
        ], 64))
      ], 2),
      B("ul", null, [
        J(n.$slots, "default")
      ])
    ], 2));
  }
});
var Ak = /* @__PURE__ */ $e($W, [["__file", "menu-item-group.vue"]]);
const IW = ut(CW, {
  MenuItem: Rk,
  MenuItemGroup: Ak,
  SubMenu: zg
}), MW = nn(Rk), PW = nn(Ak), RW = nn(zg), AW = Oe({
  icon: {
    type: Ht,
    default: () => xx
  },
  title: String,
  content: {
    type: String,
    default: ""
  }
}), LW = {
  back: () => true
}, xW = /* @__PURE__ */ j({
  name: "ElPageHeader"
}), DW = /* @__PURE__ */ j({
  ...xW,
  props: AW,
  emits: LW,
  setup(e10, { emit: t }) {
    const { t: n } = kt(), o = we("page-header");
    function r() {
      t("back");
    }
    return (a, l) => (k(), x("div", {
      class: I([
        i(o).b(),
        {
          [i(o).m("has-breadcrumb")]: !!a.$slots.breadcrumb,
          [i(o).m("has-extra")]: !!a.$slots.extra,
          [i(o).is("contentful")]: !!a.$slots.default
        }
      ])
    }, [
      a.$slots.breadcrumb ? (k(), x("div", {
        key: 0,
        class: I(i(o).e("breadcrumb"))
      }, [
        J(a.$slots, "breadcrumb")
      ], 2)) : ee("v-if", true),
      B("div", {
        class: I(i(o).e("header"))
      }, [
        B("div", {
          class: I(i(o).e("left"))
        }, [
          B("div", {
            class: I(i(o).e("back")),
            role: "button",
            tabindex: "0",
            onClick: r
          }, [
            a.icon || a.$slots.icon ? (k(), x("div", {
              key: 0,
              "aria-label": a.title || i(n)("el.pageHeader.title"),
              class: I(i(o).e("icon"))
            }, [
              J(a.$slots, "icon", {}, () => [
                a.icon ? (k(), ae(i(Be), { key: 0 }, {
                  default: H(() => [
                    (k(), ae(ht(a.icon)))
                  ]),
                  _: 1
                })) : ee("v-if", true)
              ])
            ], 10, ["aria-label"])) : ee("v-if", true),
            B("div", {
              class: I(i(o).e("title"))
            }, [
              J(a.$slots, "title", {}, () => [
                Ze(_e(a.title || i(n)("el.pageHeader.title")), 1)
              ])
            ], 2)
          ], 2),
          W(i(hk), { direction: "vertical" }),
          B("div", {
            class: I(i(o).e("content"))
          }, [
            J(a.$slots, "content", {}, () => [
              Ze(_e(a.content), 1)
            ])
          ], 2)
        ], 2),
        a.$slots.extra ? (k(), x("div", {
          key: 0,
          class: I(i(o).e("extra"))
        }, [
          J(a.$slots, "extra")
        ], 2)) : ee("v-if", true)
      ], 2),
      a.$slots.default ? (k(), x("div", {
        key: 1,
        class: I(i(o).e("main"))
      }, [
        J(a.$slots, "default")
      ], 2)) : ee("v-if", true)
    ], 2));
  }
});
var VW = /* @__PURE__ */ $e(DW, [["__file", "page-header.vue"]]);
const FW = ut(VW), Lk = Symbol("elPaginationKey"), BW = Oe({
  disabled: Boolean,
  currentPage: {
    type: Number,
    default: 1
  },
  prevText: {
    type: String
  },
  prevIcon: {
    type: Ht
  }
}), HW = {
  click: (e10) => e10 instanceof MouseEvent
}, zW = /* @__PURE__ */ j({
  name: "ElPaginationPrev"
}), KW = /* @__PURE__ */ j({
  ...zW,
  props: BW,
  emits: HW,
  setup(e10) {
    const t = e10, { t: n } = kt(), o = S(() => t.disabled || t.currentPage <= 1);
    return (r, a) => (k(), x("button", {
      type: "button",
      class: "btn-prev",
      disabled: i(o),
      "aria-label": r.prevText || i(n)("el.pagination.prev"),
      "aria-disabled": i(o),
      onClick: (l) => r.$emit("click", l)
    }, [
      r.prevText ? (k(), x("span", { key: 0 }, _e(r.prevText), 1)) : (k(), ae(i(Be), { key: 1 }, {
        default: H(() => [
          (k(), ae(ht(r.prevIcon)))
        ]),
        _: 1
      }))
    ], 8, ["disabled", "aria-label", "aria-disabled", "onClick"]));
  }
});
var WW = /* @__PURE__ */ $e(KW, [["__file", "prev.vue"]]);
const jW = Oe({
  disabled: Boolean,
  currentPage: {
    type: Number,
    default: 1
  },
  pageCount: {
    type: Number,
    default: 50
  },
  nextText: {
    type: String
  },
  nextIcon: {
    type: Ht
  }
}), UW = /* @__PURE__ */ j({
  name: "ElPaginationNext"
}), YW = /* @__PURE__ */ j({
  ...UW,
  props: jW,
  emits: ["click"],
  setup(e10) {
    const t = e10, { t: n } = kt(), o = S(() => t.disabled || t.currentPage === t.pageCount || t.pageCount === 0);
    return (r, a) => (k(), x("button", {
      type: "button",
      class: "btn-next",
      disabled: i(o),
      "aria-label": r.nextText || i(n)("el.pagination.next"),
      "aria-disabled": i(o),
      onClick: (l) => r.$emit("click", l)
    }, [
      r.nextText ? (k(), x("span", { key: 0 }, _e(r.nextText), 1)) : (k(), ae(i(Be), { key: 1 }, {
        default: H(() => [
          (k(), ae(ht(r.nextIcon)))
        ]),
        _: 1
      }))
    ], 8, ["disabled", "aria-label", "aria-disabled", "onClick"]));
  }
});
var qW = /* @__PURE__ */ $e(YW, [["__file", "next.vue"]]);
const xk = Symbol("ElSelectGroup"), $i = Symbol("ElSelect"), vh = "ElOption", GW = Oe({
  value: {
    type: [String, Number, Boolean, Object],
    required: true
  },
  label: {
    type: [String, Number]
  },
  created: Boolean,
  disabled: Boolean
});
function XW(e10, t) {
  const n = Le($i);
  n || Qt(vh, "usage: <el-select><el-option /></el-select/>");
  const o = Le(xk, { disabled: false }), r = S(() => d(Zn(n.props.modelValue), e10.value)), a = S(() => {
    var v;
    if (n.props.multiple) {
      const m = Zn((v = n.props.modelValue) != null ? v : []);
      return !r.value && m.length >= n.props.multipleLimit && n.props.multipleLimit > 0;
    } else
      return false;
  }), l = S(() => {
    var v;
    return (v = e10.label) != null ? v : at(e10.value) ? "" : e10.value;
  }), s = S(() => e10.value || e10.label || ""), u = S(() => e10.disabled || t.groupDisabled || a.value), c = it(), d = (v = [], m) => {
    if (at(e10.value)) {
      const h = n.props.valueKey;
      return v && v.some((b) => Rt(hn(b, h)) === hn(m, h));
    } else
      return v && v.includes(m);
  }, f = () => {
    !e10.disabled && !o.disabled && (n.states.hoveringIndex = n.optionsArray.indexOf(c.proxy));
  }, p = (v) => {
    const m = new RegExp(Eg(v), "i");
    t.visible = m.test(String(l.value)) || e10.created;
  };
  return ge(() => l.value, () => {
    !e10.created && !n.props.remote && n.setSelected();
  }), ge(() => e10.value, (v, m) => {
    const { remote: h, valueKey: b } = n.props;
    if ((h ? v !== m : !In(v, m)) && (n.onOptionDestroy(m, c.proxy), n.onOptionCreate(c.proxy)), !e10.created && !h) {
      if (b && at(v) && at(m) && v[b] === m[b])
        return;
      n.setSelected();
    }
  }), ge(() => o.disabled, () => {
    t.groupDisabled = o.disabled;
  }, { immediate: true }), {
    select: n,
    currentLabel: l,
    currentValue: s,
    itemSelected: r,
    isDisabled: u,
    hoverItem: f,
    updateOption: p
  };
}
const JW = /* @__PURE__ */ j({
  name: vh,
  componentName: vh,
  props: GW,
  setup(e10) {
    const t = we("select"), n = Fn(), o = S(() => [
      t.be("dropdown", "item"),
      t.is("disabled", i(s)),
      t.is("selected", i(l)),
      t.is("hovering", i(p))
    ]), r = It({
      index: -1,
      groupDisabled: false,
      visible: true,
      hover: false
    }), {
      currentLabel: a,
      itemSelected: l,
      isDisabled: s,
      select: u,
      hoverItem: c,
      updateOption: d
    } = XW(e10, r), { visible: f, hover: p } = Tn(r), v = it().proxy;
    u.onOptionCreate(v), jt(() => {
      const h = v.value, { selected: b } = u.states, g = b.some((w) => w.value === v.value);
      He(() => {
        u.states.cachedOptions.get(h) === v && !g && u.states.cachedOptions.delete(h);
      }), u.onOptionDestroy(h, v);
    });
    function m() {
      s.value || u.handleOptionSelect(v);
    }
    return {
      ns: t,
      id: n,
      containerKls: o,
      currentLabel: a,
      itemSelected: l,
      isDisabled: s,
      select: u,
      visible: f,
      hover: p,
      states: r,
      hoverItem: c,
      updateOption: d,
      selectOptionClick: m
    };
  }
});
function ZW(e10, t) {
  return lt((k(), x("li", {
    id: e10.id,
    class: I(e10.containerKls),
    role: "option",
    "aria-disabled": e10.isDisabled || void 0,
    "aria-selected": e10.itemSelected,
    onMousemove: e10.hoverItem,
    onClick: Xe(e10.selectOptionClick, ["stop"])
  }, [
    J(e10.$slots, "default", {}, () => [
      B("span", null, _e(e10.currentLabel), 1)
    ])
  ], 42, ["id", "aria-disabled", "aria-selected", "onMousemove", "onClick"])), [
    [Nt, e10.visible]
  ]);
}
var Kg = /* @__PURE__ */ $e(JW, [["render", ZW], ["__file", "option.vue"]]);
const QW = /* @__PURE__ */ j({
  name: "ElSelectDropdown",
  componentName: "ElSelectDropdown",
  setup() {
    const e10 = Le($i), t = we("select"), n = S(() => e10.props.popperClass), o = S(() => e10.props.multiple), r = S(() => e10.props.fitInputWidth), a = L("");
    function l() {
      var s;
      a.value = `${(s = e10.selectRef) == null ? void 0 : s.offsetWidth}px`;
    }
    return dt(() => {
      l(), en(e10.selectRef, l);
    }), {
      ns: t,
      minWidth: a,
      popperClass: n,
      isMultiple: o,
      isFitInputWidth: r
    };
  }
});
function ej(e10, t, n, o, r, a) {
  return k(), x("div", {
    class: I([e10.ns.b("dropdown"), e10.ns.is("multiple", e10.isMultiple), e10.popperClass]),
    style: ze({ [e10.isFitInputWidth ? "width" : "minWidth"]: e10.minWidth })
  }, [
    e10.$slots.header ? (k(), x("div", {
      key: 0,
      class: I(e10.ns.be("dropdown", "header"))
    }, [
      J(e10.$slots, "header")
    ], 2)) : ee("v-if", true),
    J(e10.$slots, "default"),
    e10.$slots.footer ? (k(), x("div", {
      key: 1,
      class: I(e10.ns.be("dropdown", "footer"))
    }, [
      J(e10.$slots, "footer")
    ], 2)) : ee("v-if", true)
  ], 6);
}
var tj = /* @__PURE__ */ $e(QW, [["render", ej], ["__file", "select-dropdown.vue"]]);
const nj = (e10, t) => {
  const { t: n } = kt(), o = Fn(), r = we("select"), a = we("input"), l = It({
    inputValue: "",
    options: /* @__PURE__ */ new Map(),
    cachedOptions: /* @__PURE__ */ new Map(),
    optionValues: [],
    selected: [],
    selectionWidth: 0,
    collapseItemWidth: 0,
    selectedLabel: "",
    hoveringIndex: -1,
    previousQuery: null,
    inputHovering: false,
    menuVisibleOnFocus: false,
    isBeforeHide: false
  }), s = L(), u = L(), c = L(), d = L(), f = L(), p = L(), v = L(), m = L(), h = L(), b = L(), g = L(), {
    isComposing: w,
    handleCompositionStart: y,
    handleCompositionUpdate: _,
    handleCompositionEnd: C
  } = uc({
    afterComposition: (Re) => et(Re)
  }), { wrapperRef: E, isFocused: T, handleBlur: O } = pl(f, {
    beforeFocus() {
      return M.value;
    },
    afterFocus() {
      e10.automaticDropdown && !N.value && (N.value = true, l.menuVisibleOnFocus = true);
    },
    beforeBlur(Re) {
      var ot, Dt;
      return ((ot = c.value) == null ? void 0 : ot.isFocusInsideContent(Re)) || ((Dt = d.value) == null ? void 0 : Dt.isFocusInsideContent(Re));
    },
    afterBlur() {
      var Re;
      N.value = false, l.menuVisibleOnFocus = false, e10.validateEvent && ((Re = P == null ? void 0 : P.validate) == null || Re.call(P, "blur").catch((ot) => _t(ot)));
    }
  }), N = L(false), $ = L(), { form: R, formItem: P } = Yn(), { inputId: z } = tr(e10, {
    formItemContext: P
  }), { valueOnClear: Y, isEmptyValue: D } = Xf(e10), M = S(() => e10.disabled || (R == null ? void 0 : R.disabled)), F = S(() => Se(e10.modelValue) ? e10.modelValue.length > 0 : !D(e10.modelValue)), A = S(() => {
    var Re;
    return (Re = R == null ? void 0 : R.statusIcon) != null ? Re : false;
  }), V = S(() => e10.clearable && !M.value && l.inputHovering && F.value), Z = S(() => e10.remote && e10.filterable && !e10.remoteShowSuffix ? "" : e10.suffixIcon), G = S(() => r.is("reverse", !!(Z.value && N.value))), le = S(() => (P == null ? void 0 : P.validateState) || ""), X = S(() => le.value && ep[le.value]), te = S(() => e10.remote ? 300 : 0), ce = S(() => e10.remote && !l.inputValue && l.options.size === 0), pe = S(() => e10.loading ? e10.loadingText || n("el.select.loading") : e10.filterable && l.inputValue && l.options.size > 0 && se.value === 0 ? e10.noMatchText || n("el.select.noMatch") : l.options.size === 0 ? e10.noDataText || n("el.select.noData") : null), se = S(() => ve.value.filter((Re) => Re.visible).length), ve = S(() => {
    const Re = Array.from(l.options.values()), ot = [];
    return l.optionValues.forEach((Dt) => {
      const wn = Re.findIndex((Gn) => Gn.value === Dt);
      wn > -1 && ot.push(Re[wn]);
    }), ot.length >= Re.length ? ot : Re;
  }), me = S(() => Array.from(l.cachedOptions.values())), De = S(() => {
    const Re = ve.value.filter((ot) => !ot.created).some((ot) => ot.currentLabel === l.inputValue);
    return e10.filterable && e10.allowCreate && l.inputValue !== "" && !Re;
  }), Te = () => {
    e10.filterable && Fe(e10.filterMethod) || e10.filterable && e10.remote && Fe(e10.remoteMethod) || ve.value.forEach((Re) => {
      var ot;
      (ot = Re.updateOption) == null || ot.call(Re, l.inputValue);
    });
  }, de = yn(), U = S(() => ["small"].includes(de.value) ? "small" : "default"), re = S({
    get() {
      return N.value && !ce.value;
    },
    set(Re) {
      N.value = Re;
    }
  }), he = S(() => {
    if (e10.multiple && !St(e10.modelValue))
      return Zn(e10.modelValue).length === 0 && !l.inputValue;
    const Re = Se(e10.modelValue) ? e10.modelValue[0] : e10.modelValue;
    return e10.filterable || St(Re) ? !l.inputValue : true;
  }), Ee = S(() => {
    var Re;
    const ot = (Re = e10.placeholder) != null ? Re : n("el.select.placeholder");
    return e10.multiple || !F.value ? ot : l.selectedLabel;
  }), ye = S(() => Qd ? null : "mouseenter");
  ge(() => e10.modelValue, (Re, ot) => {
    e10.multiple && e10.filterable && !e10.reserveKeyword && (l.inputValue = "", K("")), ue(), !In(Re, ot) && e10.validateEvent && (P == null || P.validate("change").catch((Dt) => _t(Dt)));
  }, {
    flush: "post",
    deep: true
  }), ge(() => N.value, (Re) => {
    Re ? K(l.inputValue) : (l.inputValue = "", l.previousQuery = null, l.isBeforeHide = true), t("visible-change", Re);
  }), ge(() => l.options.entries(), () => {
    Et && (ue(), e10.defaultFirstOption && (e10.filterable || e10.remote) && se.value && q());
  }, {
    flush: "post"
  }), ge([() => l.hoveringIndex, ve], ([Re]) => {
    Ye(Re) && Re > -1 ? $.value = ve.value[Re] || {} : $.value = {}, ve.value.forEach((ot) => {
      ot.hover = $.value === ot;
    });
  }), Vn(() => {
    l.isBeforeHide || Te();
  });
  const K = (Re) => {
    l.previousQuery === Re || w.value || (l.previousQuery = Re, e10.filterable && Fe(e10.filterMethod) ? e10.filterMethod(Re) : e10.filterable && e10.remote && Fe(e10.remoteMethod) && e10.remoteMethod(Re), e10.defaultFirstOption && (e10.filterable || e10.remote) && se.value ? He(q) : He(ke));
  }, q = () => {
    const Re = ve.value.filter((Gn) => Gn.visible && !Gn.disabled && !Gn.states.groupDisabled), ot = Re.find((Gn) => Gn.created), Dt = Re[0], wn = ve.value.map((Gn) => Gn.value);
    l.hoveringIndex = Q(wn, ot || Dt);
  }, ue = () => {
    if (e10.multiple)
      l.selectedLabel = "";
    else {
      const ot = Se(e10.modelValue) ? e10.modelValue[0] : e10.modelValue, Dt = be(ot);
      l.selectedLabel = Dt.currentLabel, l.selected = [Dt];
      return;
    }
    const Re = [];
    St(e10.modelValue) || Zn(e10.modelValue).forEach((ot) => {
      Re.push(be(ot));
    }), l.selected = Re;
  }, be = (Re) => {
    let ot;
    const Dt = iu(Re);
    for (let Da = l.cachedOptions.size - 1; Da >= 0; Da--) {
      const Ir = me.value[Da];
      if (Dt ? hn(Ir.value, e10.valueKey) === hn(Re, e10.valueKey) : Ir.value === Re) {
        ot = {
          value: Re,
          currentLabel: Ir.currentLabel,
          get isDisabled() {
            return Ir.isDisabled;
          }
        };
        break;
      }
    }
    if (ot)
      return ot;
    const wn = Dt ? Re.label : Re != null ? Re : "";
    return {
      value: Re,
      currentLabel: wn
    };
  }, ke = () => {
    l.hoveringIndex = ve.value.findIndex((Re) => l.selected.some((ot) => ao(ot) === ao(Re)));
  }, Ae = () => {
    l.selectionWidth = Number.parseFloat(window.getComputedStyle(u.value).width);
  }, fe = () => {
    l.collapseItemWidth = b.value.getBoundingClientRect().width;
  }, ie = () => {
    var Re, ot;
    (ot = (Re = c.value) == null ? void 0 : Re.updatePopper) == null || ot.call(Re);
  }, Ce = () => {
    var Re, ot;
    (ot = (Re = d.value) == null ? void 0 : Re.updatePopper) == null || ot.call(Re);
  }, qe = () => {
    l.inputValue.length > 0 && !N.value && (N.value = true), K(l.inputValue);
  }, et = (Re) => {
    if (l.inputValue = Re.target.value, e10.remote)
      ft();
    else
      return qe();
  }, ft = Oo(() => {
    qe();
  }, te.value), bt = (Re) => {
    In(e10.modelValue, Re) || t(gt, Re);
  }, zt = (Re) => sS(Re, (ot) => {
    const Dt = l.cachedOptions.get(ot);
    return Dt && !Dt.disabled && !Dt.states.groupDisabled;
  }), We = (Re) => {
    if (e10.multiple && Re.code !== xe.delete && Re.target.value.length <= 0) {
      const ot = Zn(e10.modelValue).slice(), Dt = zt(ot);
      if (Dt < 0)
        return;
      const wn = ot[Dt];
      ot.splice(Dt, 1), t(nt, ot), bt(ot), t("remove-tag", wn);
    }
  }, ct = (Re, ot) => {
    const Dt = l.selected.indexOf(ot);
    if (Dt > -1 && !M.value) {
      const wn = Zn(e10.modelValue).slice();
      wn.splice(Dt, 1), t(nt, wn), bt(wn), t("remove-tag", ot.value);
    }
    Re.stopPropagation(), on();
  }, oe = (Re) => {
    Re.stopPropagation();
    const ot = e10.multiple ? [] : Y.value;
    if (e10.multiple)
      for (const Dt of l.selected)
        Dt.isDisabled && ot.push(Dt.value);
    t(nt, ot), bt(ot), l.hoveringIndex = -1, N.value = false, t("clear"), on();
  }, Ne = (Re) => {
    var ot;
    if (e10.multiple) {
      const Dt = Zn((ot = e10.modelValue) != null ? ot : []).slice(), wn = Q(Dt, Re);
      wn > -1 ? Dt.splice(wn, 1) : (e10.multipleLimit <= 0 || Dt.length < e10.multipleLimit) && Dt.push(Re.value), t(nt, Dt), bt(Dt), Re.created && K(""), e10.filterable && !e10.reserveKeyword && (l.inputValue = "");
    } else
      t(nt, Re.value), bt(Re.value), N.value = false;
    on(), !N.value && He(() => {
      Me(Re);
    });
  }, Q = (Re, ot) => St(ot) ? -1 : at(ot.value) ? Re.findIndex((Dt) => In(hn(Dt, e10.valueKey), ao(ot))) : Re.indexOf(ot.value), Me = (Re) => {
    var ot, Dt, wn, Gn, Da;
    const Ir = Se(Re) ? Re[0] : Re;
    let Va = null;
    if (Ir != null && Ir.value) {
      const Fa = ve.value.filter((fs) => fs.value === Ir.value);
      Fa.length > 0 && (Va = Fa[0].$el);
    }
    if (c.value && Va) {
      const Fa = (Gn = (wn = (Dt = (ot = c.value) == null ? void 0 : ot.popperRef) == null ? void 0 : Dt.contentRef) == null ? void 0 : wn.querySelector) == null ? void 0 : Gn.call(wn, `.${r.be("dropdown", "wrap")}`);
      Fa && ng(Fa, Va);
    }
    (Da = g.value) == null || Da.handleScroll();
  }, Qe = (Re) => {
    l.options.set(Re.value, Re), l.cachedOptions.set(Re.value, Re);
  }, Ct = (Re, ot) => {
    l.options.get(Re) === ot && l.options.delete(Re);
  }, Kt = S(() => {
    var Re, ot;
    return (ot = (Re = c.value) == null ? void 0 : Re.popperRef) == null ? void 0 : ot.contentRef;
  }), pn = () => {
    l.isBeforeHide = false, He(() => {
      var Re;
      (Re = g.value) == null || Re.update(), Me(l.selected);
    });
  }, on = () => {
    var Re;
    (Re = f.value) == null || Re.focus();
  }, aa = () => {
    var Re;
    if (N.value) {
      N.value = false, He(() => {
        var ot;
        return (ot = f.value) == null ? void 0 : ot.blur();
      });
      return;
    }
    (Re = f.value) == null || Re.blur();
  }, Sn = (Re) => {
    oe(Re);
  }, Bo = (Re) => {
    if (N.value = false, T.value) {
      const ot = new FocusEvent("focus", Re);
      He(() => O(ot));
    }
  }, Ge = () => {
    l.inputValue.length > 0 ? l.inputValue = "" : N.value = false;
  }, $t = () => {
    M.value || (Qd && (l.inputHovering = true), l.menuVisibleOnFocus ? l.menuVisibleOnFocus = false : N.value = !N.value);
  }, mt = () => {
    if (!N.value)
      $t();
    else {
      const Re = ve.value[l.hoveringIndex];
      Re && !Re.isDisabled && Ne(Re);
    }
  }, ao = (Re) => at(Re.value) ? hn(Re.value, e10.valueKey) : Re.value, $r = S(() => ve.value.filter((Re) => Re.visible).every((Re) => Re.isDisabled)), xa = S(() => e10.multiple ? e10.collapseTags ? l.selected.slice(0, e10.maxCollapseTags) : l.selected : []), ds = S(() => e10.multiple ? e10.collapseTags ? l.selected.slice(e10.maxCollapseTags) : [] : []), Sc = (Re) => {
    if (!N.value) {
      N.value = true;
      return;
    }
    if (!(l.options.size === 0 || se.value === 0 || w.value) && !$r.value) {
      Re === "next" ? (l.hoveringIndex++, l.hoveringIndex === l.options.size && (l.hoveringIndex = 0)) : Re === "prev" && (l.hoveringIndex--, l.hoveringIndex < 0 && (l.hoveringIndex = l.options.size - 1));
      const ot = ve.value[l.hoveringIndex];
      (ot.isDisabled || !ot.visible) && Sc(Re), He(() => Me($.value));
    }
  }, $p = () => {
    if (!u.value)
      return 0;
    const Re = window.getComputedStyle(u.value);
    return Number.parseFloat(Re.gap || "6px");
  }, Ip = S(() => {
    const Re = $p();
    return { maxWidth: `${b.value && e10.maxCollapseTags === 1 ? l.selectionWidth - l.collapseItemWidth - Re : l.selectionWidth}px` };
  }), Mp = S(() => ({ maxWidth: `${l.selectionWidth}px` })), Pp = (Re) => {
    t("popup-scroll", Re);
  };
  return en(u, Ae), en(m, ie), en(E, ie), en(h, Ce), en(b, fe), dt(() => {
    ue();
  }), {
    inputId: z,
    contentId: o,
    nsSelect: r,
    nsInput: a,
    states: l,
    isFocused: T,
    expanded: N,
    optionsArray: ve,
    hoverOption: $,
    selectSize: de,
    filteredOptionsCount: se,
    updateTooltip: ie,
    updateTagTooltip: Ce,
    debouncedOnInputChange: ft,
    onInput: et,
    deletePrevTag: We,
    deleteTag: ct,
    deleteSelected: oe,
    handleOptionSelect: Ne,
    scrollToOption: Me,
    hasModelValue: F,
    shouldShowPlaceholder: he,
    currentPlaceholder: Ee,
    mouseEnterEventName: ye,
    needStatusIcon: A,
    showClose: V,
    iconComponent: Z,
    iconReverse: G,
    validateState: le,
    validateIcon: X,
    showNewOption: De,
    updateOptions: Te,
    collapseTagSize: U,
    setSelected: ue,
    selectDisabled: M,
    emptyText: pe,
    handleCompositionStart: y,
    handleCompositionUpdate: _,
    handleCompositionEnd: C,
    onOptionCreate: Qe,
    onOptionDestroy: Ct,
    handleMenuEnter: pn,
    focus: on,
    blur: aa,
    handleClearClick: Sn,
    handleClickOutside: Bo,
    handleEsc: Ge,
    toggleMenu: $t,
    selectOption: mt,
    getValueKey: ao,
    navigateOptions: Sc,
    dropdownMenuVisible: re,
    showTagList: xa,
    collapseTagList: ds,
    popupScroll: Pp,
    tagStyle: Ip,
    collapseTagStyle: Mp,
    popperRef: Kt,
    inputRef: f,
    tooltipRef: c,
    tagTooltipRef: d,
    prefixRef: p,
    suffixRef: v,
    selectRef: s,
    wrapperRef: E,
    selectionRef: u,
    scrollbarRef: g,
    menuRef: m,
    tagMenuRef: h,
    collapseItemRef: b
  };
};
var oj = /* @__PURE__ */ j({
  name: "ElOptions",
  setup(e10, { slots: t }) {
    const n = Le($i);
    let o = [];
    return () => {
      var r, a;
      const l = (r = t.default) == null ? void 0 : r.call(t), s = [];
      function u(c) {
        Se(c) && c.forEach((d) => {
          var f, p, v, m;
          const h = (f = (d == null ? void 0 : d.type) || {}) == null ? void 0 : f.name;
          h === "ElOptionGroup" ? u(!Ve(d.children) && !Se(d.children) && Fe((p = d.children) == null ? void 0 : p.default) ? (v = d.children) == null ? void 0 : v.default() : d.children) : h === "ElOption" ? s.push((m = d.props) == null ? void 0 : m.value) : Se(d.children) && u(d.children);
        });
      }
      return l.length && u((a = l[0]) == null ? void 0 : a.children), In(s, o) || (o = s, n && (n.states.optionValues = s)), l;
    };
  }
});
const rj = Oe({
  name: String,
  id: String,
  modelValue: {
    type: ne([
      Array,
      String,
      Number,
      Boolean,
      Object
    ]),
    default: void 0
  },
  autocomplete: {
    type: String,
    default: "off"
  },
  automaticDropdown: Boolean,
  size: _n,
  effect: {
    type: ne(String),
    default: "light"
  },
  disabled: Boolean,
  clearable: Boolean,
  filterable: Boolean,
  allowCreate: Boolean,
  loading: Boolean,
  popperClass: {
    type: String,
    default: ""
  },
  popperOptions: {
    type: ne(Object),
    default: () => ({})
  },
  remote: Boolean,
  loadingText: String,
  noMatchText: String,
  noDataText: String,
  remoteMethod: Function,
  filterMethod: Function,
  multiple: Boolean,
  multipleLimit: {
    type: Number,
    default: 0
  },
  placeholder: {
    type: String
  },
  defaultFirstOption: Boolean,
  reserveKeyword: {
    type: Boolean,
    default: true
  },
  valueKey: {
    type: String,
    default: "value"
  },
  collapseTags: Boolean,
  collapseTagsTooltip: Boolean,
  maxCollapseTags: {
    type: Number,
    default: 1
  },
  teleported: vn.teleported,
  persistent: {
    type: Boolean,
    default: true
  },
  clearIcon: {
    type: Ht,
    default: Ma
  },
  fitInputWidth: Boolean,
  suffixIcon: {
    type: Ht,
    default: ea
  },
  tagType: { ...Ea.type, default: "info" },
  tagEffect: { ...Ea.effect, default: "light" },
  validateEvent: {
    type: Boolean,
    default: true
  },
  remoteShowSuffix: Boolean,
  showArrow: {
    type: Boolean,
    default: true
  },
  offset: {
    type: Number,
    default: 12
  },
  placement: {
    type: ne(String),
    values: Pa,
    default: "bottom-start"
  },
  fallbackPlacements: {
    type: ne(Array),
    default: ["bottom-start", "top-start", "right", "left"]
  },
  tabindex: {
    type: [String, Number],
    default: 0
  },
  appendTo: vn.appendTo,
  ...ki,
  ...Bn(["ariaLabel"])
});
BS.scroll;
const B1 = "ElSelect", aj = /* @__PURE__ */ j({
  name: B1,
  componentName: B1,
  components: {
    ElSelectMenu: tj,
    ElOption: Kg,
    ElOptions: oj,
    ElTag: ai,
    ElScrollbar: ta,
    ElTooltip: Un,
    ElIcon: Be
  },
  directives: { ClickOutside: Sa },
  props: rj,
  emits: [
    nt,
    gt,
    "remove-tag",
    "clear",
    "visible-change",
    "focus",
    "blur",
    "popup-scroll"
  ],
  setup(e10, { emit: t, slots: n }) {
    const o = S(() => {
      const { modelValue: d, multiple: f } = e10, p = f ? [] : void 0;
      return Se(d) ? f ? d : p : f ? p : d;
    }), r = It({
      ...Tn(e10),
      modelValue: o
    }), a = nj(r, t), { calculatorRef: l, inputStyle: s } = Bg(), u = (d) => {
      Fr(d).filter((p) => at(p) && p.type.name === "ElOption").forEach((p) => {
        const v = { ...p.props };
        v.currentLabel = v.label || (at(v.value) ? "" : v.value), a.onOptionCreate(v);
      });
    };
    Vn(() => {
      e10.persistent || He(() => {
        var d, f;
        const p = Ke(Ie, (f = (d = n.default) == null ? void 0 : d.call(n)) != null ? f : []).children;
        u(p);
      });
    }), yt($i, It({
      props: r,
      states: a.states,
      selectRef: a.selectRef,
      optionsArray: a.optionsArray,
      setSelected: a.setSelected,
      handleOptionSelect: a.handleOptionSelect,
      onOptionCreate: a.onOptionCreate,
      onOptionDestroy: a.onOptionDestroy
    }));
    const c = S(() => e10.multiple ? a.states.selected.map((d) => d.currentLabel) : a.states.selectedLabel);
    return {
      ...a,
      modelValue: o,
      selectedLabel: c,
      calculatorRef: l,
      inputStyle: s
    };
  }
});
function lj(e10, t) {
  const n = je("el-tag"), o = je("el-tooltip"), r = je("el-icon"), a = je("el-option"), l = je("el-options"), s = je("el-scrollbar"), u = je("el-select-menu"), c = Vf("click-outside");
  return lt((k(), x("div", {
    ref: "selectRef",
    class: I([e10.nsSelect.b(), e10.nsSelect.m(e10.selectSize)]),
    [fa(e10.mouseEnterEventName)]: (d) => e10.states.inputHovering = true,
    onMouseleave: (d) => e10.states.inputHovering = false
  }, [
    W(o, {
      ref: "tooltipRef",
      visible: e10.dropdownMenuVisible,
      placement: e10.placement,
      teleported: e10.teleported,
      "popper-class": [e10.nsSelect.e("popper"), e10.popperClass],
      "popper-options": e10.popperOptions,
      "fallback-placements": e10.fallbackPlacements,
      effect: e10.effect,
      pure: "",
      trigger: "click",
      transition: `${e10.nsSelect.namespace.value}-zoom-in-top`,
      "stop-popper-mouse-event": false,
      "gpu-acceleration": false,
      persistent: e10.persistent,
      "append-to": e10.appendTo,
      "show-arrow": e10.showArrow,
      offset: e10.offset,
      onBeforeShow: e10.handleMenuEnter,
      onHide: (d) => e10.states.isBeforeHide = false
    }, {
      default: H(() => {
        var d;
        return [
          B("div", {
            ref: "wrapperRef",
            class: I([
              e10.nsSelect.e("wrapper"),
              e10.nsSelect.is("focused", e10.isFocused),
              e10.nsSelect.is("hovering", e10.states.inputHovering),
              e10.nsSelect.is("filterable", e10.filterable),
              e10.nsSelect.is("disabled", e10.selectDisabled)
            ]),
            onClick: Xe(e10.toggleMenu, ["prevent"])
          }, [
            e10.$slots.prefix ? (k(), x("div", {
              key: 0,
              ref: "prefixRef",
              class: I(e10.nsSelect.e("prefix"))
            }, [
              J(e10.$slots, "prefix")
            ], 2)) : ee("v-if", true),
            B("div", {
              ref: "selectionRef",
              class: I([
                e10.nsSelect.e("selection"),
                e10.nsSelect.is("near", e10.multiple && !e10.$slots.prefix && !!e10.states.selected.length)
              ])
            }, [
              e10.multiple ? J(e10.$slots, "tag", { key: 0 }, () => [
                (k(true), x(Ie, null, st(e10.showTagList, (f) => (k(), x("div", {
                  key: e10.getValueKey(f),
                  class: I(e10.nsSelect.e("selected-item"))
                }, [
                  W(n, {
                    closable: !e10.selectDisabled && !f.isDisabled,
                    size: e10.collapseTagSize,
                    type: e10.tagType,
                    effect: e10.tagEffect,
                    "disable-transitions": "",
                    style: ze(e10.tagStyle),
                    onClose: (p) => e10.deleteTag(p, f)
                  }, {
                    default: H(() => [
                      B("span", {
                        class: I(e10.nsSelect.e("tags-text"))
                      }, [
                        J(e10.$slots, "label", {
                          label: f.currentLabel,
                          value: f.value
                        }, () => [
                          Ze(_e(f.currentLabel), 1)
                        ])
                      ], 2)
                    ]),
                    _: 2
                  }, 1032, ["closable", "size", "type", "effect", "style", "onClose"])
                ], 2))), 128)),
                e10.collapseTags && e10.states.selected.length > e10.maxCollapseTags ? (k(), ae(o, {
                  key: 0,
                  ref: "tagTooltipRef",
                  disabled: e10.dropdownMenuVisible || !e10.collapseTagsTooltip,
                  "fallback-placements": ["bottom", "top", "right", "left"],
                  effect: e10.effect,
                  placement: "bottom",
                  teleported: e10.teleported
                }, {
                  default: H(() => [
                    B("div", {
                      ref: "collapseItemRef",
                      class: I(e10.nsSelect.e("selected-item"))
                    }, [
                      W(n, {
                        closable: false,
                        size: e10.collapseTagSize,
                        type: e10.tagType,
                        effect: e10.tagEffect,
                        "disable-transitions": "",
                        style: ze(e10.collapseTagStyle)
                      }, {
                        default: H(() => [
                          B("span", {
                            class: I(e10.nsSelect.e("tags-text"))
                          }, " + " + _e(e10.states.selected.length - e10.maxCollapseTags), 3)
                        ]),
                        _: 1
                      }, 8, ["size", "type", "effect", "style"])
                    ], 2)
                  ]),
                  content: H(() => [
                    B("div", {
                      ref: "tagMenuRef",
                      class: I(e10.nsSelect.e("selection"))
                    }, [
                      (k(true), x(Ie, null, st(e10.collapseTagList, (f) => (k(), x("div", {
                        key: e10.getValueKey(f),
                        class: I(e10.nsSelect.e("selected-item"))
                      }, [
                        W(n, {
                          class: "in-tooltip",
                          closable: !e10.selectDisabled && !f.isDisabled,
                          size: e10.collapseTagSize,
                          type: e10.tagType,
                          effect: e10.tagEffect,
                          "disable-transitions": "",
                          onClose: (p) => e10.deleteTag(p, f)
                        }, {
                          default: H(() => [
                            B("span", {
                              class: I(e10.nsSelect.e("tags-text"))
                            }, [
                              J(e10.$slots, "label", {
                                label: f.currentLabel,
                                value: f.value
                              }, () => [
                                Ze(_e(f.currentLabel), 1)
                              ])
                            ], 2)
                          ]),
                          _: 2
                        }, 1032, ["closable", "size", "type", "effect", "onClose"])
                      ], 2))), 128))
                    ], 2)
                  ]),
                  _: 3
                }, 8, ["disabled", "effect", "teleported"])) : ee("v-if", true)
              ]) : ee("v-if", true),
              B("div", {
                class: I([
                  e10.nsSelect.e("selected-item"),
                  e10.nsSelect.e("input-wrapper"),
                  e10.nsSelect.is("hidden", !e10.filterable)
                ])
              }, [
                lt(B("input", {
                  id: e10.inputId,
                  ref: "inputRef",
                  "onUpdate:modelValue": (f) => e10.states.inputValue = f,
                  type: "text",
                  name: e10.name,
                  class: I([e10.nsSelect.e("input"), e10.nsSelect.is(e10.selectSize)]),
                  disabled: e10.selectDisabled,
                  autocomplete: e10.autocomplete,
                  style: ze(e10.inputStyle),
                  tabindex: e10.tabindex,
                  role: "combobox",
                  readonly: !e10.filterable,
                  spellcheck: "false",
                  "aria-activedescendant": ((d = e10.hoverOption) == null ? void 0 : d.id) || "",
                  "aria-controls": e10.contentId,
                  "aria-expanded": e10.dropdownMenuVisible,
                  "aria-label": e10.ariaLabel,
                  "aria-autocomplete": "none",
                  "aria-haspopup": "listbox",
                  onKeydown: [
                    Bt(Xe((f) => e10.navigateOptions("next"), ["stop", "prevent"]), ["down"]),
                    Bt(Xe((f) => e10.navigateOptions("prev"), ["stop", "prevent"]), ["up"]),
                    Bt(Xe(e10.handleEsc, ["stop", "prevent"]), ["esc"]),
                    Bt(Xe(e10.selectOption, ["stop", "prevent"]), ["enter"]),
                    Bt(Xe(e10.deletePrevTag, ["stop"]), ["delete"])
                  ],
                  onCompositionstart: e10.handleCompositionStart,
                  onCompositionupdate: e10.handleCompositionUpdate,
                  onCompositionend: e10.handleCompositionEnd,
                  onInput: e10.onInput,
                  onClick: Xe(e10.toggleMenu, ["stop"])
                }, null, 46, ["id", "onUpdate:modelValue", "name", "disabled", "autocomplete", "tabindex", "readonly", "aria-activedescendant", "aria-controls", "aria-expanded", "aria-label", "onKeydown", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onInput", "onClick"]), [
                  [Qu, e10.states.inputValue]
                ]),
                e10.filterable ? (k(), x("span", {
                  key: 0,
                  ref: "calculatorRef",
                  "aria-hidden": "true",
                  class: I(e10.nsSelect.e("input-calculator")),
                  textContent: _e(e10.states.inputValue)
                }, null, 10, ["textContent"])) : ee("v-if", true)
              ], 2),
              e10.shouldShowPlaceholder ? (k(), x("div", {
                key: 1,
                class: I([
                  e10.nsSelect.e("selected-item"),
                  e10.nsSelect.e("placeholder"),
                  e10.nsSelect.is("transparent", !e10.hasModelValue || e10.expanded && !e10.states.inputValue)
                ])
              }, [
                e10.hasModelValue ? J(e10.$slots, "label", {
                  key: 0,
                  label: e10.currentPlaceholder,
                  value: e10.modelValue
                }, () => [
                  B("span", null, _e(e10.currentPlaceholder), 1)
                ]) : (k(), x("span", { key: 1 }, _e(e10.currentPlaceholder), 1))
              ], 2)) : ee("v-if", true)
            ], 2),
            B("div", {
              ref: "suffixRef",
              class: I(e10.nsSelect.e("suffix"))
            }, [
              e10.iconComponent && !e10.showClose ? (k(), ae(r, {
                key: 0,
                class: I([e10.nsSelect.e("caret"), e10.nsSelect.e("icon"), e10.iconReverse])
              }, {
                default: H(() => [
                  (k(), ae(ht(e10.iconComponent)))
                ]),
                _: 1
              }, 8, ["class"])) : ee("v-if", true),
              e10.showClose && e10.clearIcon ? (k(), ae(r, {
                key: 1,
                class: I([
                  e10.nsSelect.e("caret"),
                  e10.nsSelect.e("icon"),
                  e10.nsSelect.e("clear")
                ]),
                onClick: e10.handleClearClick
              }, {
                default: H(() => [
                  (k(), ae(ht(e10.clearIcon)))
                ]),
                _: 1
              }, 8, ["class", "onClick"])) : ee("v-if", true),
              e10.validateState && e10.validateIcon && e10.needStatusIcon ? (k(), ae(r, {
                key: 2,
                class: I([
                  e10.nsInput.e("icon"),
                  e10.nsInput.e("validateIcon"),
                  e10.nsInput.is("loading", e10.validateState === "validating")
                ])
              }, {
                default: H(() => [
                  (k(), ae(ht(e10.validateIcon)))
                ]),
                _: 1
              }, 8, ["class"])) : ee("v-if", true)
            ], 2)
          ], 10, ["onClick"])
        ];
      }),
      content: H(() => [
        W(u, { ref: "menuRef" }, {
          default: H(() => [
            e10.$slots.header ? (k(), x("div", {
              key: 0,
              class: I(e10.nsSelect.be("dropdown", "header")),
              onClick: Xe(() => {
              }, ["stop"])
            }, [
              J(e10.$slots, "header")
            ], 10, ["onClick"])) : ee("v-if", true),
            lt(W(s, {
              id: e10.contentId,
              ref: "scrollbarRef",
              tag: "ul",
              "wrap-class": e10.nsSelect.be("dropdown", "wrap"),
              "view-class": e10.nsSelect.be("dropdown", "list"),
              class: I([e10.nsSelect.is("empty", e10.filteredOptionsCount === 0)]),
              role: "listbox",
              "aria-label": e10.ariaLabel,
              "aria-orientation": "vertical",
              onScroll: e10.popupScroll
            }, {
              default: H(() => [
                e10.showNewOption ? (k(), ae(a, {
                  key: 0,
                  value: e10.states.inputValue,
                  created: true
                }, null, 8, ["value"])) : ee("v-if", true),
                W(l, null, {
                  default: H(() => [
                    J(e10.$slots, "default")
                  ]),
                  _: 3
                })
              ]),
              _: 3
            }, 8, ["id", "wrap-class", "view-class", "class", "aria-label", "onScroll"]), [
              [Nt, e10.states.options.size > 0 && !e10.loading]
            ]),
            e10.$slots.loading && e10.loading ? (k(), x("div", {
              key: 1,
              class: I(e10.nsSelect.be("dropdown", "loading"))
            }, [
              J(e10.$slots, "loading")
            ], 2)) : e10.loading || e10.filteredOptionsCount === 0 ? (k(), x("div", {
              key: 2,
              class: I(e10.nsSelect.be("dropdown", "empty"))
            }, [
              J(e10.$slots, "empty", {}, () => [
                B("span", null, _e(e10.emptyText), 1)
              ])
            ], 2)) : ee("v-if", true),
            e10.$slots.footer ? (k(), x("div", {
              key: 3,
              class: I(e10.nsSelect.be("dropdown", "footer")),
              onClick: Xe(() => {
              }, ["stop"])
            }, [
              J(e10.$slots, "footer")
            ], 10, ["onClick"])) : ee("v-if", true)
          ]),
          _: 3
        }, 512)
      ]),
      _: 3
    }, 8, ["visible", "placement", "teleported", "popper-class", "popper-options", "fallback-placements", "effect", "transition", "persistent", "append-to", "show-arrow", "offset", "onBeforeShow", "onHide"])
  ], 16, ["onMouseleave"])), [
    [c, e10.handleClickOutside, e10.popperRef]
  ]);
}
var sj = /* @__PURE__ */ $e(aj, [["render", lj], ["__file", "select.vue"]]);
const ij = /* @__PURE__ */ j({
  name: "ElOptionGroup",
  componentName: "ElOptionGroup",
  props: {
    label: String,
    disabled: Boolean
  },
  setup(e10) {
    const t = we("select"), n = L(), o = it(), r = L([]);
    yt(xk, It({
      ...Tn(e10)
    }));
    const a = S(() => r.value.some((c) => c.visible === true)), l = (c) => {
      var d;
      return c.type.name === "ElOption" && !!((d = c.component) != null && d.proxy);
    }, s = (c) => {
      const d = Zn(c), f = [];
      return d.forEach((p) => {
        var v;
        Ut(p) && (l(p) ? f.push(p.component.proxy) : Se(p.children) && p.children.length ? f.push(...s(p.children)) : (v = p.component) != null && v.subTree && f.push(...s(p.component.subTree)));
      }), f;
    }, u = () => {
      r.value = s(o.subTree);
    };
    return dt(() => {
      u();
    }), pS(n, u, {
      attributes: true,
      subtree: true,
      childList: true
    }), {
      groupRef: n,
      visible: a,
      ns: t
    };
  }
});
function uj(e10, t, n, o, r, a) {
  return lt((k(), x("ul", {
    ref: "groupRef",
    class: I(e10.ns.be("group", "wrap"))
  }, [
    B("li", {
      class: I(e10.ns.be("group", "title"))
    }, _e(e10.label), 3),
    B("li", null, [
      B("ul", {
        class: I(e10.ns.b("group"))
      }, [
        J(e10.$slots, "default")
      ], 2)
    ])
  ], 2)), [
    [Nt, e10.visible]
  ]);
}
var Dk = /* @__PURE__ */ $e(ij, [["render", uj], ["__file", "option-group.vue"]]);
const Zl = ut(sj, {
  Option: Kg,
  OptionGroup: Dk
}), df = nn(Kg), cj = nn(Dk), Wg = () => Le(Lk, {}), dj = Oe({
  pageSize: {
    type: Number,
    required: true
  },
  pageSizes: {
    type: ne(Array),
    default: () => rn([10, 20, 30, 40, 50, 100])
  },
  popperClass: {
    type: String
  },
  disabled: Boolean,
  teleported: Boolean,
  size: {
    type: String,
    values: Qr
  },
  appendSizeTo: String
}), fj = /* @__PURE__ */ j({
  name: "ElPaginationSizes"
}), pj = /* @__PURE__ */ j({
  ...fj,
  props: dj,
  emits: ["page-size-change"],
  setup(e10, { emit: t }) {
    const n = e10, { t: o } = kt(), r = we("pagination"), a = Wg(), l = L(n.pageSize);
    ge(() => n.pageSizes, (c, d) => {
      if (!In(c, d) && Se(c)) {
        const f = c.includes(n.pageSize) ? n.pageSize : n.pageSizes[0];
        t("page-size-change", f);
      }
    }), ge(() => n.pageSize, (c) => {
      l.value = c;
    });
    const s = S(() => n.pageSizes);
    function u(c) {
      var d;
      c !== l.value && (l.value = c, (d = a.handleSizeChange) == null || d.call(a, Number(c)));
    }
    return (c, d) => (k(), x("span", {
      class: I(i(r).e("sizes"))
    }, [
      W(i(Zl), {
        "model-value": l.value,
        disabled: c.disabled,
        "popper-class": c.popperClass,
        size: c.size,
        teleported: c.teleported,
        "validate-event": false,
        "append-to": c.appendSizeTo,
        onChange: u
      }, {
        default: H(() => [
          (k(true), x(Ie, null, st(i(s), (f) => (k(), ae(i(df), {
            key: f,
            value: f,
            label: f + i(o)("el.pagination.pagesize")
          }, null, 8, ["value", "label"]))), 128))
        ]),
        _: 1
      }, 8, ["model-value", "disabled", "popper-class", "size", "teleported", "append-to"])
    ], 2));
  }
});
var vj = /* @__PURE__ */ $e(pj, [["__file", "sizes.vue"]]);
const hj = Oe({
  size: {
    type: String,
    values: Qr
  }
}), mj = /* @__PURE__ */ j({
  name: "ElPaginationJumper"
}), gj = /* @__PURE__ */ j({
  ...mj,
  props: hj,
  setup(e10) {
    const { t } = kt(), n = we("pagination"), { pageCount: o, disabled: r, currentPage: a, changeEvent: l } = Wg(), s = L(), u = S(() => {
      var f;
      return (f = s.value) != null ? f : a == null ? void 0 : a.value;
    });
    function c(f) {
      s.value = f ? +f : "";
    }
    function d(f) {
      f = Math.trunc(+f), l == null || l(f), s.value = void 0;
    }
    return (f, p) => (k(), x("span", {
      class: I(i(n).e("jump")),
      disabled: i(r)
    }, [
      B("span", {
        class: I([i(n).e("goto")])
      }, _e(i(t)("el.pagination.goto")), 3),
      W(i(eo), {
        size: f.size,
        class: I([i(n).e("editor"), i(n).is("in-pagination")]),
        min: 1,
        max: i(o),
        disabled: i(r),
        "model-value": i(u),
        "validate-event": false,
        "aria-label": i(t)("el.pagination.page"),
        type: "number",
        "onUpdate:modelValue": c,
        onChange: d
      }, null, 8, ["size", "class", "max", "disabled", "model-value", "aria-label"]),
      B("span", {
        class: I([i(n).e("classifier")])
      }, _e(i(t)("el.pagination.pageClassifier")), 3)
    ], 10, ["disabled"]));
  }
});
var yj = /* @__PURE__ */ $e(gj, [["__file", "jumper.vue"]]);
const bj = Oe({
  total: {
    type: Number,
    default: 1e3
  }
}), _j = /* @__PURE__ */ j({
  name: "ElPaginationTotal"
}), wj = /* @__PURE__ */ j({
  ..._j,
  props: bj,
  setup(e10) {
    const { t } = kt(), n = we("pagination"), { disabled: o } = Wg();
    return (r, a) => (k(), x("span", {
      class: I(i(n).e("total")),
      disabled: i(o)
    }, _e(i(t)("el.pagination.total", {
      total: r.total
    })), 11, ["disabled"]));
  }
});
var Cj = /* @__PURE__ */ $e(wj, [["__file", "total.vue"]]);
const Ej = Oe({
  currentPage: {
    type: Number,
    default: 1
  },
  pageCount: {
    type: Number,
    required: true
  },
  pagerCount: {
    type: Number,
    default: 7
  },
  disabled: Boolean
}), Sj = /* @__PURE__ */ j({
  name: "ElPaginationPager"
}), kj = /* @__PURE__ */ j({
  ...Sj,
  props: Ej,
  emits: [gt],
  setup(e10, { emit: t }) {
    const n = e10, o = we("pager"), r = we("icon"), { t: a } = kt(), l = L(false), s = L(false), u = L(false), c = L(false), d = L(false), f = L(false), p = S(() => {
      const _ = n.pagerCount, C = (_ - 1) / 2, E = Number(n.currentPage), T = Number(n.pageCount);
      let O = false, N = false;
      T > _ && (E > _ - C && (O = true), E < T - C && (N = true));
      const $ = [];
      if (O && !N) {
        const R = T - (_ - 2);
        for (let P = R; P < T; P++)
          $.push(P);
      } else if (!O && N)
        for (let R = 2; R < _; R++)
          $.push(R);
      else if (O && N) {
        const R = Math.floor(_ / 2) - 1;
        for (let P = E - R; P <= E + R; P++)
          $.push(P);
      } else
        for (let R = 2; R < T; R++)
          $.push(R);
      return $;
    }), v = S(() => [
      "more",
      "btn-quickprev",
      r.b(),
      o.is("disabled", n.disabled)
    ]), m = S(() => [
      "more",
      "btn-quicknext",
      r.b(),
      o.is("disabled", n.disabled)
    ]), h = S(() => n.disabled ? -1 : 0);
    Vn(() => {
      const _ = (n.pagerCount - 1) / 2;
      l.value = false, s.value = false, n.pageCount > n.pagerCount && (n.currentPage > n.pagerCount - _ && (l.value = true), n.currentPage < n.pageCount - _ && (s.value = true));
    });
    function b(_ = false) {
      n.disabled || (_ ? u.value = true : c.value = true);
    }
    function g(_ = false) {
      _ ? d.value = true : f.value = true;
    }
    function w(_) {
      const C = _.target;
      if (C.tagName.toLowerCase() === "li" && Array.from(C.classList).includes("number")) {
        const E = Number(C.textContent);
        E !== n.currentPage && t(gt, E);
      } else C.tagName.toLowerCase() === "li" && Array.from(C.classList).includes("more") && y(_);
    }
    function y(_) {
      const C = _.target;
      if (C.tagName.toLowerCase() === "ul" || n.disabled)
        return;
      let E = Number(C.textContent);
      const T = n.pageCount, O = n.currentPage, N = n.pagerCount - 2;
      C.className.includes("more") && (C.className.includes("quickprev") ? E = O - N : C.className.includes("quicknext") && (E = O + N)), Number.isNaN(+E) || (E < 1 && (E = 1), E > T && (E = T)), E !== O && t(gt, E);
    }
    return (_, C) => (k(), x("ul", {
      class: I(i(o).b()),
      onClick: y,
      onKeyup: Bt(w, ["enter"])
    }, [
      _.pageCount > 0 ? (k(), x("li", {
        key: 0,
        class: I([[
          i(o).is("active", _.currentPage === 1),
          i(o).is("disabled", _.disabled)
        ], "number"]),
        "aria-current": _.currentPage === 1,
        "aria-label": i(a)("el.pagination.currentPage", { pager: 1 }),
        tabindex: i(h)
      }, " 1 ", 10, ["aria-current", "aria-label", "tabindex"])) : ee("v-if", true),
      l.value ? (k(), x("li", {
        key: 1,
        class: I(i(v)),
        tabindex: i(h),
        "aria-label": i(a)("el.pagination.prevPages", { pager: _.pagerCount - 2 }),
        onMouseenter: (E) => b(true),
        onMouseleave: (E) => u.value = false,
        onFocus: (E) => g(true),
        onBlur: (E) => d.value = false
      }, [
        (u.value || d.value) && !_.disabled ? (k(), ae(i(il), { key: 0 })) : (k(), ae(i(A0), { key: 1 }))
      ], 42, ["tabindex", "aria-label", "onMouseenter", "onMouseleave", "onFocus", "onBlur"])) : ee("v-if", true),
      (k(true), x(Ie, null, st(i(p), (E) => (k(), x("li", {
        key: E,
        class: I([[
          i(o).is("active", _.currentPage === E),
          i(o).is("disabled", _.disabled)
        ], "number"]),
        "aria-current": _.currentPage === E,
        "aria-label": i(a)("el.pagination.currentPage", { pager: E }),
        tabindex: i(h)
      }, _e(E), 11, ["aria-current", "aria-label", "tabindex"]))), 128)),
      s.value ? (k(), x("li", {
        key: 2,
        class: I(i(m)),
        tabindex: i(h),
        "aria-label": i(a)("el.pagination.nextPages", { pager: _.pagerCount - 2 }),
        onMouseenter: (E) => b(),
        onMouseleave: (E) => c.value = false,
        onFocus: (E) => g(),
        onBlur: (E) => f.value = false
      }, [
        (c.value || f.value) && !_.disabled ? (k(), ae(i(ul), { key: 0 })) : (k(), ae(i(A0), { key: 1 }))
      ], 42, ["tabindex", "aria-label", "onMouseenter", "onMouseleave", "onFocus", "onBlur"])) : ee("v-if", true),
      _.pageCount > 1 ? (k(), x("li", {
        key: 3,
        class: I([[
          i(o).is("active", _.currentPage === _.pageCount),
          i(o).is("disabled", _.disabled)
        ], "number"]),
        "aria-current": _.currentPage === _.pageCount,
        "aria-label": i(a)("el.pagination.currentPage", { pager: _.pageCount }),
        tabindex: i(h)
      }, _e(_.pageCount), 11, ["aria-current", "aria-label", "tabindex"])) : ee("v-if", true)
    ], 42, ["onKeyup"]));
  }
});
var Nj = /* @__PURE__ */ $e(kj, [["__file", "pager.vue"]]);
const lo = (e10) => typeof e10 != "number", Tj = Oe({
  pageSize: Number,
  defaultPageSize: Number,
  total: Number,
  pageCount: Number,
  pagerCount: {
    type: Number,
    validator: (e10) => Ye(e10) && Math.trunc(e10) === e10 && e10 > 4 && e10 < 22 && e10 % 2 === 1,
    default: 7
  },
  currentPage: Number,
  defaultCurrentPage: Number,
  layout: {
    type: String,
    default: ["prev", "pager", "next", "jumper", "->", "total"].join(", ")
  },
  pageSizes: {
    type: ne(Array),
    default: () => rn([10, 20, 30, 40, 50, 100])
  },
  popperClass: {
    type: String,
    default: ""
  },
  prevText: {
    type: String,
    default: ""
  },
  prevIcon: {
    type: Ht,
    default: () => wa
  },
  nextText: {
    type: String,
    default: ""
  },
  nextIcon: {
    type: Ht,
    default: () => oo
  },
  teleported: {
    type: Boolean,
    default: true
  },
  small: Boolean,
  size: _n,
  background: Boolean,
  disabled: Boolean,
  hideOnSinglePage: Boolean,
  appendSizeTo: String
}), Oj = {
  "update:current-page": (e10) => Ye(e10),
  "update:page-size": (e10) => Ye(e10),
  "size-change": (e10) => Ye(e10),
  change: (e10, t) => Ye(e10) && Ye(t),
  "current-change": (e10) => Ye(e10),
  "prev-click": (e10) => Ye(e10),
  "next-click": (e10) => Ye(e10)
}, H1 = "ElPagination";
var $j = /* @__PURE__ */ j({
  name: H1,
  props: Tj,
  emits: Oj,
  setup(e10, { emit: t, slots: n }) {
    const { t: o } = kt(), r = we("pagination"), a = it().vnode.props || {}, l = wS(), s = S(() => {
      var C;
      return e10.small ? "small" : (C = e10.size) != null ? C : l.value;
    });
    _a({
      from: "small",
      replacement: "size",
      version: "3.0.0",
      scope: "el-pagination",
      ref: "https://element-plus.org/zh-CN/component/pagination.html"
    }, S(() => !!e10.small));
    const u = "onUpdate:currentPage" in a || "onUpdate:current-page" in a || "onCurrentChange" in a, c = "onUpdate:pageSize" in a || "onUpdate:page-size" in a || "onSizeChange" in a, d = S(() => {
      if (lo(e10.total) && lo(e10.pageCount) || !lo(e10.currentPage) && !u)
        return false;
      if (e10.layout.includes("sizes")) {
        if (lo(e10.pageCount)) {
          if (!lo(e10.total) && !lo(e10.pageSize) && !c)
            return false;
        } else if (!c)
          return false;
      }
      return true;
    }), f = L(lo(e10.defaultPageSize) ? 10 : e10.defaultPageSize), p = L(lo(e10.defaultCurrentPage) ? 1 : e10.defaultCurrentPage), v = S({
      get() {
        return lo(e10.pageSize) ? f.value : e10.pageSize;
      },
      set(C) {
        lo(e10.pageSize) && (f.value = C), c && (t("update:page-size", C), t("size-change", C));
      }
    }), m = S(() => {
      let C = 0;
      return lo(e10.pageCount) ? lo(e10.total) || (C = Math.max(1, Math.ceil(e10.total / v.value))) : C = e10.pageCount, C;
    }), h = S({
      get() {
        return lo(e10.currentPage) ? p.value : e10.currentPage;
      },
      set(C) {
        let E = C;
        C < 1 ? E = 1 : C > m.value && (E = m.value), lo(e10.currentPage) && (p.value = E), u && (t("update:current-page", E), t("current-change", E));
      }
    });
    ge(m, (C) => {
      h.value > C && (h.value = C);
    }), ge([h, v], (C) => {
      t(gt, ...C);
    }, { flush: "post" });
    function b(C) {
      h.value = C;
    }
    function g(C) {
      v.value = C;
      const E = m.value;
      h.value > E && (h.value = E);
    }
    function w() {
      e10.disabled || (h.value -= 1, t("prev-click", h.value));
    }
    function y() {
      e10.disabled || (h.value += 1, t("next-click", h.value));
    }
    function _(C, E) {
      C && (C.props || (C.props = {}), C.props.class = [C.props.class, E].join(" "));
    }
    return yt(Lk, {
      pageCount: m,
      disabled: S(() => e10.disabled),
      currentPage: h,
      changeEvent: b,
      handleSizeChange: g
    }), () => {
      var C, E;
      if (!d.value)
        return _t(H1, o("el.pagination.deprecationWarning")), null;
      if (!e10.layout || e10.hideOnSinglePage && m.value <= 1)
        return null;
      const T = [], O = [], N = Ke("div", { class: r.e("rightwrapper") }, O), $ = {
        prev: Ke(WW, {
          disabled: e10.disabled,
          currentPage: h.value,
          prevText: e10.prevText,
          prevIcon: e10.prevIcon,
          onClick: w
        }),
        jumper: Ke(yj, {
          size: s.value
        }),
        pager: Ke(Nj, {
          currentPage: h.value,
          pageCount: m.value,
          pagerCount: e10.pagerCount,
          onChange: b,
          disabled: e10.disabled
        }),
        next: Ke(qW, {
          disabled: e10.disabled,
          currentPage: h.value,
          pageCount: m.value,
          nextText: e10.nextText,
          nextIcon: e10.nextIcon,
          onClick: y
        }),
        sizes: Ke(vj, {
          pageSize: v.value,
          pageSizes: e10.pageSizes,
          popperClass: e10.popperClass,
          disabled: e10.disabled,
          teleported: e10.teleported,
          size: s.value,
          appendSizeTo: e10.appendSizeTo
        }),
        slot: (E = (C = n == null ? void 0 : n.default) == null ? void 0 : C.call(n)) != null ? E : null,
        total: Ke(Cj, { total: lo(e10.total) ? 0 : e10.total })
      }, R = e10.layout.split(",").map((z) => z.trim());
      let P = false;
      return R.forEach((z) => {
        if (z === "->") {
          P = true;
          return;
        }
        P ? O.push($[z]) : T.push($[z]);
      }), _(T[0], r.is("first")), _(T[T.length - 1], r.is("last")), P && O.length > 0 && (_(O[0], r.is("first")), _(O[O.length - 1], r.is("last")), T.push(N)), Ke("div", {
        class: [
          r.b(),
          r.is("background", e10.background),
          r.m(s.value)
        ]
      }, T);
    };
  }
});
const Ij = ut($j), Mj = Oe({
  title: String,
  confirmButtonText: String,
  cancelButtonText: String,
  confirmButtonType: {
    type: String,
    values: Zv,
    default: "primary"
  },
  cancelButtonType: {
    type: String,
    values: Zv,
    default: "text"
  },
  icon: {
    type: Ht,
    default: () => g8
  },
  iconColor: {
    type: String,
    default: "#f90"
  },
  hideIcon: {
    type: Boolean,
    default: false
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  teleported: vn.teleported,
  persistent: vn.persistent,
  width: {
    type: [String, Number],
    default: 150
  }
}), Pj = {
  confirm: (e10) => e10 instanceof MouseEvent,
  cancel: (e10) => e10 instanceof MouseEvent
}, Rj = /* @__PURE__ */ j({
  name: "ElPopconfirm"
}), Aj = /* @__PURE__ */ j({
  ...Rj,
  props: Mj,
  emits: Pj,
  setup(e10, { emit: t }) {
    const n = e10, { t: o } = kt(), r = we("popconfirm"), a = L(), l = () => {
      var p, v;
      (v = (p = a.value) == null ? void 0 : p.onClose) == null || v.call(p);
    }, s = S(() => ({
      width: sn(n.width)
    })), u = (p) => {
      t("confirm", p), l();
    }, c = (p) => {
      t("cancel", p), l();
    }, d = S(() => n.confirmButtonText || o("el.popconfirm.confirmButtonText")), f = S(() => n.cancelButtonText || o("el.popconfirm.cancelButtonText"));
    return (p, v) => (k(), ae(i(Un), vt({
      ref_key: "tooltipRef",
      ref: a,
      trigger: "click",
      effect: "light"
    }, p.$attrs, {
      "popper-class": `${i(r).namespace.value}-popover`,
      "popper-style": i(s),
      teleported: p.teleported,
      "fallback-placements": ["bottom", "top", "right", "left"],
      "hide-after": p.hideAfter,
      persistent: p.persistent
    }), {
      content: H(() => [
        B("div", {
          class: I(i(r).b())
        }, [
          B("div", {
            class: I(i(r).e("main"))
          }, [
            !p.hideIcon && p.icon ? (k(), ae(i(Be), {
              key: 0,
              class: I(i(r).e("icon")),
              style: ze({ color: p.iconColor })
            }, {
              default: H(() => [
                (k(), ae(ht(p.icon)))
              ]),
              _: 1
            }, 8, ["class", "style"])) : ee("v-if", true),
            Ze(" " + _e(p.title), 1)
          ], 2),
          B("div", {
            class: I(i(r).e("action"))
          }, [
            J(p.$slots, "actions", {
              confirm: u,
              cancel: c
            }, () => [
              W(i(Mn), {
                size: "small",
                type: p.cancelButtonType === "text" ? "" : p.cancelButtonType,
                text: p.cancelButtonType === "text",
                onClick: c
              }, {
                default: H(() => [
                  Ze(_e(i(f)), 1)
                ]),
                _: 1
              }, 8, ["type", "text"]),
              W(i(Mn), {
                size: "small",
                type: p.confirmButtonType === "text" ? "" : p.confirmButtonType,
                text: p.confirmButtonType === "text",
                onClick: u
              }, {
                default: H(() => [
                  Ze(_e(i(d)), 1)
                ]),
                _: 1
              }, 8, ["type", "text"])
            ])
          ], 2)
        ], 2)
      ]),
      default: H(() => [
        p.$slots.reference ? J(p.$slots, "reference", { key: 0 }) : ee("v-if", true)
      ]),
      _: 3
    }, 16, ["popper-class", "popper-style", "teleported", "hide-after", "persistent"]));
  }
});
var Lj = /* @__PURE__ */ $e(Aj, [["__file", "popconfirm.vue"]]);
const xj = ut(Lj), Dj = Oe({
  trigger: Bs.trigger,
  triggerKeys: Bs.triggerKeys,
  placement: gd.placement,
  disabled: Bs.disabled,
  visible: vn.visible,
  transition: vn.transition,
  popperOptions: gd.popperOptions,
  tabindex: gd.tabindex,
  content: vn.content,
  popperStyle: vn.popperStyle,
  popperClass: vn.popperClass,
  enterable: {
    ...vn.enterable,
    default: true
  },
  effect: {
    ...vn.effect,
    default: "light"
  },
  teleported: vn.teleported,
  appendTo: vn.appendTo,
  title: String,
  width: {
    type: [String, Number],
    default: 150
  },
  offset: {
    type: Number,
    default: void 0
  },
  showAfter: {
    type: Number,
    default: 0
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  autoClose: {
    type: Number,
    default: 0
  },
  showArrow: {
    type: Boolean,
    default: true
  },
  persistent: {
    type: Boolean,
    default: true
  },
  "onUpdate:visible": {
    type: Function
  }
}), Vj = {
  "update:visible": (e10) => Vt(e10),
  "before-enter": () => true,
  "before-leave": () => true,
  "after-enter": () => true,
  "after-leave": () => true
}, Fj = "onUpdate:visible", Bj = /* @__PURE__ */ j({
  name: "ElPopover"
}), Hj = /* @__PURE__ */ j({
  ...Bj,
  props: Dj,
  emits: Vj,
  setup(e10, { expose: t, emit: n }) {
    const o = e10, r = S(() => o[Fj]), a = we("popover"), l = L(), s = S(() => {
      var b;
      return (b = i(l)) == null ? void 0 : b.popperRef;
    }), u = S(() => [
      {
        width: sn(o.width)
      },
      o.popperStyle
    ]), c = S(() => [a.b(), o.popperClass, { [a.m("plain")]: !!o.content }]), d = S(() => o.transition === `${a.namespace.value}-fade-in-linear`), f = () => {
      var b;
      (b = l.value) == null || b.hide();
    }, p = () => {
      n("before-enter");
    }, v = () => {
      n("before-leave");
    }, m = () => {
      n("after-enter");
    }, h = () => {
      n("update:visible", false), n("after-leave");
    };
    return t({
      popperRef: s,
      hide: f
    }), (b, g) => (k(), ae(i(Un), vt({
      ref_key: "tooltipRef",
      ref: l
    }, b.$attrs, {
      trigger: b.trigger,
      "trigger-keys": b.triggerKeys,
      placement: b.placement,
      disabled: b.disabled,
      visible: b.visible,
      transition: b.transition,
      "popper-options": b.popperOptions,
      tabindex: b.tabindex,
      content: b.content,
      offset: b.offset,
      "show-after": b.showAfter,
      "hide-after": b.hideAfter,
      "auto-close": b.autoClose,
      "show-arrow": b.showArrow,
      "aria-label": b.title,
      effect: b.effect,
      enterable: b.enterable,
      "popper-class": i(c),
      "popper-style": i(u),
      teleported: b.teleported,
      "append-to": b.appendTo,
      persistent: b.persistent,
      "gpu-acceleration": i(d),
      "onUpdate:visible": i(r),
      onBeforeShow: p,
      onBeforeHide: v,
      onShow: m,
      onHide: h
    }), {
      content: H(() => [
        b.title ? (k(), x("div", {
          key: 0,
          class: I(i(a).e("title")),
          role: "title"
        }, _e(b.title), 3)) : ee("v-if", true),
        J(b.$slots, "default", {}, () => [
          Ze(_e(b.content), 1)
        ])
      ]),
      default: H(() => [
        b.$slots.reference ? J(b.$slots, "reference", { key: 0 }) : ee("v-if", true)
      ]),
      _: 3
    }, 16, ["trigger", "trigger-keys", "placement", "disabled", "visible", "transition", "popper-options", "tabindex", "content", "offset", "show-after", "hide-after", "auto-close", "show-arrow", "aria-label", "effect", "enterable", "popper-class", "popper-style", "teleported", "append-to", "persistent", "gpu-acceleration", "onUpdate:visible"]));
  }
});
var zj = /* @__PURE__ */ $e(Hj, [["__file", "popover.vue"]]);
const z1 = (e10, t) => {
  const n = t.arg || t.value, o = n == null ? void 0 : n.popperRef;
  o && (o.triggerRef = e10);
};
var Kj = {
  mounted(e10, t) {
    z1(e10, t);
  },
  updated(e10, t) {
    z1(e10, t);
  }
};
const Wj = "popover", Vk = kx(Kj, Wj), jj = ut(zj, {
  directive: Vk
}), Uj = Oe({
  type: {
    type: String,
    default: "line",
    values: ["line", "circle", "dashboard"]
  },
  percentage: {
    type: Number,
    default: 0,
    validator: (e10) => e10 >= 0 && e10 <= 100
  },
  status: {
    type: String,
    default: "",
    values: ["", "success", "exception", "warning"]
  },
  indeterminate: Boolean,
  duration: {
    type: Number,
    default: 3
  },
  strokeWidth: {
    type: Number,
    default: 6
  },
  strokeLinecap: {
    type: ne(String),
    default: "round"
  },
  textInside: Boolean,
  width: {
    type: Number,
    default: 126
  },
  showText: {
    type: Boolean,
    default: true
  },
  color: {
    type: ne([
      String,
      Array,
      Function
    ]),
    default: ""
  },
  striped: Boolean,
  stripedFlow: Boolean,
  format: {
    type: ne(Function),
    default: (e10) => `${e10}%`
  }
}), Yj = /* @__PURE__ */ j({
  name: "ElProgress"
}), qj = /* @__PURE__ */ j({
  ...Yj,
  props: Uj,
  setup(e10) {
    const t = e10, n = {
      success: "#13ce66",
      exception: "#ff4949",
      warning: "#e6a23c",
      default: "#20a0ff"
    }, o = we("progress"), r = S(() => {
      const y = {
        width: `${t.percentage}%`,
        animationDuration: `${t.duration}s`
      }, _ = w(t.percentage);
      return _.includes("gradient") ? y.background = _ : y.backgroundColor = _, y;
    }), a = S(() => (t.strokeWidth / t.width * 100).toFixed(1)), l = S(() => ["circle", "dashboard"].includes(t.type) ? Number.parseInt(`${50 - Number.parseFloat(a.value) / 2}`, 10) : 0), s = S(() => {
      const y = l.value, _ = t.type === "dashboard";
      return `
          M 50 50
          m 0 ${_ ? "" : "-"}${y}
          a ${y} ${y} 0 1 1 0 ${_ ? "-" : ""}${y * 2}
          a ${y} ${y} 0 1 1 0 ${_ ? "" : "-"}${y * 2}
          `;
    }), u = S(() => 2 * Math.PI * l.value), c = S(() => t.type === "dashboard" ? 0.75 : 1), d = S(() => `${-1 * u.value * (1 - c.value) / 2}px`), f = S(() => ({
      strokeDasharray: `${u.value * c.value}px, ${u.value}px`,
      strokeDashoffset: d.value
    })), p = S(() => ({
      strokeDasharray: `${u.value * c.value * (t.percentage / 100)}px, ${u.value}px`,
      strokeDashoffset: d.value,
      transition: "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease, opacity ease 0.6s"
    })), v = S(() => {
      let y;
      return t.color ? y = w(t.percentage) : y = n[t.status] || n.default, y;
    }), m = S(() => t.status === "warning" ? Qf : t.type === "line" ? t.status === "success" ? og : Ma : t.status === "success" ? sc : Jo), h = S(() => t.type === "line" ? 12 + t.strokeWidth * 0.4 : t.width * 0.111111 + 2), b = S(() => t.format(t.percentage));
    function g(y) {
      const _ = 100 / y.length;
      return y.map((E, T) => Ve(E) ? {
        color: E,
        percentage: (T + 1) * _
      } : E).sort((E, T) => E.percentage - T.percentage);
    }
    const w = (y) => {
      var _;
      const { color: C } = t;
      if (Fe(C))
        return C(y);
      if (Ve(C))
        return C;
      {
        const E = g(C);
        for (const T of E)
          if (T.percentage > y)
            return T.color;
        return (_ = E[E.length - 1]) == null ? void 0 : _.color;
      }
    };
    return (y, _) => (k(), x("div", {
      class: I([
        i(o).b(),
        i(o).m(y.type),
        i(o).is(y.status),
        {
          [i(o).m("without-text")]: !y.showText,
          [i(o).m("text-inside")]: y.textInside
        }
      ]),
      role: "progressbar",
      "aria-valuenow": y.percentage,
      "aria-valuemin": "0",
      "aria-valuemax": "100"
    }, [
      y.type === "line" ? (k(), x("div", {
        key: 0,
        class: I(i(o).b("bar"))
      }, [
        B("div", {
          class: I(i(o).be("bar", "outer")),
          style: ze({ height: `${y.strokeWidth}px` })
        }, [
          B("div", {
            class: I([
              i(o).be("bar", "inner"),
              { [i(o).bem("bar", "inner", "indeterminate")]: y.indeterminate },
              { [i(o).bem("bar", "inner", "striped")]: y.striped },
              { [i(o).bem("bar", "inner", "striped-flow")]: y.stripedFlow }
            ]),
            style: ze(i(r))
          }, [
            (y.showText || y.$slots.default) && y.textInside ? (k(), x("div", {
              key: 0,
              class: I(i(o).be("bar", "innerText"))
            }, [
              J(y.$slots, "default", { percentage: y.percentage }, () => [
                B("span", null, _e(i(b)), 1)
              ])
            ], 2)) : ee("v-if", true)
          ], 6)
        ], 6)
      ], 2)) : (k(), x("div", {
        key: 1,
        class: I(i(o).b("circle")),
        style: ze({ height: `${y.width}px`, width: `${y.width}px` })
      }, [
        (k(), x("svg", { viewBox: "0 0 100 100" }, [
          B("path", {
            class: I(i(o).be("circle", "track")),
            d: i(s),
            stroke: `var(${i(o).cssVarName("fill-color-light")}, #e5e9f2)`,
            "stroke-linecap": y.strokeLinecap,
            "stroke-width": i(a),
            fill: "none",
            style: ze(i(f))
          }, null, 14, ["d", "stroke", "stroke-linecap", "stroke-width"]),
          B("path", {
            class: I(i(o).be("circle", "path")),
            d: i(s),
            stroke: i(v),
            fill: "none",
            opacity: y.percentage ? 1 : 0,
            "stroke-linecap": y.strokeLinecap,
            "stroke-width": i(a),
            style: ze(i(p))
          }, null, 14, ["d", "stroke", "opacity", "stroke-linecap", "stroke-width"])
        ]))
      ], 6)),
      (y.showText || y.$slots.default) && !y.textInside ? (k(), x("div", {
        key: 2,
        class: I(i(o).e("text")),
        style: ze({ fontSize: `${i(h)}px` })
      }, [
        J(y.$slots, "default", { percentage: y.percentage }, () => [
          y.status ? (k(), ae(i(Be), { key: 1 }, {
            default: H(() => [
              (k(), ae(ht(i(m))))
            ]),
            _: 1
          })) : (k(), x("span", { key: 0 }, _e(i(b)), 1))
        ])
      ], 6)) : ee("v-if", true)
    ], 10, ["aria-valuenow"]));
  }
});
var Gj = /* @__PURE__ */ $e(qj, [["__file", "progress.vue"]]);
const Fk = ut(Gj), Xj = Oe({
  modelValue: {
    type: Number,
    default: 0
  },
  id: {
    type: String,
    default: void 0
  },
  lowThreshold: {
    type: Number,
    default: 2
  },
  highThreshold: {
    type: Number,
    default: 4
  },
  max: {
    type: Number,
    default: 5
  },
  colors: {
    type: ne([Array, Object]),
    default: () => rn(["", "", ""])
  },
  voidColor: {
    type: String,
    default: ""
  },
  disabledVoidColor: {
    type: String,
    default: ""
  },
  icons: {
    type: ne([Array, Object]),
    default: () => [Rc, Rc, Rc]
  },
  voidIcon: {
    type: Ht,
    default: () => P8
  },
  disabledVoidIcon: {
    type: Ht,
    default: () => Rc
  },
  disabled: Boolean,
  allowHalf: Boolean,
  showText: Boolean,
  showScore: Boolean,
  textColor: {
    type: String,
    default: ""
  },
  texts: {
    type: ne(Array),
    default: () => rn([
      "Extremely bad",
      "Disappointed",
      "Fair",
      "Satisfied",
      "Surprise"
    ])
  },
  scoreTemplate: {
    type: String,
    default: "{value}"
  },
  size: _n,
  clearable: Boolean,
  ...Bn(["ariaLabel"])
}), Jj = {
  [gt]: (e10) => Ye(e10),
  [nt]: (e10) => Ye(e10)
}, Zj = /* @__PURE__ */ j({
  name: "ElRate"
}), Qj = /* @__PURE__ */ j({
  ...Zj,
  props: Xj,
  emits: Jj,
  setup(e10, { expose: t, emit: n }) {
    const o = e10;
    function r(M, F) {
      const A = (G) => at(G), V = Object.keys(F).map((G) => +G).filter((G) => {
        const le = F[G];
        return (A(le) ? le.excluded : false) ? M < G : M <= G;
      }).sort((G, le) => G - le), Z = F[V[0]];
      return A(Z) && Z.value || Z;
    }
    const a = Le(cs, void 0), l = Le(qr, void 0), s = yn(), u = we("rate"), { inputId: c, isLabeledByFormItem: d } = tr(o, {
      formItemContext: l
    }), f = L(o.modelValue), p = L(-1), v = L(true), m = S(() => [u.b(), u.m(s.value)]), h = S(() => o.disabled || (a == null ? void 0 : a.disabled)), b = S(() => u.cssVarBlock({
      "void-color": o.voidColor,
      "disabled-void-color": o.disabledVoidColor,
      "fill-color": _.value
    })), g = S(() => {
      let M = "";
      return o.showScore ? M = o.scoreTemplate.replace(/\{\s*value\s*\}/, h.value ? `${o.modelValue}` : `${f.value}`) : o.showText && (M = o.texts[Math.ceil(f.value) - 1]), M;
    }), w = S(() => o.modelValue * 100 - Math.floor(o.modelValue) * 100), y = S(() => Se(o.colors) ? {
      [o.lowThreshold]: o.colors[0],
      [o.highThreshold]: { value: o.colors[1], excluded: true },
      [o.max]: o.colors[2]
    } : o.colors), _ = S(() => {
      const M = r(f.value, y.value);
      return at(M) ? "" : M;
    }), C = S(() => {
      let M = "";
      return h.value ? M = `${w.value}%` : o.allowHalf && (M = "50%"), {
        color: _.value,
        width: M
      };
    }), E = S(() => {
      let M = Se(o.icons) ? [...o.icons] : { ...o.icons };
      return M = ya(M), Se(M) ? {
        [o.lowThreshold]: M[0],
        [o.highThreshold]: {
          value: M[1],
          excluded: true
        },
        [o.max]: M[2]
      } : M;
    }), T = S(() => r(o.modelValue, E.value)), O = S(() => h.value ? Ve(o.disabledVoidIcon) ? o.disabledVoidIcon : ya(o.disabledVoidIcon) : Ve(o.voidIcon) ? o.voidIcon : ya(o.voidIcon)), N = S(() => r(f.value, E.value));
    function $(M) {
      const F = h.value && w.value > 0 && M - 1 < o.modelValue && M > o.modelValue, A = o.allowHalf && v.value && M - 0.5 <= f.value && M > f.value;
      return F || A;
    }
    function R(M) {
      o.clearable && M === o.modelValue && (M = 0), n(nt, M), o.modelValue !== M && n(gt, M);
    }
    function P(M) {
      h.value || (o.allowHalf && v.value ? R(f.value) : R(M));
    }
    function z(M) {
      if (h.value)
        return;
      let F = f.value;
      const A = M.code;
      return A === xe.up || A === xe.right ? (o.allowHalf ? F += 0.5 : F += 1, M.stopPropagation(), M.preventDefault()) : (A === xe.left || A === xe.down) && (o.allowHalf ? F -= 0.5 : F -= 1, M.stopPropagation(), M.preventDefault()), F = F < 0 ? 0 : F, F = F > o.max ? o.max : F, n(nt, F), n(gt, F), F;
    }
    function Y(M, F) {
      if (!h.value) {
        if (o.allowHalf && F) {
          let A = F.target;
          Eo(A, u.e("item")) && (A = A.querySelector(`.${u.e("icon")}`)), (A.clientWidth === 0 || Eo(A, u.e("decimal"))) && (A = A.parentNode), v.value = F.offsetX * 2 <= A.clientWidth, f.value = v.value ? M - 0.5 : M;
        } else
          f.value = M;
        p.value = M;
      }
    }
    function D() {
      h.value || (o.allowHalf && (v.value = o.modelValue !== Math.floor(o.modelValue)), f.value = o.modelValue, p.value = -1);
    }
    return ge(() => o.modelValue, (M) => {
      f.value = M, v.value = o.modelValue !== Math.floor(o.modelValue);
    }), o.modelValue || n(nt, 0), t({
      setCurrentValue: Y,
      resetCurrentValue: D
    }), (M, F) => {
      var A;
      return k(), x("div", {
        id: i(c),
        class: I([i(m), i(u).is("disabled", i(h))]),
        role: "slider",
        "aria-label": i(d) ? void 0 : M.ariaLabel || "rating",
        "aria-labelledby": i(d) ? (A = i(l)) == null ? void 0 : A.labelId : void 0,
        "aria-valuenow": f.value,
        "aria-valuetext": i(g) || void 0,
        "aria-valuemin": "0",
        "aria-valuemax": M.max,
        tabindex: "0",
        style: ze(i(b)),
        onKeydown: z
      }, [
        (k(true), x(Ie, null, st(M.max, (V, Z) => (k(), x("span", {
          key: Z,
          class: I(i(u).e("item")),
          onMousemove: (G) => Y(V, G),
          onMouseleave: D,
          onClick: (G) => P(V)
        }, [
          W(i(Be), {
            class: I([
              i(u).e("icon"),
              { hover: p.value === V },
              i(u).is("active", V <= f.value)
            ])
          }, {
            default: H(() => [
              $(V) ? ee("v-if", true) : (k(), x(Ie, { key: 0 }, [
                lt((k(), ae(ht(i(N)), null, null, 512)), [
                  [Nt, V <= f.value]
                ]),
                lt((k(), ae(ht(i(O)), null, null, 512)), [
                  [Nt, !(V <= f.value)]
                ])
              ], 64)),
              $(V) ? (k(), x(Ie, { key: 1 }, [
                (k(), ae(ht(i(O)), {
                  class: I([i(u).em("decimal", "box")])
                }, null, 8, ["class"])),
                W(i(Be), {
                  style: ze(i(C)),
                  class: I([i(u).e("icon"), i(u).e("decimal")])
                }, {
                  default: H(() => [
                    (k(), ae(ht(i(T))))
                  ]),
                  _: 1
                }, 8, ["style", "class"])
              ], 64)) : ee("v-if", true)
            ]),
            _: 2
          }, 1032, ["class"])
        ], 42, ["onMousemove", "onClick"]))), 128)),
        M.showText || M.showScore ? (k(), x("span", {
          key: 0,
          class: I(i(u).e("text")),
          style: ze({ color: M.textColor })
        }, _e(i(g)), 7)) : ee("v-if", true)
      ], 46, ["id", "aria-label", "aria-labelledby", "aria-valuenow", "aria-valuetext", "aria-valuemax"]);
    };
  }
});
var eU = /* @__PURE__ */ $e(Qj, [["__file", "rate.vue"]]);
const tU = ut(eU), Nl = {
  primary: "icon-primary",
  success: "icon-success",
  warning: "icon-warning",
  error: "icon-error",
  info: "icon-info"
}, K1 = {
  [Nl.primary]: Cu,
  [Nl.success]: Wx,
  [Nl.warning]: Qf,
  [Nl.error]: rg,
  [Nl.info]: Cu
}, nU = Oe({
  title: {
    type: String,
    default: ""
  },
  subTitle: {
    type: String,
    default: ""
  },
  icon: {
    type: String,
    values: ["primary", "success", "warning", "info", "error"],
    default: "info"
  }
}), oU = /* @__PURE__ */ j({
  name: "ElResult"
}), rU = /* @__PURE__ */ j({
  ...oU,
  props: nU,
  setup(e10) {
    const t = e10, n = we("result"), o = S(() => {
      const r = t.icon, a = r && Nl[r] ? Nl[r] : "icon-info", l = K1[a] || K1["icon-info"];
      return {
        class: a,
        component: l
      };
    });
    return (r, a) => (k(), x("div", {
      class: I(i(n).b())
    }, [
      B("div", {
        class: I(i(n).e("icon"))
      }, [
        J(r.$slots, "icon", {}, () => [
          i(o).component ? (k(), ae(ht(i(o).component), {
            key: 0,
            class: I(i(o).class)
          }, null, 8, ["class"])) : ee("v-if", true)
        ])
      ], 2),
      r.title || r.$slots.title ? (k(), x("div", {
        key: 0,
        class: I(i(n).e("title"))
      }, [
        J(r.$slots, "title", {}, () => [
          B("p", null, _e(r.title), 1)
        ])
      ], 2)) : ee("v-if", true),
      r.subTitle || r.$slots["sub-title"] ? (k(), x("div", {
        key: 1,
        class: I(i(n).e("subtitle"))
      }, [
        J(r.$slots, "sub-title", {}, () => [
          B("p", null, _e(r.subTitle), 1)
        ])
      ], 2)) : ee("v-if", true),
      r.$slots.extra ? (k(), x("div", {
        key: 2,
        class: I(i(n).e("extra"))
      }, [
        J(r.$slots, "extra")
      ], 2)) : ee("v-if", true)
    ], 2));
  }
});
var aU = /* @__PURE__ */ $e(rU, [["__file", "result.vue"]]);
const lU = ut(aU), sU = [
  "start",
  "center",
  "end",
  "space-around",
  "space-between",
  "space-evenly"
], iU = ["top", "middle", "bottom"], uU = Oe({
  tag: {
    type: String,
    default: "div"
  },
  gutter: {
    type: Number,
    default: 0
  },
  justify: {
    type: String,
    values: sU,
    default: "start"
  },
  align: {
    type: String,
    values: iU
  }
}), cU = /* @__PURE__ */ j({
  name: "ElRow"
}), dU = /* @__PURE__ */ j({
  ...cU,
  props: uU,
  setup(e10) {
    const t = e10, n = we("row"), o = S(() => t.gutter);
    yt(K2, {
      gutter: o
    });
    const r = S(() => {
      const l = {};
      return t.gutter && (l.marginRight = l.marginLeft = `-${t.gutter / 2}px`), l;
    }), a = S(() => [
      n.b(),
      n.is(`justify-${t.justify}`, t.justify !== "start"),
      n.is(`align-${t.align}`, !!t.align)
    ]);
    return (l, s) => (k(), ae(ht(l.tag), {
      class: I(i(a)),
      style: ze(i(r))
    }, {
      default: H(() => [
        J(l.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "style"]));
  }
});
var fU = /* @__PURE__ */ $e(dU, [["__file", "row.vue"]]);
const pU = ut(fU), vU = /* @__PURE__ */ j({
  props: {
    item: {
      type: Object,
      required: true
    },
    style: {
      type: Object
    },
    height: Number
  },
  setup() {
    return {
      ns: we("select")
    };
  }
});
function hU(e10, t, n, o, r, a) {
  return k(), x("div", {
    class: I(e10.ns.be("group", "title")),
    style: ze({ ...e10.style, lineHeight: `${e10.height}px` })
  }, _e(e10.item.label), 7);
}
var mU = /* @__PURE__ */ $e(vU, [["render", hU], ["__file", "group-item.vue"]]);
function gU(e10, { emit: t }) {
  return {
    hoverItem: () => {
      e10.disabled || t("hover", e10.index);
    },
    selectOptionClick: () => {
      e10.disabled || t("select", e10.item, e10.index);
    }
  };
}
const Bk = {
  label: "label",
  value: "value",
  disabled: "disabled",
  options: "options"
};
function cp(e10) {
  const t = S(() => ({ ...Bk, ...e10.props }));
  return {
    aliasProps: t,
    getLabel: (l) => hn(l, t.value.label),
    getValue: (l) => hn(l, t.value.value),
    getDisabled: (l) => hn(l, t.value.disabled),
    getOptions: (l) => hn(l, t.value.options)
  };
}
const yU = Oe({
  allowCreate: Boolean,
  autocomplete: {
    type: ne(String),
    default: "none"
  },
  automaticDropdown: Boolean,
  clearable: Boolean,
  clearIcon: {
    type: Ht,
    default: Ma
  },
  effect: {
    type: ne(String),
    default: "light"
  },
  collapseTags: Boolean,
  collapseTagsTooltip: Boolean,
  maxCollapseTags: {
    type: Number,
    default: 1
  },
  defaultFirstOption: Boolean,
  disabled: Boolean,
  estimatedOptionHeight: {
    type: Number,
    default: void 0
  },
  filterable: Boolean,
  filterMethod: Function,
  height: {
    type: Number,
    default: 274
  },
  itemHeight: {
    type: Number,
    default: 34
  },
  id: String,
  loading: Boolean,
  loadingText: String,
  modelValue: {
    type: ne([Array, String, Number, Boolean, Object])
  },
  multiple: Boolean,
  multipleLimit: {
    type: Number,
    default: 0
  },
  name: String,
  noDataText: String,
  noMatchText: String,
  remoteMethod: Function,
  reserveKeyword: {
    type: Boolean,
    default: true
  },
  options: {
    type: ne(Array),
    required: true
  },
  placeholder: {
    type: String
  },
  teleported: vn.teleported,
  persistent: {
    type: Boolean,
    default: true
  },
  popperClass: {
    type: String,
    default: ""
  },
  popperOptions: {
    type: ne(Object),
    default: () => ({})
  },
  remote: Boolean,
  size: _n,
  props: {
    type: ne(Object),
    default: () => Bk
  },
  valueKey: {
    type: String,
    default: "value"
  },
  scrollbarAlwaysOn: Boolean,
  validateEvent: {
    type: Boolean,
    default: true
  },
  offset: {
    type: Number,
    default: 12
  },
  showArrow: {
    type: Boolean,
    default: true
  },
  placement: {
    type: ne(String),
    values: Pa,
    default: "bottom-start"
  },
  fallbackPlacements: {
    type: ne(Array),
    default: ["bottom-start", "top-start", "right", "left"]
  },
  tagType: { ...Ea.type, default: "info" },
  tagEffect: { ...Ea.effect, default: "light" },
  tabindex: {
    type: [String, Number],
    default: 0
  },
  appendTo: vn.appendTo,
  fitInputWidth: {
    type: [Boolean, Number],
    default: true,
    validator(e10) {
      return Vt(e10) || Ye(e10);
    }
  },
  suffixIcon: {
    type: Ht,
    default: ea
  },
  ...ki,
  ...Bn(["ariaLabel"])
}), bU = Oe({
  data: Array,
  disabled: Boolean,
  hovering: Boolean,
  item: {
    type: ne(Object),
    required: true
  },
  index: Number,
  style: Object,
  selected: Boolean,
  created: Boolean
}), _U = {
  [nt]: (e10) => true,
  [gt]: (e10) => true,
  "remove-tag": (e10) => true,
  "visible-change": (e10) => true,
  focus: (e10) => e10 instanceof FocusEvent,
  blur: (e10) => e10 instanceof FocusEvent,
  clear: () => true
}, wU = {
  hover: (e10) => Ye(e10),
  select: (e10, t) => true
}, jg = Symbol("ElSelectV2Injection"), CU = /* @__PURE__ */ j({
  props: bU,
  emits: wU,
  setup(e10, { emit: t }) {
    const n = Le(jg), o = we("select"), { hoverItem: r, selectOptionClick: a } = gU(e10, { emit: t }), { getLabel: l } = cp(n.props);
    return {
      ns: o,
      hoverItem: r,
      selectOptionClick: a,
      getLabel: l
    };
  }
});
function EU(e10, t, n, o, r, a) {
  return k(), x("li", {
    "aria-selected": e10.selected,
    style: ze(e10.style),
    class: I([
      e10.ns.be("dropdown", "item"),
      e10.ns.is("selected", e10.selected),
      e10.ns.is("disabled", e10.disabled),
      e10.ns.is("created", e10.created),
      e10.ns.is("hovering", e10.hovering)
    ]),
    onMousemove: e10.hoverItem,
    onClick: Xe(e10.selectOptionClick, ["stop"])
  }, [
    J(e10.$slots, "default", {
      item: e10.item,
      index: e10.index,
      disabled: e10.disabled
    }, () => [
      B("span", null, _e(e10.getLabel(e10.item)), 1)
    ])
  ], 46, ["aria-selected", "onMousemove", "onClick"]);
}
var SU = /* @__PURE__ */ $e(CU, [["render", EU], ["__file", "option-item.vue"]]), W1 = Number.isNaN || function(t) {
  return typeof t == "number" && t !== t;
};
function kU(e10, t) {
  return !!(e10 === t || W1(e10) && W1(t));
}
function NU(e10, t) {
  if (e10.length !== t.length)
    return false;
  for (var n = 0; n < e10.length; n++)
    if (!kU(e10[n], t[n]))
      return false;
  return true;
}
function TU(e10, t) {
  t === void 0 && (t = NU);
  var n = null;
  function o() {
    for (var r = [], a = 0; a < arguments.length; a++)
      r[a] = arguments[a];
    if (n && n.lastThis === this && t(r, n.lastArgs))
      return n.lastResult;
    var l = e10.apply(this, r);
    return n = {
      lastResult: l,
      lastArgs: r,
      lastThis: this
    }, l;
  }
  return o.clear = function() {
    n = null;
  }, o;
}
const Hk = () => {
  const t = it().proxy.$props;
  return S(() => {
    const n = (o, r, a) => ({});
    return t.perfMode ? Uf(n) : TU(n);
  });
}, hh = 50, ff = "itemRendered", pf = "scroll", Ms = "forward", vf = "backward", Uo = "auto", dp = "smart", Iu = "start", Br = "center", Mu = "end", ui = "horizontal", Ug = "vertical", OU = "ltr", Hs = "rtl", Pu = "negative", Yg = "positive-ascending", qg = "positive-descending", $U = {
  [ui]: "left",
  [Ug]: "top"
}, IU = 20, MU = {
  [ui]: "deltaX",
  [Ug]: "deltaY"
}, PU = ({ atEndEdge: e10, atStartEdge: t, layout: n }, o) => {
  let r, a = 0;
  const l = (u) => u < 0 && t.value || u > 0 && e10.value;
  return {
    hasReachedEdge: l,
    onWheel: (u) => {
      Jl(r);
      const c = u[MU[n.value]];
      l(a) && l(a + c) || (a += c, lg() || u.preventDefault(), r = sl(() => {
        o(a), a = 0;
      }));
    }
  };
}, mh = Er({
  type: ne([Number, Function]),
  required: true
}), gh = Er({
  type: Number
}), yh = Er({
  type: Number,
  default: 2
}), RU = Er({
  type: String,
  values: ["ltr", "rtl"],
  default: "ltr"
}), bh = Er({
  type: Number,
  default: 0
}), hf = Er({
  type: Number,
  required: true
}), zk = Er({
  type: String,
  values: ["horizontal", "vertical"],
  default: Ug
}), Kk = Oe({
  className: {
    type: String,
    default: ""
  },
  containerElement: {
    type: ne([String, Object]),
    default: "div"
  },
  data: {
    type: ne(Array),
    default: () => rn([])
  },
  direction: RU,
  height: {
    type: [String, Number],
    required: true
  },
  innerElement: {
    type: [String, Object],
    default: "div"
  },
  style: {
    type: ne([Object, String, Array])
  },
  useIsScrolling: {
    type: Boolean,
    default: false
  },
  width: {
    type: [Number, String],
    required: false
  },
  perfMode: {
    type: Boolean,
    default: true
  },
  scrollbarAlwaysOn: {
    type: Boolean,
    default: false
  }
}), Wk = Oe({
  cache: yh,
  estimatedItemSize: gh,
  layout: zk,
  initScrollOffset: bh,
  total: hf,
  itemSize: mh,
  ...Kk
}), _h = {
  type: Number,
  default: 6
}, jk = { type: Number, default: 0 }, Uk = { type: Number, default: 2 }, Wl = Oe({
  columnCache: yh,
  columnWidth: mh,
  estimatedColumnWidth: gh,
  estimatedRowHeight: gh,
  initScrollLeft: bh,
  initScrollTop: bh,
  itemKey: {
    type: ne(Function),
    default: ({
      columnIndex: e10,
      rowIndex: t
    }) => `${t}:${e10}`
  },
  rowCache: yh,
  rowHeight: mh,
  totalColumn: hf,
  totalRow: hf,
  hScrollbarSize: _h,
  vScrollbarSize: _h,
  scrollbarStartGap: jk,
  scrollbarEndGap: Uk,
  role: String,
  ...Kk
}), Yk = Oe({
  alwaysOn: Boolean,
  class: String,
  layout: zk,
  total: hf,
  ratio: {
    type: Number,
    required: true
  },
  clientSize: {
    type: Number,
    required: true
  },
  scrollFrom: {
    type: Number,
    required: true
  },
  scrollbarSize: _h,
  startGap: jk,
  endGap: Uk,
  visible: Boolean
}), Ml = (e10, t) => e10 < t ? Ms : vf, Ru = (e10) => e10 === OU || e10 === Hs || e10 === ui, j1 = (e10) => e10 === Hs;
let bs = null;
function mf(e10 = false) {
  if (bs === null || e10) {
    const t = document.createElement("div"), n = t.style;
    n.width = "50px", n.height = "50px", n.overflow = "scroll", n.direction = "rtl";
    const o = document.createElement("div"), r = o.style;
    return r.width = "100px", r.height = "100px", t.appendChild(o), document.body.appendChild(t), t.scrollLeft > 0 ? bs = qg : (t.scrollLeft = 1, t.scrollLeft === 0 ? bs = Pu : bs = Yg), document.body.removeChild(t), bs;
  }
  return bs;
}
function AU({ move: e10, size: t, bar: n }, o) {
  const r = {}, a = `translate${n.axis}(${e10}px)`;
  return r[n.size] = t, r.transform = a, o === "horizontal" ? r.height = "100%" : r.width = "100%", r;
}
const wh = /* @__PURE__ */ j({
  name: "ElVirtualScrollBar",
  props: Yk,
  emits: ["scroll", "start-move", "stop-move"],
  setup(e10, { emit: t }) {
    const n = S(() => e10.startGap + e10.endGap), o = we("virtual-scrollbar"), r = we("scrollbar"), a = L(), l = L();
    let s = null, u = null;
    const c = It({
      isDragging: false,
      traveled: 0
    }), d = S(() => FS[e10.layout]), f = S(() => e10.clientSize - i(n)), p = S(() => ({
      position: "absolute",
      width: `${ui === e10.layout ? f.value : e10.scrollbarSize}px`,
      height: `${ui === e10.layout ? e10.scrollbarSize : f.value}px`,
      [$U[e10.layout]]: "2px",
      right: "2px",
      bottom: "2px",
      borderRadius: "4px"
    })), v = S(() => {
      const E = e10.ratio;
      if (E >= 100)
        return Number.POSITIVE_INFINITY;
      if (E >= 50)
        return E * f.value / 100;
      const T = f.value / 3;
      return Math.floor(Math.min(Math.max(E * f.value, IU), T));
    }), m = S(() => {
      if (!Number.isFinite(v.value))
        return {
          display: "none"
        };
      const E = `${v.value}px`;
      return AU({
        bar: d.value,
        size: E,
        move: c.traveled
      }, e10.layout);
    }), h = S(() => Math.ceil(e10.clientSize - v.value - i(n))), b = () => {
      window.addEventListener("mousemove", _), window.addEventListener("mouseup", y);
      const E = i(l);
      E && (u = document.onselectstart, document.onselectstart = () => false, E.addEventListener("touchmove", _, { passive: true }), E.addEventListener("touchend", y));
    }, g = () => {
      window.removeEventListener("mousemove", _), window.removeEventListener("mouseup", y), document.onselectstart = u, u = null;
      const E = i(l);
      E && (E.removeEventListener("touchmove", _), E.removeEventListener("touchend", y));
    }, w = (E) => {
      E.stopImmediatePropagation(), !(E.ctrlKey || [1, 2].includes(E.button)) && (c.isDragging = true, c[d.value.axis] = E.currentTarget[d.value.offset] - (E[d.value.client] - E.currentTarget.getBoundingClientRect()[d.value.direction]), t("start-move"), b());
    }, y = () => {
      c.isDragging = false, c[d.value.axis] = 0, t("stop-move"), g();
    }, _ = (E) => {
      const { isDragging: T } = c;
      if (!T || !l.value || !a.value)
        return;
      const O = c[d.value.axis];
      if (!O)
        return;
      Jl(s);
      const N = (a.value.getBoundingClientRect()[d.value.direction] - E[d.value.client]) * -1, $ = l.value[d.value.offset] - O, R = N - $;
      s = sl(() => {
        c.traveled = Math.max(0, Math.min(R, h.value)), t("scroll", R, h.value);
      });
    }, C = (E) => {
      const T = Math.abs(E.target.getBoundingClientRect()[d.value.direction] - E[d.value.client]), O = l.value[d.value.offset] / 2, N = T - O;
      c.traveled = Math.max(0, Math.min(N, h.value)), t("scroll", N, h.value);
    };
    return ge(() => e10.scrollFrom, (E) => {
      c.isDragging || (c.traveled = Math.ceil(E * h.value));
    }), jt(() => {
      g();
    }), () => Ke("div", {
      role: "presentation",
      ref: a,
      class: [
        o.b(),
        e10.class,
        (e10.alwaysOn || c.isDragging) && "always-on"
      ],
      style: p.value,
      onMousedown: Xe(C, ["stop", "prevent"]),
      onTouchstartPrevent: w
    }, Ke("div", {
      ref: l,
      class: r.e("thumb"),
      style: m.value,
      onMousedown: w
    }, []));
  }
}), qk = ({
  name: e10,
  getOffset: t,
  getItemSize: n,
  getItemOffset: o,
  getEstimatedTotalSize: r,
  getStartIndexForOffset: a,
  getStopIndexForStartIndex: l,
  initCache: s,
  clearCache: u,
  validateProps: c
}) => /* @__PURE__ */ j({
  name: e10 != null ? e10 : "ElVirtualList",
  props: Wk,
  emits: [ff, pf],
  setup(d, { emit: f, expose: p }) {
    c(d);
    const v = it(), m = we("vl"), h = L(s(d, v)), b = Hk(), g = L(), w = L(), y = L(), _ = L({
      isScrolling: false,
      scrollDir: "forward",
      scrollOffset: Ye(d.initScrollOffset) ? d.initScrollOffset : 0,
      updateRequested: false,
      isScrollbarDragging: false,
      scrollbarAlwaysOn: d.scrollbarAlwaysOn
    }), C = S(() => {
      const { total: X, cache: te } = d, { isScrolling: ce, scrollDir: pe, scrollOffset: se } = i(_);
      if (X === 0)
        return [0, 0, 0, 0];
      const ve = a(d, se, i(h)), me = l(d, ve, se, i(h)), De = !ce || pe === vf ? Math.max(1, te) : 1, Te = !ce || pe === Ms ? Math.max(1, te) : 1;
      return [
        Math.max(0, ve - De),
        Math.max(0, Math.min(X - 1, me + Te)),
        ve,
        me
      ];
    }), E = S(() => r(d, i(h))), T = S(() => Ru(d.layout)), O = S(() => [
      {
        position: "relative",
        [`overflow-${T.value ? "x" : "y"}`]: "scroll",
        WebkitOverflowScrolling: "touch",
        willChange: "transform"
      },
      {
        direction: d.direction,
        height: Ye(d.height) ? `${d.height}px` : d.height,
        width: Ye(d.width) ? `${d.width}px` : d.width
      },
      d.style
    ]), N = S(() => {
      const X = i(E), te = i(T);
      return {
        height: te ? "100%" : `${X}px`,
        pointerEvents: i(_).isScrolling ? "none" : void 0,
        width: te ? `${X}px` : "100%"
      };
    }), $ = S(() => T.value ? d.width : d.height), { onWheel: R } = PU({
      atStartEdge: S(() => _.value.scrollOffset <= 0),
      atEndEdge: S(() => _.value.scrollOffset >= E.value),
      layout: S(() => d.layout)
    }, (X) => {
      var te, ce;
      (ce = (te = y.value).onMouseUp) == null || ce.call(te), F(Math.min(_.value.scrollOffset + X, E.value - $.value));
    });
    Ft(g, "wheel", R, {
      passive: false
    });
    const P = () => {
      const { total: X } = d;
      if (X > 0) {
        const [se, ve, me, De] = i(C);
        f(ff, se, ve, me, De);
      }
      const { scrollDir: te, scrollOffset: ce, updateRequested: pe } = i(_);
      f(pf, te, ce, pe);
    }, z = (X) => {
      const { clientHeight: te, scrollHeight: ce, scrollTop: pe } = X.currentTarget, se = i(_);
      if (se.scrollOffset === pe)
        return;
      const ve = Math.max(0, Math.min(pe, ce - te));
      _.value = {
        ...se,
        isScrolling: true,
        scrollDir: Ml(se.scrollOffset, ve),
        scrollOffset: ve,
        updateRequested: false
      }, He(Z);
    }, Y = (X) => {
      const { clientWidth: te, scrollLeft: ce, scrollWidth: pe } = X.currentTarget, se = i(_);
      if (se.scrollOffset === ce)
        return;
      const { direction: ve } = d;
      let me = ce;
      if (ve === Hs)
        switch (mf()) {
          case Pu: {
            me = -ce;
            break;
          }
          case qg: {
            me = pe - te - ce;
            break;
          }
        }
      me = Math.max(0, Math.min(me, pe - te)), _.value = {
        ...se,
        isScrolling: true,
        scrollDir: Ml(se.scrollOffset, me),
        scrollOffset: me,
        updateRequested: false
      }, He(Z);
    }, D = (X) => {
      i(T) ? Y(X) : z(X), P();
    }, M = (X, te) => {
      const ce = (E.value - $.value) / te * X;
      F(Math.min(E.value - $.value, ce));
    }, F = (X) => {
      X = Math.max(X, 0), X !== i(_).scrollOffset && (_.value = {
        ...i(_),
        scrollOffset: X,
        scrollDir: Ml(i(_).scrollOffset, X),
        updateRequested: true
      }, He(Z));
    }, A = (X, te = Uo) => {
      const { scrollOffset: ce } = i(_);
      X = Math.max(0, Math.min(X, d.total - 1)), F(t(d, X, te, ce, i(h)));
    }, V = (X) => {
      const { direction: te, itemSize: ce, layout: pe } = d, se = b.value(u && ce, u && pe, u && te);
      let ve;
      if (Tt(se, String(X)))
        ve = se[X];
      else {
        const me = o(d, X, i(h)), De = n(d, X, i(h)), Te = i(T), de = te === Hs, U = Te ? me : 0;
        se[X] = ve = {
          position: "absolute",
          left: de ? void 0 : `${U}px`,
          right: de ? `${U}px` : void 0,
          top: Te ? 0 : `${me}px`,
          height: Te ? "100%" : `${De}px`,
          width: Te ? `${De}px` : "100%"
        };
      }
      return ve;
    }, Z = () => {
      _.value.isScrolling = false, He(() => {
        b.value(-1, null, null);
      });
    }, G = () => {
      const X = g.value;
      X && (X.scrollTop = 0);
    };
    dt(() => {
      if (!Et)
        return;
      const { initScrollOffset: X } = d, te = i(g);
      Ye(X) && te && (i(T) ? te.scrollLeft = X : te.scrollTop = X), P();
    }), wr(() => {
      const { direction: X, layout: te } = d, { scrollOffset: ce, updateRequested: pe } = i(_), se = i(g);
      if (pe && se)
        if (te === ui)
          if (X === Hs)
            switch (mf()) {
              case Pu: {
                se.scrollLeft = -ce;
                break;
              }
              case Yg: {
                se.scrollLeft = ce;
                break;
              }
              default: {
                const { clientWidth: ve, scrollWidth: me } = se;
                se.scrollLeft = me - ve - ce;
                break;
              }
            }
          else
            se.scrollLeft = ce;
        else
          se.scrollTop = ce;
    }), Lf(() => {
      i(g).scrollTop = i(_).scrollOffset;
    });
    const le = {
      ns: m,
      clientSize: $,
      estimatedTotalSize: E,
      windowStyle: O,
      windowRef: g,
      innerRef: w,
      innerStyle: N,
      itemsToRender: C,
      scrollbarRef: y,
      states: _,
      getItemStyle: V,
      onScroll: D,
      onScrollbarScroll: M,
      onWheel: R,
      scrollTo: F,
      scrollToItem: A,
      resetScrollTop: G
    };
    return p({
      windowRef: g,
      innerRef: w,
      getItemStyleCache: b,
      scrollTo: F,
      scrollToItem: A,
      resetScrollTop: G,
      states: _
    }), le;
  },
  render(d) {
    var f;
    const {
      $slots: p,
      className: v,
      clientSize: m,
      containerElement: h,
      data: b,
      getItemStyle: g,
      innerElement: w,
      itemsToRender: y,
      innerStyle: _,
      layout: C,
      total: E,
      onScroll: T,
      onScrollbarScroll: O,
      states: N,
      useIsScrolling: $,
      windowStyle: R,
      ns: P
    } = d, [z, Y] = y, D = ht(h), M = ht(w), F = [];
    if (E > 0)
      for (let G = z; G <= Y; G++)
        F.push(Ke(Ie, { key: G }, (f = p.default) == null ? void 0 : f.call(p, {
          data: b,
          index: G,
          isScrolling: $ ? N.isScrolling : void 0,
          style: g(G)
        })));
    const A = [
      Ke(M, {
        style: _,
        ref: "innerRef"
      }, Ve(M) ? F : {
        default: () => F
      })
    ], V = Ke(wh, {
      ref: "scrollbarRef",
      clientSize: m,
      layout: C,
      onScroll: O,
      ratio: m * 100 / this.estimatedTotalSize,
      scrollFrom: N.scrollOffset / (this.estimatedTotalSize - m),
      total: E
    }), Z = Ke(D, {
      class: [P.e("window"), v],
      style: R,
      onScroll: T,
      ref: "windowRef",
      key: 0
    }, Ve(D) ? [A] : { default: () => [A] });
    return Ke("div", {
      key: 0,
      class: [P.e("wrapper"), N.scrollbarAlwaysOn ? "always-on" : ""]
    }, [Z, V]);
  }
}), Gk = qk({
  name: "ElFixedSizeList",
  getItemOffset: ({ itemSize: e10 }, t) => t * e10,
  getItemSize: ({ itemSize: e10 }) => e10,
  getEstimatedTotalSize: ({ total: e10, itemSize: t }) => t * e10,
  getOffset: ({ height: e10, total: t, itemSize: n, layout: o, width: r }, a, l, s) => {
    const u = Ru(o) ? r : e10;
     true && Ve(u) && Qt("[ElVirtualList]", `
        You should set
          width/height
        to number when your layout is
          horizontal/vertical
      `);
    const c = Math.max(0, t * n - u), d = Math.min(c, a * n), f = Math.max(0, (a + 1) * n - u);
    switch (l === dp && (s >= f - u && s <= d + u ? l = Uo : l = Br), l) {
      case Iu:
        return d;
      case Mu:
        return f;
      case Br: {
        const p = Math.round(f + (d - f) / 2);
        return p < Math.ceil(u / 2) ? 0 : p > c + Math.floor(u / 2) ? c : p;
      }
      case Uo:
      default:
        return s >= f && s <= d ? s : s < f ? f : d;
    }
  },
  getStartIndexForOffset: ({ total: e10, itemSize: t }, n) => Math.max(0, Math.min(e10 - 1, Math.floor(n / t))),
  getStopIndexForStartIndex: ({ height: e10, total: t, itemSize: n, layout: o, width: r }, a, l) => {
    const s = a * n, u = Ru(o) ? r : e10, c = Math.ceil((u + l - s) / n);
    return Math.max(0, Math.min(t - 1, a + c - 1));
  },
  initCache() {
  },
  clearCache: true,
  validateProps() {
  }
}), LU = "ElDynamicSizeList", Ps = (e10, t, n) => {
  const { itemSize: o } = e10, { items: r, lastVisitedIndex: a } = n;
  if (t > a) {
    let l = 0;
    if (a >= 0) {
      const s = r[a];
      l = s.offset + s.size;
    }
    for (let s = a + 1; s <= t; s++) {
      const u = o(s);
      r[s] = {
        offset: l,
        size: u
      }, l += u;
    }
    n.lastVisitedIndex = t;
  }
  return r[t];
}, xU = (e10, t, n) => {
  const { items: o, lastVisitedIndex: r } = t;
  return (r > 0 ? o[r].offset : 0) >= n ? Xk(e10, t, 0, r, n) : DU(e10, t, Math.max(0, r), n);
}, Xk = (e10, t, n, o, r) => {
  for (; n <= o; ) {
    const a = n + Math.floor((o - n) / 2), l = Ps(e10, a, t).offset;
    if (l === r)
      return a;
    l < r ? n = a + 1 : l > r && (o = a - 1);
  }
  return Math.max(0, n - 1);
}, DU = (e10, t, n, o) => {
  const { total: r } = e10;
  let a = 1;
  for (; n < r && Ps(e10, n, t).offset < o; )
    n += a, a *= 2;
  return Xk(e10, t, Math.floor(n / 2), Math.min(n, r - 1), o);
}, U1 = ({ total: e10 }, { items: t, estimatedItemSize: n, lastVisitedIndex: o }) => {
  let r = 0;
  if (o >= e10 && (o = e10 - 1), o >= 0) {
    const s = t[o];
    r = s.offset + s.size;
  }
  const l = (e10 - o - 1) * n;
  return r + l;
}, VU = qk({
  name: "ElDynamicSizeList",
  getItemOffset: (e10, t, n) => Ps(e10, t, n).offset,
  getItemSize: (e10, t, { items: n }) => n[t].size,
  getEstimatedTotalSize: U1,
  getOffset: (e10, t, n, o, r) => {
    const { height: a, layout: l, width: s } = e10, u = Ru(l) ? s : a, c = Ps(e10, t, r), d = U1(e10, r), f = Math.max(0, Math.min(d - u, c.offset)), p = Math.max(0, c.offset - u + c.size);
    switch (n === dp && (o >= p - u && o <= f + u ? n = Uo : n = Br), n) {
      case Iu:
        return f;
      case Mu:
        return p;
      case Br:
        return Math.round(p + (f - p) / 2);
      case Uo:
      default:
        return o >= p && o <= f ? o : o < p ? p : f;
    }
  },
  getStartIndexForOffset: (e10, t, n) => xU(e10, n, t),
  getStopIndexForStartIndex: (e10, t, n, o) => {
    const { height: r, total: a, layout: l, width: s } = e10, u = Ru(l) ? s : r, c = Ps(e10, t, o), d = n + u;
    let f = c.offset + c.size, p = t;
    for (; p < a - 1 && f < d; )
      p++, f += Ps(e10, p, o).size;
    return p;
  },
  initCache({ estimatedItemSize: e10 = hh }, t) {
    const n = {
      items: {},
      estimatedItemSize: e10,
      lastVisitedIndex: -1
    };
    return n.clearCacheAfterIndex = (o, r = true) => {
      var a, l;
      n.lastVisitedIndex = Math.min(n.lastVisitedIndex, o - 1), (a = t.exposed) == null || a.getItemStyleCache(-1), r && ((l = t.proxy) == null || l.$forceUpdate());
    }, n;
  },
  clearCache: false,
  validateProps: ({ itemSize: e10 }) => {
     true && typeof e10 != "function" && Qt(LU, `
          itemSize is required as function, but the given value was ${typeof e10}
        `);
  }
}), FU = {
  loading: Boolean,
  data: {
    type: Array,
    required: true
  },
  hoveringIndex: Number,
  width: Number
};
var BU = /* @__PURE__ */ j({
  name: "ElSelectDropdown",
  props: FU,
  setup(e10, {
    slots: t,
    expose: n
  }) {
    const o = Le(jg), r = we("select"), {
      getLabel: a,
      getValue: l,
      getDisabled: s
    } = cp(o.props), u = L([]), c = L(), d = S(() => e10.data.length);
    ge(() => d.value, () => {
      var R, P;
      (P = (R = o.tooltipRef.value) == null ? void 0 : R.updatePopper) == null || P.call(R);
    });
    const f = S(() => St(o.props.estimatedOptionHeight)), p = S(() => f.value ? {
      itemSize: o.props.itemHeight
    } : {
      estimatedSize: o.props.estimatedOptionHeight,
      itemSize: (R) => u.value[R]
    }), v = (R = [], P) => {
      const {
        props: {
          valueKey: z
        }
      } = o;
      return at(P) ? R && R.some((Y) => Rt(hn(Y, z)) === hn(P, z)) : R.includes(P);
    }, m = (R, P) => {
      if (at(P)) {
        const {
          valueKey: z
        } = o.props;
        return hn(R, z) === hn(P, z);
      } else
        return R === P;
    }, h = (R, P) => o.props.multiple ? v(R, l(P)) : m(R, l(P)), b = (R, P) => {
      const {
        disabled: z,
        multiple: Y,
        multipleLimit: D
      } = o.props;
      return z || !P && (Y ? D > 0 && R.length >= D : false);
    }, g = (R) => e10.hoveringIndex === R;
    n({
      listRef: c,
      isSized: f,
      isItemDisabled: b,
      isItemHovering: g,
      isItemSelected: h,
      scrollToItem: (R) => {
        const P = c.value;
        P && P.scrollToItem(R);
      },
      resetScrollTop: () => {
        const R = c.value;
        R && R.resetScrollTop();
      }
    });
    const C = (R) => {
      const {
        index: P,
        data: z,
        style: Y
      } = R, D = i(f), {
        itemSize: M,
        estimatedSize: F
      } = i(p), {
        modelValue: A
      } = o.props, {
        onSelect: V,
        onHover: Z
      } = o, G = z[P];
      if (G.type === "Group")
        return W(mU, {
          item: G,
          style: Y,
          height: D ? M : F
        }, null);
      const le = h(A, G), X = b(A, le), te = g(P);
      return W(SU, vt(R, {
        selected: le,
        disabled: s(G) || X,
        created: !!G.created,
        hovering: te,
        item: G,
        onSelect: V,
        onHover: Z
      }), {
        default: (ce) => {
          var pe;
          return ((pe = t.default) == null ? void 0 : pe.call(t, ce)) || W("span", null, [a(G)]);
        }
      });
    }, {
      onKeyboardNavigate: E,
      onKeyboardSelect: T
    } = o, O = () => {
      E("forward");
    }, N = () => {
      E("backward");
    }, $ = (R) => {
      const {
        code: P
      } = R, {
        tab: z,
        esc: Y,
        down: D,
        up: M,
        enter: F,
        numpadEnter: A
      } = xe;
      switch ([Y, D, M, F, A].includes(P) && (R.preventDefault(), R.stopPropagation()), P) {
        case z:
        case Y:
          break;
        case D:
          O();
          break;
        case M:
          N();
          break;
        case F:
        case A:
          T();
          break;
      }
    };
    return () => {
      var R, P, z, Y;
      const {
        data: D,
        width: M
      } = e10, {
        height: F,
        multiple: A,
        scrollbarAlwaysOn: V
      } = o.props, Z = S(() => Qd ? true : V), G = i(f) ? Gk : VU;
      return W("div", {
        class: [r.b("dropdown"), r.is("multiple", A)],
        style: {
          width: `${M}px`
        }
      }, [(R = t.header) == null ? void 0 : R.call(t), ((P = t.loading) == null ? void 0 : P.call(t)) || ((z = t.empty) == null ? void 0 : z.call(t)) || W(G, vt({
        ref: c
      }, i(p), {
        className: r.be("dropdown", "list"),
        scrollbarAlwaysOn: Z.value,
        data: D,
        height: F,
        width: M,
        total: D.length,
        onKeydown: $
      }), {
        default: (le) => W(C, le, null)
      }), (Y = t.footer) == null ? void 0 : Y.call(t)]);
    };
  }
});
function HU(e10, t) {
  const { aliasProps: n, getLabel: o, getValue: r } = cp(e10), a = L(0), l = L(), s = S(() => e10.allowCreate && e10.filterable);
  function u(v) {
    const m = (h) => o(h) === v;
    return e10.options && e10.options.some(m) || t.createdOptions.some(m);
  }
  function c(v) {
    s.value && (e10.multiple && v.created ? a.value++ : l.value = v);
  }
  function d(v) {
    if (s.value)
      if (v && v.length > 0) {
        if (u(v))
          return;
        const m = {
          [n.value.value]: v,
          [n.value.label]: v,
          created: true,
          [n.value.disabled]: false
        };
        t.createdOptions.length >= a.value ? t.createdOptions[a.value] = m : t.createdOptions.push(m);
      } else if (e10.multiple)
        t.createdOptions.length = a.value;
      else {
        const m = l.value;
        t.createdOptions.length = 0, m && m.created && t.createdOptions.push(m);
      }
  }
  function f(v) {
    if (!s.value || !v || !v.created || v.created && e10.reserveKeyword && t.inputValue === o(v))
      return;
    const m = t.createdOptions.findIndex((h) => r(h) === r(v));
    ~m && (t.createdOptions.splice(m, 1), a.value--);
  }
  function p() {
    s.value && (t.createdOptions.length = 0, a.value = 0);
  }
  return {
    createNewOption: d,
    removeNewOption: f,
    selectNewOption: c,
    clearAllNewOption: p
  };
}
const zU = (e10, t) => {
  const { t: n } = kt(), o = we("select"), r = we("input"), { form: a, formItem: l } = Yn(), { inputId: s } = tr(e10, {
    formItemContext: l
  }), { aliasProps: u, getLabel: c, getValue: d, getDisabled: f, getOptions: p } = cp(e10), { valueOnClear: v, isEmptyValue: m } = Xf(e10), h = It({
    inputValue: "",
    cachedOptions: [],
    createdOptions: [],
    hoveringIndex: -1,
    inputHovering: false,
    selectionWidth: 0,
    collapseItemWidth: 0,
    previousQuery: null,
    previousValue: void 0,
    selectedLabel: "",
    menuVisibleOnFocus: false,
    isBeforeHide: false
  }), b = L(-1), g = L(), w = L(), y = L(), _ = L(), C = L(), E = L(), T = L(), O = L(), N = L(), $ = L(), {
    isComposing: R,
    handleCompositionStart: P,
    handleCompositionEnd: z,
    handleCompositionUpdate: Y
  } = uc({
    afterComposition: (Pe) => Gn(Pe)
  }), { wrapperRef: D, isFocused: M, handleBlur: F } = pl(C, {
    beforeFocus() {
      return le.value;
    },
    afterFocus() {
      e10.automaticDropdown && !G.value && (G.value = true, h.menuVisibleOnFocus = true);
    },
    beforeBlur(Pe) {
      var tt, wt;
      return ((tt = y.value) == null ? void 0 : tt.isFocusInsideContent(Pe)) || ((wt = _.value) == null ? void 0 : wt.isFocusInsideContent(Pe));
    },
    afterBlur() {
      var Pe;
      G.value = false, h.menuVisibleOnFocus = false, e10.validateEvent && ((Pe = l == null ? void 0 : l.validate) == null || Pe.call(l, "blur").catch((tt) => _t(tt)));
    }
  }), A = S(() => U("")), V = S(() => e10.loading ? false : e10.options.length > 0 || h.createdOptions.length > 0), Z = L([]), G = L(false), le = S(() => e10.disabled || (a == null ? void 0 : a.disabled)), X = S(() => {
    var Pe;
    return (Pe = a == null ? void 0 : a.statusIcon) != null ? Pe : false;
  }), te = S(() => {
    const Pe = Z.value.length * e10.itemHeight;
    return Pe > e10.height ? e10.height : Pe;
  }), ce = S(() => e10.multiple ? Se(e10.modelValue) && e10.modelValue.length > 0 : !m(e10.modelValue)), pe = S(() => e10.clearable && !le.value && h.inputHovering && ce.value), se = S(() => e10.remote && e10.filterable ? "" : e10.suffixIcon), ve = S(() => se.value && o.is("reverse", G.value)), me = S(() => (l == null ? void 0 : l.validateState) || ""), De = S(() => {
    if (me.value)
      return ep[me.value];
  }), Te = S(() => e10.remote ? 300 : 0), de = S(() => e10.loading ? e10.loadingText || n("el.select.loading") : e10.remote && !h.inputValue && !V.value ? false : e10.filterable && h.inputValue && V.value && Z.value.length === 0 ? e10.noMatchText || n("el.select.noMatch") : V.value ? null : e10.noDataText || n("el.select.noData")), U = (Pe) => {
    const tt = new RegExp(Eg(Pe), "i"), wt = e10.filterable && Fe(e10.filterMethod), At = e10.filterable && e10.remote && Fe(e10.remoteMethod), Ln = (Io) => wt || At ? true : Pe ? tt.test(c(Io) || "") : true;
    return e10.loading ? [] : [...h.createdOptions, ...e10.options].reduce((Io, yl) => {
      const bl = p(yl);
      if (Se(bl)) {
        const kc = bl.filter(Ln);
        kc.length > 0 && Io.push({
          label: c(yl),
          type: "Group"
        }, ...kc);
      } else (e10.remote || Ln(yl)) && Io.push(yl);
      return Io;
    }, []);
  }, re = () => {
    Z.value = U(h.inputValue);
  }, he = S(() => {
    const Pe = /* @__PURE__ */ new Map();
    return A.value.forEach((tt, wt) => {
      Pe.set(Sn(d(tt)), { option: tt, index: wt });
    }), Pe;
  }), Ee = S(() => {
    const Pe = /* @__PURE__ */ new Map();
    return Z.value.forEach((tt, wt) => {
      Pe.set(Sn(d(tt)), { option: tt, index: wt });
    }), Pe;
  }), ye = S(() => Z.value.every((Pe) => f(Pe))), K = yn(), q = S(() => K.value === "small" ? "small" : "default"), ue = () => {
    var Pe;
    if (Ye(e10.fitInputWidth)) {
      b.value = e10.fitInputWidth;
      return;
    }
    const tt = ((Pe = g.value) == null ? void 0 : Pe.offsetWidth) || 200;
    !e10.fitInputWidth && V.value ? He(() => {
      b.value = Math.max(tt, be());
    }) : b.value = tt;
  }, be = () => {
    var Pe, tt;
    const At = document.createElement("canvas").getContext("2d"), Ln = o.be("dropdown", "item"), yl = (((tt = (Pe = O.value) == null ? void 0 : Pe.listRef) == null ? void 0 : tt.innerRef) || document).querySelector(`.${Ln}`);
    if (yl === null || At === null)
      return 0;
    const bl = getComputedStyle(yl), kc = Number.parseFloat(bl.paddingLeft) + Number.parseFloat(bl.paddingRight);
    return At.font = `bold ${bl.font.replace(new RegExp(`\\b${bl.fontWeight}\\b`), "")}`, Z.value.reduce((BO, HO) => {
      const zO = At.measureText(c(HO));
      return Math.max(zO.width, BO);
    }, 0) + kc;
  }, ke = () => {
    if (!w.value)
      return 0;
    const Pe = window.getComputedStyle(w.value);
    return Number.parseFloat(Pe.gap || "6px");
  }, Ae = S(() => {
    const Pe = ke();
    return { maxWidth: `${$.value && e10.maxCollapseTags === 1 ? h.selectionWidth - h.collapseItemWidth - Pe : h.selectionWidth}px` };
  }), fe = S(() => ({ maxWidth: `${h.selectionWidth}px` })), ie = S(() => Se(e10.modelValue) ? e10.modelValue.length === 0 && !h.inputValue : e10.filterable ? !h.inputValue : true), Ce = S(() => {
    var Pe;
    const tt = (Pe = e10.placeholder) != null ? Pe : n("el.select.placeholder");
    return e10.multiple || !ce.value ? tt : h.selectedLabel;
  }), qe = S(() => {
    var Pe, tt;
    return (tt = (Pe = y.value) == null ? void 0 : Pe.popperRef) == null ? void 0 : tt.contentRef;
  }), et = S(() => {
    if (e10.multiple) {
      const Pe = e10.modelValue.length;
      if (e10.modelValue.length > 0 && Ee.value.has(e10.modelValue[Pe - 1])) {
        const { index: tt } = Ee.value.get(e10.modelValue[Pe - 1]);
        return tt;
      }
    } else if (!m(e10.modelValue) && Ee.value.has(e10.modelValue)) {
      const { index: Pe } = Ee.value.get(e10.modelValue);
      return Pe;
    }
    return -1;
  }), ft = S({
    get() {
      return G.value && de.value !== false;
    },
    set(Pe) {
      G.value = Pe;
    }
  }), bt = S(() => e10.multiple ? e10.collapseTags ? h.cachedOptions.slice(0, e10.maxCollapseTags) : h.cachedOptions : []), zt = S(() => e10.multiple ? e10.collapseTags ? h.cachedOptions.slice(e10.maxCollapseTags) : [] : []), {
    createNewOption: We,
    removeNewOption: ct,
    selectNewOption: oe,
    clearAllNewOption: Ne
  } = HU(e10, h), Q = () => {
    le.value || (h.menuVisibleOnFocus ? h.menuVisibleOnFocus = false : G.value = !G.value);
  }, Me = () => {
    h.inputValue.length > 0 && !G.value && (G.value = true), We(h.inputValue), He(() => {
      Ct(h.inputValue);
    });
  }, Qe = Oo(Me, Te.value), Ct = (Pe) => {
    h.previousQuery === Pe || R.value || (h.previousQuery = Pe, e10.filterable && Fe(e10.filterMethod) ? e10.filterMethod(Pe) : e10.filterable && e10.remote && Fe(e10.remoteMethod) && e10.remoteMethod(Pe), e10.defaultFirstOption && (e10.filterable || e10.remote) && Z.value.length ? He(Kt) : He(wn));
  }, Kt = () => {
    const Pe = Z.value.filter((At) => !At.disabled && At.type !== "Group"), tt = Pe.find((At) => At.created), wt = Pe[0];
    h.hoveringIndex = aa(Z.value, tt || wt);
  }, pn = (Pe) => {
    In(e10.modelValue, Pe) || t(gt, Pe);
  }, on = (Pe) => {
    t(nt, Pe), pn(Pe), h.previousValue = e10.multiple ? String(Pe) : Pe, He(() => {
      if (e10.multiple && Se(e10.modelValue)) {
        const tt = h.cachedOptions.slice(), wt = e10.modelValue.map((At) => Fa(At, tt));
        In(h.cachedOptions, wt) || (h.cachedOptions = wt);
      } else
        fs(true);
    });
  }, aa = (Pe = [], tt) => {
    if (!at(tt))
      return Pe.indexOf(tt);
    const wt = e10.valueKey;
    let At = -1;
    return Pe.some((Ln, Io) => hn(Ln, wt) === hn(tt, wt) ? (At = Io, true) : false), At;
  }, Sn = (Pe) => at(Pe) ? hn(Pe, e10.valueKey) : Pe, Bo = () => {
    ue();
  }, Ge = () => {
    h.selectionWidth = Number.parseFloat(window.getComputedStyle(w.value).width);
  }, $t = () => {
    h.collapseItemWidth = $.value.getBoundingClientRect().width;
  }, mt = () => {
    var Pe, tt;
    (tt = (Pe = y.value) == null ? void 0 : Pe.updatePopper) == null || tt.call(Pe);
  }, ao = () => {
    var Pe, tt;
    (tt = (Pe = _.value) == null ? void 0 : Pe.updatePopper) == null || tt.call(Pe);
  }, $r = (Pe) => {
    if (e10.multiple) {
      let tt = e10.modelValue.slice();
      const wt = aa(tt, d(Pe));
      wt > -1 ? (tt = [
        ...tt.slice(0, wt),
        ...tt.slice(wt + 1)
      ], h.cachedOptions.splice(wt, 1), ct(Pe)) : (e10.multipleLimit <= 0 || tt.length < e10.multipleLimit) && (tt = [...tt, d(Pe)], h.cachedOptions.push(Pe), oe(Pe)), on(tt), Pe.created && Ct(""), e10.filterable && !e10.reserveKeyword && (h.inputValue = "");
    } else
      h.selectedLabel = c(Pe), on(d(Pe)), G.value = false, oe(Pe), Pe.created || Ne();
    ds();
  }, xa = (Pe, tt) => {
    let wt = e10.modelValue.slice();
    const At = aa(wt, d(tt));
    At > -1 && !le.value && (wt = [
      ...e10.modelValue.slice(0, At),
      ...e10.modelValue.slice(At + 1)
    ], h.cachedOptions.splice(At, 1), on(wt), t("remove-tag", d(tt)), ct(tt)), Pe.stopPropagation(), ds();
  }, ds = () => {
    var Pe;
    (Pe = C.value) == null || Pe.focus();
  }, Sc = () => {
    var Pe;
    if (G.value) {
      G.value = false, He(() => {
        var tt;
        return (tt = C.value) == null ? void 0 : tt.blur();
      });
      return;
    }
    (Pe = C.value) == null || Pe.blur();
  }, $p = () => {
    h.inputValue.length > 0 ? h.inputValue = "" : G.value = false;
  }, Ip = (Pe) => sS(Pe, (tt) => !h.cachedOptions.some((wt) => d(wt) === tt && f(wt))), Mp = (Pe) => {
    if (e10.multiple && Pe.code !== xe.delete && h.inputValue.length === 0) {
      Pe.preventDefault();
      const tt = e10.modelValue.slice(), wt = Ip(tt);
      if (wt < 0)
        return;
      const At = tt[wt];
      tt.splice(wt, 1);
      const Ln = h.cachedOptions[wt];
      h.cachedOptions.splice(wt, 1), ct(Ln), on(tt), t("remove-tag", At);
    }
  }, Pp = () => {
    let Pe;
    Se(e10.modelValue) ? Pe = [] : Pe = v.value, h.selectedLabel = "", G.value = false, on(Pe), t("clear"), Ne(), ds();
  }, Re = (Pe, tt = void 0) => {
    const wt = Z.value;
    if (!["forward", "backward"].includes(Pe) || le.value || wt.length <= 0 || ye.value || R.value)
      return;
    if (!G.value)
      return Q();
    St(tt) && (tt = h.hoveringIndex);
    let At = -1;
    Pe === "forward" ? (At = tt + 1, At >= wt.length && (At = 0)) : Pe === "backward" && (At = tt - 1, (At < 0 || At >= wt.length) && (At = wt.length - 1));
    const Ln = wt[At];
    if (f(Ln) || Ln.type === "Group")
      return Re(Pe, At);
    h.hoveringIndex = At, Va(At);
  }, ot = () => {
    if (G.value)
      ~h.hoveringIndex && Z.value[h.hoveringIndex] && $r(Z.value[h.hoveringIndex]);
    else return Q();
  }, Dt = (Pe) => {
    h.hoveringIndex = Pe != null ? Pe : -1;
  }, wn = () => {
    e10.multiple ? h.hoveringIndex = Z.value.findIndex((Pe) => e10.modelValue.some((tt) => Sn(tt) === Sn(d(Pe)))) : h.hoveringIndex = Z.value.findIndex((Pe) => Sn(d(Pe)) === Sn(e10.modelValue));
  }, Gn = (Pe) => {
    if (h.inputValue = Pe.target.value, e10.remote)
      Qe();
    else
      return Me();
  }, Da = (Pe) => {
    if (G.value = false, M.value) {
      const tt = new FocusEvent("focus", Pe);
      F(tt);
    }
  }, Ir = () => (h.isBeforeHide = false, He(() => {
    ~et.value && Va(h.hoveringIndex);
  })), Va = (Pe) => {
    O.value.scrollToItem(Pe);
  }, Fa = (Pe, tt) => {
    const wt = Sn(Pe);
    if (he.value.has(wt)) {
      const { option: At } = he.value.get(wt);
      return At;
    }
    if (tt && tt.length) {
      const At = tt.find((Ln) => Sn(d(Ln)) === wt);
      if (At)
        return At;
    }
    return {
      [u.value.value]: Pe,
      [u.value.label]: Pe
    };
  }, fs = (Pe = false) => {
    if (e10.multiple)
      if (e10.modelValue.length > 0) {
        const tt = h.cachedOptions.slice();
        h.cachedOptions.length = 0, h.previousValue = e10.modelValue.toString();
        for (const wt of e10.modelValue) {
          const At = Fa(wt, tt);
          h.cachedOptions.push(At);
        }
      } else
        h.cachedOptions = [], h.previousValue = void 0;
    else if (ce.value) {
      h.previousValue = e10.modelValue;
      const tt = Z.value, wt = tt.findIndex((At) => Sn(d(At)) === Sn(e10.modelValue));
      ~wt ? h.selectedLabel = c(tt[wt]) : (!h.selectedLabel || Pe) && (h.selectedLabel = Sn(e10.modelValue));
    } else
      h.selectedLabel = "", h.previousValue = void 0;
    Ne(), ue();
  };
  return ge(() => e10.fitInputWidth, () => {
    ue();
  }), ge(G, (Pe) => {
    Pe ? (e10.persistent || ue(), Ct("")) : (h.inputValue = "", h.previousQuery = null, h.isBeforeHide = true, We("")), t("visible-change", Pe);
  }), ge(() => e10.modelValue, (Pe, tt) => {
    var wt;
    (!Pe || Se(Pe) && Pe.length === 0 || e10.multiple && !In(Pe.toString(), h.previousValue) || !e10.multiple && Sn(Pe) !== Sn(h.previousValue)) && fs(true), !In(Pe, tt) && e10.validateEvent && ((wt = l == null ? void 0 : l.validate) == null || wt.call(l, "change").catch((Ln) => _t(Ln)));
  }, {
    deep: true
  }), ge(() => e10.options, () => {
    const Pe = C.value;
    (!Pe || Pe && document.activeElement !== Pe) && fs();
  }, {
    deep: true,
    flush: "post"
  }), ge(() => Z.value, () => (ue(), O.value && He(O.value.resetScrollTop))), Vn(() => {
    h.isBeforeHide || re();
  }), Vn(() => {
    const { valueKey: Pe, options: tt } = e10, wt = /* @__PURE__ */ new Map();
    for (const At of tt) {
      const Ln = d(At);
      let Io = Ln;
      if (at(Io) && (Io = hn(Ln, Pe)), wt.get(Io)) {
        _t("ElSelectV2", "The option values you provided seem to be duplicated, which may cause some problems, please check.");
        break;
      } else
        wt.set(Io, true);
    }
  }), dt(() => {
    fs();
  }), en(g, Bo), en(w, Ge), en(O, mt), en(D, mt), en(N, ao), en($, $t), {
    inputId: s,
    collapseTagSize: q,
    currentPlaceholder: Ce,
    expanded: G,
    emptyText: de,
    popupHeight: te,
    debounce: Te,
    allOptions: A,
    filteredOptions: Z,
    iconComponent: se,
    iconReverse: ve,
    tagStyle: Ae,
    collapseTagStyle: fe,
    popperSize: b,
    dropdownMenuVisible: ft,
    hasModelValue: ce,
    shouldShowPlaceholder: ie,
    selectDisabled: le,
    selectSize: K,
    needStatusIcon: X,
    showClearBtn: pe,
    states: h,
    isFocused: M,
    nsSelect: o,
    nsInput: r,
    inputRef: C,
    menuRef: O,
    tagMenuRef: N,
    tooltipRef: y,
    tagTooltipRef: _,
    selectRef: g,
    wrapperRef: D,
    selectionRef: w,
    prefixRef: E,
    suffixRef: T,
    collapseItemRef: $,
    popperRef: qe,
    validateState: me,
    validateIcon: De,
    showTagList: bt,
    collapseTagList: zt,
    debouncedOnInputChange: Qe,
    deleteTag: xa,
    getLabel: c,
    getValue: d,
    getDisabled: f,
    getValueKey: Sn,
    handleClear: Pp,
    handleClickOutside: Da,
    handleDel: Mp,
    handleEsc: $p,
    focus: ds,
    blur: Sc,
    handleMenuEnter: Ir,
    handleResize: Bo,
    resetSelectionWidth: Ge,
    updateTooltip: mt,
    updateTagTooltip: ao,
    updateOptions: re,
    toggleMenu: Q,
    scrollTo: Va,
    onInput: Gn,
    onKeyboardNavigate: Re,
    onKeyboardSelect: ot,
    onSelect: $r,
    onHover: Dt,
    handleCompositionStart: P,
    handleCompositionEnd: z,
    handleCompositionUpdate: Y
  };
}, KU = /* @__PURE__ */ j({
  name: "ElSelectV2",
  components: {
    ElSelectMenu: BU,
    ElTag: ai,
    ElTooltip: Un,
    ElIcon: Be
  },
  directives: { ClickOutside: Sa },
  props: yU,
  emits: _U,
  setup(e10, { emit: t }) {
    const n = S(() => {
      const { modelValue: s, multiple: u } = e10, c = u ? [] : void 0;
      return Se(s) ? u ? s : c : u ? c : s;
    }), o = zU(It({
      ...Tn(e10),
      modelValue: n
    }), t), { calculatorRef: r, inputStyle: a } = Bg();
    yt(jg, {
      props: It({
        ...Tn(e10),
        height: o.popupHeight,
        modelValue: n
      }),
      expanded: o.expanded,
      tooltipRef: o.tooltipRef,
      onSelect: o.onSelect,
      onHover: o.onHover,
      onKeyboardNavigate: o.onKeyboardNavigate,
      onKeyboardSelect: o.onKeyboardSelect
    });
    const l = S(() => e10.multiple ? o.states.cachedOptions.map((s) => s.label) : o.states.selectedLabel);
    return {
      ...o,
      modelValue: n,
      selectedLabel: l,
      calculatorRef: r,
      inputStyle: a
    };
  }
});
function WU(e10, t, n, o, r, a) {
  const l = je("el-tag"), s = je("el-tooltip"), u = je("el-icon"), c = je("el-select-menu"), d = Vf("click-outside");
  return lt((k(), x("div", {
    ref: "selectRef",
    class: I([e10.nsSelect.b(), e10.nsSelect.m(e10.selectSize)]),
    onMouseenter: (f) => e10.states.inputHovering = true,
    onMouseleave: (f) => e10.states.inputHovering = false
  }, [
    W(s, {
      ref: "tooltipRef",
      visible: e10.dropdownMenuVisible,
      teleported: e10.teleported,
      "popper-class": [e10.nsSelect.e("popper"), e10.popperClass],
      "gpu-acceleration": false,
      "stop-popper-mouse-event": false,
      "popper-options": e10.popperOptions,
      "fallback-placements": e10.fallbackPlacements,
      effect: e10.effect,
      placement: e10.placement,
      pure: "",
      transition: `${e10.nsSelect.namespace.value}-zoom-in-top`,
      trigger: "click",
      persistent: e10.persistent,
      "append-to": e10.appendTo,
      "show-arrow": e10.showArrow,
      offset: e10.offset,
      onBeforeShow: e10.handleMenuEnter,
      onHide: (f) => e10.states.isBeforeHide = false
    }, {
      default: H(() => [
        B("div", {
          ref: "wrapperRef",
          class: I([
            e10.nsSelect.e("wrapper"),
            e10.nsSelect.is("focused", e10.isFocused),
            e10.nsSelect.is("hovering", e10.states.inputHovering),
            e10.nsSelect.is("filterable", e10.filterable),
            e10.nsSelect.is("disabled", e10.selectDisabled)
          ]),
          onClick: Xe(e10.toggleMenu, ["prevent"])
        }, [
          e10.$slots.prefix ? (k(), x("div", {
            key: 0,
            ref: "prefixRef",
            class: I(e10.nsSelect.e("prefix"))
          }, [
            J(e10.$slots, "prefix")
          ], 2)) : ee("v-if", true),
          B("div", {
            ref: "selectionRef",
            class: I([
              e10.nsSelect.e("selection"),
              e10.nsSelect.is("near", e10.multiple && !e10.$slots.prefix && !!e10.modelValue.length)
            ])
          }, [
            e10.multiple ? J(e10.$slots, "tag", { key: 0 }, () => [
              (k(true), x(Ie, null, st(e10.showTagList, (f) => (k(), x("div", {
                key: e10.getValueKey(e10.getValue(f)),
                class: I(e10.nsSelect.e("selected-item"))
              }, [
                W(l, {
                  closable: !e10.selectDisabled && !e10.getDisabled(f),
                  size: e10.collapseTagSize,
                  type: e10.tagType,
                  effect: e10.tagEffect,
                  "disable-transitions": "",
                  style: ze(e10.tagStyle),
                  onClose: (p) => e10.deleteTag(p, f)
                }, {
                  default: H(() => [
                    B("span", {
                      class: I(e10.nsSelect.e("tags-text"))
                    }, [
                      J(e10.$slots, "label", {
                        label: e10.getLabel(f),
                        value: e10.getValue(f)
                      }, () => [
                        Ze(_e(e10.getLabel(f)), 1)
                      ])
                    ], 2)
                  ]),
                  _: 2
                }, 1032, ["closable", "size", "type", "effect", "style", "onClose"])
              ], 2))), 128)),
              e10.collapseTags && e10.modelValue.length > e10.maxCollapseTags ? (k(), ae(s, {
                key: 0,
                ref: "tagTooltipRef",
                disabled: e10.dropdownMenuVisible || !e10.collapseTagsTooltip,
                "fallback-placements": ["bottom", "top", "right", "left"],
                effect: e10.effect,
                placement: "bottom",
                teleported: e10.teleported
              }, {
                default: H(() => [
                  B("div", {
                    ref: "collapseItemRef",
                    class: I(e10.nsSelect.e("selected-item"))
                  }, [
                    W(l, {
                      closable: false,
                      size: e10.collapseTagSize,
                      type: e10.tagType,
                      effect: e10.tagEffect,
                      style: ze(e10.collapseTagStyle),
                      "disable-transitions": ""
                    }, {
                      default: H(() => [
                        B("span", {
                          class: I(e10.nsSelect.e("tags-text"))
                        }, " + " + _e(e10.modelValue.length - e10.maxCollapseTags), 3)
                      ]),
                      _: 1
                    }, 8, ["size", "type", "effect", "style"])
                  ], 2)
                ]),
                content: H(() => [
                  B("div", {
                    ref: "tagMenuRef",
                    class: I(e10.nsSelect.e("selection"))
                  }, [
                    (k(true), x(Ie, null, st(e10.collapseTagList, (f) => (k(), x("div", {
                      key: e10.getValueKey(e10.getValue(f)),
                      class: I(e10.nsSelect.e("selected-item"))
                    }, [
                      W(l, {
                        class: "in-tooltip",
                        closable: !e10.selectDisabled && !e10.getDisabled(f),
                        size: e10.collapseTagSize,
                        type: e10.tagType,
                        effect: e10.tagEffect,
                        "disable-transitions": "",
                        onClose: (p) => e10.deleteTag(p, f)
                      }, {
                        default: H(() => [
                          B("span", {
                            class: I(e10.nsSelect.e("tags-text"))
                          }, [
                            J(e10.$slots, "label", {
                              label: e10.getLabel(f),
                              value: e10.getValue(f)
                            }, () => [
                              Ze(_e(e10.getLabel(f)), 1)
                            ])
                          ], 2)
                        ]),
                        _: 2
                      }, 1032, ["closable", "size", "type", "effect", "onClose"])
                    ], 2))), 128))
                  ], 2)
                ]),
                _: 3
              }, 8, ["disabled", "effect", "teleported"])) : ee("v-if", true)
            ]) : ee("v-if", true),
            B("div", {
              class: I([
                e10.nsSelect.e("selected-item"),
                e10.nsSelect.e("input-wrapper"),
                e10.nsSelect.is("hidden", !e10.filterable)
              ])
            }, [
              lt(B("input", {
                id: e10.inputId,
                ref: "inputRef",
                "onUpdate:modelValue": (f) => e10.states.inputValue = f,
                style: ze(e10.inputStyle),
                autocomplete: e10.autocomplete,
                tabindex: e10.tabindex,
                "aria-autocomplete": "list",
                "aria-haspopup": "listbox",
                autocapitalize: "off",
                "aria-expanded": e10.expanded,
                "aria-label": e10.ariaLabel,
                class: I([e10.nsSelect.e("input"), e10.nsSelect.is(e10.selectSize)]),
                disabled: e10.selectDisabled,
                role: "combobox",
                readonly: !e10.filterable,
                spellcheck: "false",
                type: "text",
                name: e10.name,
                onInput: e10.onInput,
                onCompositionstart: e10.handleCompositionStart,
                onCompositionupdate: e10.handleCompositionUpdate,
                onCompositionend: e10.handleCompositionEnd,
                onKeydown: [
                  Bt(Xe((f) => e10.onKeyboardNavigate("backward"), ["stop", "prevent"]), ["up"]),
                  Bt(Xe((f) => e10.onKeyboardNavigate("forward"), ["stop", "prevent"]), ["down"]),
                  Bt(Xe(e10.onKeyboardSelect, ["stop", "prevent"]), ["enter"]),
                  Bt(Xe(e10.handleEsc, ["stop", "prevent"]), ["esc"]),
                  Bt(Xe(e10.handleDel, ["stop"]), ["delete"])
                ],
                onClick: Xe(e10.toggleMenu, ["stop"])
              }, null, 46, ["id", "onUpdate:modelValue", "autocomplete", "tabindex", "aria-expanded", "aria-label", "disabled", "readonly", "name", "onInput", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onKeydown", "onClick"]), [
                [Qu, e10.states.inputValue]
              ]),
              e10.filterable ? (k(), x("span", {
                key: 0,
                ref: "calculatorRef",
                "aria-hidden": "true",
                class: I(e10.nsSelect.e("input-calculator")),
                textContent: _e(e10.states.inputValue)
              }, null, 10, ["textContent"])) : ee("v-if", true)
            ], 2),
            e10.shouldShowPlaceholder ? (k(), x("div", {
              key: 1,
              class: I([
                e10.nsSelect.e("selected-item"),
                e10.nsSelect.e("placeholder"),
                e10.nsSelect.is("transparent", !e10.hasModelValue || e10.expanded && !e10.states.inputValue)
              ])
            }, [
              e10.hasModelValue ? J(e10.$slots, "label", {
                key: 0,
                label: e10.currentPlaceholder,
                value: e10.modelValue
              }, () => [
                B("span", null, _e(e10.currentPlaceholder), 1)
              ]) : (k(), x("span", { key: 1 }, _e(e10.currentPlaceholder), 1))
            ], 2)) : ee("v-if", true)
          ], 2),
          B("div", {
            ref: "suffixRef",
            class: I(e10.nsSelect.e("suffix"))
          }, [
            e10.iconComponent ? lt((k(), ae(u, {
              key: 0,
              class: I([e10.nsSelect.e("caret"), e10.nsInput.e("icon"), e10.iconReverse])
            }, {
              default: H(() => [
                (k(), ae(ht(e10.iconComponent)))
              ]),
              _: 1
            }, 8, ["class"])), [
              [Nt, !e10.showClearBtn]
            ]) : ee("v-if", true),
            e10.showClearBtn && e10.clearIcon ? (k(), ae(u, {
              key: 1,
              class: I([
                e10.nsSelect.e("caret"),
                e10.nsInput.e("icon"),
                e10.nsSelect.e("clear")
              ]),
              onClick: Xe(e10.handleClear, ["prevent", "stop"])
            }, {
              default: H(() => [
                (k(), ae(ht(e10.clearIcon)))
              ]),
              _: 1
            }, 8, ["class", "onClick"])) : ee("v-if", true),
            e10.validateState && e10.validateIcon && e10.needStatusIcon ? (k(), ae(u, {
              key: 2,
              class: I([
                e10.nsInput.e("icon"),
                e10.nsInput.e("validateIcon"),
                e10.nsInput.is("loading", e10.validateState === "validating")
              ])
            }, {
              default: H(() => [
                (k(), ae(ht(e10.validateIcon)))
              ]),
              _: 1
            }, 8, ["class"])) : ee("v-if", true)
          ], 2)
        ], 10, ["onClick"])
      ]),
      content: H(() => [
        W(c, {
          ref: "menuRef",
          data: e10.filteredOptions,
          width: e10.popperSize,
          "hovering-index": e10.states.hoveringIndex,
          "scrollbar-always-on": e10.scrollbarAlwaysOn
        }, ro({
          default: H((f) => [
            J(e10.$slots, "default", Ao(jr(f)))
          ]),
          _: 2
        }, [
          e10.$slots.header ? {
            name: "header",
            fn: H(() => [
              B("div", {
                class: I(e10.nsSelect.be("dropdown", "header"))
              }, [
                J(e10.$slots, "header")
              ], 2)
            ])
          } : void 0,
          e10.$slots.loading && e10.loading ? {
            name: "loading",
            fn: H(() => [
              B("div", {
                class: I(e10.nsSelect.be("dropdown", "loading"))
              }, [
                J(e10.$slots, "loading")
              ], 2)
            ])
          } : e10.loading || e10.filteredOptions.length === 0 ? {
            name: "empty",
            fn: H(() => [
              B("div", {
                class: I(e10.nsSelect.be("dropdown", "empty"))
              }, [
                J(e10.$slots, "empty", {}, () => [
                  B("span", null, _e(e10.emptyText), 1)
                ])
              ], 2)
            ])
          } : void 0,
          e10.$slots.footer ? {
            name: "footer",
            fn: H(() => [
              B("div", {
                class: I(e10.nsSelect.be("dropdown", "footer"))
              }, [
                J(e10.$slots, "footer")
              ], 2)
            ])
          } : void 0
        ]), 1032, ["data", "width", "hovering-index", "scrollbar-always-on"])
      ]),
      _: 3
    }, 8, ["visible", "teleported", "popper-class", "popper-options", "fallback-placements", "effect", "placement", "transition", "persistent", "append-to", "show-arrow", "offset", "onBeforeShow", "onHide"])
  ], 42, ["onMouseenter", "onMouseleave"])), [
    [d, e10.handleClickOutside, e10.popperRef]
  ]);
}
var jU = /* @__PURE__ */ $e(KU, [["render", WU], ["__file", "select.vue"]]);
const UU = ut(jU), YU = Oe({
  animated: {
    type: Boolean,
    default: false
  },
  count: {
    type: Number,
    default: 1
  },
  rows: {
    type: Number,
    default: 3
  },
  loading: {
    type: Boolean,
    default: true
  },
  throttle: {
    type: ne([Number, Object])
  }
}), qU = Oe({
  variant: {
    type: String,
    values: [
      "circle",
      "rect",
      "h1",
      "h3",
      "text",
      "caption",
      "p",
      "image",
      "button"
    ],
    default: "text"
  }
}), GU = /* @__PURE__ */ j({
  name: "ElSkeletonItem"
}), XU = /* @__PURE__ */ j({
  ...GU,
  props: qU,
  setup(e10) {
    const t = we("skeleton");
    return (n, o) => (k(), x("div", {
      class: I([i(t).e("item"), i(t).e(n.variant)])
    }, [
      n.variant === "image" ? (k(), ae(i(v8), { key: 0 })) : ee("v-if", true)
    ], 2));
  }
});
var gf = /* @__PURE__ */ $e(XU, [["__file", "skeleton-item.vue"]]);
const JU = (e10, t = 0) => {
  if (t === 0)
    return e10;
  const n = at(t) && !!t.initVal, o = L(n);
  let r = null;
  const a = (s) => {
    if (St(s)) {
      o.value = e10.value;
      return;
    }
    r && clearTimeout(r), r = setTimeout(() => {
      o.value = e10.value;
    }, s);
  }, l = (s) => {
    s === "leading" ? Ye(t) ? a(t) : a(t.leading) : at(t) ? a(t.trailing) : o.value = false;
  };
  return dt(() => l("leading")), ge(() => e10.value, (s) => {
    l(s ? "leading" : "trailing");
  }), o;
}, ZU = /* @__PURE__ */ j({
  name: "ElSkeleton"
}), QU = /* @__PURE__ */ j({
  ...ZU,
  props: YU,
  setup(e10, { expose: t }) {
    const n = e10, o = we("skeleton"), r = JU(Lt(n, "loading"), n.throttle);
    return t({
      uiLoading: r
    }), (a, l) => i(r) ? (k(), x("div", vt({
      key: 0,
      class: [i(o).b(), i(o).is("animated", a.animated)]
    }, a.$attrs), [
      (k(true), x(Ie, null, st(a.count, (s) => (k(), x(Ie, { key: s }, [
        i(r) ? J(a.$slots, "template", { key: s }, () => [
          W(gf, {
            class: I(i(o).is("first")),
            variant: "p"
          }, null, 8, ["class"]),
          (k(true), x(Ie, null, st(a.rows, (u) => (k(), ae(gf, {
            key: u,
            class: I([
              i(o).e("paragraph"),
              i(o).is("last", u === a.rows && a.rows > 1)
            ]),
            variant: "p"
          }, null, 8, ["class"]))), 128))
        ]) : ee("v-if", true)
      ], 64))), 128))
    ], 16)) : J(a.$slots, "default", Ao(vt({ key: 1 }, a.$attrs)));
  }
});
var eY = /* @__PURE__ */ $e(QU, [["__file", "skeleton.vue"]]);
const tY = ut(eY, {
  SkeletonItem: gf
}), nY = nn(gf), Jk = Symbol("sliderContextKey"), oY = Oe({
  modelValue: {
    type: ne([Number, Array]),
    default: 0
  },
  id: {
    type: String,
    default: void 0
  },
  min: {
    type: Number,
    default: 0
  },
  max: {
    type: Number,
    default: 100
  },
  step: {
    type: Number,
    default: 1
  },
  showInput: Boolean,
  showInputControls: {
    type: Boolean,
    default: true
  },
  size: _n,
  inputSize: _n,
  showStops: Boolean,
  showTooltip: {
    type: Boolean,
    default: true
  },
  formatTooltip: {
    type: ne(Function),
    default: void 0
  },
  disabled: Boolean,
  range: Boolean,
  vertical: Boolean,
  height: String,
  debounce: {
    type: Number,
    default: 300
  },
  rangeStartLabel: {
    type: String,
    default: void 0
  },
  rangeEndLabel: {
    type: String,
    default: void 0
  },
  formatValueText: {
    type: ne(Function),
    default: void 0
  },
  tooltipClass: {
    type: String,
    default: void 0
  },
  placement: {
    type: String,
    values: Pa,
    default: "top"
  },
  marks: {
    type: ne(Object)
  },
  validateEvent: {
    type: Boolean,
    default: true
  },
  persistent: {
    type: Boolean,
    default: true
  },
  ...Bn(["ariaLabel"])
}), cv = (e10) => Ye(e10) || Se(e10) && e10.every(Ye), rY = {
  [nt]: cv,
  [bn]: cv,
  [gt]: cv
}, aY = Oe({
  modelValue: {
    type: Number,
    default: 0
  },
  vertical: Boolean,
  tooltipClass: String,
  placement: {
    type: String,
    values: Pa,
    default: "top"
  }
}), lY = {
  [nt]: (e10) => Ye(e10)
}, sY = (e10, t, n) => {
  const o = L(), r = L(false), a = S(() => t.value instanceof Function), l = S(() => a.value && t.value(e10.modelValue) || e10.modelValue), s = Oo(() => {
    n.value && (r.value = true);
  }, 50), u = Oo(() => {
    n.value && (r.value = false);
  }, 50);
  return {
    tooltip: o,
    tooltipVisible: r,
    formatValue: l,
    displayTooltip: s,
    hideTooltip: u
  };
}, iY = (e10, t, n) => {
  const {
    disabled: o,
    min: r,
    max: a,
    step: l,
    showTooltip: s,
    persistent: u,
    precision: c,
    sliderSize: d,
    formatTooltip: f,
    emitChange: p,
    resetSize: v,
    updateDragging: m
  } = Le(Jk), { tooltip: h, tooltipVisible: b, formatValue: g, displayTooltip: w, hideTooltip: y } = sY(e10, f, s), _ = L(), C = S(() => `${(e10.modelValue - r.value) / (a.value - r.value) * 100}%`), E = S(() => e10.vertical ? { bottom: C.value } : { left: C.value }), T = () => {
    t.hovering = true, w();
  }, O = () => {
    t.hovering = false, t.dragging || y();
  }, N = (X) => {
    o.value || (X.preventDefault(), V(X), window.addEventListener("mousemove", Z), window.addEventListener("touchmove", Z), window.addEventListener("mouseup", G), window.addEventListener("touchend", G), window.addEventListener("contextmenu", G), _.value.focus());
  }, $ = (X) => {
    o.value || (t.newPosition = Number.parseFloat(C.value) + X / (a.value - r.value) * 100, le(t.newPosition), p());
  }, R = () => {
    $(-l.value);
  }, P = () => {
    $(l.value);
  }, z = () => {
    $(-l.value * 4);
  }, Y = () => {
    $(l.value * 4);
  }, D = () => {
    o.value || (le(0), p());
  }, M = () => {
    o.value || (le(100), p());
  }, F = (X) => {
    let te = true;
    switch (X.code) {
      case xe.left:
      case xe.down:
        R();
        break;
      case xe.right:
      case xe.up:
        P();
        break;
      case xe.home:
        D();
        break;
      case xe.end:
        M();
        break;
      case xe.pageDown:
        z();
        break;
      case xe.pageUp:
        Y();
        break;
      default:
        te = false;
        break;
    }
    te && X.preventDefault();
  }, A = (X) => {
    let te, ce;
    return X.type.startsWith("touch") ? (ce = X.touches[0].clientY, te = X.touches[0].clientX) : (ce = X.clientY, te = X.clientX), {
      clientX: te,
      clientY: ce
    };
  }, V = (X) => {
    t.dragging = true, t.isClick = true;
    const { clientX: te, clientY: ce } = A(X);
    e10.vertical ? t.startY = ce : t.startX = te, t.startPosition = Number.parseFloat(C.value), t.newPosition = t.startPosition;
  }, Z = (X) => {
    if (t.dragging) {
      t.isClick = false, w(), v();
      let te;
      const { clientX: ce, clientY: pe } = A(X);
      e10.vertical ? (t.currentY = pe, te = (t.startY - t.currentY) / d.value * 100) : (t.currentX = ce, te = (t.currentX - t.startX) / d.value * 100), t.newPosition = t.startPosition + te, le(t.newPosition);
    }
  }, G = () => {
    t.dragging && (setTimeout(() => {
      t.dragging = false, t.hovering || y(), t.isClick || le(t.newPosition), p();
    }, 0), window.removeEventListener("mousemove", Z), window.removeEventListener("touchmove", Z), window.removeEventListener("mouseup", G), window.removeEventListener("touchend", G), window.removeEventListener("contextmenu", G));
  }, le = async (X) => {
    if (X === null || Number.isNaN(+X))
      return;
    X < 0 ? X = 0 : X > 100 && (X = 100);
    const te = 100 / ((a.value - r.value) / l.value);
    let pe = Math.round(X / te) * te * (a.value - r.value) * 0.01 + r.value;
    pe = Number.parseFloat(pe.toFixed(c.value)), pe !== e10.modelValue && n(nt, pe), !t.dragging && e10.modelValue !== t.oldValue && (t.oldValue = e10.modelValue), await He(), t.dragging && w(), h.value.updatePopper();
  };
  return ge(() => t.dragging, (X) => {
    m(X);
  }), Ft(_, "touchstart", N, { passive: false }), {
    disabled: o,
    button: _,
    tooltip: h,
    tooltipVisible: b,
    showTooltip: s,
    persistent: u,
    wrapperStyle: E,
    formatValue: g,
    handleMouseEnter: T,
    handleMouseLeave: O,
    onButtonDown: N,
    onKeyDown: F,
    setPosition: le
  };
}, uY = /* @__PURE__ */ j({
  name: "ElSliderButton"
}), cY = /* @__PURE__ */ j({
  ...uY,
  props: aY,
  emits: lY,
  setup(e10, { expose: t, emit: n }) {
    const o = e10, r = we("slider"), a = It({
      hovering: false,
      dragging: false,
      isClick: false,
      startX: 0,
      currentX: 0,
      startY: 0,
      currentY: 0,
      startPosition: 0,
      newPosition: 0,
      oldValue: o.modelValue
    }), l = S(() => d.value ? f.value : false), {
      disabled: s,
      button: u,
      tooltip: c,
      showTooltip: d,
      persistent: f,
      tooltipVisible: p,
      wrapperStyle: v,
      formatValue: m,
      handleMouseEnter: h,
      handleMouseLeave: b,
      onButtonDown: g,
      onKeyDown: w,
      setPosition: y
    } = iY(o, a, n), { hovering: _, dragging: C } = Tn(a);
    return t({
      onButtonDown: g,
      onKeyDown: w,
      setPosition: y,
      hovering: _,
      dragging: C
    }), (E, T) => (k(), x("div", {
      ref_key: "button",
      ref: u,
      class: I([i(r).e("button-wrapper"), { hover: i(_), dragging: i(C) }]),
      style: ze(i(v)),
      tabindex: i(s) ? -1 : 0,
      onMouseenter: i(h),
      onMouseleave: i(b),
      onMousedown: i(g),
      onFocus: i(h),
      onBlur: i(b),
      onKeydown: i(w)
    }, [
      W(i(Un), {
        ref_key: "tooltip",
        ref: c,
        visible: i(p),
        placement: E.placement,
        "fallback-placements": ["top", "bottom", "right", "left"],
        "stop-popper-mouse-event": false,
        "popper-class": E.tooltipClass,
        disabled: !i(d),
        persistent: i(l)
      }, {
        content: H(() => [
          B("span", null, _e(i(m)), 1)
        ]),
        default: H(() => [
          B("div", {
            class: I([i(r).e("button"), { hover: i(_), dragging: i(C) }])
          }, null, 2)
        ]),
        _: 1
      }, 8, ["visible", "placement", "popper-class", "disabled", "persistent"])
    ], 46, ["tabindex", "onMouseenter", "onMouseleave", "onMousedown", "onFocus", "onBlur", "onKeydown"]));
  }
});
var Y1 = /* @__PURE__ */ $e(cY, [["__file", "button.vue"]]);
const dY = Oe({
  mark: {
    type: ne([String, Object]),
    default: void 0
  }
});
var fY = /* @__PURE__ */ j({
  name: "ElSliderMarker",
  props: dY,
  setup(e10) {
    const t = we("slider"), n = S(() => Ve(e10.mark) ? e10.mark : e10.mark.label), o = S(() => Ve(e10.mark) ? void 0 : e10.mark.style);
    return () => Ke("div", {
      class: t.e("marks-text"),
      style: o.value
    }, n.value);
  }
});
const pY = (e10, t, n) => {
  const { form: o, formItem: r } = Yn(), a = qt(), l = L(), s = L(), u = {
    firstButton: l,
    secondButton: s
  }, c = S(() => e10.disabled || (o == null ? void 0 : o.disabled) || false), d = S(() => Math.min(t.firstValue, t.secondValue)), f = S(() => Math.max(t.firstValue, t.secondValue)), p = S(() => e10.range ? `${100 * (f.value - d.value) / (e10.max - e10.min)}%` : `${100 * (t.firstValue - e10.min) / (e10.max - e10.min)}%`), v = S(() => e10.range ? `${100 * (d.value - e10.min) / (e10.max - e10.min)}%` : "0%"), m = S(() => e10.vertical ? { height: e10.height } : {}), h = S(() => e10.vertical ? {
    height: p.value,
    bottom: v.value
  } : {
    width: p.value,
    left: v.value
  }), b = () => {
    a.value && (t.sliderSize = a.value[`client${e10.vertical ? "Height" : "Width"}`]);
  }, g = (P) => {
    const z = e10.min + P * (e10.max - e10.min) / 100;
    if (!e10.range)
      return l;
    let Y;
    return Math.abs(d.value - z) < Math.abs(f.value - z) ? Y = t.firstValue < t.secondValue ? "firstButton" : "secondButton" : Y = t.firstValue > t.secondValue ? "firstButton" : "secondButton", u[Y];
  }, w = (P) => {
    const z = g(P);
    return z.value.setPosition(P), z;
  }, y = (P) => {
    t.firstValue = P != null ? P : e10.min, C(e10.range ? [d.value, f.value] : P != null ? P : e10.min);
  }, _ = (P) => {
    t.secondValue = P, e10.range && C([d.value, f.value]);
  }, C = (P) => {
    n(nt, P), n(bn, P);
  }, E = async () => {
    await He(), n(gt, e10.range ? [d.value, f.value] : e10.modelValue);
  }, T = (P) => {
    var z, Y, D, M, F, A;
    if (c.value || t.dragging)
      return;
    b();
    let V = 0;
    if (e10.vertical) {
      const Z = (D = (Y = (z = P.touches) == null ? void 0 : z.item(0)) == null ? void 0 : Y.clientY) != null ? D : P.clientY;
      V = (a.value.getBoundingClientRect().bottom - Z) / t.sliderSize * 100;
    } else {
      const Z = (A = (F = (M = P.touches) == null ? void 0 : M.item(0)) == null ? void 0 : F.clientX) != null ? A : P.clientX, G = a.value.getBoundingClientRect().left;
      V = (Z - G) / t.sliderSize * 100;
    }
    if (!(V < 0 || V > 100))
      return w(V);
  };
  return {
    elFormItem: r,
    slider: a,
    firstButton: l,
    secondButton: s,
    sliderDisabled: c,
    minValue: d,
    maxValue: f,
    runwayStyle: m,
    barStyle: h,
    resetSize: b,
    setPosition: w,
    emitChange: E,
    onSliderWrapperPrevent: (P) => {
      var z, Y;
      ((z = u.firstButton.value) != null && z.dragging || (Y = u.secondButton.value) != null && Y.dragging) && P.preventDefault();
    },
    onSliderClick: (P) => {
      T(P) && E();
    },
    onSliderDown: async (P) => {
      const z = T(P);
      z && (await He(), z.value.onButtonDown(P));
    },
    onSliderMarkerDown: (P) => {
      if (c.value || t.dragging)
        return;
      w(P) && E();
    },
    setFirstValue: y,
    setSecondValue: _
  };
}, vY = (e10, t, n, o) => ({
  stops: S(() => {
    if (!e10.showStops || e10.min > e10.max)
      return [];
    if (e10.step === 0)
      return _t("ElSlider", "step should not be 0."), [];
    const l = (e10.max - e10.min) / e10.step, s = 100 * e10.step / (e10.max - e10.min), u = Array.from({ length: l - 1 }).map((c, d) => (d + 1) * s);
    return e10.range ? u.filter((c) => c < 100 * (n.value - e10.min) / (e10.max - e10.min) || c > 100 * (o.value - e10.min) / (e10.max - e10.min)) : u.filter((c) => c > 100 * (t.firstValue - e10.min) / (e10.max - e10.min));
  }),
  getStopStyle: (l) => e10.vertical ? { bottom: `${l}%` } : { left: `${l}%` }
}), hY = (e10) => S(() => e10.marks ? Object.keys(e10.marks).map(Number.parseFloat).sort((n, o) => n - o).filter((n) => n <= e10.max && n >= e10.min).map((n) => ({
  point: n,
  position: (n - e10.min) * 100 / (e10.max - e10.min),
  mark: e10.marks[n]
})) : []), mY = (e10, t, n, o, r, a) => {
  const l = (c) => {
    r(nt, c), r(bn, c);
  }, s = () => e10.range ? ![n.value, o.value].every((c, d) => c === t.oldValue[d]) : e10.modelValue !== t.oldValue, u = () => {
    var c, d;
    e10.min > e10.max && Qt("Slider", "min should not be greater than max.");
    const f = e10.modelValue;
    e10.range && Se(f) ? f[1] < e10.min ? l([e10.min, e10.min]) : f[0] > e10.max ? l([e10.max, e10.max]) : f[0] < e10.min ? l([e10.min, f[1]]) : f[1] > e10.max ? l([f[0], e10.max]) : (t.firstValue = f[0], t.secondValue = f[1], s() && (e10.validateEvent && ((c = a == null ? void 0 : a.validate) == null || c.call(a, "change").catch((p) => _t(p))), t.oldValue = f.slice())) : !e10.range && Ye(f) && !Number.isNaN(f) && (f < e10.min ? l(e10.min) : f > e10.max ? l(e10.max) : (t.firstValue = f, s() && (e10.validateEvent && ((d = a == null ? void 0 : a.validate) == null || d.call(a, "change").catch((p) => _t(p))), t.oldValue = f)));
  };
  u(), ge(() => t.dragging, (c) => {
    c || u();
  }), ge(() => e10.modelValue, (c, d) => {
    t.dragging || Se(c) && Se(d) && c.every((f, p) => f === d[p]) && t.firstValue === c[0] && t.secondValue === c[1] || u();
  }, {
    deep: true
  }), ge(() => [e10.min, e10.max], () => {
    u();
  });
}, gY = (e10, t, n) => {
  const o = L();
  return dt(async () => {
    e10.range ? (Se(e10.modelValue) ? (t.firstValue = Math.max(e10.min, e10.modelValue[0]), t.secondValue = Math.min(e10.max, e10.modelValue[1])) : (t.firstValue = e10.min, t.secondValue = e10.max), t.oldValue = [t.firstValue, t.secondValue]) : (!Ye(e10.modelValue) || Number.isNaN(e10.modelValue) ? t.firstValue = e10.min : t.firstValue = Math.min(e10.max, Math.max(e10.min, e10.modelValue)), t.oldValue = t.firstValue), Ft(window, "resize", n), await He(), n();
  }), {
    sliderWrapper: o
  };
}, yY = /* @__PURE__ */ j({
  name: "ElSlider"
}), bY = /* @__PURE__ */ j({
  ...yY,
  props: oY,
  emits: rY,
  setup(e10, { expose: t, emit: n }) {
    const o = e10, r = we("slider"), { t: a } = kt(), l = It({
      firstValue: 0,
      secondValue: 0,
      oldValue: 0,
      dragging: false,
      sliderSize: 1
    }), {
      elFormItem: s,
      slider: u,
      firstButton: c,
      secondButton: d,
      sliderDisabled: f,
      minValue: p,
      maxValue: v,
      runwayStyle: m,
      barStyle: h,
      resetSize: b,
      emitChange: g,
      onSliderWrapperPrevent: w,
      onSliderClick: y,
      onSliderDown: _,
      onSliderMarkerDown: C,
      setFirstValue: E,
      setSecondValue: T
    } = pY(o, l, n), { stops: O, getStopStyle: N } = vY(o, l, p, v), { inputId: $, isLabeledByFormItem: R } = tr(o, {
      formItemContext: s
    }), P = yn(), z = S(() => o.inputSize || P.value), Y = S(() => o.ariaLabel || a("el.slider.defaultLabel", {
      min: o.min,
      max: o.max
    })), D = S(() => o.range ? o.rangeStartLabel || a("el.slider.defaultRangeStartLabel") : Y.value), M = S(() => o.formatValueText ? o.formatValueText(X.value) : `${X.value}`), F = S(() => o.rangeEndLabel || a("el.slider.defaultRangeEndLabel")), A = S(() => o.formatValueText ? o.formatValueText(te.value) : `${te.value}`), V = S(() => [
      r.b(),
      r.m(P.value),
      r.is("vertical", o.vertical),
      { [r.m("with-input")]: o.showInput }
    ]), Z = hY(o);
    mY(o, l, p, v, n, s);
    const G = S(() => {
      const se = [o.min, o.max, o.step].map((ve) => {
        const me = `${ve}`.split(".")[1];
        return me ? me.length : 0;
      });
      return Math.max.apply(null, se);
    }), { sliderWrapper: le } = gY(o, l, b), { firstValue: X, secondValue: te, sliderSize: ce } = Tn(l), pe = (se) => {
      l.dragging = se;
    };
    return Ft(le, "touchstart", w, {
      passive: false
    }), Ft(le, "touchmove", w, {
      passive: false
    }), yt(Jk, {
      ...Tn(o),
      sliderSize: ce,
      disabled: f,
      precision: G,
      emitChange: g,
      resetSize: b,
      updateDragging: pe
    }), t({
      onSliderClick: y
    }), (se, ve) => {
      var me, De;
      return k(), x("div", {
        id: se.range ? i($) : void 0,
        ref_key: "sliderWrapper",
        ref: le,
        class: I(i(V)),
        role: se.range ? "group" : void 0,
        "aria-label": se.range && !i(R) ? i(Y) : void 0,
        "aria-labelledby": se.range && i(R) ? (me = i(s)) == null ? void 0 : me.labelId : void 0
      }, [
        B("div", {
          ref_key: "slider",
          ref: u,
          class: I([
            i(r).e("runway"),
            { "show-input": se.showInput && !se.range },
            i(r).is("disabled", i(f))
          ]),
          style: ze(i(m)),
          onMousedown: i(_),
          onTouchstartPassive: i(_)
        }, [
          B("div", {
            class: I(i(r).e("bar")),
            style: ze(i(h))
          }, null, 6),
          W(Y1, {
            id: se.range ? void 0 : i($),
            ref_key: "firstButton",
            ref: c,
            "model-value": i(X),
            vertical: se.vertical,
            "tooltip-class": se.tooltipClass,
            placement: se.placement,
            role: "slider",
            "aria-label": se.range || !i(R) ? i(D) : void 0,
            "aria-labelledby": !se.range && i(R) ? (De = i(s)) == null ? void 0 : De.labelId : void 0,
            "aria-valuemin": se.min,
            "aria-valuemax": se.range ? i(te) : se.max,
            "aria-valuenow": i(X),
            "aria-valuetext": i(M),
            "aria-orientation": se.vertical ? "vertical" : "horizontal",
            "aria-disabled": i(f),
            "onUpdate:modelValue": i(E)
          }, null, 8, ["id", "model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-labelledby", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"]),
          se.range ? (k(), ae(Y1, {
            key: 0,
            ref_key: "secondButton",
            ref: d,
            "model-value": i(te),
            vertical: se.vertical,
            "tooltip-class": se.tooltipClass,
            placement: se.placement,
            role: "slider",
            "aria-label": i(F),
            "aria-valuemin": i(X),
            "aria-valuemax": se.max,
            "aria-valuenow": i(te),
            "aria-valuetext": i(A),
            "aria-orientation": se.vertical ? "vertical" : "horizontal",
            "aria-disabled": i(f),
            "onUpdate:modelValue": i(T)
          }, null, 8, ["model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"])) : ee("v-if", true),
          se.showStops ? (k(), x("div", { key: 1 }, [
            (k(true), x(Ie, null, st(i(O), (Te, de) => (k(), x("div", {
              key: de,
              class: I(i(r).e("stop")),
              style: ze(i(N)(Te))
            }, null, 6))), 128))
          ])) : ee("v-if", true),
          i(Z).length > 0 ? (k(), x(Ie, { key: 2 }, [
            B("div", null, [
              (k(true), x(Ie, null, st(i(Z), (Te, de) => (k(), x("div", {
                key: de,
                style: ze(i(N)(Te.position)),
                class: I([i(r).e("stop"), i(r).e("marks-stop")])
              }, null, 6))), 128))
            ]),
            B("div", {
              class: I(i(r).e("marks"))
            }, [
              (k(true), x(Ie, null, st(i(Z), (Te, de) => (k(), ae(i(fY), {
                key: de,
                mark: Te.mark,
                style: ze(i(N)(Te.position)),
                onMousedown: Xe((U) => i(C)(Te.position), ["stop"])
              }, null, 8, ["mark", "style", "onMousedown"]))), 128))
            ], 2)
          ], 64)) : ee("v-if", true)
        ], 46, ["onMousedown", "onTouchstartPassive"]),
        se.showInput && !se.range ? (k(), ae(i(Ik), {
          key: 0,
          ref: "input",
          "model-value": i(X),
          class: I(i(r).e("input")),
          step: se.step,
          disabled: i(f),
          controls: se.showInputControls,
          min: se.min,
          max: se.max,
          precision: i(G),
          debounce: se.debounce,
          size: i(z),
          "onUpdate:modelValue": i(E),
          onChange: i(g)
        }, null, 8, ["model-value", "class", "step", "disabled", "controls", "min", "max", "precision", "debounce", "size", "onUpdate:modelValue", "onChange"])) : ee("v-if", true)
      ], 10, ["id", "role", "aria-label", "aria-labelledby"]);
    };
  }
});
var _Y = /* @__PURE__ */ $e(bY, [["__file", "slider.vue"]]);
const wY = ut(_Y), CY = Oe({
  prefixCls: {
    type: String
  }
}), q1 = /* @__PURE__ */ j({
  name: "ElSpaceItem",
  props: CY,
  setup(e10, { slots: t }) {
    const n = we("space"), o = S(() => `${e10.prefixCls || n.b()}__item`);
    return () => Ke("div", { class: o.value }, J(t, "default"));
  }
}), G1 = {
  small: 8,
  default: 12,
  large: 16
};
function EY(e10) {
  const t = we("space"), n = S(() => [t.b(), t.m(e10.direction), e10.class]), o = L(0), r = L(0), a = S(() => {
    const s = e10.wrap || e10.fill ? { flexWrap: "wrap" } : {}, u = {
      alignItems: e10.alignment
    }, c = {
      rowGap: `${r.value}px`,
      columnGap: `${o.value}px`
    };
    return [s, u, c, e10.style];
  }), l = S(() => e10.fill ? { flexGrow: 1, minWidth: `${e10.fillRatio}%` } : {});
  return Vn(() => {
    const { size: s = "small", wrap: u, direction: c, fill: d } = e10;
    if (Se(s)) {
      const [f = 0, p = 0] = s;
      o.value = f, r.value = p;
    } else {
      let f;
      Ye(s) ? f = s : f = G1[s || "small"] || G1.small, (u || d) && c === "horizontal" ? o.value = r.value = f : c === "horizontal" ? (o.value = f, r.value = 0) : (r.value = f, o.value = 0);
    }
  }), {
    classes: n,
    containerStyle: a,
    itemStyle: l
  };
}
const SY = Oe({
  direction: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "horizontal"
  },
  class: {
    type: ne([
      String,
      Object,
      Array
    ]),
    default: ""
  },
  style: {
    type: ne([String, Array, Object]),
    default: ""
  },
  alignment: {
    type: ne(String),
    default: "center"
  },
  prefixCls: {
    type: String
  },
  spacer: {
    type: ne([Object, String, Number, Array]),
    default: null,
    validator: (e10) => Ut(e10) || Ye(e10) || Ve(e10)
  },
  wrap: Boolean,
  fill: Boolean,
  fillRatio: {
    type: Number,
    default: 100
  },
  size: {
    type: [String, Array, Number],
    values: Qr,
    validator: (e10) => Ye(e10) || Se(e10) && e10.length === 2 && e10.every(Ye)
  }
}), kY = /* @__PURE__ */ j({
  name: "ElSpace",
  props: SY,
  setup(e10, { slots: t }) {
    const { classes: n, containerStyle: o, itemStyle: r } = EY(e10);
    function a(l, s = "", u = []) {
      const { prefixCls: c } = e10;
      return l.forEach((d, f) => {
        th(d) ? Se(d.children) && d.children.forEach((p, v) => {
          th(p) && Se(p.children) ? a(p.children, `${s + v}-`, u) : Ut(p) && (p == null ? void 0 : p.type) === tn ? u.push(p) : u.push(W(q1, {
            style: r.value,
            prefixCls: c,
            key: `nested-${s + v}`
          }, {
            default: () => [p]
          }, zo.PROPS | zo.STYLE, ["style", "prefixCls"]));
        }) : i5(d) ? u.push(W(q1, {
          style: r.value,
          prefixCls: c,
          key: `LoopKey${s + f}`
        }, {
          default: () => [d]
        }, zo.PROPS | zo.STYLE, ["style", "prefixCls"])) : Ut(d) && d.type === tn && u.push(d);
      }), u;
    }
    return () => {
      var l;
      const { spacer: s, direction: u } = e10, c = J(t, "default", { key: 0 }, () => []);
      if (((l = c.children) != null ? l : []).length === 0)
        return null;
      if (Se(c.children)) {
        let d = a(c.children);
        if (s) {
          const f = d.length - 1;
          d = d.reduce((p, v, m) => {
            const h = [...p, v];
            return m !== f && h.push(W("span", {
              style: [
                r.value,
                u === "vertical" ? "width: 100%" : null
              ],
              key: m
            }, [
              Ut(s) ? s : Ze(s, zo.TEXT)
            ], zo.STYLE)), h;
          }, []);
        }
        return W("div", {
          class: n.value,
          style: o.value
        }, d, zo.STYLE | zo.CLASS);
      }
      return c.children;
    };
  }
}), NY = ut(kY), TY = Oe({
  decimalSeparator: {
    type: String,
    default: "."
  },
  groupSeparator: {
    type: String,
    default: ","
  },
  precision: {
    type: Number,
    default: 0
  },
  formatter: Function,
  value: {
    type: ne([Number, Object]),
    default: 0
  },
  prefix: String,
  suffix: String,
  title: String,
  valueStyle: {
    type: ne([String, Object, Array])
  }
}), OY = /* @__PURE__ */ j({
  name: "ElStatistic"
}), $Y = /* @__PURE__ */ j({
  ...OY,
  props: TY,
  setup(e10, { expose: t }) {
    const n = e10, o = we("statistic"), r = S(() => {
      const { value: a, formatter: l, precision: s, decimalSeparator: u, groupSeparator: c } = n;
      if (Fe(l))
        return l(a);
      if (!Ye(a) || Number.isNaN(a))
        return a;
      let [d, f = ""] = String(a).split(".");
      return f = f.padEnd(s, "0").slice(0, s > 0 ? s : 0), d = d.replace(/\B(?=(\d{3})+(?!\d))/g, c), [d, f].join(f ? u : "");
    });
    return t({
      displayValue: r
    }), (a, l) => (k(), x("div", {
      class: I(i(o).b())
    }, [
      a.$slots.title || a.title ? (k(), x("div", {
        key: 0,
        class: I(i(o).e("head"))
      }, [
        J(a.$slots, "title", {}, () => [
          Ze(_e(a.title), 1)
        ])
      ], 2)) : ee("v-if", true),
      B("div", {
        class: I(i(o).e("content"))
      }, [
        a.$slots.prefix || a.prefix ? (k(), x("div", {
          key: 0,
          class: I(i(o).e("prefix"))
        }, [
          J(a.$slots, "prefix", {}, () => [
            B("span", null, _e(a.prefix), 1)
          ])
        ], 2)) : ee("v-if", true),
        B("span", {
          class: I(i(o).e("number")),
          style: ze(a.valueStyle)
        }, _e(i(r)), 7),
        a.$slots.suffix || a.suffix ? (k(), x("div", {
          key: 1,
          class: I(i(o).e("suffix"))
        }, [
          J(a.$slots, "suffix", {}, () => [
            B("span", null, _e(a.suffix), 1)
          ])
        ], 2)) : ee("v-if", true)
      ], 2)
    ], 2));
  }
});
var IY = /* @__PURE__ */ $e($Y, [["__file", "statistic.vue"]]);
const Zk = ut(IY), MY = Oe({
  format: {
    type: String,
    default: "HH:mm:ss"
  },
  prefix: String,
  suffix: String,
  title: String,
  value: {
    type: ne([Number, Object]),
    default: 0
  },
  valueStyle: {
    type: ne([String, Object, Array])
  }
}), PY = {
  finish: () => true,
  [gt]: (e10) => Ye(e10)
}, RY = [
  ["Y", 1e3 * 60 * 60 * 24 * 365],
  ["M", 1e3 * 60 * 60 * 24 * 30],
  ["D", 1e3 * 60 * 60 * 24],
  ["H", 1e3 * 60 * 60],
  ["m", 1e3 * 60],
  ["s", 1e3],
  ["S", 1]
], X1 = (e10) => Ye(e10) ? new Date(e10).getTime() : e10.valueOf(), J1 = (e10, t) => {
  let n = e10;
  const o = /\[([^\]]*)]/g;
  return RY.reduce((a, [l, s]) => {
    const u = new RegExp(`${l}+(?![^\\[\\]]*\\])`, "g");
    if (u.test(a)) {
      const c = Math.floor(n / s);
      return n -= c * s, a.replace(u, (d) => String(c).padStart(d.length, "0"));
    }
    return a;
  }, t).replace(o, "$1");
}, AY = /* @__PURE__ */ j({
  name: "ElCountdown"
}), LY = /* @__PURE__ */ j({
  ...AY,
  props: MY,
  emits: PY,
  setup(e10, { expose: t, emit: n }) {
    const o = e10;
    let r;
    const a = L(0), l = S(() => J1(a.value, o.format)), s = (d) => J1(d, o.format), u = () => {
      r && (Jl(r), r = void 0);
    }, c = () => {
      const d = X1(o.value), f = () => {
        let p = d - Date.now();
        n(gt, p), p <= 0 ? (p = 0, u(), n("finish")) : r = sl(f), a.value = p;
      };
      r = sl(f);
    };
    return dt(() => {
      a.value = X1(o.value) - Date.now(), ge(() => [o.value, o.format], () => {
        u(), c();
      }, {
        immediate: true
      });
    }), jt(() => {
      u();
    }), t({
      displayValue: l
    }), (d, f) => (k(), ae(i(Zk), {
      value: a.value,
      title: d.title,
      prefix: d.prefix,
      suffix: d.suffix,
      "value-style": d.valueStyle,
      formatter: s
    }, ro({
      _: 2
    }, [
      st(d.$slots, (p, v) => ({
        name: v,
        fn: H(() => [
          J(d.$slots, v)
        ])
      }))
    ]), 1032, ["value", "title", "prefix", "suffix", "value-style"]));
  }
});
var xY = /* @__PURE__ */ $e(LY, [["__file", "countdown.vue"]]);
const DY = ut(xY), VY = Oe({
  space: {
    type: [Number, String],
    default: ""
  },
  active: {
    type: Number,
    default: 0
  },
  direction: {
    type: String,
    default: "horizontal",
    values: ["horizontal", "vertical"]
  },
  alignCenter: {
    type: Boolean
  },
  simple: {
    type: Boolean
  },
  finishStatus: {
    type: String,
    values: ["wait", "process", "finish", "error", "success"],
    default: "finish"
  },
  processStatus: {
    type: String,
    values: ["wait", "process", "finish", "error", "success"],
    default: "process"
  }
}), FY = {
  [gt]: (e10, t) => [e10, t].every(Ye)
}, Qk = "ElSteps", BY = /* @__PURE__ */ j({
  name: "ElSteps"
}), HY = /* @__PURE__ */ j({
  ...BY,
  props: VY,
  emits: FY,
  setup(e10, { emit: t }) {
    const n = e10, o = we("steps"), {
      children: r,
      addChild: a,
      removeChild: l
    } = ap(it(), "ElStep");
    return ge(r, () => {
      r.value.forEach((s, u) => {
        s.setIndex(u);
      });
    }), yt(Qk, { props: n, steps: r, addStep: a, removeStep: l }), ge(() => n.active, (s, u) => {
      t(gt, s, u);
    }), (s, u) => (k(), x("div", {
      class: I([i(o).b(), i(o).m(s.simple ? "simple" : s.direction)])
    }, [
      J(s.$slots, "default")
    ], 2));
  }
});
var zY = /* @__PURE__ */ $e(HY, [["__file", "steps.vue"]]);
const KY = Oe({
  title: {
    type: String,
    default: ""
  },
  icon: {
    type: Ht
  },
  description: {
    type: String,
    default: ""
  },
  status: {
    type: String,
    values: ["", "wait", "process", "finish", "error", "success"],
    default: ""
  }
}), WY = /* @__PURE__ */ j({
  name: "ElStep"
}), jY = /* @__PURE__ */ j({
  ...WY,
  props: KY,
  setup(e10) {
    const t = e10, n = we("step"), o = L(-1), r = L({}), a = L(""), l = Le(Qk), s = it();
    dt(() => {
      ge([
        () => l.props.active,
        () => l.props.processStatus,
        () => l.props.finishStatus
      ], ([E]) => {
        _(E);
      }, { immediate: true });
    }), jt(() => {
      l.removeStep(C.uid);
    });
    const u = S(() => t.status || a.value), c = S(() => {
      const E = l.steps.value[o.value - 1];
      return E ? E.currentStatus : "wait";
    }), d = S(() => l.props.alignCenter), f = S(() => l.props.direction === "vertical"), p = S(() => l.props.simple), v = S(() => l.steps.value.length), m = S(() => {
      var E;
      return ((E = l.steps.value[v.value - 1]) == null ? void 0 : E.uid) === (s == null ? void 0 : s.uid);
    }), h = S(() => p.value ? "" : l.props.space), b = S(() => [
      n.b(),
      n.is(p.value ? "simple" : l.props.direction),
      n.is("flex", m.value && !h.value && !d.value),
      n.is("center", d.value && !f.value && !p.value)
    ]), g = S(() => {
      const E = {
        flexBasis: Ye(h.value) ? `${h.value}px` : h.value ? h.value : `${100 / (v.value - (d.value ? 0 : 1))}%`
      };
      return f.value || m.value && (E.maxWidth = `${100 / v.value}%`), E;
    }), w = (E) => {
      o.value = E;
    }, y = (E) => {
      const T = E === "wait", O = {
        transitionDelay: `${T ? "-" : ""}${150 * o.value}ms`
      }, N = E === l.props.processStatus || T ? 0 : 100;
      O.borderWidth = N && !p.value ? "1px" : 0, O[l.props.direction === "vertical" ? "height" : "width"] = `${N}%`, r.value = O;
    }, _ = (E) => {
      E > o.value ? a.value = l.props.finishStatus : E === o.value && c.value !== "error" ? a.value = l.props.processStatus : a.value = "wait";
      const T = l.steps.value[o.value - 1];
      T && T.calcProgress(a.value);
    }, C = It({
      uid: s.uid,
      currentStatus: u,
      setIndex: w,
      calcProgress: y
    });
    return l.addStep(C), (E, T) => (k(), x("div", {
      style: ze(i(g)),
      class: I(i(b))
    }, [
      ee(" icon & line "),
      B("div", {
        class: I([i(n).e("head"), i(n).is(i(u))])
      }, [
        i(p) ? ee("v-if", true) : (k(), x("div", {
          key: 0,
          class: I(i(n).e("line"))
        }, [
          B("i", {
            class: I(i(n).e("line-inner")),
            style: ze(r.value)
          }, null, 6)
        ], 2)),
        B("div", {
          class: I([i(n).e("icon"), i(n).is(E.icon || E.$slots.icon ? "icon" : "text")])
        }, [
          J(E.$slots, "icon", {}, () => [
            E.icon ? (k(), ae(i(Be), {
              key: 0,
              class: I(i(n).e("icon-inner"))
            }, {
              default: H(() => [
                (k(), ae(ht(E.icon)))
              ]),
              _: 1
            }, 8, ["class"])) : i(u) === "success" ? (k(), ae(i(Be), {
              key: 1,
              class: I([i(n).e("icon-inner"), i(n).is("status")])
            }, {
              default: H(() => [
                W(i(sc))
              ]),
              _: 1
            }, 8, ["class"])) : i(u) === "error" ? (k(), ae(i(Be), {
              key: 2,
              class: I([i(n).e("icon-inner"), i(n).is("status")])
            }, {
              default: H(() => [
                W(i(Jo))
              ]),
              _: 1
            }, 8, ["class"])) : i(p) ? ee("v-if", true) : (k(), x("div", {
              key: 3,
              class: I(i(n).e("icon-inner"))
            }, _e(o.value + 1), 3))
          ])
        ], 2)
      ], 2),
      ee(" title & description "),
      B("div", {
        class: I(i(n).e("main"))
      }, [
        B("div", {
          class: I([i(n).e("title"), i(n).is(i(u))])
        }, [
          J(E.$slots, "title", {}, () => [
            Ze(_e(E.title), 1)
          ])
        ], 2),
        i(p) ? (k(), x("div", {
          key: 0,
          class: I(i(n).e("arrow"))
        }, null, 2)) : (k(), x("div", {
          key: 1,
          class: I([i(n).e("description"), i(n).is(i(u))])
        }, [
          J(E.$slots, "description", {}, () => [
            Ze(_e(E.description), 1)
          ])
        ], 2))
      ], 2)
    ], 6));
  }
});
var eN = /* @__PURE__ */ $e(jY, [["__file", "item.vue"]]);
const UY = ut(zY, {
  Step: eN
}), YY = nn(eN), tN = (e10) => ["", ...Qr].includes(e10), qY = Oe({
  modelValue: {
    type: [Boolean, String, Number],
    default: false
  },
  disabled: Boolean,
  loading: Boolean,
  size: {
    type: String,
    validator: tN
  },
  width: {
    type: [String, Number],
    default: ""
  },
  inlinePrompt: Boolean,
  inactiveActionIcon: {
    type: Ht
  },
  activeActionIcon: {
    type: Ht
  },
  activeIcon: {
    type: Ht
  },
  inactiveIcon: {
    type: Ht
  },
  activeText: {
    type: String,
    default: ""
  },
  inactiveText: {
    type: String,
    default: ""
  },
  activeValue: {
    type: [Boolean, String, Number],
    default: true
  },
  inactiveValue: {
    type: [Boolean, String, Number],
    default: false
  },
  name: {
    type: String,
    default: ""
  },
  validateEvent: {
    type: Boolean,
    default: true
  },
  beforeChange: {
    type: ne(Function)
  },
  id: String,
  tabindex: {
    type: [String, Number]
  },
  ...Bn(["ariaLabel"])
}), GY = {
  [nt]: (e10) => Vt(e10) || Ve(e10) || Ye(e10),
  [gt]: (e10) => Vt(e10) || Ve(e10) || Ye(e10),
  [bn]: (e10) => Vt(e10) || Ve(e10) || Ye(e10)
}, Ch = "ElSwitch", XY = /* @__PURE__ */ j({
  name: Ch
}), JY = /* @__PURE__ */ j({
  ...XY,
  props: qY,
  emits: GY,
  setup(e10, { expose: t, emit: n }) {
    const o = e10, { formItem: r } = Yn(), a = yn(), l = we("switch"), { inputId: s } = tr(o, {
      formItemContext: r
    }), u = Hn(S(() => o.loading)), c = L(o.modelValue !== false), d = L(), f = L(), p = S(() => [
      l.b(),
      l.m(a.value),
      l.is("disabled", u.value),
      l.is("checked", g.value)
    ]), v = S(() => [
      l.e("label"),
      l.em("label", "left"),
      l.is("active", !g.value)
    ]), m = S(() => [
      l.e("label"),
      l.em("label", "right"),
      l.is("active", g.value)
    ]), h = S(() => ({
      width: sn(o.width)
    }));
    ge(() => o.modelValue, () => {
      c.value = true;
    });
    const b = S(() => c.value ? o.modelValue : false), g = S(() => b.value === o.activeValue);
    [o.activeValue, o.inactiveValue].includes(b.value) || (n(nt, o.inactiveValue), n(gt, o.inactiveValue), n(bn, o.inactiveValue)), ge(g, (C) => {
      var E;
      d.value.checked = C, o.validateEvent && ((E = r == null ? void 0 : r.validate) == null || E.call(r, "change").catch((T) => _t(T)));
    });
    const w = () => {
      const C = g.value ? o.inactiveValue : o.activeValue;
      n(nt, C), n(gt, C), n(bn, C), He(() => {
        d.value.checked = g.value;
      });
    }, y = () => {
      if (u.value)
        return;
      const { beforeChange: C } = o;
      if (!C) {
        w();
        return;
      }
      const E = C();
      [
        ol(E),
        Vt(E)
      ].includes(true) || Qt(Ch, "beforeChange must return type `Promise<boolean>` or `boolean`"), ol(E) ? E.then((O) => {
        O && w();
      }).catch((O) => {
        _t(Ch, `some error occurred: ${O}`);
      }) : E && w();
    }, _ = () => {
      var C, E;
      (E = (C = d.value) == null ? void 0 : C.focus) == null || E.call(C);
    };
    return dt(() => {
      d.value.checked = g.value;
    }), t({
      focus: _,
      checked: g
    }), (C, E) => (k(), x("div", {
      class: I(i(p)),
      onClick: Xe(y, ["prevent"])
    }, [
      B("input", {
        id: i(s),
        ref_key: "input",
        ref: d,
        class: I(i(l).e("input")),
        type: "checkbox",
        role: "switch",
        "aria-checked": i(g),
        "aria-disabled": i(u),
        "aria-label": C.ariaLabel,
        name: C.name,
        "true-value": C.activeValue,
        "false-value": C.inactiveValue,
        disabled: i(u),
        tabindex: C.tabindex,
        onChange: w,
        onKeydown: Bt(y, ["enter"])
      }, null, 42, ["id", "aria-checked", "aria-disabled", "aria-label", "name", "true-value", "false-value", "disabled", "tabindex", "onKeydown"]),
      !C.inlinePrompt && (C.inactiveIcon || C.inactiveText) ? (k(), x("span", {
        key: 0,
        class: I(i(v))
      }, [
        C.inactiveIcon ? (k(), ae(i(Be), { key: 0 }, {
          default: H(() => [
            (k(), ae(ht(C.inactiveIcon)))
          ]),
          _: 1
        })) : ee("v-if", true),
        !C.inactiveIcon && C.inactiveText ? (k(), x("span", {
          key: 1,
          "aria-hidden": i(g)
        }, _e(C.inactiveText), 9, ["aria-hidden"])) : ee("v-if", true)
      ], 2)) : ee("v-if", true),
      B("span", {
        ref_key: "core",
        ref: f,
        class: I(i(l).e("core")),
        style: ze(i(h))
      }, [
        C.inlinePrompt ? (k(), x("div", {
          key: 0,
          class: I(i(l).e("inner"))
        }, [
          C.activeIcon || C.inactiveIcon ? (k(), ae(i(Be), {
            key: 0,
            class: I(i(l).is("icon"))
          }, {
            default: H(() => [
              (k(), ae(ht(i(g) ? C.activeIcon : C.inactiveIcon)))
            ]),
            _: 1
          }, 8, ["class"])) : C.activeText || C.inactiveText ? (k(), x("span", {
            key: 1,
            class: I(i(l).is("text")),
            "aria-hidden": !i(g)
          }, _e(i(g) ? C.activeText : C.inactiveText), 11, ["aria-hidden"])) : ee("v-if", true)
        ], 2)) : ee("v-if", true),
        B("div", {
          class: I(i(l).e("action"))
        }, [
          C.loading ? (k(), ae(i(Be), {
            key: 0,
            class: I(i(l).is("loading"))
          }, {
            default: H(() => [
              W(i(Yr))
            ]),
            _: 1
          }, 8, ["class"])) : i(g) ? J(C.$slots, "active-action", { key: 1 }, () => [
            C.activeActionIcon ? (k(), ae(i(Be), { key: 0 }, {
              default: H(() => [
                (k(), ae(ht(C.activeActionIcon)))
              ]),
              _: 1
            })) : ee("v-if", true)
          ]) : i(g) ? ee("v-if", true) : J(C.$slots, "inactive-action", { key: 2 }, () => [
            C.inactiveActionIcon ? (k(), ae(i(Be), { key: 0 }, {
              default: H(() => [
                (k(), ae(ht(C.inactiveActionIcon)))
              ]),
              _: 1
            })) : ee("v-if", true)
          ])
        ], 2)
      ], 6),
      !C.inlinePrompt && (C.activeIcon || C.activeText) ? (k(), x("span", {
        key: 1,
        class: I(i(m))
      }, [
        C.activeIcon ? (k(), ae(i(Be), { key: 0 }, {
          default: H(() => [
            (k(), ae(ht(C.activeIcon)))
          ]),
          _: 1
        })) : ee("v-if", true),
        !C.activeIcon && C.activeText ? (k(), x("span", {
          key: 1,
          "aria-hidden": !i(g)
        }, _e(C.activeText), 9, ["aria-hidden"])) : ee("v-if", true)
      ], 2)) : ee("v-if", true)
    ], 10, ["onClick"]));
  }
});
var ZY = /* @__PURE__ */ $e(JY, [["__file", "switch.vue"]]);
const QY = ut(ZY), dv = function(e10) {
  var t;
  return (t = e10.target) == null ? void 0 : t.closest("td");
}, eq = function(e10, t, n, o, r) {
  if (!t && !o && (!r || Se(r) && !r.length))
    return e10;
  Ve(n) ? n = n === "descending" ? -1 : 1 : n = n && n < 0 ? -1 : 1;
  const a = o ? null : function(s, u) {
    return r ? (Se(r) || (r = [r]), r.map((c) => Ve(c) ? hn(s, c) : c(s, u, e10))) : (t !== "$key" && at(s) && "$value" in s && (s = s.$value), [at(s) ? hn(s, t) : s]);
  }, l = function(s, u) {
    if (o)
      return o(s.value, u.value);
    for (let c = 0, d = s.key.length; c < d; c++) {
      if (s.key[c] < u.key[c])
        return -1;
      if (s.key[c] > u.key[c])
        return 1;
    }
    return 0;
  };
  return e10.map((s, u) => ({
    value: s,
    index: u,
    key: a ? a(s, u) : null
  })).sort((s, u) => {
    let c = l(s, u);
    return c || (c = s.index - u.index), c * +n;
  }).map((s) => s.value);
}, nN = function(e10, t) {
  let n = null;
  return e10.columns.forEach((o) => {
    o.id === t && (n = o);
  }), n;
}, tq = function(e10, t) {
  let n = null;
  for (let o = 0; o < e10.columns.length; o++) {
    const r = e10.columns[o];
    if (r.columnKey === t) {
      n = r;
      break;
    }
  }
  return n || Qt("ElTable", `No column matching with column-key: ${t}`), n;
}, Z1 = function(e10, t, n) {
  const o = (t.className || "").match(new RegExp(`${n}-table_[^\\s]+`, "gm"));
  return o ? nN(e10, o[0]) : null;
}, Qn = (e10, t) => {
  if (!e10)
    throw new Error("Row is required when get row identity");
  if (Ve(t)) {
    if (!t.includes("."))
      return `${e10[t]}`;
    const n = t.split(".");
    let o = e10;
    for (const r of n)
      o = o[r];
    return `${o}`;
  } else if (Fe(t))
    return t.call(null, e10);
}, zs = function(e10, t, n = false, o = "children") {
  const r = e10 || [], a = {};
  return r.forEach((l, s) => {
    if (a[Qn(l, t)] = { row: l, index: s }, n) {
      const u = l[o];
      Se(u) && Object.assign(a, zs(u, t, true, o));
    }
  }), a;
};
function nq(e10, t) {
  const n = {};
  let o;
  for (o in e10)
    n[o] = e10[o];
  for (o in t)
    if (Tt(t, o)) {
      const r = t[o];
      St(r) || (n[o] = r);
    }
  return n;
}
function Gg(e10) {
  return e10 === "" || St(e10) || (e10 = Number.parseInt(e10, 10), Number.isNaN(e10) && (e10 = "")), e10;
}
function oN(e10) {
  return e10 === "" || St(e10) || (e10 = Gg(e10), Number.isNaN(e10) && (e10 = 80)), e10;
}
function oq(e10) {
  return Ye(e10) ? e10 : Ve(e10) ? /^\d+(?:px)?$/.test(e10) ? Number.parseInt(e10, 10) : e10 : null;
}
function rq(...e10) {
  return e10.length === 0 ? (t) => t : e10.length === 1 ? e10[0] : e10.reduce((t, n) => (...o) => t(n(...o)));
}
function yf(e10, t, n, o, r, a) {
  let l = a != null ? a : 0, s = false;
  const u = e10.indexOf(t), c = u !== -1, d = r == null ? void 0 : r.call(null, t, l), f = (v) => {
    v === "add" ? e10.push(t) : e10.splice(u, 1), s = true;
  }, p = (v) => {
    let m = 0;
    const h = (o == null ? void 0 : o.children) && v[o.children];
    return h && Se(h) && (m += h.length, h.forEach((b) => {
      m += p(b);
    })), m;
  };
  return (!r || d) && (Vt(n) ? n && !c ? f("add") : !n && c && f("remove") : f(c ? "remove" : "add")), !(o != null && o.checkStrictly) && (o != null && o.children) && Se(t[o.children]) && t[o.children].forEach((v) => {
    const m = yf(e10, v, n != null ? n : !c, o, r, l + 1);
    l += p(v) + 1, m && (s = m);
  }), s;
}
function aq(e10, t, n = "children", o = "hasChildren") {
  const r = (l) => !(Se(l) && l.length);
  function a(l, s, u) {
    t(l, s, u), s.forEach((c) => {
      if (c[o]) {
        t(c, null, u + 1);
        return;
      }
      const d = c[n];
      r(d) || a(c, d, u + 1);
    });
  }
  e10.forEach((l) => {
    if (l[o]) {
      t(l, null, 0);
      return;
    }
    const s = l[n];
    r(s) || a(l, s, 0);
  });
}
const lq = (e10, t, n, o) => {
  const r = {
    strategy: "fixed",
    ...e10.popperOptions
  }, a = Fe(o.tooltipFormatter) ? o.tooltipFormatter({
    row: n,
    column: o,
    cellValue: nu(n, o.property).value
  }) : void 0;
  return Ut(a) ? {
    slotContent: a,
    content: null,
    ...e10,
    popperOptions: r
  } : {
    slotContent: null,
    content: a != null ? a : t,
    ...e10,
    popperOptions: r
  };
};
let wo = null;
function sq(e10, t, n, o, r, a) {
  const l = lq(e10, t, n, o), s = {
    ...l,
    slotContent: void 0
  };
  if ((wo == null ? void 0 : wo.trigger) === r) {
    const v = wo.vm.component;
    iS(v.props, s), l.slotContent && (v.slots.content = () => [l.slotContent]);
    return;
  }
  wo == null || wo();
  const u = a == null ? void 0 : a.refs.tableWrapper, c = u == null ? void 0 : u.dataset.prefix, d = W(Un, {
    virtualTriggering: true,
    virtualRef: r,
    appendTo: u,
    placement: "top",
    transition: "none",
    offset: 0,
    hideAfter: 0,
    ...s
  }, l.slotContent ? {
    content: () => l.slotContent
  } : void 0);
  d.appContext = { ...a.appContext, ...a };
  const f = document.createElement("div");
  al(d, f), d.component.exposed.onOpen();
  const p = u == null ? void 0 : u.querySelector(`.${c}-scrollbar__wrap`);
  wo = () => {
    al(null, f), p == null || p.removeEventListener("scroll", wo), wo = null;
  }, wo.trigger = r, wo.vm = d, p == null || p.addEventListener("scroll", wo);
}
function rN(e10) {
  return e10.children ? lL(e10.children, rN) : [e10];
}
function Q1(e10, t) {
  return e10 + t.colSpan;
}
const aN = (e10, t, n, o) => {
  let r = 0, a = e10;
  const l = n.states.columns.value;
  if (o) {
    const u = rN(o[e10]);
    r = l.slice(0, l.indexOf(u[0])).reduce(Q1, 0), a = r + u.reduce(Q1, 0) - 1;
  } else
    r = e10;
  let s;
  switch (t) {
    case "left":
      a < n.states.fixedLeafColumnsLength.value && (s = "left");
      break;
    case "right":
      r >= l.length - n.states.rightFixedLeafColumnsLength.value && (s = "right");
      break;
    default:
      a < n.states.fixedLeafColumnsLength.value ? s = "left" : r >= l.length - n.states.rightFixedLeafColumnsLength.value && (s = "right");
  }
  return s ? {
    direction: s,
    start: r,
    after: a
  } : {};
}, Xg = (e10, t, n, o, r, a = 0) => {
  const l = [], { direction: s, start: u, after: c } = aN(t, n, o, r);
  if (s) {
    const d = s === "left";
    l.push(`${e10}-fixed-column--${s}`), d && c + a === o.states.fixedLeafColumnsLength.value - 1 ? l.push("is-last-column") : !d && u - a === o.states.columns.value.length - o.states.rightFixedLeafColumnsLength.value && l.push("is-first-column");
  }
  return l;
};
function e_(e10, t) {
  return e10 + (rc(t.realWidth) || Number.isNaN(t.realWidth) ? Number(t.width) : t.realWidth);
}
const Jg = (e10, t, n, o) => {
  const {
    direction: r,
    start: a = 0,
    after: l = 0
  } = aN(e10, t, n, o);
  if (!r)
    return;
  const s = {}, u = r === "left", c = n.states.columns.value;
  return u ? s.left = c.slice(0, a).reduce(e_, 0) : s.right = c.slice(l + 1).reverse().reduce(e_, 0), s;
}, ci = (e10, t) => {
  e10 && (Number.isNaN(e10[t]) || (e10[t] = `${e10[t]}px`));
};
function iq(e10) {
  const t = it(), n = L(false), o = L([]);
  return {
    updateExpandRows: () => {
      const u = e10.data.value || [], c = e10.rowKey.value;
      if (n.value)
        o.value = u.slice();
      else if (c) {
        const d = zs(o.value, c);
        o.value = u.reduce((f, p) => {
          const v = Qn(p, c);
          return d[v] && f.push(p), f;
        }, []);
      } else
        o.value = [];
    },
    toggleRowExpansion: (u, c) => {
      yf(o.value, u, c) && t.emit("expand-change", u, o.value.slice());
    },
    setExpandRowKeys: (u) => {
      t.store.assertRowKey();
      const c = e10.data.value || [], d = e10.rowKey.value, f = zs(c, d);
      o.value = u.reduce((p, v) => {
        const m = f[v];
        return m && p.push(m.row), p;
      }, []);
    },
    isRowExpanded: (u) => {
      const c = e10.rowKey.value;
      return c ? !!zs(o.value, c)[Qn(u, c)] : o.value.includes(u);
    },
    states: {
      expandRows: o,
      defaultExpandAll: n
    }
  };
}
function uq(e10) {
  const t = it(), n = L(null), o = L(null), r = (c) => {
    t.store.assertRowKey(), n.value = c, l(c);
  }, a = () => {
    n.value = null;
  }, l = (c) => {
    const { data: d, rowKey: f } = e10;
    let p = null;
    f.value && (p = (i(d) || []).find((v) => Qn(v, f.value) === c)), o.value = p, t.emit("current-change", o.value, null);
  };
  return {
    setCurrentRowKey: r,
    restoreCurrentRowKey: a,
    setCurrentRowByKey: l,
    updateCurrentRow: (c) => {
      const d = o.value;
      if (c && c !== d) {
        o.value = c, t.emit("current-change", o.value, d);
        return;
      }
      !c && d && (o.value = null, t.emit("current-change", null, d));
    },
    updateCurrentRowData: () => {
      const c = e10.rowKey.value, d = e10.data.value || [], f = o.value;
      if (!d.includes(f) && f) {
        if (c) {
          const p = Qn(f, c);
          l(p);
        } else
          o.value = null;
        rc(o.value) && t.emit("current-change", null, f);
      } else n.value && (l(n.value), a());
    },
    states: {
      _currentRowKey: n,
      currentRow: o
    }
  };
}
function cq(e10) {
  const t = L([]), n = L({}), o = L(16), r = L(false), a = L({}), l = L("hasChildren"), s = L("children"), u = L(false), c = it(), d = S(() => {
    if (!e10.rowKey.value)
      return {};
    const _ = e10.data.value || [];
    return p(_);
  }), f = S(() => {
    const _ = e10.rowKey.value, C = Object.keys(a.value), E = {};
    return C.length && C.forEach((T) => {
      if (a.value[T].length) {
        const O = { children: [] };
        a.value[T].forEach((N) => {
          const $ = Qn(N, _);
          O.children.push($), N[l.value] && !E[$] && (E[$] = { children: [] });
        }), E[T] = O;
      }
    }), E;
  }), p = (_) => {
    const C = e10.rowKey.value, E = {};
    return aq(_, (T, O, N) => {
      const $ = Qn(T, C);
      Se(O) ? E[$] = {
        children: O.map((R) => Qn(R, C)),
        level: N
      } : r.value && (E[$] = {
        children: [],
        lazy: true,
        level: N
      });
    }, s.value, l.value), E;
  }, v = (_ = false, C = ((E) => (E = c.store) == null ? void 0 : E.states.defaultExpandAll.value)()) => {
    var E;
    const T = d.value, O = f.value, N = Object.keys(T), $ = {};
    if (N.length) {
      const R = i(n), P = [], z = (D, M) => {
        if (_)
          return t.value ? C || t.value.includes(M) : !!(C || D != null && D.expanded);
        {
          const F = C || t.value && t.value.includes(M);
          return !!(D != null && D.expanded || F);
        }
      };
      N.forEach((D) => {
        const M = R[D], F = { ...T[D] };
        if (F.expanded = z(M, D), F.lazy) {
          const { loaded: A = false, loading: V = false } = M || {};
          F.loaded = !!A, F.loading = !!V, P.push(D);
        }
        $[D] = F;
      });
      const Y = Object.keys(O);
      r.value && Y.length && P.length && Y.forEach((D) => {
        const M = R[D], F = O[D].children;
        if (P.includes(D)) {
          if ($[D].children.length !== 0)
            throw new Error("[ElTable]children must be an empty array.");
          $[D].children = F;
        } else {
          const { loaded: A = false, loading: V = false } = M || {};
          $[D] = {
            lazy: true,
            loaded: !!A,
            loading: !!V,
            expanded: z(M, D),
            children: F,
            level: ""
          };
        }
      });
    }
    n.value = $, (E = c.store) == null || E.updateTableScrollY();
  };
  ge(() => t.value, () => {
    v(true);
  }), ge(() => d.value, () => {
    v();
  }), ge(() => f.value, () => {
    v();
  });
  const m = (_) => {
    t.value = _, v();
  }, h = (_) => r.value && _ && "loaded" in _ && !_.loaded, b = (_, C) => {
    c.store.assertRowKey();
    const E = e10.rowKey.value, T = Qn(_, E), O = T && n.value[T];
    if (T && O && "expanded" in O) {
      const N = O.expanded;
      C = St(C) ? !O.expanded : C, n.value[T].expanded = C, N !== C && c.emit("expand-change", _, C), h(O) && w(_, T, O), c.store.updateTableScrollY();
    }
  }, g = (_) => {
    c.store.assertRowKey();
    const C = e10.rowKey.value, E = Qn(_, C), T = n.value[E];
    h(T) ? w(_, E, T) : b(_, void 0);
  }, w = (_, C, E) => {
    const { load: T } = c.props;
    T && !n.value[C].loaded && (n.value[C].loading = true, T(_, E, (O) => {
      if (!Se(O))
        throw new TypeError("[ElTable] data must be an array");
      n.value[C].loading = false, n.value[C].loaded = true, n.value[C].expanded = true, O.length && (a.value[C] = O), c.emit("expand-change", _, true);
    }));
  };
  return {
    loadData: w,
    loadOrToggle: g,
    toggleTreeExpansion: b,
    updateTreeExpandKeys: m,
    updateTreeData: v,
    updateKeyChildren: (_, C) => {
      const { lazy: E, rowKey: T } = c.props;
      if (E) {
        if (!T)
          throw new Error("[Table] rowKey is required in updateKeyChild");
        a.value[_] && (a.value[_] = C);
      }
    },
    normalize: p,
    states: {
      expandRowKeys: t,
      treeData: n,
      indent: o,
      lazy: r,
      lazyTreeNodeMap: a,
      lazyColumnIdentifier: l,
      childrenColumnName: s,
      checkStrictly: u
    }
  };
}
const dq = (e10, t) => {
  const n = t.sortingColumn;
  return !n || Ve(n.sortable) ? e10 : eq(e10, t.sortProp, t.sortOrder, n.sortMethod, n.sortBy);
}, wd = (e10) => {
  const t = [];
  return e10.forEach((n) => {
    n.children && n.children.length > 0 ? t.push.apply(t, wd(n.children)) : t.push(n);
  }), t;
};
function fq() {
  var e10;
  const t = it(), { size: n } = Tn((e10 = t.proxy) == null ? void 0 : e10.$props), o = L(null), r = L([]), a = L([]), l = L(false), s = L([]), u = L([]), c = L([]), d = L([]), f = L([]), p = L([]), v = L([]), m = L([]), h = [], b = L(0), g = L(0), w = L(0), y = L(false), _ = L([]), C = L(false), E = L(false), T = L(null), O = L({}), N = L(null), $ = L(null), R = L(null), P = L(null), z = L(null), Y = S(() => o.value ? zs(_.value, o.value) : void 0);
  ge(r, () => {
    var We;
    t.state && (A(false), t.props.tableLayout === "auto" && ((We = t.refs.tableHeaderRef) == null || We.updateFixedColumnStyle()));
  }, {
    deep: true
  });
  const D = () => {
    if (!o.value)
      throw new Error("[ElTable] prop row-key is required");
  }, M = (We) => {
    var ct;
    (ct = We.children) == null || ct.forEach((oe) => {
      oe.fixed = We.fixed, M(oe);
    });
  }, F = () => {
    s.value.forEach((Qe) => {
      M(Qe);
    }), d.value = s.value.filter((Qe) => [true, "left"].includes(Qe.fixed));
    const We = s.value.find((Qe) => Qe.type === "selection");
    let ct;
    We && We.fixed !== "right" && !d.value.includes(We) && s.value.indexOf(We) === 0 && d.value.length && (d.value.unshift(We), ct = true), f.value = s.value.filter((Qe) => Qe.fixed === "right");
    const oe = s.value.filter((Qe) => (ct ? Qe.type !== "selection" : true) && !Qe.fixed);
    u.value = [].concat(d.value).concat(oe).concat(f.value);
    const Ne = wd(oe), Q = wd(d.value), Me = wd(f.value);
    b.value = Ne.length, g.value = Q.length, w.value = Me.length, c.value = [].concat(Q).concat(Ne).concat(Me), l.value = d.value.length > 0 || f.value.length > 0;
  }, A = (We, ct = false) => {
    We && F(), ct ? t.state.doLayout() : t.state.debouncedUpdateLayout();
  }, V = (We) => Y.value ? !!Y.value[Qn(We, o.value)] : _.value.includes(We), Z = () => {
    y.value = false;
    const We = _.value;
    _.value = [], We.length && t.emit("selection-change", []);
  }, G = () => {
    var We, ct;
    let oe;
    if (o.value) {
      oe = [];
      const Ne = (ct = (We = t == null ? void 0 : t.store) == null ? void 0 : We.states) == null ? void 0 : ct.childrenColumnName.value, Q = zs(r.value, o.value, true, Ne);
      for (const Me in Y.value)
        Tt(Y.value, Me) && !Q[Me] && oe.push(Y.value[Me].row);
    } else
      oe = _.value.filter((Ne) => !r.value.includes(Ne));
    if (oe.length) {
      const Ne = _.value.filter((Q) => !oe.includes(Q));
      _.value = Ne, t.emit("selection-change", Ne.slice());
    }
  }, le = () => (_.value || []).slice(), X = (We, ct, oe = true, Ne = false) => {
    var Q, Me, Qe, Ct;
    const Kt = {
      children: (Me = (Q = t == null ? void 0 : t.store) == null ? void 0 : Q.states) == null ? void 0 : Me.childrenColumnName.value,
      checkStrictly: (Ct = (Qe = t == null ? void 0 : t.store) == null ? void 0 : Qe.states) == null ? void 0 : Ct.checkStrictly.value
    };
    if (yf(_.value, We, ct, Kt, Ne ? void 0 : T.value, r.value.indexOf(We))) {
      const on = (_.value || []).slice();
      oe && t.emit("select", on, We), t.emit("selection-change", on);
    }
  }, te = () => {
    var We, ct;
    const oe = E.value ? !y.value : !(y.value || _.value.length);
    y.value = oe;
    let Ne = false, Q = 0;
    const Me = (ct = (We = t == null ? void 0 : t.store) == null ? void 0 : We.states) == null ? void 0 : ct.rowKey.value, { childrenColumnName: Qe } = t.store.states, Ct = {
      children: Qe.value,
      checkStrictly: false
    };
    r.value.forEach((Kt, pn) => {
      const on = pn + Q;
      yf(_.value, Kt, oe, Ct, T.value, on) && (Ne = true), Q += se(Qn(Kt, Me));
    }), Ne && t.emit("selection-change", _.value ? _.value.slice() : []), t.emit("select-all", (_.value || []).slice());
  }, ce = () => {
    r.value.forEach((We) => {
      const ct = Qn(We, o.value), oe = Y.value[ct];
      oe && (_.value[oe.index] = We);
    });
  }, pe = () => {
    var We;
    if (((We = r.value) == null ? void 0 : We.length) === 0) {
      y.value = false;
      return;
    }
    const { childrenColumnName: ct } = t.store.states;
    let oe = 0, Ne = 0;
    const Q = (Qe) => {
      var Ct;
      for (const Kt of Qe) {
        const pn = T.value && T.value.call(null, Kt, oe);
        if (V(Kt))
          Ne++;
        else if (!T.value || pn)
          return false;
        if (oe++, (Ct = Kt[ct.value]) != null && Ct.length && !Q(Kt[ct.value]))
          return false;
      }
      return true;
    }, Me = Q(r.value || []);
    y.value = Ne === 0 ? false : Me;
  }, se = (We) => {
    var ct;
    if (!t || !t.store)
      return 0;
    const { treeData: oe } = t.store.states;
    let Ne = 0;
    const Q = (ct = oe.value[We]) == null ? void 0 : ct.children;
    return Q && (Ne += Q.length, Q.forEach((Me) => {
      Ne += se(Me);
    })), Ne;
  }, ve = (We, ct) => {
    Se(We) || (We = [We]);
    const oe = {};
    return We.forEach((Ne) => {
      O.value[Ne.id] = ct, oe[Ne.columnKey || Ne.id] = ct;
    }), oe;
  }, me = (We, ct, oe) => {
    $.value && $.value !== We && ($.value.order = null), $.value = We, R.value = ct, P.value = oe;
  }, De = () => {
    let We = i(a);
    Object.keys(O.value).forEach((ct) => {
      const oe = O.value[ct];
      if (!oe || oe.length === 0)
        return;
      const Ne = nN({
        columns: c.value
      }, ct);
      Ne && Ne.filterMethod && (We = We.filter((Q) => oe.some((Me) => Ne.filterMethod.call(null, Me, Q, Ne))));
    }), N.value = We;
  }, Te = () => {
    r.value = dq(N.value, {
      sortingColumn: $.value,
      sortProp: R.value,
      sortOrder: P.value
    });
  }, de = (We = void 0) => {
    We && We.filter || De(), Te();
  }, U = (We) => {
    const { tableHeaderRef: ct } = t.refs;
    if (!ct)
      return;
    const oe = Object.assign({}, ct.filterPanels), Ne = Object.keys(oe);
    if (Ne.length)
      if (Ve(We) && (We = [We]), Se(We)) {
        const Q = We.map((Me) => tq({
          columns: c.value
        }, Me));
        Ne.forEach((Me) => {
          const Qe = Q.find((Ct) => Ct.id === Me);
          Qe && (Qe.filteredValue = []);
        }), t.store.commit("filterChange", {
          column: Q,
          values: [],
          silent: true,
          multi: true
        });
      } else
        Ne.forEach((Q) => {
          const Me = c.value.find((Qe) => Qe.id === Q);
          Me && (Me.filteredValue = []);
        }), O.value = {}, t.store.commit("filterChange", {
          column: {},
          values: [],
          silent: true
        });
  }, re = () => {
    $.value && (me(null, null, null), t.store.commit("changeSortCondition", {
      silent: true
    }));
  }, {
    setExpandRowKeys: he,
    toggleRowExpansion: Ee,
    updateExpandRows: ye,
    states: K,
    isRowExpanded: q
  } = iq({
    data: r,
    rowKey: o
  }), {
    updateTreeExpandKeys: ue,
    toggleTreeExpansion: be,
    updateTreeData: ke,
    updateKeyChildren: Ae,
    loadOrToggle: fe,
    states: ie
  } = cq({
    data: r,
    rowKey: o
  }), {
    updateCurrentRowData: Ce,
    updateCurrentRow: qe,
    setCurrentRowKey: et,
    states: ft
  } = uq({
    data: r,
    rowKey: o
  });
  return {
    assertRowKey: D,
    updateColumns: F,
    scheduleLayout: A,
    isSelected: V,
    clearSelection: Z,
    cleanSelection: G,
    getSelectionRows: le,
    toggleRowSelection: X,
    _toggleAllSelection: te,
    toggleAllSelection: null,
    updateSelectionByRowKey: ce,
    updateAllSelected: pe,
    updateFilters: ve,
    updateCurrentRow: qe,
    updateSort: me,
    execFilter: De,
    execSort: Te,
    execQuery: de,
    clearFilter: U,
    clearSort: re,
    toggleRowExpansion: Ee,
    setExpandRowKeysAdapter: (We) => {
      he(We), ue(We);
    },
    setCurrentRowKey: et,
    toggleRowExpansionAdapter: (We, ct) => {
      c.value.some(({ type: Ne }) => Ne === "expand") ? Ee(We, ct) : be(We, ct);
    },
    isRowExpanded: q,
    updateExpandRows: ye,
    updateCurrentRowData: Ce,
    loadOrToggle: fe,
    updateTreeData: ke,
    updateKeyChildren: Ae,
    states: {
      tableSize: n,
      rowKey: o,
      data: r,
      _data: a,
      isComplex: l,
      _columns: s,
      originColumns: u,
      columns: c,
      fixedColumns: d,
      rightFixedColumns: f,
      leafColumns: p,
      fixedLeafColumns: v,
      rightFixedLeafColumns: m,
      updateOrderFns: h,
      leafColumnsLength: b,
      fixedLeafColumnsLength: g,
      rightFixedLeafColumnsLength: w,
      isAllSelected: y,
      selection: _,
      reserveSelection: C,
      selectOnIndeterminate: E,
      selectable: T,
      filters: O,
      filteredData: N,
      sortingColumn: $,
      sortProp: R,
      sortOrder: P,
      hoverRow: z,
      ...K,
      ...ie,
      ...ft
    }
  };
}
function Eh(e10, t) {
  return e10.map((n) => {
    var o;
    return n.id === t.id ? t : ((o = n.children) != null && o.length && (n.children = Eh(n.children, t)), n);
  });
}
function Sh(e10) {
  e10.forEach((t) => {
    var n, o;
    t.no = (n = t.getColumnIndex) == null ? void 0 : n.call(t), (o = t.children) != null && o.length && Sh(t.children);
  }), e10.sort((t, n) => t.no - n.no);
}
function pq() {
  const e10 = it(), t = fq();
  return {
    ns: we("table"),
    ...t,
    mutations: {
      setData(l, s) {
        const u = i(l._data) !== s;
        l.data.value = s, l._data.value = s, e10.store.execQuery(), e10.store.updateCurrentRowData(), e10.store.updateExpandRows(), e10.store.updateTreeData(e10.store.states.defaultExpandAll.value), i(l.reserveSelection) ? (e10.store.assertRowKey(), e10.store.updateSelectionByRowKey()) : u ? e10.store.clearSelection() : e10.store.cleanSelection(), e10.store.updateAllSelected(), e10.$ready && e10.store.scheduleLayout();
      },
      insertColumn(l, s, u, c) {
        const d = i(l._columns);
        let f = [];
        u ? (u && !u.children && (u.children = []), u.children.push(s), f = Eh(d, u)) : (d.push(s), f = d), Sh(f), l._columns.value = f, l.updateOrderFns.push(c), s.type === "selection" && (l.selectable.value = s.selectable, l.reserveSelection.value = s.reserveSelection), e10.$ready && (e10.store.updateColumns(), e10.store.scheduleLayout());
      },
      updateColumnOrder(l, s) {
        var u;
        ((u = s.getColumnIndex) == null ? void 0 : u.call(s)) !== s.no && (Sh(l._columns.value), e10.$ready && e10.store.updateColumns());
      },
      removeColumn(l, s, u, c) {
        const d = i(l._columns) || [];
        if (u)
          u.children.splice(u.children.findIndex((p) => p.id === s.id), 1), He(() => {
            var p;
            ((p = u.children) == null ? void 0 : p.length) === 0 && delete u.children;
          }), l._columns.value = Eh(d, u);
        else {
          const p = d.indexOf(s);
          p > -1 && (d.splice(p, 1), l._columns.value = d);
        }
        const f = l.updateOrderFns.indexOf(c);
        f > -1 && l.updateOrderFns.splice(f, 1), e10.$ready && (e10.store.updateColumns(), e10.store.scheduleLayout());
      },
      sort(l, s) {
        const { prop: u, order: c, init: d } = s;
        if (u) {
          const f = i(l.columns).find((p) => p.property === u);
          f && (f.order = c, e10.store.updateSort(f, u, c), e10.store.commit("changeSortCondition", { init: d }));
        }
      },
      changeSortCondition(l, s) {
        const { sortingColumn: u, sortProp: c, sortOrder: d } = l, f = i(u), p = i(c), v = i(d);
        rc(v) && (l.sortingColumn.value = null, l.sortProp.value = null);
        const m = { filter: true };
        e10.store.execQuery(m), (!s || !(s.silent || s.init)) && e10.emit("sort-change", {
          column: f,
          prop: p,
          order: v
        }), e10.store.updateTableScrollY();
      },
      filterChange(l, s) {
        const { column: u, values: c, silent: d } = s, f = e10.store.updateFilters(u, c);
        e10.store.execQuery(), d || e10.emit("filter-change", f), e10.store.updateTableScrollY();
      },
      toggleAllSelection() {
        e10.store.toggleAllSelection();
      },
      rowSelectedChanged(l, s) {
        e10.store.toggleRowSelection(s), e10.store.updateAllSelected();
      },
      setHoverRow(l, s) {
        l.hoverRow.value = s;
      },
      setCurrentRow(l, s) {
        e10.store.updateCurrentRow(s);
      }
    },
    commit: function(l, ...s) {
      const u = e10.store.mutations;
      if (u[l])
        u[l].apply(e10, [e10.store.states].concat(s));
      else
        throw new Error(`Action not found: ${l}`);
    },
    updateTableScrollY: function() {
      He(() => e10.layout.updateScrollY.apply(e10.layout));
    }
  };
}
const lu = {
  rowKey: "rowKey",
  defaultExpandAll: "defaultExpandAll",
  selectOnIndeterminate: "selectOnIndeterminate",
  indent: "indent",
  lazy: "lazy",
  data: "data",
  "treeProps.hasChildren": {
    key: "lazyColumnIdentifier",
    default: "hasChildren"
  },
  "treeProps.children": {
    key: "childrenColumnName",
    default: "children"
  },
  "treeProps.checkStrictly": {
    key: "checkStrictly",
    default: false
  }
};
function vq(e10, t) {
  if (!e10)
    throw new Error("Table is required.");
  const n = pq();
  return n.toggleAllSelection = Oo(n._toggleAllSelection, 10), Object.keys(lu).forEach((o) => {
    lN(sN(t, o), o, n);
  }), hq(n, t), n;
}
function hq(e10, t) {
  Object.keys(lu).forEach((n) => {
    ge(() => sN(t, n), (o) => {
      lN(o, n, e10);
    });
  });
}
function lN(e10, t, n) {
  let o = e10, r = lu[t];
  at(lu[t]) && (r = r.key, o = o || lu[t].default), n.states[r].value = o;
}
function sN(e10, t) {
  if (t.includes(".")) {
    const n = t.split(".");
    let o = e10;
    return n.forEach((r) => {
      o = o[r];
    }), o;
  } else
    return e10[t];
}
class mq {
  constructor(t) {
    this.observers = [], this.table = null, this.store = null, this.columns = [], this.fit = true, this.showHeader = true, this.height = L(null), this.scrollX = L(false), this.scrollY = L(false), this.bodyWidth = L(null), this.fixedWidth = L(null), this.rightFixedWidth = L(null), this.gutterWidth = 0;
    for (const n in t)
      Tt(t, n) && (Ot(this[n]) ? this[n].value = t[n] : this[n] = t[n]);
    if (!this.table)
      throw new Error("Table is required for Table Layout");
    if (!this.store)
      throw new Error("Store is required for Table Layout");
  }
  updateScrollY() {
    const t = this.height.value;
    if (rc(t))
      return false;
    const n = this.table.refs.scrollBarRef;
    if (this.table.vnode.el && (n != null && n.wrapRef)) {
      let o = true;
      const r = this.scrollY.value;
      return o = n.wrapRef.scrollHeight > n.wrapRef.clientHeight, this.scrollY.value = o, r !== o;
    }
    return false;
  }
  setHeight(t, n = "height") {
    if (!Et)
      return;
    const o = this.table.vnode.el;
    if (t = oq(t), this.height.value = Number(t), !o && (t || t === 0))
      return He(() => this.setHeight(t, n));
    Ye(t) ? (o.style[n] = `${t}px`, this.updateElsHeight()) : Ve(t) && (o.style[n] = t, this.updateElsHeight());
  }
  setMaxHeight(t) {
    this.setHeight(t, "max-height");
  }
  getFlattenColumns() {
    const t = [];
    return this.table.store.states.columns.value.forEach((o) => {
      o.isColumnGroup ? t.push.apply(t, o.columns) : t.push(o);
    }), t;
  }
  updateElsHeight() {
    this.updateScrollY(), this.notifyObservers("scrollable");
  }
  headerDisplayNone(t) {
    if (!t)
      return true;
    let n = t;
    for (; n.tagName !== "DIV"; ) {
      if (getComputedStyle(n).display === "none")
        return true;
      n = n.parentElement;
    }
    return false;
  }
  updateColumnsWidth() {
    if (!Et)
      return;
    const t = this.fit, n = this.table.vnode.el.clientWidth;
    let o = 0;
    const r = this.getFlattenColumns(), a = r.filter((u) => !Ye(u.width));
    if (r.forEach((u) => {
      Ye(u.width) && u.realWidth && (u.realWidth = null);
    }), a.length > 0 && t) {
      if (r.forEach((u) => {
        o += Number(u.width || u.minWidth || 80);
      }), o <= n) {
        this.scrollX.value = false;
        const u = n - o;
        if (a.length === 1)
          a[0].realWidth = Number(a[0].minWidth || 80) + u;
        else {
          const c = a.reduce((p, v) => p + Number(v.minWidth || 80), 0), d = u / c;
          let f = 0;
          a.forEach((p, v) => {
            if (v === 0)
              return;
            const m = Math.floor(Number(p.minWidth || 80) * d);
            f += m, p.realWidth = Number(p.minWidth || 80) + m;
          }), a[0].realWidth = Number(a[0].minWidth || 80) + u - f;
        }
      } else
        this.scrollX.value = true, a.forEach((u) => {
          u.realWidth = Number(u.minWidth);
        });
      this.bodyWidth.value = Math.max(o, n), this.table.state.resizeState.value.width = this.bodyWidth.value;
    } else
      r.forEach((u) => {
        !u.width && !u.minWidth ? u.realWidth = 80 : u.realWidth = Number(u.width || u.minWidth), o += u.realWidth;
      }), this.scrollX.value = o > n, this.bodyWidth.value = o;
    const l = this.store.states.fixedColumns.value;
    if (l.length > 0) {
      let u = 0;
      l.forEach((c) => {
        u += Number(c.realWidth || c.width);
      }), this.fixedWidth.value = u;
    }
    const s = this.store.states.rightFixedColumns.value;
    if (s.length > 0) {
      let u = 0;
      s.forEach((c) => {
        u += Number(c.realWidth || c.width);
      }), this.rightFixedWidth.value = u;
    }
    this.notifyObservers("columns");
  }
  addObserver(t) {
    this.observers.push(t);
  }
  removeObserver(t) {
    const n = this.observers.indexOf(t);
    n !== -1 && this.observers.splice(n, 1);
  }
  notifyObservers(t) {
    this.observers.forEach((o) => {
      var r, a;
      switch (t) {
        case "columns":
          (r = o.state) == null || r.onColumnsChange(this);
          break;
        case "scrollable":
          (a = o.state) == null || a.onScrollableChange(this);
          break;
        default:
          throw new Error(`Table Layout don't have event ${t}.`);
      }
    });
  }
}
const { CheckboxGroup: gq } = er, yq = /* @__PURE__ */ j({
  name: "ElTableFilterPanel",
  components: {
    ElCheckbox: er,
    ElCheckboxGroup: gq,
    ElScrollbar: ta,
    ElTooltip: Un,
    ElIcon: Be,
    ArrowDown: ea,
    ArrowUp: Zf
  },
  directives: { ClickOutside: Sa },
  props: {
    placement: {
      type: String,
      default: "bottom-start"
    },
    store: {
      type: Object
    },
    column: {
      type: Object
    },
    upDataColumn: {
      type: Function
    },
    appendTo: vn.appendTo
  },
  setup(e10) {
    const t = it(), { t: n } = kt(), o = we("table-filter"), r = t == null ? void 0 : t.parent;
    r.filterPanels.value[e10.column.id] || (r.filterPanels.value[e10.column.id] = t);
    const a = L(false), l = L(null), s = S(() => e10.column && e10.column.filters), u = S(() => e10.column.filterClassName ? `${o.b()} ${e10.column.filterClassName}` : o.b()), c = S({
      get: () => {
        var C;
        return (((C = e10.column) == null ? void 0 : C.filteredValue) || [])[0];
      },
      set: (C) => {
        d.value && (So(C) ? d.value.splice(0, 1) : d.value.splice(0, 1, C));
      }
    }), d = S({
      get() {
        return e10.column ? e10.column.filteredValue || [] : [];
      },
      set(C) {
        e10.column && e10.upDataColumn("filteredValue", C);
      }
    }), f = S(() => e10.column ? e10.column.filterMultiple : true), p = (C) => C.value === c.value, v = () => {
      a.value = false;
    }, m = (C) => {
      C.stopPropagation(), a.value = !a.value;
    }, h = () => {
      a.value = false;
    }, b = () => {
      y(d.value), v();
    }, g = () => {
      d.value = [], y(d.value), v();
    }, w = (C) => {
      c.value = C, So(C) ? y([]) : y(d.value), v();
    }, y = (C) => {
      e10.store.commit("filterChange", {
        column: e10.column,
        values: C
      }), e10.store.updateAllSelected();
    };
    ge(a, (C) => {
      e10.column && e10.upDataColumn("filterOpened", C);
    }, {
      immediate: true
    });
    const _ = S(() => {
      var C, E;
      return (E = (C = l.value) == null ? void 0 : C.popperRef) == null ? void 0 : E.contentRef;
    });
    return {
      tooltipVisible: a,
      multiple: f,
      filterClassName: u,
      filteredValue: d,
      filterValue: c,
      filters: s,
      handleConfirm: b,
      handleReset: g,
      handleSelect: w,
      isPropAbsent: So,
      isActive: p,
      t: n,
      ns: o,
      showFilterPanel: m,
      hideFilterPanel: h,
      popperPaneRef: _,
      tooltip: l
    };
  }
});
function bq(e10, t, n, o, r, a) {
  const l = je("el-checkbox"), s = je("el-checkbox-group"), u = je("el-scrollbar"), c = je("arrow-up"), d = je("arrow-down"), f = je("el-icon"), p = je("el-tooltip"), v = Vf("click-outside");
  return k(), ae(p, {
    ref: "tooltip",
    visible: e10.tooltipVisible,
    offset: 0,
    placement: e10.placement,
    "show-arrow": false,
    "stop-popper-mouse-event": false,
    teleported: "",
    effect: "light",
    pure: "",
    "popper-class": e10.filterClassName,
    persistent: "",
    "append-to": e10.appendTo
  }, {
    content: H(() => [
      e10.multiple ? (k(), x("div", { key: 0 }, [
        B("div", {
          class: I(e10.ns.e("content"))
        }, [
          W(u, {
            "wrap-class": e10.ns.e("wrap")
          }, {
            default: H(() => [
              W(s, {
                modelValue: e10.filteredValue,
                "onUpdate:modelValue": (m) => e10.filteredValue = m,
                class: I(e10.ns.e("checkbox-group"))
              }, {
                default: H(() => [
                  (k(true), x(Ie, null, st(e10.filters, (m) => (k(), ae(l, {
                    key: m.value,
                    value: m.value
                  }, {
                    default: H(() => [
                      Ze(_e(m.text), 1)
                    ]),
                    _: 2
                  }, 1032, ["value"]))), 128))
                ]),
                _: 1
              }, 8, ["modelValue", "onUpdate:modelValue", "class"])
            ]),
            _: 1
          }, 8, ["wrap-class"])
        ], 2),
        B("div", {
          class: I(e10.ns.e("bottom"))
        }, [
          B("button", {
            class: I({ [e10.ns.is("disabled")]: e10.filteredValue.length === 0 }),
            disabled: e10.filteredValue.length === 0,
            type: "button",
            onClick: e10.handleConfirm
          }, _e(e10.t("el.table.confirmFilter")), 11, ["disabled", "onClick"]),
          B("button", {
            type: "button",
            onClick: e10.handleReset
          }, _e(e10.t("el.table.resetFilter")), 9, ["onClick"])
        ], 2)
      ])) : (k(), x("ul", {
        key: 1,
        class: I(e10.ns.e("list"))
      }, [
        B("li", {
          class: I([
            e10.ns.e("list-item"),
            {
              [e10.ns.is("active")]: e10.isPropAbsent(e10.filterValue)
            }
          ]),
          onClick: (m) => e10.handleSelect(null)
        }, _e(e10.t("el.table.clearFilter")), 11, ["onClick"]),
        (k(true), x(Ie, null, st(e10.filters, (m) => (k(), x("li", {
          key: m.value,
          class: I([e10.ns.e("list-item"), e10.ns.is("active", e10.isActive(m))]),
          label: m.value,
          onClick: (h) => e10.handleSelect(m.value)
        }, _e(m.text), 11, ["label", "onClick"]))), 128))
      ], 2))
    ]),
    default: H(() => [
      lt((k(), x("span", {
        class: I([
          `${e10.ns.namespace.value}-table__column-filter-trigger`,
          `${e10.ns.namespace.value}-none-outline`
        ]),
        onClick: e10.showFilterPanel
      }, [
        W(f, null, {
          default: H(() => [
            J(e10.$slots, "filter-icon", {}, () => [
              e10.column.filterOpened ? (k(), ae(c, { key: 0 })) : (k(), ae(d, { key: 1 }))
            ])
          ]),
          _: 3
        })
      ], 10, ["onClick"])), [
        [v, e10.hideFilterPanel, e10.popperPaneRef]
      ])
    ]),
    _: 3
  }, 8, ["visible", "placement", "popper-class", "append-to"]);
}
var _q = /* @__PURE__ */ $e(yq, [["render", bq], ["__file", "filter-panel.vue"]]);
function Zg(e10) {
  const t = it();
  Df(() => {
    n.value.addObserver(t);
  }), dt(() => {
    o(n.value), r(n.value);
  }), wr(() => {
    o(n.value), r(n.value);
  }), Jr(() => {
    n.value.removeObserver(t);
  });
  const n = S(() => {
    const a = e10.layout;
    if (!a)
      throw new Error("Can not find table layout.");
    return a;
  }), o = (a) => {
    var l;
    const s = ((l = e10.vnode.el) == null ? void 0 : l.querySelectorAll("colgroup > col")) || [];
    if (!s.length)
      return;
    const u = a.getFlattenColumns(), c = {};
    u.forEach((d) => {
      c[d.id] = d;
    });
    for (let d = 0, f = s.length; d < f; d++) {
      const p = s[d], v = p.getAttribute("name"), m = c[v];
      m && p.setAttribute("width", m.realWidth || m.width);
    }
  }, r = (a) => {
    var l, s;
    const u = ((l = e10.vnode.el) == null ? void 0 : l.querySelectorAll("colgroup > col[name=gutter]")) || [];
    for (let d = 0, f = u.length; d < f; d++)
      u[d].setAttribute("width", a.scrollY.value ? a.gutterWidth : "0");
    const c = ((s = e10.vnode.el) == null ? void 0 : s.querySelectorAll("th.gutter")) || [];
    for (let d = 0, f = c.length; d < f; d++) {
      const p = c[d];
      p.style.width = a.scrollY.value ? `${a.gutterWidth}px` : "0", p.style.display = a.scrollY.value ? "" : "none";
    }
  };
  return {
    tableLayout: n.value,
    onColumnsChange: o,
    onScrollableChange: r
  };
}
const kr = Symbol("ElTable");
function wq(e10, t) {
  const n = it(), o = Le(kr), r = (h) => {
    h.stopPropagation();
  }, a = (h, b) => {
    !b.filters && b.sortable ? m(h, b, false) : b.filterable && !b.sortable && r(h), o == null || o.emit("header-click", b, h);
  }, l = (h, b) => {
    o == null || o.emit("header-contextmenu", b, h);
  }, s = L(null), u = L(false), c = L({}), d = (h, b) => {
    if (Et && !(b.children && b.children.length > 0) && s.value && e10.border) {
      u.value = true;
      const g = o;
      t("set-drag-visible", true);
      const y = (g == null ? void 0 : g.vnode.el).getBoundingClientRect().left, _ = n.vnode.el.querySelector(`th.${b.id}`), C = _.getBoundingClientRect(), E = C.left - y + 30;
      jo(_, "noclick"), c.value = {
        startMouseLeft: h.clientX,
        startLeft: C.right - y,
        startColumnLeft: C.left - y,
        tableLeft: y
      };
      const T = g == null ? void 0 : g.refs.resizeProxy;
      T.style.left = `${c.value.startLeft}px`, document.onselectstart = function() {
        return false;
      }, document.ondragstart = function() {
        return false;
      };
      const O = ($) => {
        const R = $.clientX - c.value.startMouseLeft, P = c.value.startLeft + R;
        T.style.left = `${Math.max(E, P)}px`;
      }, N = () => {
        if (u.value) {
          const { startColumnLeft: $, startLeft: R } = c.value, z = Number.parseInt(T.style.left, 10) - $;
          b.width = b.realWidth = z, g == null || g.emit("header-dragend", b.width, R - $, b, h), requestAnimationFrame(() => {
            e10.store.scheduleLayout(false, true);
          }), document.body.style.cursor = "", u.value = false, s.value = null, c.value = {}, t("set-drag-visible", false);
        }
        document.removeEventListener("mousemove", O), document.removeEventListener("mouseup", N), document.onselectstart = null, document.ondragstart = null, setTimeout(() => {
          no(_, "noclick");
        }, 0);
      };
      document.addEventListener("mousemove", O), document.addEventListener("mouseup", N);
    }
  }, f = (h, b) => {
    var g;
    if (b.children && b.children.length > 0)
      return;
    const w = h.target;
    if (!to(w))
      return;
    const y = w == null ? void 0 : w.closest("th");
    if (!(!b || !b.resizable || !y) && !u.value && e10.border) {
      const _ = y.getBoundingClientRect(), C = document.body.style, E = ((g = y.parentNode) == null ? void 0 : g.lastElementChild) === y, T = e10.allowDragLastColumn || !E;
      _.width > 12 && _.right - h.clientX < 8 && T ? (C.cursor = "col-resize", Eo(y, "is-sortable") && (y.style.cursor = "col-resize"), s.value = b) : u.value || (C.cursor = "", Eo(y, "is-sortable") && (y.style.cursor = "pointer"), s.value = null);
    }
  }, p = () => {
    Et && (document.body.style.cursor = "");
  }, v = ({ order: h, sortOrders: b }) => {
    if (h === "")
      return b[0];
    const g = b.indexOf(h || null);
    return b[g > b.length - 2 ? 0 : g + 1];
  }, m = (h, b, g) => {
    var w;
    h.stopPropagation();
    const y = b.order === g ? null : g || v(b), _ = (w = h.target) == null ? void 0 : w.closest("th");
    if (_ && Eo(_, "noclick")) {
      no(_, "noclick");
      return;
    }
    if (!b.sortable)
      return;
    const C = h.currentTarget;
    if (["ascending", "descending"].some(($) => Eo(C, $) && !b.sortOrders.includes($)))
      return;
    const E = e10.store.states;
    let T = E.sortProp.value, O;
    const N = E.sortingColumn.value;
    (N !== b || N === b && rc(N.order)) && (N && (N.order = null), E.sortingColumn.value = b, T = b.property), y ? O = b.order = y : O = b.order = null, E.sortProp.value = T, E.sortOrder.value = O, o == null || o.store.commit("changeSortCondition");
  };
  return {
    handleHeaderClick: a,
    handleHeaderContextMenu: l,
    handleMouseDown: d,
    handleMouseMove: f,
    handleMouseOut: p,
    handleSortClick: m,
    handleFilterClick: r
  };
}
function Cq(e10) {
  const t = Le(kr), n = we("table");
  return {
    getHeaderRowStyle: (s) => {
      const u = t == null ? void 0 : t.props.headerRowStyle;
      return Fe(u) ? u.call(null, { rowIndex: s }) : u;
    },
    getHeaderRowClass: (s) => {
      const u = [], c = t == null ? void 0 : t.props.headerRowClassName;
      return Ve(c) ? u.push(c) : Fe(c) && u.push(c.call(null, { rowIndex: s })), u.join(" ");
    },
    getHeaderCellStyle: (s, u, c, d) => {
      var f;
      let p = (f = t == null ? void 0 : t.props.headerCellStyle) != null ? f : {};
      Fe(p) && (p = p.call(null, {
        rowIndex: s,
        columnIndex: u,
        row: c,
        column: d
      }));
      const v = Jg(u, d.fixed, e10.store, c);
      return ci(v, "left"), ci(v, "right"), Object.assign({}, p, v);
    },
    getHeaderCellClass: (s, u, c, d) => {
      const f = Xg(n.b(), u, d.fixed, e10.store, c), p = [
        d.id,
        d.order,
        d.headerAlign,
        d.className,
        d.labelClassName,
        ...f
      ];
      d.children || p.push("is-leaf"), d.sortable && p.push("is-sortable");
      const v = t == null ? void 0 : t.props.headerCellClassName;
      return Ve(v) ? p.push(v) : Fe(v) && p.push(v.call(null, {
        rowIndex: s,
        columnIndex: u,
        row: c,
        column: d
      })), p.push(n.e("cell")), p.filter((m) => !!m).join(" ");
    }
  };
}
const iN = (e10) => {
  const t = [];
  return e10.forEach((n) => {
    n.children ? (t.push(n), t.push.apply(t, iN(n.children))) : t.push(n);
  }), t;
}, uN = (e10) => {
  let t = 1;
  const n = (a, l) => {
    if (l && (a.level = l.level + 1, t < a.level && (t = a.level)), a.children) {
      let s = 0;
      a.children.forEach((u) => {
        n(u, a), s += u.colSpan;
      }), a.colSpan = s;
    } else
      a.colSpan = 1;
  };
  e10.forEach((a) => {
    a.level = 1, n(a, void 0);
  });
  const o = [];
  for (let a = 0; a < t; a++)
    o.push([]);
  return iN(e10).forEach((a) => {
    a.children ? (a.rowSpan = 1, a.children.forEach((l) => l.isSubColumn = true)) : a.rowSpan = t - a.level + 1, o[a.level - 1].push(a);
  }), o;
};
function Eq(e10) {
  const t = Le(kr), n = S(() => uN(e10.store.states.originColumns.value));
  return {
    isGroup: S(() => {
      const a = n.value.length > 1;
      return a && t && (t.state.isGroup.value = true), a;
    }),
    toggleAllSelection: (a) => {
      a.stopPropagation(), t == null || t.store.commit("toggleAllSelection");
    },
    columnRows: n
  };
}
var Sq = /* @__PURE__ */ j({
  name: "ElTableHeader",
  components: {
    ElCheckbox: er
  },
  props: {
    fixed: {
      type: String,
      default: ""
    },
    store: {
      required: true,
      type: Object
    },
    border: Boolean,
    defaultSort: {
      type: Object,
      default: () => ({
        prop: "",
        order: ""
      })
    },
    appendFilterPanelTo: {
      type: String
    },
    allowDragLastColumn: {
      type: Boolean
    }
  },
  setup(e10, { emit: t }) {
    const n = it(), o = Le(kr), r = we("table"), a = L({}), { onColumnsChange: l, onScrollableChange: s } = Zg(o), u = (o == null ? void 0 : o.props.tableLayout) === "auto", c = It(/* @__PURE__ */ new Map()), d = L(), f = () => {
      setTimeout(() => {
        c.size > 0 && (c.forEach(($, R) => {
          const P = d.value.querySelector(`.${R.replace(/\s/g, ".")}`);
          if (P) {
            const z = P.getBoundingClientRect().width;
            $.width = z;
          }
        }), c.clear());
      });
    };
    ge(c, f), dt(async () => {
      await He(), await He();
      const { prop: $, order: R } = e10.defaultSort;
      o == null || o.store.commit("sort", { prop: $, order: R, init: true }), f();
    });
    const {
      handleHeaderClick: p,
      handleHeaderContextMenu: v,
      handleMouseDown: m,
      handleMouseMove: h,
      handleMouseOut: b,
      handleSortClick: g,
      handleFilterClick: w
    } = wq(e10, t), {
      getHeaderRowStyle: y,
      getHeaderRowClass: _,
      getHeaderCellStyle: C,
      getHeaderCellClass: E
    } = Cq(e10), { isGroup: T, toggleAllSelection: O, columnRows: N } = Eq(e10);
    return n.state = {
      onColumnsChange: l,
      onScrollableChange: s
    }, n.filterPanels = a, {
      ns: r,
      filterPanels: a,
      onColumnsChange: l,
      onScrollableChange: s,
      columnRows: N,
      getHeaderRowClass: _,
      getHeaderRowStyle: y,
      getHeaderCellClass: E,
      getHeaderCellStyle: C,
      handleHeaderClick: p,
      handleHeaderContextMenu: v,
      handleMouseDown: m,
      handleMouseMove: h,
      handleMouseOut: b,
      handleSortClick: g,
      handleFilterClick: w,
      isGroup: T,
      toggleAllSelection: O,
      saveIndexSelection: c,
      isTableLayoutAuto: u,
      theadRef: d,
      updateFixedColumnStyle: f
    };
  },
  render() {
    const {
      ns: e10,
      isGroup: t,
      columnRows: n,
      getHeaderCellStyle: o,
      getHeaderCellClass: r,
      getHeaderRowClass: a,
      getHeaderRowStyle: l,
      handleHeaderClick: s,
      handleHeaderContextMenu: u,
      handleMouseDown: c,
      handleMouseMove: d,
      handleSortClick: f,
      handleMouseOut: p,
      store: v,
      $parent: m,
      saveIndexSelection: h,
      isTableLayoutAuto: b
    } = this;
    let g = 1;
    return Ke("thead", {
      ref: "theadRef",
      class: { [e10.is("group")]: t }
    }, n.map((w, y) => Ke("tr", {
      class: a(y),
      key: y,
      style: l(y)
    }, w.map((_, C) => {
      _.rowSpan > g && (g = _.rowSpan);
      const E = r(y, C, w, _);
      return b && _.fixed && h.set(E, _), Ke("th", {
        class: E,
        colspan: _.colSpan,
        key: `${_.id}-thead`,
        rowspan: _.rowSpan,
        style: o(y, C, w, _),
        onClick: (T) => {
          T.currentTarget.classList.contains("noclick") || s(T, _);
        },
        onContextmenu: (T) => u(T, _),
        onMousedown: (T) => c(T, _),
        onMousemove: (T) => d(T, _),
        onMouseout: p
      }, [
        Ke("div", {
          class: [
            "cell",
            _.filteredValue && _.filteredValue.length > 0 ? "highlight" : ""
          ]
        }, [
          _.renderHeader ? _.renderHeader({
            column: _,
            $index: C,
            store: v,
            _self: m
          }) : _.label,
          _.sortable && Ke("span", {
            onClick: (T) => f(T, _),
            class: "caret-wrapper"
          }, [
            Ke("i", {
              onClick: (T) => f(T, _, "ascending"),
              class: "sort-caret ascending"
            }),
            Ke("i", {
              onClick: (T) => f(T, _, "descending"),
              class: "sort-caret descending"
            })
          ]),
          _.filterable && Ke(_q, {
            store: v,
            placement: _.filterPlacement || "bottom-start",
            appendTo: m.appendFilterPanelTo,
            column: _,
            upDataColumn: (T, O) => {
              _[T] = O;
            }
          }, {
            "filter-icon": () => _.renderFilterIcon ? _.renderFilterIcon({
              filterOpened: _.filterOpened
            }) : null
          })
        ])
      ]);
    }))));
  }
});
function fv(e10, t, n = 0.03) {
  return e10 - t > n;
}
function kq(e10) {
  const t = Le(kr), n = L(""), o = L(Ke("div")), r = (m, h, b) => {
    var g;
    const w = t, y = dv(m);
    let _;
    const C = (g = w == null ? void 0 : w.vnode.el) == null ? void 0 : g.dataset.prefix;
    y && (_ = Z1({
      columns: e10.store.states.columns.value
    }, y, C), _ && (w == null || w.emit(`cell-${b}`, h, _, y, m))), w == null || w.emit(`row-${b}`, h, _, m);
  }, a = (m, h) => {
    r(m, h, "dblclick");
  }, l = (m, h) => {
    e10.store.commit("setCurrentRow", h), r(m, h, "click");
  }, s = (m, h) => {
    r(m, h, "contextmenu");
  }, u = Oo((m) => {
    e10.store.commit("setHoverRow", m);
  }, 30), c = Oo(() => {
    e10.store.commit("setHoverRow", null);
  }, 30), d = (m) => {
    const h = window.getComputedStyle(m, null), b = Number.parseInt(h.paddingLeft, 10) || 0, g = Number.parseInt(h.paddingRight, 10) || 0, w = Number.parseInt(h.paddingTop, 10) || 0, y = Number.parseInt(h.paddingBottom, 10) || 0;
    return {
      left: b,
      right: g,
      top: w,
      bottom: y
    };
  }, f = (m, h, b) => {
    let g = h.target.parentNode;
    for (; m > 1 && (g = g == null ? void 0 : g.nextSibling, !(!g || g.nodeName !== "TR")); )
      b(g, "hover-row hover-fixed-row"), m--;
  };
  return {
    handleDoubleClick: a,
    handleClick: l,
    handleContextMenu: s,
    handleMouseEnter: u,
    handleMouseLeave: c,
    handleCellMouseEnter: (m, h, b) => {
      var g, w, y;
      const _ = t, C = dv(m), E = (g = _ == null ? void 0 : _.vnode.el) == null ? void 0 : g.dataset.prefix;
      let T;
      if (C) {
        T = Z1({
          columns: e10.store.states.columns.value
        }, C, E), C.rowSpan > 1 && f(C.rowSpan, m, jo);
        const Z = _.hoverState = { cell: C, column: T, row: h };
        _ == null || _.emit("cell-mouse-enter", Z.row, Z.column, Z.cell, m);
      }
      if (!b)
        return;
      const O = m.target.querySelector(".cell");
      if (!(Eo(O, `${E}-tooltip`) && O.childNodes.length))
        return;
      const N = document.createRange();
      N.setStart(O, 0), N.setEnd(O, O.childNodes.length);
      const { width: $, height: R } = N.getBoundingClientRect(), { width: P, height: z } = O.getBoundingClientRect(), { top: Y, left: D, right: M, bottom: F } = d(O), A = D + M, V = Y + F;
      fv($ + A, P) || fv(R + V, z) || fv(O.scrollWidth, P) ? sq(b, C.innerText || C.textContent, h, T, C, _) : ((w = wo) == null ? void 0 : w.trigger) === C && ((y = wo) == null || y());
    },
    handleCellMouseLeave: (m) => {
      const h = dv(m);
      if (!h)
        return;
      h.rowSpan > 1 && f(h.rowSpan, m, no);
      const b = t == null ? void 0 : t.hoverState;
      t == null || t.emit("cell-mouse-leave", b == null ? void 0 : b.row, b == null ? void 0 : b.column, b == null ? void 0 : b.cell, m);
    },
    tooltipContent: n,
    tooltipTrigger: o
  };
}
function Nq(e10) {
  const t = Le(kr), n = we("table");
  return {
    getRowStyle: (c, d) => {
      const f = t == null ? void 0 : t.props.rowStyle;
      return Fe(f) ? f.call(null, {
        row: c,
        rowIndex: d
      }) : f || null;
    },
    getRowClass: (c, d) => {
      const f = [n.e("row")];
      t != null && t.props.highlightCurrentRow && c === e10.store.states.currentRow.value && f.push("current-row"), e10.stripe && d % 2 === 1 && f.push(n.em("row", "striped"));
      const p = t == null ? void 0 : t.props.rowClassName;
      return Ve(p) ? f.push(p) : Fe(p) && f.push(p.call(null, {
        row: c,
        rowIndex: d
      })), f;
    },
    getCellStyle: (c, d, f, p) => {
      const v = t == null ? void 0 : t.props.cellStyle;
      let m = v != null ? v : {};
      Fe(v) && (m = v.call(null, {
        rowIndex: c,
        columnIndex: d,
        row: f,
        column: p
      }));
      const h = Jg(d, e10 == null ? void 0 : e10.fixed, e10.store);
      return ci(h, "left"), ci(h, "right"), Object.assign({}, m, h);
    },
    getCellClass: (c, d, f, p, v) => {
      const m = Xg(n.b(), d, e10 == null ? void 0 : e10.fixed, e10.store, void 0, v), h = [p.id, p.align, p.className, ...m], b = t == null ? void 0 : t.props.cellClassName;
      return Ve(b) ? h.push(b) : Fe(b) && h.push(b.call(null, {
        rowIndex: c,
        columnIndex: d,
        row: f,
        column: p
      })), h.push(n.e("cell")), h.filter((g) => !!g).join(" ");
    },
    getSpan: (c, d, f, p) => {
      let v = 1, m = 1;
      const h = t == null ? void 0 : t.props.spanMethod;
      if (Fe(h)) {
        const b = h({
          row: c,
          column: d,
          rowIndex: f,
          columnIndex: p
        });
        Se(b) ? (v = b[0], m = b[1]) : at(b) && (v = b.rowspan, m = b.colspan);
      }
      return { rowspan: v, colspan: m };
    },
    getColspanRealWidth: (c, d, f) => {
      if (d < 1)
        return c[f].realWidth;
      const p = c.map(({ realWidth: v, width: m }) => v || m).slice(f, f + d);
      return Number(p.reduce((v, m) => Number(v) + Number(m), -1));
    }
  };
}
const Tq = /* @__PURE__ */ j({
  name: "TableTdWrapper"
}), Oq = /* @__PURE__ */ j({
  ...Tq,
  props: {
    colspan: {
      type: Number,
      default: 1
    },
    rowspan: {
      type: Number,
      default: 1
    }
  },
  setup(e10) {
    return (t, n) => (k(), x("td", {
      colspan: e10.colspan,
      rowspan: e10.rowspan
    }, [
      J(t.$slots, "default")
    ], 8, ["colspan", "rowspan"]));
  }
});
var $q = /* @__PURE__ */ $e(Oq, [["__file", "td-wrapper.vue"]]);
function Iq(e10) {
  const t = Le(kr), n = we("table"), {
    handleDoubleClick: o,
    handleClick: r,
    handleContextMenu: a,
    handleMouseEnter: l,
    handleMouseLeave: s,
    handleCellMouseEnter: u,
    handleCellMouseLeave: c,
    tooltipContent: d,
    tooltipTrigger: f
  } = kq(e10), {
    getRowStyle: p,
    getRowClass: v,
    getCellStyle: m,
    getCellClass: h,
    getSpan: b,
    getColspanRealWidth: g
  } = Nq(e10), w = S(() => e10.store.states.columns.value.findIndex(({ type: T }) => T === "default")), y = (T, O) => {
    const N = t.props.rowKey;
    return N ? Qn(T, N) : O;
  }, _ = (T, O, N, $ = false) => {
    const { tooltipEffect: R, tooltipOptions: P, store: z } = e10, { indent: Y, columns: D } = z.states, M = v(T, O);
    let F = true;
    return N && (M.push(n.em("row", `level-${N.level}`)), F = N.display), Ke("tr", {
      style: [F ? null : { display: "none" }, p(T, O)],
      class: M,
      key: y(T, O),
      onDblclick: (V) => o(V, T),
      onClick: (V) => r(V, T),
      onContextmenu: (V) => a(V, T),
      onMouseenter: () => l(O),
      onMouseleave: s
    }, D.value.map((V, Z) => {
      const { rowspan: G, colspan: le } = b(T, V, O, Z);
      if (!G || !le)
        return null;
      const X = Object.assign({}, V);
      X.realWidth = g(D.value, le, Z);
      const te = {
        store: e10.store,
        _self: e10.context || t,
        column: X,
        row: T,
        $index: O,
        cellIndex: Z,
        expanded: $
      };
      Z === w.value && N && (te.treeNode = {
        indent: N.level * Y.value,
        level: N.level
      }, Vt(N.expanded) && (te.treeNode.expanded = N.expanded, "loading" in N && (te.treeNode.loading = N.loading), "noLazyChildren" in N && (te.treeNode.noLazyChildren = N.noLazyChildren)));
      const ce = `${y(T, O)},${Z}`, pe = X.columnKey || X.rawColumnKey || "", se = V.showOverflowTooltip && iS({
        effect: R
      }, P, V.showOverflowTooltip);
      return Ke($q, {
        style: m(O, Z, T, V),
        class: h(O, Z, T, V, le - 1),
        key: `${pe}${ce}`,
        rowspan: G,
        colspan: le,
        onMouseenter: (ve) => u(ve, T, se),
        onMouseleave: c
      }, {
        default: () => C(Z, V, te)
      });
    }));
  }, C = (T, O, N) => O.renderCell(N);
  return {
    wrappedRowRender: (T, O) => {
      const N = e10.store, { isRowExpanded: $, assertRowKey: R } = N, { treeData: P, lazyTreeNodeMap: z, childrenColumnName: Y, rowKey: D } = N.states, M = N.states.columns.value;
      if (M.some(({ type: A }) => A === "expand")) {
        const A = $(T), V = _(T, O, void 0, A), Z = t.renderExpanded;
        if (!Z)
          return console.error("[Element Error]renderExpanded is required."), V;
        const G = [[V]];
        return (t.props.preserveExpandedContent || A) && G[0].push(Ke("tr", {
          key: `expanded-row__${V.key}`,
          style: { display: A ? "" : "none" }
        }, [
          Ke("td", {
            colspan: M.length,
            class: `${n.e("cell")} ${n.e("expanded-cell")}`
          }, [Z({ row: T, $index: O, store: N, expanded: A })])
        ])), G;
      } else if (Object.keys(P.value).length) {
        R();
        const A = Qn(T, D.value);
        let V = P.value[A], Z = null;
        V && (Z = {
          expanded: V.expanded,
          level: V.level,
          display: true
        }, Vt(V.lazy) && (Vt(V.loaded) && V.loaded && (Z.noLazyChildren = !(V.children && V.children.length)), Z.loading = V.loading));
        const G = [_(T, O, Z)];
        if (V) {
          let le = 0;
          const X = (ce, pe) => {
            ce && ce.length && pe && ce.forEach((se) => {
              const ve = {
                display: pe.display && pe.expanded,
                level: pe.level + 1,
                expanded: false,
                noLazyChildren: false,
                loading: false
              }, me = Qn(se, D.value);
              if (So(me))
                throw new Error("For nested data item, row-key is required.");
              if (V = { ...P.value[me] }, V && (ve.expanded = V.expanded, V.level = V.level || ve.level, V.display = !!(V.expanded && ve.display), Vt(V.lazy) && (Vt(V.loaded) && V.loaded && (ve.noLazyChildren = !(V.children && V.children.length)), ve.loading = V.loading)), le++, G.push(_(se, O + le, ve)), V) {
                const De = z.value[me] || se[Y.value];
                X(De, V);
              }
            });
          };
          V.display = true;
          const te = z.value[A] || T[Y.value];
          X(te, V);
        }
        return G;
      } else
        return _(T, O, void 0);
    },
    tooltipContent: d,
    tooltipTrigger: f
  };
}
const Mq = {
  store: {
    required: true,
    type: Object
  },
  stripe: Boolean,
  tooltipEffect: String,
  tooltipOptions: {
    type: Object
  },
  context: {
    default: () => ({}),
    type: Object
  },
  rowClassName: [String, Function],
  rowStyle: [Object, Function],
  fixed: {
    type: String,
    default: ""
  },
  highlight: Boolean
};
var Pq = /* @__PURE__ */ j({
  name: "ElTableBody",
  props: Mq,
  setup(e10) {
    const t = it(), n = Le(kr), o = we("table"), { wrappedRowRender: r, tooltipContent: a, tooltipTrigger: l } = Iq(e10), { onColumnsChange: s, onScrollableChange: u } = Zg(n), c = [];
    return ge(e10.store.states.hoverRow, (d, f) => {
      var p;
      const v = t == null ? void 0 : t.vnode.el, m = Array.from((v == null ? void 0 : v.children) || []).filter((g) => g == null ? void 0 : g.classList.contains(`${o.e("row")}`));
      let h = d;
      const b = (p = m[h]) == null ? void 0 : p.childNodes;
      if (b != null && b.length) {
        let g = 0;
        Array.from(b).reduce((y, _, C) => {
          var E, T;
          return ((E = b[C]) == null ? void 0 : E.colSpan) > 1 && (g = (T = b[C]) == null ? void 0 : T.colSpan), _.nodeName !== "TD" && g === 0 && y.push(C), g > 0 && g--, y;
        }, []).forEach((y) => {
          var _;
          for (h = d; h > 0; ) {
            const C = (_ = m[h - 1]) == null ? void 0 : _.childNodes;
            if (C[y] && C[y].nodeName === "TD" && C[y].rowSpan > 1) {
              jo(C[y], "hover-cell"), c.push(C[y]);
              break;
            }
            h--;
          }
        });
      } else
        c.forEach((g) => no(g, "hover-cell")), c.length = 0;
      !e10.store.states.isComplex.value || !Et || sl(() => {
        const g = m[f], w = m[d];
        g && !g.classList.contains("hover-fixed-row") && no(g, "hover-row"), w && jo(w, "hover-row");
      });
    }), Jr(() => {
      var d;
      (d = wo) == null || d();
    }), {
      ns: o,
      onColumnsChange: s,
      onScrollableChange: u,
      wrappedRowRender: r,
      tooltipContent: a,
      tooltipTrigger: l
    };
  },
  render() {
    const { wrappedRowRender: e10, store: t } = this, n = t.states.data.value || [];
    return Ke("tbody", { tabIndex: -1 }, [
      n.reduce((o, r) => o.concat(e10(r, o.length)), [])
    ]);
  }
});
function Rq() {
  var e10;
  const t = Le(kr), n = t == null ? void 0 : t.store, o = S(() => {
    var u;
    return (u = n == null ? void 0 : n.states.fixedLeafColumnsLength.value) != null ? u : 0;
  }), r = S(() => {
    var u;
    return (u = n == null ? void 0 : n.states.rightFixedColumns.value.length) != null ? u : 0;
  }), a = S(() => {
    var u;
    return (u = n == null ? void 0 : n.states.columns.value.length) != null ? u : 0;
  }), l = S(() => {
    var u;
    return (u = n == null ? void 0 : n.states.fixedColumns.value.length) != null ? u : 0;
  }), s = S(() => {
    var u;
    return (u = n == null ? void 0 : n.states.rightFixedColumns.value.length) != null ? u : 0;
  });
  return {
    leftFixedLeafCount: o,
    rightFixedLeafCount: r,
    columnsCount: a,
    leftFixedCount: l,
    rightFixedCount: s,
    columns: (e10 = n == null ? void 0 : n.states.columns) != null ? e10 : []
  };
}
function Aq(e10) {
  const { columns: t } = Rq(), n = we("table");
  return {
    getCellClasses: (a, l) => {
      const s = a[l], u = [
        n.e("cell"),
        s.id,
        s.align,
        s.labelClassName,
        ...Xg(n.b(), l, s.fixed, e10.store)
      ];
      return s.className && u.push(s.className), s.children || u.push(n.is("leaf")), u;
    },
    getCellStyles: (a, l) => {
      const s = Jg(l, a.fixed, e10.store);
      return ci(s, "left"), ci(s, "right"), s;
    },
    columns: t
  };
}
var Lq = /* @__PURE__ */ j({
  name: "ElTableFooter",
  props: {
    fixed: {
      type: String,
      default: ""
    },
    store: {
      required: true,
      type: Object
    },
    summaryMethod: Function,
    sumText: String,
    border: Boolean,
    defaultSort: {
      type: Object,
      default: () => ({
        prop: "",
        order: ""
      })
    }
  },
  setup(e10) {
    const t = Le(kr), n = we("table"), { getCellClasses: o, getCellStyles: r, columns: a } = Aq(e10), { onScrollableChange: l, onColumnsChange: s } = Zg(t);
    return {
      ns: n,
      onScrollableChange: l,
      onColumnsChange: s,
      getCellClasses: o,
      getCellStyles: r,
      columns: a
    };
  },
  render() {
    const { columns: e10, getCellStyles: t, getCellClasses: n, summaryMethod: o, sumText: r } = this, a = this.store.states.data.value;
    let l = [];
    return o ? l = o({
      columns: e10,
      data: a
    }) : e10.forEach((s, u) => {
      if (u === 0) {
        l[u] = r;
        return;
      }
      const c = a.map((v) => Number(v[s.property])), d = [];
      let f = true;
      c.forEach((v) => {
        if (!Number.isNaN(+v)) {
          f = false;
          const m = `${v}`.split(".")[1];
          d.push(m ? m.length : 0);
        }
      });
      const p = Math.max.apply(null, d);
      f ? l[u] = "" : l[u] = c.reduce((v, m) => {
        const h = Number(m);
        return Number.isNaN(+h) ? v : Number.parseFloat((v + m).toFixed(Math.min(p, 20)));
      }, 0);
    }), Ke(Ke("tfoot", [
      Ke("tr", {}, [
        ...e10.map((s, u) => Ke("td", {
          key: u,
          colspan: s.colSpan,
          rowspan: s.rowSpan,
          class: n(e10, u),
          style: t(s, u)
        }, [
          Ke("div", {
            class: ["cell", s.labelClassName]
          }, [l[u]])
        ]))
      ])
    ]));
  }
});
function xq(e10) {
  return {
    setCurrentRow: (f) => {
      e10.commit("setCurrentRow", f);
    },
    getSelectionRows: () => e10.getSelectionRows(),
    toggleRowSelection: (f, p, v = true) => {
      e10.toggleRowSelection(f, p, false, v), e10.updateAllSelected();
    },
    clearSelection: () => {
      e10.clearSelection();
    },
    clearFilter: (f) => {
      e10.clearFilter(f);
    },
    toggleAllSelection: () => {
      e10.commit("toggleAllSelection");
    },
    toggleRowExpansion: (f, p) => {
      e10.toggleRowExpansionAdapter(f, p);
    },
    clearSort: () => {
      e10.clearSort();
    },
    sort: (f, p) => {
      e10.commit("sort", { prop: f, order: p });
    },
    updateKeyChildren: (f, p) => {
      e10.updateKeyChildren(f, p);
    }
  };
}
function Dq(e10, t, n, o) {
  const r = L(false), a = L(null), l = L(false), s = (A) => {
    l.value = A;
  }, u = L({
    width: null,
    height: null,
    headerHeight: null
  }), c = L(false), d = {
    display: "inline-block",
    verticalAlign: "middle"
  }, f = L(), p = L(0), v = L(0), m = L(0), h = L(0), b = L(0);
  Vn(() => {
    t.setHeight(e10.height);
  }), Vn(() => {
    t.setMaxHeight(e10.maxHeight);
  }), ge(() => [e10.currentRowKey, n.states.rowKey], ([A, V]) => {
    !i(V) || !i(A) || n.setCurrentRowKey(`${A}`);
  }, {
    immediate: true
  }), ge(() => e10.data, (A) => {
    o.store.commit("setData", A);
  }, {
    immediate: true,
    deep: true
  }), Vn(() => {
    e10.expandRowKeys && n.setExpandRowKeysAdapter(e10.expandRowKeys);
  });
  const g = () => {
    o.store.commit("setHoverRow", null), o.hoverState && (o.hoverState = null);
  }, w = (A, V) => {
    const { pixelX: Z, pixelY: G } = V;
    Math.abs(Z) >= Math.abs(G) && (o.refs.bodyWrapper.scrollLeft += V.pixelX / 5);
  }, y = S(() => e10.height || e10.maxHeight || n.states.fixedColumns.value.length > 0 || n.states.rightFixedColumns.value.length > 0), _ = S(() => ({
    width: t.bodyWidth.value ? `${t.bodyWidth.value}px` : ""
  })), C = () => {
    y.value && t.updateElsHeight(), t.updateColumnsWidth(), !(typeof window > "u") && requestAnimationFrame(N);
  };
  dt(async () => {
    await He(), n.updateColumns(), $(), requestAnimationFrame(C);
    const A = o.vnode.el, V = o.refs.headerWrapper;
    e10.flexible && A && A.parentElement && (A.parentElement.style.minWidth = "0"), u.value = {
      width: f.value = A.offsetWidth,
      height: A.offsetHeight,
      headerHeight: e10.showHeader && V ? V.offsetHeight : null
    }, n.states.columns.value.forEach((Z) => {
      Z.filteredValue && Z.filteredValue.length && o.store.commit("filterChange", {
        column: Z,
        values: Z.filteredValue,
        silent: true
      });
    }), o.$ready = true;
  });
  const E = (A, V) => {
    if (!A)
      return;
    const Z = Array.from(A.classList).filter((G) => !G.startsWith("is-scrolling-"));
    Z.push(t.scrollX.value ? V : "is-scrolling-none"), A.className = Z.join(" ");
  }, T = (A) => {
    const { tableWrapper: V } = o.refs;
    E(V, A);
  }, O = (A) => {
    const { tableWrapper: V } = o.refs;
    return !!(V && V.classList.contains(A));
  }, N = function() {
    if (!o.refs.scrollBarRef)
      return;
    if (!t.scrollX.value) {
      const ce = "is-scrolling-none";
      O(ce) || T(ce);
      return;
    }
    const A = o.refs.scrollBarRef.wrapRef;
    if (!A)
      return;
    const { scrollLeft: V, offsetWidth: Z, scrollWidth: G } = A, { headerWrapper: le, footerWrapper: X } = o.refs;
    le && (le.scrollLeft = V), X && (X.scrollLeft = V);
    const te = G - Z - 1;
    V >= te ? T("is-scrolling-right") : T(V === 0 ? "is-scrolling-left" : "is-scrolling-middle");
  }, $ = () => {
    o.refs.scrollBarRef && (o.refs.scrollBarRef.wrapRef && Ft(o.refs.scrollBarRef.wrapRef, "scroll", N, {
      passive: true
    }), e10.fit ? en(o.vnode.el, R) : Ft(window, "resize", R), en(o.refs.bodyWrapper, () => {
      var A, V;
      R(), (V = (A = o.refs) == null ? void 0 : A.scrollBarRef) == null || V.update();
    }));
  }, R = () => {
    var A, V, Z, G;
    const le = o.vnode.el;
    if (!o.$ready || !le)
      return;
    let X = false;
    const {
      width: te,
      height: ce,
      headerHeight: pe
    } = u.value, se = f.value = le.offsetWidth;
    te !== se && (X = true);
    const ve = le.offsetHeight;
    (e10.height || y.value) && ce !== ve && (X = true);
    const me = e10.tableLayout === "fixed" ? o.refs.headerWrapper : (A = o.refs.tableHeaderRef) == null ? void 0 : A.$el;
    e10.showHeader && (me == null ? void 0 : me.offsetHeight) !== pe && (X = true), p.value = ((V = o.refs.tableWrapper) == null ? void 0 : V.scrollHeight) || 0, m.value = (me == null ? void 0 : me.scrollHeight) || 0, h.value = ((Z = o.refs.footerWrapper) == null ? void 0 : Z.offsetHeight) || 0, b.value = ((G = o.refs.appendWrapper) == null ? void 0 : G.offsetHeight) || 0, v.value = p.value - m.value - h.value - b.value, X && (u.value = {
      width: se,
      height: ve,
      headerHeight: e10.showHeader && (me == null ? void 0 : me.offsetHeight) || 0
    }, C());
  }, P = yn(), z = S(() => {
    const { bodyWidth: A, scrollY: V, gutterWidth: Z } = t;
    return A.value ? `${A.value - (V.value ? Z : 0)}px` : "";
  }), Y = S(() => e10.maxHeight ? "fixed" : e10.tableLayout), D = S(() => {
    if (e10.data && e10.data.length)
      return null;
    let A = "100%";
    e10.height && v.value && (A = `${v.value}px`);
    const V = f.value;
    return {
      width: V ? `${V}px` : "",
      height: A
    };
  }), M = S(() => e10.height ? {
    height: "100%"
  } : e10.maxHeight ? Number.isNaN(Number(e10.maxHeight)) ? {
    maxHeight: `calc(${e10.maxHeight} - ${m.value + h.value}px)`
  } : {
    maxHeight: `${e10.maxHeight - m.value - h.value}px`
  } : {});
  return {
    isHidden: r,
    renderExpanded: a,
    setDragVisible: s,
    isGroup: c,
    handleMouseLeave: g,
    handleHeaderFooterMousewheel: w,
    tableSize: P,
    emptyBlockStyle: D,
    handleFixedMousewheel: (A, V) => {
      const Z = o.refs.bodyWrapper;
      if (Math.abs(V.spinY) > 0) {
        const G = Z.scrollTop;
        V.pixelY < 0 && G !== 0 && A.preventDefault(), V.pixelY > 0 && Z.scrollHeight - Z.clientHeight > G && A.preventDefault(), Z.scrollTop += Math.ceil(V.pixelY / 5);
      } else
        Z.scrollLeft += Math.ceil(V.pixelX / 5);
    },
    resizeProxyVisible: l,
    bodyWidth: z,
    resizeState: u,
    doLayout: C,
    tableBodyStyles: _,
    tableLayout: Y,
    scrollbarViewStyle: d,
    scrollbarStyle: M
  };
}
function Vq(e10) {
  const t = L(), n = () => {
    const r = e10.vnode.el.querySelector(".hidden-columns"), a = { childList: true, subtree: true }, l = e10.store.states.updateOrderFns;
    t.value = new MutationObserver(() => {
      l.forEach((s) => s());
    }), t.value.observe(r, a);
  };
  dt(() => {
    n();
  }), Jr(() => {
    var o;
    (o = t.value) == null || o.disconnect();
  });
}
var Fq = {
  data: {
    type: Array,
    default: () => []
  },
  size: _n,
  width: [String, Number],
  height: [String, Number],
  maxHeight: [String, Number],
  fit: {
    type: Boolean,
    default: true
  },
  stripe: Boolean,
  border: Boolean,
  rowKey: [String, Function],
  showHeader: {
    type: Boolean,
    default: true
  },
  showSummary: Boolean,
  sumText: String,
  summaryMethod: Function,
  rowClassName: [String, Function],
  rowStyle: [Object, Function],
  cellClassName: [String, Function],
  cellStyle: [Object, Function],
  headerRowClassName: [String, Function],
  headerRowStyle: [Object, Function],
  headerCellClassName: [String, Function],
  headerCellStyle: [Object, Function],
  highlightCurrentRow: Boolean,
  currentRowKey: [String, Number],
  emptyText: String,
  expandRowKeys: Array,
  defaultExpandAll: Boolean,
  defaultSort: Object,
  tooltipEffect: String,
  tooltipOptions: Object,
  spanMethod: Function,
  selectOnIndeterminate: {
    type: Boolean,
    default: true
  },
  indent: {
    type: Number,
    default: 16
  },
  treeProps: {
    type: Object,
    default: () => ({
      hasChildren: "hasChildren",
      children: "children",
      checkStrictly: false
    })
  },
  lazy: Boolean,
  load: Function,
  style: {
    type: Object,
    default: () => ({})
  },
  className: {
    type: String,
    default: ""
  },
  tableLayout: {
    type: String,
    default: "fixed"
  },
  scrollbarAlwaysOn: Boolean,
  flexible: Boolean,
  showOverflowTooltip: [Boolean, Object],
  tooltipFormatter: Function,
  appendFilterPanelTo: String,
  scrollbarTabindex: {
    type: [Number, String],
    default: void 0
  },
  allowDragLastColumn: {
    type: Boolean,
    default: true
  },
  preserveExpandedContent: {
    type: Boolean,
    default: false
  }
};
function cN(e10) {
  const t = e10.tableLayout === "auto";
  let n = e10.columns || [];
  t && n.every(({ width: r }) => St(r)) && (n = []);
  const o = (r) => {
    const a = {
      key: `${e10.tableLayout}_${r.id}`,
      style: {},
      name: void 0
    };
    return t ? a.style = {
      width: `${r.width}px`
    } : a.name = r.id, a;
  };
  return Ke("colgroup", {}, n.map((r) => Ke("col", o(r))));
}
cN.props = ["columns", "tableLayout"];
const Bq = () => {
  const e10 = L(), t = (a, l) => {
    const s = e10.value;
    s && s.scrollTo(a, l);
  }, n = (a, l) => {
    const s = e10.value;
    s && Ye(l) && ["Top", "Left"].includes(a) && s[`setScroll${a}`](l);
  };
  return {
    scrollBarRef: e10,
    scrollTo: t,
    setScrollTop: (a) => n("Top", a),
    setScrollLeft: (a) => n("Left", a)
  };
};
var t_ = false, Tl, kh, Nh, Cd, Ed, dN, Sd, Th, Oh, $h, fN, Ih, Mh, pN, vN;
function _o() {
  if (!t_) {
    t_ = true;
    var e10 = navigator.userAgent, t = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(e10), n = /(Mac OS X)|(Windows)|(Linux)/.exec(e10);
    if (Ih = /\b(iPhone|iP[ao]d)/.exec(e10), Mh = /\b(iP[ao]d)/.exec(e10), $h = /Android/i.exec(e10), pN = /FBAN\/\w+;/i.exec(e10), vN = /Mobile/i.exec(e10), fN = !!/Win64/.exec(e10), t) {
      Tl = t[1] ? parseFloat(t[1]) : t[5] ? parseFloat(t[5]) : NaN, Tl && document && document.documentMode && (Tl = document.documentMode);
      var o = /(?:Trident\/(\d+.\d+))/.exec(e10);
      dN = o ? parseFloat(o[1]) + 4 : Tl, kh = t[2] ? parseFloat(t[2]) : NaN, Nh = t[3] ? parseFloat(t[3]) : NaN, Cd = t[4] ? parseFloat(t[4]) : NaN, Cd ? (t = /(?:Chrome\/(\d+\.\d+))/.exec(e10), Ed = t && t[1] ? parseFloat(t[1]) : NaN) : Ed = NaN;
    } else Tl = kh = Nh = Ed = Cd = NaN;
    if (n) {
      if (n[1]) {
        var r = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(e10);
        Sd = r ? parseFloat(r[1].replace("_", ".")) : true;
      } else Sd = false;
      Th = !!n[2], Oh = !!n[3];
    } else Sd = Th = Oh = false;
  }
}
var Ph = { ie: function() {
  return _o() || Tl;
}, ieCompatibilityMode: function() {
  return _o() || dN > Tl;
}, ie64: function() {
  return Ph.ie() && fN;
}, firefox: function() {
  return _o() || kh;
}, opera: function() {
  return _o() || Nh;
}, webkit: function() {
  return _o() || Cd;
}, safari: function() {
  return Ph.webkit();
}, chrome: function() {
  return _o() || Ed;
}, windows: function() {
  return _o() || Th;
}, osx: function() {
  return _o() || Sd;
}, linux: function() {
  return _o() || Oh;
}, iphone: function() {
  return _o() || Ih;
}, mobile: function() {
  return _o() || Ih || Mh || $h || vN;
}, nativeApp: function() {
  return _o() || pN;
}, android: function() {
  return _o() || $h;
}, ipad: function() {
  return _o() || Mh;
} }, Hq = Ph, zq = !!(typeof window < "u" && window.document && window.document.createElement), Kq = { canUseDOM: zq }, hN = Kq, mN;
hN.canUseDOM && (mN = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== true);
function Wq(e10, t) {
  if (!hN.canUseDOM || t && !("addEventListener" in document)) return false;
  var n = "on" + e10, o = n in document;
  if (!o) {
    var r = document.createElement("div");
    r.setAttribute(n, "return;"), o = typeof r[n] == "function";
  }
  return !o && mN && e10 === "wheel" && (o = document.implementation.hasFeature("Events.wheel", "3.0")), o;
}
var jq = Wq, n_ = 10, o_ = 40, r_ = 800;
function gN(e10) {
  var t = 0, n = 0, o = 0, r = 0;
  return "detail" in e10 && (n = e10.detail), "wheelDelta" in e10 && (n = -e10.wheelDelta / 120), "wheelDeltaY" in e10 && (n = -e10.wheelDeltaY / 120), "wheelDeltaX" in e10 && (t = -e10.wheelDeltaX / 120), "axis" in e10 && e10.axis === e10.HORIZONTAL_AXIS && (t = n, n = 0), o = t * n_, r = n * n_, "deltaY" in e10 && (r = e10.deltaY), "deltaX" in e10 && (o = e10.deltaX), (o || r) && e10.deltaMode && (e10.deltaMode == 1 ? (o *= o_, r *= o_) : (o *= r_, r *= r_)), o && !t && (t = o < 1 ? -1 : 1), r && !n && (n = r < 1 ? -1 : 1), { spinX: t, spinY: n, pixelX: o, pixelY: r };
}
gN.getEventType = function() {
  return Hq.firefox() ? "DOMMouseScroll" : jq("wheel") ? "wheel" : "mousewheel";
};
var Uq = gN;
/**
* Checks if an event is supported in the current execution environment.
*
* NOTE: This will not work correctly for non-generic events such as `change`,
* `reset`, `load`, `error`, and `select`.
*
* Borrows from Modernizr.
*
* @param {string} eventNameSuffix Event name, e.g. "click".
* @param {?boolean} capture Check if the capture phase is supported.
* @return {boolean} True if the event is supported.
* @internal
* @license Modernizr 3.0.0pre (Custom Build) | MIT
*/
const Yq = function(e10, t) {
  if (e10 && e10.addEventListener) {
    const n = function(o) {
      const r = Uq(o);
      t && Reflect.apply(t, this, [o, r]);
    };
    e10.addEventListener("wheel", n, { passive: true });
  }
}, qq = {
  beforeMount(e10, t) {
    Yq(e10, t.value);
  }
};
let Gq = 1;
const Xq = /* @__PURE__ */ j({
  name: "ElTable",
  directives: {
    Mousewheel: qq
  },
  components: {
    TableHeader: Sq,
    TableBody: Pq,
    TableFooter: Lq,
    ElScrollbar: ta,
    hColgroup: cN
  },
  props: Fq,
  emits: [
    "select",
    "select-all",
    "selection-change",
    "cell-mouse-enter",
    "cell-mouse-leave",
    "cell-contextmenu",
    "cell-click",
    "cell-dblclick",
    "row-click",
    "row-contextmenu",
    "row-dblclick",
    "header-click",
    "header-contextmenu",
    "sort-change",
    "filter-change",
    "current-change",
    "header-dragend",
    "expand-change",
    "scroll"
  ],
  setup(e10) {
    const { t } = kt(), n = we("table"), o = it();
    yt(kr, o);
    const r = vq(o, e10);
    o.store = r;
    const a = new mq({
      store: o.store,
      table: o,
      fit: e10.fit,
      showHeader: e10.showHeader
    });
    o.layout = a;
    const l = S(() => (r.states.data.value || []).length === 0), {
      setCurrentRow: s,
      getSelectionRows: u,
      toggleRowSelection: c,
      clearSelection: d,
      clearFilter: f,
      toggleAllSelection: p,
      toggleRowExpansion: v,
      clearSort: m,
      sort: h,
      updateKeyChildren: b
    } = xq(r), {
      isHidden: g,
      renderExpanded: w,
      setDragVisible: y,
      isGroup: _,
      handleMouseLeave: C,
      handleHeaderFooterMousewheel: E,
      tableSize: T,
      emptyBlockStyle: O,
      handleFixedMousewheel: N,
      resizeProxyVisible: $,
      bodyWidth: R,
      resizeState: P,
      doLayout: z,
      tableBodyStyles: Y,
      tableLayout: D,
      scrollbarViewStyle: M,
      scrollbarStyle: F
    } = Dq(e10, a, r, o), { scrollBarRef: A, scrollTo: V, setScrollLeft: Z, setScrollTop: G } = Bq(), le = Oo(z, 50), X = `${n.namespace.value}-table_${Gq++}`;
    o.tableId = X, o.state = {
      isGroup: _,
      resizeState: P,
      doLayout: z,
      debouncedUpdateLayout: le
    };
    const te = S(() => {
      var se;
      return (se = e10.sumText) != null ? se : t("el.table.sumText");
    }), ce = S(() => {
      var se;
      return (se = e10.emptyText) != null ? se : t("el.table.emptyText");
    }), pe = S(() => uN(r.states.originColumns.value)[0]);
    return Vq(o), jt(() => {
      le.cancel();
    }), {
      ns: n,
      layout: a,
      store: r,
      columns: pe,
      handleHeaderFooterMousewheel: E,
      handleMouseLeave: C,
      tableId: X,
      tableSize: T,
      isHidden: g,
      isEmpty: l,
      renderExpanded: w,
      resizeProxyVisible: $,
      resizeState: P,
      isGroup: _,
      bodyWidth: R,
      tableBodyStyles: Y,
      emptyBlockStyle: O,
      debouncedUpdateLayout: le,
      handleFixedMousewheel: N,
      setCurrentRow: s,
      getSelectionRows: u,
      toggleRowSelection: c,
      clearSelection: d,
      clearFilter: f,
      toggleAllSelection: p,
      toggleRowExpansion: v,
      clearSort: m,
      doLayout: z,
      sort: h,
      updateKeyChildren: b,
      t,
      setDragVisible: y,
      context: o,
      computedSumText: te,
      computedEmptyText: ce,
      tableLayout: D,
      scrollbarViewStyle: M,
      scrollbarStyle: F,
      scrollBarRef: A,
      scrollTo: V,
      setScrollLeft: Z,
      setScrollTop: G,
      allowDragLastColumn: e10.allowDragLastColumn
    };
  }
});
function Jq(e10, t, n, o, r, a) {
  const l = je("hColgroup"), s = je("table-header"), u = je("table-body"), c = je("table-footer"), d = je("el-scrollbar"), f = Vf("mousewheel");
  return k(), x("div", {
    ref: "tableWrapper",
    class: I([
      {
        [e10.ns.m("fit")]: e10.fit,
        [e10.ns.m("striped")]: e10.stripe,
        [e10.ns.m("border")]: e10.border || e10.isGroup,
        [e10.ns.m("hidden")]: e10.isHidden,
        [e10.ns.m("group")]: e10.isGroup,
        [e10.ns.m("fluid-height")]: e10.maxHeight,
        [e10.ns.m("scrollable-x")]: e10.layout.scrollX.value,
        [e10.ns.m("scrollable-y")]: e10.layout.scrollY.value,
        [e10.ns.m("enable-row-hover")]: !e10.store.states.isComplex.value,
        [e10.ns.m("enable-row-transition")]: (e10.store.states.data.value || []).length !== 0 && (e10.store.states.data.value || []).length < 100,
        "has-footer": e10.showSummary
      },
      e10.ns.m(e10.tableSize),
      e10.className,
      e10.ns.b(),
      e10.ns.m(`layout-${e10.tableLayout}`)
    ]),
    style: ze(e10.style),
    "data-prefix": e10.ns.namespace.value,
    onMouseleave: e10.handleMouseLeave
  }, [
    B("div", {
      class: I(e10.ns.e("inner-wrapper"))
    }, [
      B("div", {
        ref: "hiddenColumns",
        class: "hidden-columns"
      }, [
        J(e10.$slots, "default")
      ], 512),
      e10.showHeader && e10.tableLayout === "fixed" ? lt((k(), x("div", {
        key: 0,
        ref: "headerWrapper",
        class: I(e10.ns.e("header-wrapper"))
      }, [
        B("table", {
          ref: "tableHeader",
          class: I(e10.ns.e("header")),
          style: ze(e10.tableBodyStyles),
          border: "0",
          cellpadding: "0",
          cellspacing: "0"
        }, [
          W(l, {
            columns: e10.store.states.columns.value,
            "table-layout": e10.tableLayout
          }, null, 8, ["columns", "table-layout"]),
          W(s, {
            ref: "tableHeaderRef",
            border: e10.border,
            "default-sort": e10.defaultSort,
            store: e10.store,
            "append-filter-panel-to": e10.appendFilterPanelTo,
            "allow-drag-last-column": e10.allowDragLastColumn,
            onSetDragVisible: e10.setDragVisible
          }, null, 8, ["border", "default-sort", "store", "append-filter-panel-to", "allow-drag-last-column", "onSetDragVisible"])
        ], 6)
      ], 2)), [
        [f, e10.handleHeaderFooterMousewheel]
      ]) : ee("v-if", true),
      B("div", {
        ref: "bodyWrapper",
        class: I(e10.ns.e("body-wrapper"))
      }, [
        W(d, {
          ref: "scrollBarRef",
          "view-style": e10.scrollbarViewStyle,
          "wrap-style": e10.scrollbarStyle,
          always: e10.scrollbarAlwaysOn,
          tabindex: e10.scrollbarTabindex,
          onScroll: (p) => e10.$emit("scroll", p)
        }, {
          default: H(() => [
            B("table", {
              ref: "tableBody",
              class: I(e10.ns.e("body")),
              cellspacing: "0",
              cellpadding: "0",
              border: "0",
              style: ze({
                width: e10.bodyWidth,
                tableLayout: e10.tableLayout
              })
            }, [
              W(l, {
                columns: e10.store.states.columns.value,
                "table-layout": e10.tableLayout
              }, null, 8, ["columns", "table-layout"]),
              e10.showHeader && e10.tableLayout === "auto" ? (k(), ae(s, {
                key: 0,
                ref: "tableHeaderRef",
                class: I(e10.ns.e("body-header")),
                border: e10.border,
                "default-sort": e10.defaultSort,
                store: e10.store,
                "append-filter-panel-to": e10.appendFilterPanelTo,
                onSetDragVisible: e10.setDragVisible
              }, null, 8, ["class", "border", "default-sort", "store", "append-filter-panel-to", "onSetDragVisible"])) : ee("v-if", true),
              W(u, {
                context: e10.context,
                highlight: e10.highlightCurrentRow,
                "row-class-name": e10.rowClassName,
                "tooltip-effect": e10.tooltipEffect,
                "tooltip-options": e10.tooltipOptions,
                "row-style": e10.rowStyle,
                store: e10.store,
                stripe: e10.stripe
              }, null, 8, ["context", "highlight", "row-class-name", "tooltip-effect", "tooltip-options", "row-style", "store", "stripe"]),
              e10.showSummary && e10.tableLayout === "auto" ? (k(), ae(c, {
                key: 1,
                class: I(e10.ns.e("body-footer")),
                border: e10.border,
                "default-sort": e10.defaultSort,
                store: e10.store,
                "sum-text": e10.computedSumText,
                "summary-method": e10.summaryMethod
              }, null, 8, ["class", "border", "default-sort", "store", "sum-text", "summary-method"])) : ee("v-if", true)
            ], 6),
            e10.isEmpty ? (k(), x("div", {
              key: 0,
              ref: "emptyBlock",
              style: ze(e10.emptyBlockStyle),
              class: I(e10.ns.e("empty-block"))
            }, [
              B("span", {
                class: I(e10.ns.e("empty-text"))
              }, [
                J(e10.$slots, "empty", {}, () => [
                  Ze(_e(e10.computedEmptyText), 1)
                ])
              ], 2)
            ], 6)) : ee("v-if", true),
            e10.$slots.append ? (k(), x("div", {
              key: 1,
              ref: "appendWrapper",
              class: I(e10.ns.e("append-wrapper"))
            }, [
              J(e10.$slots, "append")
            ], 2)) : ee("v-if", true)
          ]),
          _: 3
        }, 8, ["view-style", "wrap-style", "always", "tabindex", "onScroll"])
      ], 2),
      e10.showSummary && e10.tableLayout === "fixed" ? lt((k(), x("div", {
        key: 1,
        ref: "footerWrapper",
        class: I(e10.ns.e("footer-wrapper"))
      }, [
        B("table", {
          class: I(e10.ns.e("footer")),
          cellspacing: "0",
          cellpadding: "0",
          border: "0",
          style: ze(e10.tableBodyStyles)
        }, [
          W(l, {
            columns: e10.store.states.columns.value,
            "table-layout": e10.tableLayout
          }, null, 8, ["columns", "table-layout"]),
          W(c, {
            border: e10.border,
            "default-sort": e10.defaultSort,
            store: e10.store,
            "sum-text": e10.computedSumText,
            "summary-method": e10.summaryMethod
          }, null, 8, ["border", "default-sort", "store", "sum-text", "summary-method"])
        ], 6)
      ], 2)), [
        [Nt, !e10.isEmpty],
        [f, e10.handleHeaderFooterMousewheel]
      ]) : ee("v-if", true),
      e10.border || e10.isGroup ? (k(), x("div", {
        key: 2,
        class: I(e10.ns.e("border-left-patch"))
      }, null, 2)) : ee("v-if", true)
    ], 2),
    lt(B("div", {
      ref: "resizeProxy",
      class: I(e10.ns.e("column-resize-proxy"))
    }, null, 2), [
      [Nt, e10.resizeProxyVisible]
    ])
  ], 46, ["data-prefix", "onMouseleave"]);
}
var Zq = /* @__PURE__ */ $e(Xq, [["render", Jq], ["__file", "table.vue"]]);
const Qq = {
  selection: "table-column--selection",
  expand: "table__expand-column"
}, eG = {
  default: {
    order: ""
  },
  selection: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  },
  expand: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  },
  index: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  }
}, tG = (e10) => Qq[e10] || "", nG = {
  selection: {
    renderHeader({ store: e10, column: t }) {
      function n() {
        return e10.states.data.value && e10.states.data.value.length === 0;
      }
      return Ke(er, {
        disabled: n(),
        size: e10.states.tableSize.value,
        indeterminate: e10.states.selection.value.length > 0 && !e10.states.isAllSelected.value,
        "onUpdate:modelValue": e10.toggleAllSelection,
        modelValue: e10.states.isAllSelected.value,
        ariaLabel: t.label
      });
    },
    renderCell({
      row: e10,
      column: t,
      store: n,
      $index: o
    }) {
      return Ke(er, {
        disabled: t.selectable ? !t.selectable.call(null, e10, o) : false,
        size: n.states.tableSize.value,
        onChange: () => {
          n.commit("rowSelectedChanged", e10);
        },
        onClick: (r) => r.stopPropagation(),
        modelValue: n.isSelected(e10),
        ariaLabel: t.label
      });
    },
    sortable: false,
    resizable: false
  },
  index: {
    renderHeader({ column: e10 }) {
      return e10.label || "#";
    },
    renderCell({
      column: e10,
      $index: t
    }) {
      let n = t + 1;
      const o = e10.index;
      return Ye(o) ? n = t + o : Fe(o) && (n = o(t)), Ke("div", {}, [n]);
    },
    sortable: false
  },
  expand: {
    renderHeader({ column: e10 }) {
      return e10.label || "";
    },
    renderCell({
      column: e10,
      row: t,
      store: n,
      expanded: o
    }) {
      const { ns: r } = n, a = [r.e("expand-icon")];
      return !e10.renderExpand && o && a.push(r.em("expand-icon", "expanded")), Ke("div", {
        class: a,
        onClick: function(s) {
          s.stopPropagation(), n.toggleRowExpansion(t);
        }
      }, {
        default: () => e10.renderExpand ? [
          e10.renderExpand({
            expanded: o
          })
        ] : [
          Ke(Be, null, {
            default: () => [Ke(oo)]
          })
        ]
      });
    },
    sortable: false,
    resizable: false
  }
};
function oG({
  row: e10,
  column: t,
  $index: n
}) {
  var o;
  const r = t.property, a = r && nu(e10, r).value;
  return t && t.formatter ? t.formatter(e10, t, a, n) : ((o = a == null ? void 0 : a.toString) == null ? void 0 : o.call(a)) || "";
}
function rG({
  row: e10,
  treeNode: t,
  store: n
}, o = false) {
  const { ns: r } = n;
  if (!t)
    return o ? [
      Ke("span", {
        class: r.e("placeholder")
      })
    ] : null;
  const a = [], l = function(s) {
    s.stopPropagation(), !t.loading && n.loadOrToggle(e10);
  };
  if (t.indent && a.push(Ke("span", {
    class: r.e("indent"),
    style: { "padding-left": `${t.indent}px` }
  })), Vt(t.expanded) && !t.noLazyChildren) {
    const s = [
      r.e("expand-icon"),
      t.expanded ? r.em("expand-icon", "expanded") : ""
    ];
    let u = oo;
    t.loading && (u = Yr), a.push(Ke("div", {
      class: s,
      onClick: l
    }, {
      default: () => [
        Ke(Be, { class: { [r.is("loading")]: t.loading } }, {
          default: () => [Ke(u)]
        })
      ]
    }));
  } else
    a.push(Ke("span", {
      class: r.e("placeholder")
    }));
  return a;
}
function a_(e10, t) {
  return e10.reduce((n, o) => (n[o] = o, n), t);
}
function aG(e10, t) {
  const n = it();
  return {
    registerComplexWatchers: () => {
      const a = ["fixed"], l = {
        realWidth: "width",
        realMinWidth: "minWidth"
      }, s = a_(a, l);
      Object.keys(s).forEach((u) => {
        const c = l[u];
        Tt(t, c) && ge(() => t[c], (d) => {
          let f = d;
          c === "width" && u === "realWidth" && (f = Gg(d)), c === "minWidth" && u === "realMinWidth" && (f = oN(d)), n.columnConfig.value[c] = f, n.columnConfig.value[u] = f;
          const p = c === "fixed";
          e10.value.store.scheduleLayout(p);
        });
      });
    },
    registerNormalWatchers: () => {
      const a = [
        "label",
        "filters",
        "filterMultiple",
        "filteredValue",
        "sortable",
        "index",
        "formatter",
        "className",
        "labelClassName",
        "filterClassName",
        "showOverflowTooltip",
        "tooltipFormatter"
      ], l = {
        property: "prop",
        align: "realAlign",
        headerAlign: "realHeaderAlign"
      }, s = a_(a, l);
      Object.keys(s).forEach((u) => {
        const c = l[u];
        Tt(t, c) && ge(() => t[c], (d) => {
          n.columnConfig.value[u] = d;
        });
      });
    }
  };
}
function lG(e10, t, n) {
  const o = it(), r = L(""), a = L(false), l = L(), s = L(), u = we("table");
  Vn(() => {
    l.value = e10.align ? `is-${e10.align}` : null, l.value;
  }), Vn(() => {
    s.value = e10.headerAlign ? `is-${e10.headerAlign}` : l.value, s.value;
  });
  const c = S(() => {
    let _ = o.vnode.vParent || o.parent;
    for (; _ && !_.tableId && !_.columnId; )
      _ = _.vnode.vParent || _.parent;
    return _;
  }), d = S(() => {
    const { store: _ } = o.parent;
    if (!_)
      return false;
    const { treeData: C } = _.states, E = C.value;
    return E && Object.keys(E).length > 0;
  }), f = L(Gg(e10.width)), p = L(oN(e10.minWidth)), v = (_) => (f.value && (_.width = f.value), p.value && (_.minWidth = p.value), !f.value && p.value && (_.width = void 0), _.minWidth || (_.minWidth = 80), _.realWidth = Number(St(_.width) ? _.minWidth : _.width), _), m = (_) => {
    const C = _.type, E = nG[C] || {};
    Object.keys(E).forEach((O) => {
      const N = E[O];
      O !== "className" && !St(N) && (_[O] = N);
    });
    const T = tG(C);
    if (T) {
      const O = `${i(u.namespace)}-${T}`;
      _.className = _.className ? `${_.className} ${O}` : O;
    }
    return _;
  }, h = (_) => {
    Se(_) ? _.forEach((E) => C(E)) : C(_);
    function C(E) {
      var T;
      ((T = E == null ? void 0 : E.type) == null ? void 0 : T.name) === "ElTableColumn" && (E.vParent = o);
    }
  };
  return {
    columnId: r,
    realAlign: l,
    isSubColumn: a,
    realHeaderAlign: s,
    columnOrTableParent: c,
    setColumnWidth: v,
    setColumnForcedProps: m,
    setColumnRenders: (_) => {
      e10.renderHeader ? _t("TableColumn", "Comparing to render-header, scoped-slot header is easier to use. We recommend users to use scoped-slot header.") : _.type !== "selection" && (_.renderHeader = (E) => (o.columnConfig.value.label, J(t, "header", E, () => [_.label]))), t["filter-icon"] && (_.renderFilterIcon = (E) => J(t, "filter-icon", E)), t.expand && (_.renderExpand = (E) => J(t, "expand", E));
      let C = _.renderCell;
      return _.type === "expand" ? (_.renderCell = (E) => Ke("div", {
        class: "cell"
      }, [C(E)]), n.value.renderExpanded = (E) => t.default ? t.default(E) : t.default) : (C = C || oG, _.renderCell = (E) => {
        let T = null;
        if (t.default) {
          const z = t.default(E);
          T = z.some((Y) => Y.type !== tn) ? z : C(E);
        } else
          T = C(E);
        const { columns: O } = n.value.store.states, N = O.value.findIndex((z) => z.type === "default"), $ = d.value && E.cellIndex === N, R = rG(E, $), P = {
          class: "cell",
          style: {}
        };
        return _.showOverflowTooltip && (P.class = `${P.class} ${i(u.namespace)}-tooltip`, P.style = {
          width: `${(E.column.realWidth || Number(E.column.width)) - 1}px`
        }), h(T), Ke("div", P, [R, T]);
      }), _;
    },
    getPropsData: (..._) => _.reduce((C, E) => (Se(E) && E.forEach((T) => {
      C[T] = e10[T];
    }), C), {}),
    getColumnElIndex: (_, C) => Array.prototype.indexOf.call(_, C),
    updateColumnOrder: () => {
      n.value.store.commit("updateColumnOrder", o.columnConfig.value);
    }
  };
}
var sG = {
  type: {
    type: String,
    default: "default"
  },
  label: String,
  className: String,
  labelClassName: String,
  property: String,
  prop: String,
  width: {
    type: [String, Number],
    default: ""
  },
  minWidth: {
    type: [String, Number],
    default: ""
  },
  renderHeader: Function,
  sortable: {
    type: [Boolean, String],
    default: false
  },
  sortMethod: Function,
  sortBy: [String, Function, Array],
  resizable: {
    type: Boolean,
    default: true
  },
  columnKey: String,
  align: String,
  headerAlign: String,
  showOverflowTooltip: {
    type: [Boolean, Object],
    default: void 0
  },
  tooltipFormatter: Function,
  fixed: [Boolean, String],
  formatter: Function,
  selectable: Function,
  reserveSelection: Boolean,
  filterMethod: Function,
  filteredValue: Array,
  filters: Array,
  filterPlacement: String,
  filterMultiple: {
    type: Boolean,
    default: true
  },
  filterClassName: String,
  index: [Number, Function],
  sortOrders: {
    type: Array,
    default: () => ["ascending", "descending", null],
    validator: (e10) => e10.every((t) => ["ascending", "descending", null].includes(t))
  }
};
let iG = 1;
var yN = /* @__PURE__ */ j({
  name: "ElTableColumn",
  components: {
    ElCheckbox: er
  },
  props: sG,
  setup(e10, { slots: t }) {
    const n = it(), o = L({}), r = S(() => {
      let y = n.parent;
      for (; y && !y.tableId; )
        y = y.parent;
      return y;
    }), { registerNormalWatchers: a, registerComplexWatchers: l } = aG(r, e10), {
      columnId: s,
      isSubColumn: u,
      realHeaderAlign: c,
      columnOrTableParent: d,
      setColumnWidth: f,
      setColumnForcedProps: p,
      setColumnRenders: v,
      getPropsData: m,
      getColumnElIndex: h,
      realAlign: b,
      updateColumnOrder: g
    } = lG(e10, t, r), w = d.value;
    s.value = `${w.tableId || w.columnId}_column_${iG++}`, Df(() => {
      u.value = r.value !== w;
      const y = e10.type || "default", _ = e10.sortable === "" ? true : e10.sortable, C = y === "selection" ? false : St(e10.showOverflowTooltip) ? w.props.showOverflowTooltip : e10.showOverflowTooltip, E = St(e10.tooltipFormatter) ? w.props.tooltipFormatter : e10.tooltipFormatter, T = {
        ...eG[y],
        id: s.value,
        type: y,
        property: e10.prop || e10.property,
        align: b,
        headerAlign: c,
        showOverflowTooltip: C,
        tooltipFormatter: E,
        filterable: e10.filters || e10.filterMethod,
        filteredValue: [],
        filterPlacement: "",
        filterClassName: "",
        isColumnGroup: false,
        isSubColumn: false,
        filterOpened: false,
        sortable: _,
        index: e10.index,
        rawColumnKey: n.vnode.key
      };
      let P = m([
        "columnKey",
        "label",
        "className",
        "labelClassName",
        "type",
        "renderHeader",
        "formatter",
        "fixed",
        "resizable"
      ], ["sortMethod", "sortBy", "sortOrders"], ["selectable", "reserveSelection"], [
        "filterMethod",
        "filters",
        "filterMultiple",
        "filterOpened",
        "filteredValue",
        "filterPlacement",
        "filterClassName"
      ]);
      P = nq(T, P), P = rq(v, f, p)(P), o.value = P, a(), l();
    }), dt(() => {
      var y;
      const _ = d.value, C = u.value ? _.vnode.el.children : (y = _.refs.hiddenColumns) == null ? void 0 : y.children, E = () => h(C || [], n.vnode.el);
      o.value.getColumnIndex = E, E() > -1 && r.value.store.commit("insertColumn", o.value, u.value ? _.columnConfig.value : null, g);
    }), jt(() => {
      const y = o.value.getColumnIndex;
      (y ? y() : -1) > -1 && r.value.store.commit("removeColumn", o.value, u.value ? w.columnConfig.value : null, g);
    }), n.columnId = s.value, n.columnConfig = o;
  },
  render() {
    var e10, t, n;
    try {
      const o = (t = (e10 = this.$slots).default) == null ? void 0 : t.call(e10, {
        row: {},
        column: {},
        $index: -1
      }), r = [];
      if (Se(o))
        for (const l of o)
          ((n = l.type) == null ? void 0 : n.name) === "ElTableColumn" || l.shapeFlag & 2 ? r.push(l) : l.type === Ie && Se(l.children) && l.children.forEach((s) => {
            (s == null ? void 0 : s.patchFlag) !== 1024 && !Ve(s == null ? void 0 : s.children) && r.push(s);
          });
      return Ke("div", r);
    } catch {
      return Ke("div", []);
    }
  }
});
const uG = ut(Zq, {
  TableColumn: yN
}), cG = nn(yN);
var Au = /* @__PURE__ */ ((e10) => (e10.ASC = "asc", e10.DESC = "desc", e10))(Au || {}), Lu = /* @__PURE__ */ ((e10) => (e10.CENTER = "center", e10.RIGHT = "right", e10))(Lu || {}), bN = /* @__PURE__ */ ((e10) => (e10.LEFT = "left", e10.RIGHT = "right", e10))(bN || {});
const Rh = {
  asc: "desc",
  desc: "asc"
  /* ASC */
}, xu = Symbol("placeholder"), dG = (e10, t, n) => {
  var o;
  const r = {
    flexGrow: 0,
    flexShrink: 0,
    ...n ? {} : {
      flexGrow: e10.flexGrow || 0,
      flexShrink: e10.flexShrink || 1
    }
  };
  n || (r.flexShrink = 1);
  const a = {
    ...(o = e10.style) != null ? o : {},
    ...r,
    flexBasis: "auto",
    width: e10.width
  };
  return t || (e10.maxWidth && (a.maxWidth = e10.maxWidth), e10.minWidth && (a.minWidth = e10.minWidth)), a;
};
function fG(e10, t, n) {
  const o = S(() => i(t).map((b, g) => {
    var w, y;
    return {
      ...b,
      key: (y = (w = b.key) != null ? w : b.dataKey) != null ? y : g
    };
  })), r = S(() => i(o).filter((b) => !b.hidden)), a = S(() => i(r).filter((b) => b.fixed === "left" || b.fixed === true)), l = S(() => i(r).filter((b) => b.fixed === "right")), s = S(() => i(r).filter((b) => !b.fixed)), u = S(() => {
    const b = [];
    return i(a).forEach((g) => {
      b.push({
        ...g,
        placeholderSign: xu
      });
    }), i(s).forEach((g) => {
      b.push(g);
    }), i(l).forEach((g) => {
      b.push({
        ...g,
        placeholderSign: xu
      });
    }), b;
  }), c = S(() => i(a).length || i(l).length), d = S(() => i(o).reduce((b, g) => (b[g.key] = dG(g, i(n), e10.fixed), b), {})), f = S(() => i(r).reduce((b, g) => b + g.width, 0)), p = (b) => i(o).find((g) => g.key === b), v = (b) => i(d)[b], m = (b, g) => {
    b.width = g;
  };
  function h(b) {
    var g;
    const { key: w } = b.currentTarget.dataset;
    if (!w)
      return;
    const { sortState: y, sortBy: _ } = e10;
    let C = Au.ASC;
    at(y) ? C = Rh[y[w]] : C = Rh[_.order], (g = e10.onColumnSort) == null || g.call(e10, { column: p(w), key: w, order: C });
  }
  return {
    columns: o,
    columnsStyles: d,
    columnsTotalWidth: f,
    fixedColumnsOnLeft: a,
    fixedColumnsOnRight: l,
    hasFixedColumns: c,
    mainColumns: u,
    normalColumns: s,
    visibleColumns: r,
    getColumn: p,
    getColumnStyle: v,
    updateColumnWidth: m,
    onColumnSorted: h
  };
}
const pG = (e10, {
  mainTableRef: t,
  leftTableRef: n,
  rightTableRef: o,
  onMaybeEndReached: r
}) => {
  const a = L({ scrollLeft: 0, scrollTop: 0 });
  function l(v) {
    var m, h, b;
    const { scrollTop: g } = v;
    (m = t.value) == null || m.scrollTo(v), (h = n.value) == null || h.scrollToTop(g), (b = o.value) == null || b.scrollToTop(g);
  }
  function s(v) {
    a.value = v, l(v);
  }
  function u(v) {
    a.value.scrollTop = v, l(i(a));
  }
  function c(v) {
    var m, h;
    a.value.scrollLeft = v, (h = (m = t.value) == null ? void 0 : m.scrollTo) == null || h.call(m, i(a));
  }
  function d(v) {
    var m;
    s(v), (m = e10.onScroll) == null || m.call(e10, v);
  }
  function f({ scrollTop: v }) {
    const { scrollTop: m } = i(a);
    v !== m && u(v);
  }
  function p(v, m = "auto") {
    var h;
    (h = t.value) == null || h.scrollToRow(v, m);
  }
  return ge(() => i(a).scrollTop, (v, m) => {
    v > m && r();
  }), {
    scrollPos: a,
    scrollTo: s,
    scrollToLeft: c,
    scrollToTop: u,
    scrollToRow: p,
    onScroll: d,
    onVerticalScroll: f
  };
}, vG = (e10, {
  mainTableRef: t,
  leftTableRef: n,
  rightTableRef: o,
  tableInstance: r,
  ns: a,
  isScrolling: l
}) => {
  const s = it(), { emit: u } = s, c = qt(false), d = L(e10.defaultExpandedRowKeys || []), f = L(-1), p = qt(null), v = L({}), m = L({}), h = qt({}), b = qt({}), g = qt({}), w = S(() => Ye(e10.estimatedRowHeight));
  function y($) {
    var R;
    (R = e10.onRowsRendered) == null || R.call(e10, $), $.rowCacheEnd > i(f) && (f.value = $.rowCacheEnd);
  }
  function _({ hovered: $, rowKey: R }) {
    if (l.value)
      return;
    r.vnode.el.querySelectorAll(`[rowkey="${String(R)}"]`).forEach((Y) => {
      $ ? Y.classList.add(a.is("hovered")) : Y.classList.remove(a.is("hovered"));
    });
  }
  function C({
    expanded: $,
    rowData: R,
    rowIndex: P,
    rowKey: z
  }) {
    var Y, D;
    const M = [...i(d)], F = M.indexOf(z);
    $ ? F === -1 && M.push(z) : F > -1 && M.splice(F, 1), d.value = M, u("update:expandedRowKeys", M), (Y = e10.onRowExpand) == null || Y.call(e10, {
      expanded: $,
      rowData: R,
      rowIndex: P,
      rowKey: z
    }), (D = e10.onExpandedRowsChange) == null || D.call(e10, M);
  }
  const E = Oo(() => {
    var $, R, P, z;
    c.value = true, v.value = { ...i(v), ...i(m) }, T(i(p), false), m.value = {}, p.value = null, ($ = t.value) == null || $.forceUpdate(), (R = n.value) == null || R.forceUpdate(), (P = o.value) == null || P.forceUpdate(), (z = s.proxy) == null || z.$forceUpdate(), c.value = false;
  }, 0);
  function T($, R = false) {
    i(w) && [t, n, o].forEach((P) => {
      const z = i(P);
      z && z.resetAfterRowIndex($, R);
    });
  }
  function O($, R, P) {
    const z = i(p);
    (z === null || z > P) && (p.value = P), m.value[$] = R;
  }
  function N({ rowKey: $, height: R, rowIndex: P }, z) {
    z ? z === bN.RIGHT ? g.value[$] = R : h.value[$] = R : b.value[$] = R;
    const Y = Math.max(...[h, g, b].map((D) => D.value[$] || 0));
    i(v)[$] !== Y && (O($, Y, P), E());
  }
  return {
    expandedRowKeys: d,
    lastRenderedRowIndex: f,
    isDynamic: w,
    isResetting: c,
    rowHeights: v,
    resetAfterIndex: T,
    onRowExpanded: C,
    onRowHovered: _,
    onRowsRendered: y,
    onRowHeightChange: N
  };
}, hG = (e10, { expandedRowKeys: t, lastRenderedRowIndex: n, resetAfterIndex: o }) => {
  const r = L({}), a = S(() => {
    const s = {}, { data: u, rowKey: c } = e10, d = i(t);
    if (!d || !d.length)
      return u;
    const f = [], p = /* @__PURE__ */ new Set();
    d.forEach((m) => p.add(m));
    let v = u.slice();
    for (v.forEach((m) => s[m[c]] = 0); v.length > 0; ) {
      const m = v.shift();
      f.push(m), p.has(m[c]) && Se(m.children) && m.children.length > 0 && (v = [...m.children, ...v], m.children.forEach((h) => s[h[c]] = s[m[c]] + 1));
    }
    return r.value = s, f;
  }), l = S(() => {
    const { data: s, expandColumnKey: u } = e10;
    return u ? i(a) : s;
  });
  return ge(l, (s, u) => {
    s !== u && (n.value = -1, o(0, true));
  }), {
    data: l,
    depthMap: r
  };
}, mG = (e10, t) => e10 + t, kd = (e10) => Se(e10) ? e10.reduce(mG, 0) : e10, Ql = (e10, t, n = {}) => Fe(e10) ? e10(t) : e10 != null ? e10 : n, Za = (e10) => (["width", "maxWidth", "minWidth", "height"].forEach((t) => {
  e10[t] = sn(e10[t]);
}), e10), _N = (e10) => Ut(e10) ? (t) => Ke(e10, t) : e10, gG = (e10, {
  columnsTotalWidth: t,
  rowsHeight: n,
  fixedColumnsOnLeft: o,
  fixedColumnsOnRight: r
}) => {
  const a = S(() => {
    const { fixed: g, width: w, vScrollbarSize: y } = e10, _ = w - y;
    return g ? Math.max(Math.round(i(t)), _) : _;
  }), l = S(() => {
    const { height: g = 0, maxHeight: w = 0, footerHeight: y, hScrollbarSize: _ } = e10;
    if (w > 0) {
      const C = i(p), E = i(n), O = i(f) + C + E + _;
      return Math.min(O, w - y);
    }
    return g - y;
  }), s = S(() => {
    const { maxHeight: g } = e10, w = i(l);
    if (Ye(g) && g > 0)
      return w;
    const y = i(n) + i(f) + i(p);
    return Math.min(w, y);
  }), u = (g) => g.width, c = S(() => kd(i(o).map(u))), d = S(() => kd(i(r).map(u))), f = S(() => kd(e10.headerHeight)), p = S(() => {
    var g;
    return (((g = e10.fixedData) == null ? void 0 : g.length) || 0) * e10.rowHeight;
  }), v = S(() => i(l) - i(f) - i(p)), m = S(() => {
    const { style: g = {}, height: w, width: y } = e10;
    return Za({
      ...g,
      height: w,
      width: y
    });
  }), h = S(() => Za({ height: e10.footerHeight })), b = S(() => ({
    top: sn(i(f)),
    bottom: sn(e10.footerHeight),
    width: sn(e10.width)
  }));
  return {
    bodyWidth: a,
    fixedTableHeight: s,
    mainTableHeight: l,
    leftTableWidth: c,
    rightTableWidth: d,
    windowHeight: v,
    footerHeight: h,
    emptyStyle: b,
    rootStyle: m,
    headerHeight: f
  };
};
function yG(e10) {
  const t = L(), n = L(), o = L(), {
    columns: r,
    columnsStyles: a,
    columnsTotalWidth: l,
    fixedColumnsOnLeft: s,
    fixedColumnsOnRight: u,
    hasFixedColumns: c,
    mainColumns: d,
    onColumnSorted: f
  } = fG(e10, Lt(e10, "columns"), Lt(e10, "fixed")), {
    scrollTo: p,
    scrollToLeft: v,
    scrollToTop: m,
    scrollToRow: h,
    onScroll: b,
    onVerticalScroll: g,
    scrollPos: w
  } = pG(e10, {
    mainTableRef: t,
    leftTableRef: n,
    rightTableRef: o,
    onMaybeEndReached: U
  }), y = we("table-v2"), _ = it(), C = qt(false), {
    expandedRowKeys: E,
    lastRenderedRowIndex: T,
    isDynamic: O,
    isResetting: N,
    rowHeights: $,
    resetAfterIndex: R,
    onRowExpanded: P,
    onRowHeightChange: z,
    onRowHovered: Y,
    onRowsRendered: D
  } = vG(e10, {
    mainTableRef: t,
    leftTableRef: n,
    rightTableRef: o,
    tableInstance: _,
    ns: y,
    isScrolling: C
  }), { data: M, depthMap: F } = hG(e10, {
    expandedRowKeys: E,
    lastRenderedRowIndex: T,
    resetAfterIndex: R
  }), A = S(() => {
    const { estimatedRowHeight: re, rowHeight: he } = e10, Ee = i(M);
    return Ye(re) ? Object.values(i($)).reduce((ye, K) => ye + K, 0) : Ee.length * he;
  }), {
    bodyWidth: V,
    fixedTableHeight: Z,
    mainTableHeight: G,
    leftTableWidth: le,
    rightTableWidth: X,
    windowHeight: te,
    footerHeight: ce,
    emptyStyle: pe,
    rootStyle: se,
    headerHeight: ve
  } = gG(e10, {
    columnsTotalWidth: l,
    fixedColumnsOnLeft: s,
    fixedColumnsOnRight: u,
    rowsHeight: A
  }), me = L(), De = S(() => {
    const re = i(M).length === 0;
    return Se(e10.fixedData) ? e10.fixedData.length === 0 && re : re;
  });
  function Te(re) {
    const { estimatedRowHeight: he, rowHeight: Ee, rowKey: ye } = e10;
    return he ? i($)[i(M)[re][ye]] || he : Ee;
  }
  const de = L(false);
  function U() {
    const { onEndReached: re } = e10;
    if (!re)
      return;
    const { scrollTop: he } = i(w), Ee = i(A), ye = i(te), K = Ee - (he + ye) + e10.hScrollbarSize;
    !de.value && i(T) >= 0 && Ee <= he + i(G) - i(ve) ? (de.value = true, re(K)) : de.value = false;
  }
  return ge(() => i(A), () => de.value = false), ge(() => e10.expandedRowKeys, (re) => E.value = re, {
    deep: true
  }), {
    columns: r,
    containerRef: me,
    mainTableRef: t,
    leftTableRef: n,
    rightTableRef: o,
    isDynamic: O,
    isResetting: N,
    isScrolling: C,
    hasFixedColumns: c,
    columnsStyles: a,
    columnsTotalWidth: l,
    data: M,
    expandedRowKeys: E,
    depthMap: F,
    fixedColumnsOnLeft: s,
    fixedColumnsOnRight: u,
    mainColumns: d,
    bodyWidth: V,
    emptyStyle: pe,
    rootStyle: se,
    footerHeight: ce,
    mainTableHeight: G,
    fixedTableHeight: Z,
    leftTableWidth: le,
    rightTableWidth: X,
    showEmpty: De,
    getRowHeight: Te,
    onColumnSorted: f,
    onRowHovered: Y,
    onRowExpanded: P,
    onRowsRendered: D,
    onRowHeightChange: z,
    scrollTo: p,
    scrollToLeft: v,
    scrollToTop: m,
    scrollToRow: h,
    onScroll: b,
    onVerticalScroll: g
  };
}
const Qg = Symbol("tableV2"), wN = "tableV2GridScrollLeft", CN = String, vc = {
  type: ne(Array),
  required: true
}, ey = {
  type: ne(Array)
}, EN = {
  ...ey,
  required: true
}, bG = String, l_ = {
  type: ne(Array),
  default: () => rn([])
}, Ol = {
  type: Number,
  required: true
}, SN = {
  type: ne([String, Number, Symbol]),
  default: "id"
}, s_ = {
  type: ne(Object)
}, Pl = Oe({
  class: String,
  columns: vc,
  columnsStyles: {
    type: ne(Object),
    required: true
  },
  depth: Number,
  expandColumnKey: bG,
  estimatedRowHeight: {
    ...Wl.estimatedRowHeight,
    default: void 0
  },
  isScrolling: Boolean,
  onRowExpand: {
    type: ne(Function)
  },
  onRowHover: {
    type: ne(Function)
  },
  onRowHeightChange: {
    type: ne(Function)
  },
  rowData: {
    type: ne(Object),
    required: true
  },
  rowEventHandlers: {
    type: ne(Object)
  },
  rowIndex: {
    type: Number,
    required: true
  },
  rowKey: SN,
  style: {
    type: ne(Object)
  }
}), pv = {
  type: Number,
  required: true
}, ty = Oe({
  class: String,
  columns: vc,
  fixedHeaderData: {
    type: ne(Array)
  },
  headerData: {
    type: ne(Array),
    required: true
  },
  headerHeight: {
    type: ne([Number, Array]),
    default: 50
  },
  rowWidth: pv,
  rowHeight: {
    type: Number,
    default: 50
  },
  height: pv,
  width: pv
}), Nd = Oe({
  columns: vc,
  data: EN,
  fixedData: ey,
  estimatedRowHeight: Pl.estimatedRowHeight,
  width: Ol,
  height: Ol,
  headerWidth: Ol,
  headerHeight: ty.headerHeight,
  bodyWidth: Ol,
  rowHeight: Ol,
  cache: Wk.cache,
  useIsScrolling: Boolean,
  scrollbarAlwaysOn: Wl.scrollbarAlwaysOn,
  scrollbarStartGap: Wl.scrollbarStartGap,
  scrollbarEndGap: Wl.scrollbarEndGap,
  class: CN,
  style: s_,
  containerStyle: s_,
  getRowHeight: {
    type: ne(Function),
    required: true
  },
  rowKey: Pl.rowKey,
  onRowsRendered: {
    type: ne(Function)
  },
  onScroll: {
    type: ne(Function)
  }
}), _G = Oe({
  cache: Nd.cache,
  estimatedRowHeight: Pl.estimatedRowHeight,
  rowKey: SN,
  headerClass: {
    type: ne([
      String,
      Function
    ])
  },
  headerProps: {
    type: ne([
      Object,
      Function
    ])
  },
  headerCellProps: {
    type: ne([
      Object,
      Function
    ])
  },
  headerHeight: ty.headerHeight,
  footerHeight: {
    type: Number,
    default: 0
  },
  rowClass: {
    type: ne([String, Function])
  },
  rowProps: {
    type: ne([Object, Function])
  },
  rowHeight: {
    type: Number,
    default: 50
  },
  cellProps: {
    type: ne([
      Object,
      Function
    ])
  },
  columns: vc,
  data: EN,
  dataGetter: {
    type: ne(Function)
  },
  fixedData: ey,
  expandColumnKey: Pl.expandColumnKey,
  expandedRowKeys: l_,
  defaultExpandedRowKeys: l_,
  class: CN,
  fixed: Boolean,
  style: {
    type: ne(Object)
  },
  width: Ol,
  height: Ol,
  maxHeight: Number,
  useIsScrolling: Boolean,
  indentSize: {
    type: Number,
    default: 12
  },
  iconSize: {
    type: Number,
    default: 12
  },
  hScrollbarSize: Wl.hScrollbarSize,
  vScrollbarSize: Wl.vScrollbarSize,
  scrollbarAlwaysOn: Yk.alwaysOn,
  sortBy: {
    type: ne(Object),
    default: () => ({})
  },
  sortState: {
    type: ne(Object),
    default: void 0
  },
  onColumnSort: {
    type: ne(Function)
  },
  onExpandedRowsChange: {
    type: ne(Function)
  },
  onEndReached: {
    type: ne(Function)
  },
  onRowExpand: Pl.onRowExpand,
  onScroll: Nd.onScroll,
  onRowsRendered: Nd.onRowsRendered,
  rowEventHandlers: Pl.rowEventHandlers
}), wG = "ElTableV2Header", CG = /* @__PURE__ */ j({
  name: wG,
  props: ty,
  setup(e10, {
    slots: t,
    expose: n
  }) {
    const o = we("table-v2"), r = Le(wN), a = L(), l = S(() => Za({
      width: e10.width,
      height: e10.height
    })), s = S(() => Za({
      width: e10.rowWidth,
      height: e10.height
    })), u = S(() => Zn(i(e10.headerHeight))), c = (p) => {
      const v = i(a);
      He(() => {
        v != null && v.scroll && v.scroll({
          left: p
        });
      });
    }, d = () => {
      const p = o.e("fixed-header-row"), {
        columns: v,
        fixedHeaderData: m,
        rowHeight: h
      } = e10;
      return m == null ? void 0 : m.map((b, g) => {
        var w;
        const y = Za({
          height: h,
          width: "100%"
        });
        return (w = t.fixed) == null ? void 0 : w.call(t, {
          class: p,
          columns: v,
          rowData: b,
          rowIndex: -(g + 1),
          style: y
        });
      });
    }, f = () => {
      const p = o.e("dynamic-header-row"), {
        columns: v
      } = e10;
      return i(u).map((m, h) => {
        var b;
        const g = Za({
          width: "100%",
          height: m
        });
        return (b = t.dynamic) == null ? void 0 : b.call(t, {
          class: p,
          columns: v,
          headerIndex: h,
          style: g
        });
      });
    };
    return wr(() => {
      r != null && r.value && c(r.value);
    }), n({
      scrollToLeft: c
    }), () => {
      if (!(e10.height <= 0))
        return W("div", {
          ref: a,
          class: e10.class,
          style: i(l),
          role: "rowgroup"
        }, [W("div", {
          style: i(s),
          class: o.e("header")
        }, [f(), d()])]);
    };
  }
});
var EG = CG;
const SG = ({ atXEndEdge: e10, atXStartEdge: t, atYEndEdge: n, atYStartEdge: o }, r) => {
  let a = null, l = 0, s = 0;
  const u = (d, f) => {
    const p = d <= 0 && t.value || d >= 0 && e10.value, v = f <= 0 && o.value || f >= 0 && n.value;
    return p && v;
  };
  return {
    hasReachedEdge: u,
    onWheel: (d) => {
      Jl(a);
      let f = d.deltaX, p = d.deltaY;
      Math.abs(f) > Math.abs(p) ? p = 0 : f = 0, d.shiftKey && p !== 0 && (f = p, p = 0), !(u(l, s) && u(l + f, s + p)) && (l += f, s += p, d.preventDefault(), a = sl(() => {
        r(l, s), l = 0, s = 0;
      }));
    }
  };
}, kN = ({
  name: e10,
  clearCache: t,
  getColumnPosition: n,
  getColumnStartIndexForOffset: o,
  getColumnStopIndexForStartIndex: r,
  getEstimatedTotalHeight: a,
  getEstimatedTotalWidth: l,
  getColumnOffset: s,
  getRowOffset: u,
  getRowPosition: c,
  getRowStartIndexForOffset: d,
  getRowStopIndexForStartIndex: f,
  initCache: p,
  injectToInstance: v,
  validateProps: m
}) => /* @__PURE__ */ j({
  name: e10 != null ? e10 : "ElVirtualList",
  props: Wl,
  emits: [ff, pf],
  setup(h, { emit: b, expose: g, slots: w }) {
    const y = we("vl");
    m(h);
    const _ = it(), C = L(p(h, _));
    v == null || v(_, C);
    const E = L(), T = L(), O = L(), N = L(null), $ = L({
      isScrolling: false,
      scrollLeft: Ye(h.initScrollLeft) ? h.initScrollLeft : 0,
      scrollTop: Ye(h.initScrollTop) ? h.initScrollTop : 0,
      updateRequested: false,
      xAxisScrollDir: Ms,
      yAxisScrollDir: Ms
    }), R = Hk(), P = S(() => Number.parseInt(`${h.height}`, 10)), z = S(() => Number.parseInt(`${h.width}`, 10)), Y = S(() => {
      const { totalColumn: ye, totalRow: K, columnCache: q } = h, { isScrolling: ue, xAxisScrollDir: be, scrollLeft: ke } = i($);
      if (ye === 0 || K === 0)
        return [0, 0, 0, 0];
      const Ae = o(h, ke, i(C)), fe = r(h, Ae, ke, i(C)), ie = !ue || be === vf ? Math.max(1, q) : 1, Ce = !ue || be === Ms ? Math.max(1, q) : 1;
      return [
        Math.max(0, Ae - ie),
        Math.max(0, Math.min(ye - 1, fe + Ce)),
        Ae,
        fe
      ];
    }), D = S(() => {
      const { totalColumn: ye, totalRow: K, rowCache: q } = h, { isScrolling: ue, yAxisScrollDir: be, scrollTop: ke } = i($);
      if (ye === 0 || K === 0)
        return [0, 0, 0, 0];
      const Ae = d(h, ke, i(C)), fe = f(h, Ae, ke, i(C)), ie = !ue || be === vf ? Math.max(1, q) : 1, Ce = !ue || be === Ms ? Math.max(1, q) : 1;
      return [
        Math.max(0, Ae - ie),
        Math.max(0, Math.min(K - 1, fe + Ce)),
        Ae,
        fe
      ];
    }), M = S(() => a(h, i(C))), F = S(() => l(h, i(C))), A = S(() => {
      var ye;
      return [
        {
          position: "relative",
          overflow: "hidden",
          WebkitOverflowScrolling: "touch",
          willChange: "transform"
        },
        {
          direction: h.direction,
          height: Ye(h.height) ? `${h.height}px` : h.height,
          width: Ye(h.width) ? `${h.width}px` : h.width
        },
        (ye = h.style) != null ? ye : {}
      ];
    }), V = S(() => {
      const ye = `${i(F)}px`;
      return {
        height: `${i(M)}px`,
        pointerEvents: i($).isScrolling ? "none" : void 0,
        width: ye
      };
    }), Z = () => {
      const { totalColumn: ye, totalRow: K } = h;
      if (ye > 0 && K > 0) {
        const [
          fe,
          ie,
          Ce,
          qe
        ] = i(Y), [et, ft, bt, zt] = i(D);
        b(ff, {
          columnCacheStart: fe,
          columnCacheEnd: ie,
          rowCacheStart: et,
          rowCacheEnd: ft,
          columnVisibleStart: Ce,
          columnVisibleEnd: qe,
          rowVisibleStart: bt,
          rowVisibleEnd: zt
        });
      }
      const {
        scrollLeft: q,
        scrollTop: ue,
        updateRequested: be,
        xAxisScrollDir: ke,
        yAxisScrollDir: Ae
      } = i($);
      b(pf, {
        xAxisScrollDir: ke,
        scrollLeft: q,
        yAxisScrollDir: Ae,
        scrollTop: ue,
        updateRequested: be
      });
    }, G = (ye) => {
      const {
        clientHeight: K,
        clientWidth: q,
        scrollHeight: ue,
        scrollLeft: be,
        scrollTop: ke,
        scrollWidth: Ae
      } = ye.currentTarget, fe = i($);
      if (fe.scrollTop === ke && fe.scrollLeft === be)
        return;
      let ie = be;
      if (j1(h.direction))
        switch (mf()) {
          case Pu:
            ie = -be;
            break;
          case qg:
            ie = Ae - q - be;
            break;
        }
      $.value = {
        ...fe,
        isScrolling: true,
        scrollLeft: ie,
        scrollTop: Math.max(0, Math.min(ke, ue - K)),
        updateRequested: true,
        xAxisScrollDir: Ml(fe.scrollLeft, ie),
        yAxisScrollDir: Ml(fe.scrollTop, ke)
      }, He(() => ve()), me(), Z();
    }, le = (ye, K) => {
      const q = i(P), ue = (M.value - q) / K * ye;
      ce({
        scrollTop: Math.min(M.value - q, ue)
      });
    }, X = (ye, K) => {
      const q = i(z), ue = (F.value - q) / K * ye;
      ce({
        scrollLeft: Math.min(F.value - q, ue)
      });
    }, { onWheel: te } = SG({
      atXStartEdge: S(() => $.value.scrollLeft <= 0),
      atXEndEdge: S(() => $.value.scrollLeft >= F.value - i(z)),
      atYStartEdge: S(() => $.value.scrollTop <= 0),
      atYEndEdge: S(() => $.value.scrollTop >= M.value - i(P))
    }, (ye, K) => {
      var q, ue, be, ke;
      (ue = (q = T.value) == null ? void 0 : q.onMouseUp) == null || ue.call(q), (ke = (be = O.value) == null ? void 0 : be.onMouseUp) == null || ke.call(be);
      const Ae = i(z), fe = i(P);
      ce({
        scrollLeft: Math.min($.value.scrollLeft + ye, F.value - Ae),
        scrollTop: Math.min($.value.scrollTop + K, M.value - fe)
      });
    });
    Ft(E, "wheel", te, {
      passive: false
    });
    const ce = ({
      scrollLeft: ye = $.value.scrollLeft,
      scrollTop: K = $.value.scrollTop
    }) => {
      ye = Math.max(ye, 0), K = Math.max(K, 0);
      const q = i($);
      K === q.scrollTop && ye === q.scrollLeft || ($.value = {
        ...q,
        xAxisScrollDir: Ml(q.scrollLeft, ye),
        yAxisScrollDir: Ml(q.scrollTop, K),
        scrollLeft: ye,
        scrollTop: K,
        updateRequested: true
      }, He(() => ve()), me(), Z());
    }, pe = (ye = 0, K = 0, q = Uo) => {
      const ue = i($);
      K = Math.max(0, Math.min(K, h.totalColumn - 1)), ye = Math.max(0, Math.min(ye, h.totalRow - 1));
      const be = NS(y.namespace.value), ke = i(C), Ae = a(h, ke), fe = l(h, ke);
      ce({
        scrollLeft: s(h, K, q, ue.scrollLeft, ke, fe > h.width ? be : 0),
        scrollTop: u(h, ye, q, ue.scrollTop, ke, Ae > h.height ? be : 0)
      });
    }, se = (ye, K) => {
      const { columnWidth: q, direction: ue, rowHeight: be } = h, ke = R.value(t && q, t && be, t && ue), Ae = `${ye},${K}`;
      if (Tt(ke, Ae))
        return ke[Ae];
      {
        const [, fe] = n(h, K, i(C)), ie = i(C), Ce = j1(ue), [qe, et] = c(h, ye, ie), [ft] = n(h, K, ie);
        return ke[Ae] = {
          position: "absolute",
          left: Ce ? void 0 : `${fe}px`,
          right: Ce ? `${fe}px` : void 0,
          top: `${et}px`,
          height: `${qe}px`,
          width: `${ft}px`
        }, ke[Ae];
      }
    }, ve = () => {
      $.value.isScrolling = false, He(() => {
        R.value(-1, null, null);
      });
    };
    dt(() => {
      if (!Et)
        return;
      const { initScrollLeft: ye, initScrollTop: K } = h, q = i(E);
      q && (Ye(ye) && (q.scrollLeft = ye), Ye(K) && (q.scrollTop = K)), Z();
    });
    const me = () => {
      const { direction: ye } = h, { scrollLeft: K, scrollTop: q, updateRequested: ue } = i($), be = i(E);
      if (ue && be) {
        if (ye === Hs)
          switch (mf()) {
            case Pu: {
              be.scrollLeft = -K;
              break;
            }
            case Yg: {
              be.scrollLeft = K;
              break;
            }
            default: {
              const { clientWidth: ke, scrollWidth: Ae } = be;
              be.scrollLeft = Ae - ke - K;
              break;
            }
          }
        else
          be.scrollLeft = Math.max(0, K);
        be.scrollTop = Math.max(0, q);
      }
    }, { resetAfterColumnIndex: De, resetAfterRowIndex: Te, resetAfter: de } = _.proxy;
    g({
      windowRef: E,
      innerRef: N,
      getItemStyleCache: R,
      scrollTo: ce,
      scrollToItem: pe,
      states: $,
      resetAfterColumnIndex: De,
      resetAfterRowIndex: Te,
      resetAfter: de
    });
    const U = () => {
      const {
        scrollbarAlwaysOn: ye,
        scrollbarStartGap: K,
        scrollbarEndGap: q,
        totalColumn: ue,
        totalRow: be
      } = h, ke = i(z), Ae = i(P), fe = i(F), ie = i(M), { scrollLeft: Ce, scrollTop: qe } = i($), et = Ke(wh, {
        ref: T,
        alwaysOn: ye,
        startGap: K,
        endGap: q,
        class: y.e("horizontal"),
        clientSize: ke,
        layout: "horizontal",
        onScroll: X,
        ratio: ke * 100 / fe,
        scrollFrom: Ce / (fe - ke),
        total: be,
        visible: true
      }), ft = Ke(wh, {
        ref: O,
        alwaysOn: ye,
        startGap: K,
        endGap: q,
        class: y.e("vertical"),
        clientSize: Ae,
        layout: "vertical",
        onScroll: le,
        ratio: Ae * 100 / ie,
        scrollFrom: qe / (ie - Ae),
        total: ue,
        visible: true
      });
      return {
        horizontalScrollbar: et,
        verticalScrollbar: ft
      };
    }, re = () => {
      var ye;
      const [K, q] = i(Y), [ue, be] = i(D), { data: ke, totalColumn: Ae, totalRow: fe, useIsScrolling: ie, itemKey: Ce } = h, qe = [];
      if (fe > 0 && Ae > 0)
        for (let et = ue; et <= be; et++)
          for (let ft = K; ft <= q; ft++) {
            const bt = Ce({ columnIndex: ft, data: ke, rowIndex: et });
            qe.push(Ke(Ie, { key: bt }, (ye = w.default) == null ? void 0 : ye.call(w, {
              columnIndex: ft,
              data: ke,
              isScrolling: ie ? i($).isScrolling : void 0,
              style: se(et, ft),
              rowIndex: et
            })));
          }
      return qe;
    }, he = () => {
      const ye = ht(h.innerElement), K = re();
      return [
        Ke(ye, {
          style: i(V),
          ref: N
        }, Ve(ye) ? K : {
          default: () => K
        })
      ];
    };
    return () => {
      const ye = ht(h.containerElement), { horizontalScrollbar: K, verticalScrollbar: q } = U(), ue = he();
      return Ke("div", {
        key: 0,
        class: y.e("wrapper"),
        role: h.role
      }, [
        Ke(ye, {
          class: h.className,
          style: i(A),
          onScroll: G,
          ref: E
        }, Ve(ye) ? ue : { default: () => ue }),
        K,
        q
      ]);
    };
  }
}), { max: bf, min: NN, floor: TN } = Math, i_ = "ElDynamicSizeGrid", kG = {
  column: "columnWidth",
  row: "rowHeight"
}, Ah = {
  column: "lastVisitedColumnIndex",
  row: "lastVisitedRowIndex"
}, pa = (e10, t, n, o) => {
  const [r, a, l] = [
    n[o],
    e10[kG[o]],
    n[Ah[o]]
  ];
  if (t > l) {
    let s = 0;
    if (l >= 0) {
      const u = r[l];
      s = u.offset + u.size;
    }
    for (let u = l + 1; u <= t; u++) {
      const c = a(u);
      r[u] = {
        offset: s,
        size: c
      }, s += c;
    }
    n[Ah[o]] = t;
  }
  return r[t];
}, ON = (e10, t, n, o, r, a) => {
  for (; n <= o; ) {
    const l = n + TN((o - n) / 2), s = pa(e10, l, t, a).offset;
    if (s === r)
      return l;
    s < r ? n = l + 1 : o = l - 1;
  }
  return bf(0, n - 1);
}, NG = (e10, t, n, o, r) => {
  const a = r === "column" ? e10.totalColumn : e10.totalRow;
  let l = 1;
  for (; n < a && pa(e10, n, t, r).offset < o; )
    n += l, l *= 2;
  return ON(e10, t, TN(n / 2), NN(n, a - 1), o, r);
}, u_ = (e10, t, n, o) => {
  const [r, a] = [
    t[o],
    t[Ah[o]]
  ];
  return (a > 0 ? r[a].offset : 0) >= n ? ON(e10, t, 0, a, n, o) : NG(e10, t, bf(0, a), n, o);
}, $N = ({ totalRow: e10 }, { estimatedRowHeight: t, lastVisitedRowIndex: n, row: o }) => {
  let r = 0;
  if (n >= e10 && (n = e10 - 1), n >= 0) {
    const s = o[n];
    r = s.offset + s.size;
  }
  const l = (e10 - n - 1) * t;
  return r + l;
}, IN = ({ totalColumn: e10 }, { column: t, estimatedColumnWidth: n, lastVisitedColumnIndex: o }) => {
  let r = 0;
  if (o > e10 && (o = e10 - 1), o >= 0) {
    const s = t[o];
    r = s.offset + s.size;
  }
  const l = (e10 - o - 1) * n;
  return r + l;
}, TG = {
  column: IN,
  row: $N
}, c_ = (e10, t, n, o, r, a, l) => {
  const [s, u] = [
    a === "row" ? e10.height : e10.width,
    TG[a]
  ], c = pa(e10, t, r, a), d = u(e10, r), f = bf(0, NN(d - s, c.offset)), p = bf(0, c.offset - s + l + c.size);
  switch (n === dp && (o >= p - s && o <= f + s ? n = Uo : n = Br), n) {
    case Iu:
      return f;
    case Mu:
      return p;
    case Br:
      return Math.round(p + (f - p) / 2);
    case Uo:
    default:
      return o >= p && o <= f ? o : p > f || o < p ? p : f;
  }
}, OG = kN({
  name: "ElDynamicSizeGrid",
  getColumnPosition: (e10, t, n) => {
    const o = pa(e10, t, n, "column");
    return [o.size, o.offset];
  },
  getRowPosition: (e10, t, n) => {
    const o = pa(e10, t, n, "row");
    return [o.size, o.offset];
  },
  getColumnOffset: (e10, t, n, o, r, a) => c_(e10, t, n, o, r, "column", a),
  getRowOffset: (e10, t, n, o, r, a) => c_(e10, t, n, o, r, "row", a),
  getColumnStartIndexForOffset: (e10, t, n) => u_(e10, n, t, "column"),
  getColumnStopIndexForStartIndex: (e10, t, n, o) => {
    const r = pa(e10, t, o, "column"), a = n + e10.width;
    let l = r.offset + r.size, s = t;
    for (; s < e10.totalColumn - 1 && l < a; )
      s++, l += pa(e10, t, o, "column").size;
    return s;
  },
  getEstimatedTotalHeight: $N,
  getEstimatedTotalWidth: IN,
  getRowStartIndexForOffset: (e10, t, n) => u_(e10, n, t, "row"),
  getRowStopIndexForStartIndex: (e10, t, n, o) => {
    const { totalRow: r, height: a } = e10, l = pa(e10, t, o, "row"), s = n + a;
    let u = l.size + l.offset, c = t;
    for (; c < r - 1 && u < s; )
      c++, u += pa(e10, c, o, "row").size;
    return c;
  },
  injectToInstance: (e10, t) => {
    const n = ({ columnIndex: a, rowIndex: l }, s) => {
      var u, c;
      s = St(s) ? true : s, Ye(a) && (t.value.lastVisitedColumnIndex = Math.min(t.value.lastVisitedColumnIndex, a - 1)), Ye(l) && (t.value.lastVisitedRowIndex = Math.min(t.value.lastVisitedRowIndex, l - 1)), (u = e10.exposed) == null || u.getItemStyleCache.value(-1, null, null), s && ((c = e10.proxy) == null || c.$forceUpdate());
    }, o = (a, l) => {
      n({
        columnIndex: a
      }, l);
    }, r = (a, l) => {
      n({
        rowIndex: a
      }, l);
    };
    Object.assign(e10.proxy, {
      resetAfterColumnIndex: o,
      resetAfterRowIndex: r,
      resetAfter: n
    });
  },
  initCache: ({
    estimatedColumnWidth: e10 = hh,
    estimatedRowHeight: t = hh
  }) => ({
    column: {},
    estimatedColumnWidth: e10,
    estimatedRowHeight: t,
    lastVisitedColumnIndex: -1,
    lastVisitedRowIndex: -1,
    row: {}
  }),
  clearCache: false,
  validateProps: ({ columnWidth: e10, rowHeight: t }) => {
     true && (Fe(e10) || Qt(i_, `
          "columnWidth" must be passed as function,
            instead ${typeof e10} was given.
        `), Fe(t) || Qt(i_, `
          "rowHeight" must be passed as function,
            instead ${typeof t} was given.
        `));
  }
}), d_ = "ElFixedSizeGrid", $G = kN({
  name: "ElFixedSizeGrid",
  getColumnPosition: ({ columnWidth: e10 }, t) => [
    e10,
    t * e10
  ],
  getRowPosition: ({ rowHeight: e10 }, t) => [
    e10,
    t * e10
  ],
  getEstimatedTotalHeight: ({ totalRow: e10, rowHeight: t }) => t * e10,
  getEstimatedTotalWidth: ({ totalColumn: e10, columnWidth: t }) => t * e10,
  getColumnOffset: ({ totalColumn: e10, columnWidth: t, width: n }, o, r, a, l, s) => {
    n = Number(n);
    const u = Math.max(0, e10 * t - n), c = Math.min(u, o * t), d = Math.max(0, o * t - n + s + t);
    switch (r === "smart" && (a >= d - n && a <= c + n ? r = Uo : r = Br), r) {
      case Iu:
        return c;
      case Mu:
        return d;
      case Br: {
        const f = Math.round(d + (c - d) / 2);
        return f < Math.ceil(n / 2) ? 0 : f > u + Math.floor(n / 2) ? u : f;
      }
      case Uo:
      default:
        return a >= d && a <= c ? a : d > c || a < d ? d : c;
    }
  },
  getRowOffset: ({ rowHeight: e10, height: t, totalRow: n }, o, r, a, l, s) => {
    t = Number(t);
    const u = Math.max(0, n * e10 - t), c = Math.min(u, o * e10), d = Math.max(0, o * e10 - t + s + e10);
    switch (r === dp && (a >= d - t && a <= c + t ? r = Uo : r = Br), r) {
      case Iu:
        return c;
      case Mu:
        return d;
      case Br: {
        const f = Math.round(d + (c - d) / 2);
        return f < Math.ceil(t / 2) ? 0 : f > u + Math.floor(t / 2) ? u : f;
      }
      case Uo:
      default:
        return a >= d && a <= c ? a : d > c || a < d ? d : c;
    }
  },
  getColumnStartIndexForOffset: ({ columnWidth: e10, totalColumn: t }, n) => Math.max(0, Math.min(t - 1, Math.floor(n / e10))),
  getColumnStopIndexForStartIndex: ({ columnWidth: e10, totalColumn: t, width: n }, o, r) => {
    const a = o * e10, l = Math.ceil((n + r - a) / e10);
    return Math.max(0, Math.min(t - 1, o + l - 1));
  },
  getRowStartIndexForOffset: ({ rowHeight: e10, totalRow: t }, n) => Math.max(0, Math.min(t - 1, Math.floor(n / e10))),
  getRowStopIndexForStartIndex: ({ rowHeight: e10, totalRow: t, height: n }, o, r) => {
    const a = o * e10, l = Math.ceil((n + r - a) / e10);
    return Math.max(0, Math.min(t - 1, o + l - 1));
  },
  initCache: () => {
  },
  clearCache: true,
  validateProps: ({ columnWidth: e10, rowHeight: t }) => {
     true && (Ye(e10) || Qt(d_, `
          "columnWidth" must be passed as number,
            instead ${typeof e10} was given.
        `), Ye(t) || Qt(d_, `
          "columnWidth" must be passed as number,
            instead ${typeof t} was given.
        `));
  }
}), IG = "ElTableV2Grid", MG = (e10) => {
  const t = L(), n = L(), o = L(0), r = S(() => {
    const {
      data: b,
      rowHeight: g,
      estimatedRowHeight: w
    } = e10;
    if (!w)
      return b.length * g;
  }), a = S(() => {
    const {
      fixedData: b,
      rowHeight: g
    } = e10;
    return ((b == null ? void 0 : b.length) || 0) * g;
  }), l = S(() => kd(e10.headerHeight)), s = S(() => {
    const {
      height: b
    } = e10;
    return Math.max(0, b - i(l) - i(a));
  }), u = S(() => i(l) + i(a) > 0), c = ({
    data: b,
    rowIndex: g
  }) => b[g][e10.rowKey];
  function d({
    rowCacheStart: b,
    rowCacheEnd: g,
    rowVisibleStart: w,
    rowVisibleEnd: y
  }) {
    var _;
    (_ = e10.onRowsRendered) == null || _.call(e10, {
      rowCacheStart: b,
      rowCacheEnd: g,
      rowVisibleStart: w,
      rowVisibleEnd: y
    });
  }
  function f(b, g) {
    var w;
    (w = n.value) == null || w.resetAfterRowIndex(b, g);
  }
  function p(b, g) {
    const w = i(t), y = i(n);
    at(b) ? (w == null || w.scrollToLeft(b.scrollLeft), o.value = b.scrollLeft, y == null || y.scrollTo(b)) : (w == null || w.scrollToLeft(b), o.value = b, y == null || y.scrollTo({
      scrollLeft: b,
      scrollTop: g
    }));
  }
  function v(b) {
    var g;
    (g = i(n)) == null || g.scrollTo({
      scrollTop: b
    });
  }
  function m(b, g) {
    var w;
    (w = i(n)) == null || w.scrollToItem(b, 1, g);
  }
  function h() {
    var b, g;
    (b = i(n)) == null || b.$forceUpdate(), (g = i(t)) == null || g.$forceUpdate();
  }
  return ge(() => e10.bodyWidth, () => {
    var b;
    Ye(e10.estimatedRowHeight) && ((b = n.value) == null || b.resetAfter({
      columnIndex: 0
    }, false));
  }), {
    bodyRef: n,
    forceUpdate: h,
    fixedRowHeight: a,
    gridHeight: s,
    hasHeader: u,
    headerHeight: l,
    headerRef: t,
    totalHeight: r,
    itemKey: c,
    onItemRendered: d,
    resetAfterRowIndex: f,
    scrollTo: p,
    scrollToTop: v,
    scrollToRow: m,
    scrollLeft: o
  };
}, PG = /* @__PURE__ */ j({
  name: IG,
  props: Nd,
  setup(e10, {
    slots: t,
    expose: n
  }) {
    const {
      ns: o
    } = Le(Qg), {
      bodyRef: r,
      fixedRowHeight: a,
      gridHeight: l,
      hasHeader: s,
      headerRef: u,
      headerHeight: c,
      totalHeight: d,
      forceUpdate: f,
      itemKey: p,
      onItemRendered: v,
      resetAfterRowIndex: m,
      scrollTo: h,
      scrollToTop: b,
      scrollToRow: g,
      scrollLeft: w
    } = MG(e10);
    yt(wN, w), Lf(async () => {
      var _;
      await He();
      const C = (_ = r.value) == null ? void 0 : _.states.scrollTop;
      C && b(Math.round(C) + 1);
    }), n({
      forceUpdate: f,
      totalHeight: d,
      scrollTo: h,
      scrollToTop: b,
      scrollToRow: g,
      resetAfterRowIndex: m
    });
    const y = () => e10.bodyWidth;
    return () => {
      const {
        cache: _,
        columns: C,
        data: E,
        fixedData: T,
        useIsScrolling: O,
        scrollbarAlwaysOn: N,
        scrollbarEndGap: $,
        scrollbarStartGap: R,
        style: P,
        rowHeight: z,
        bodyWidth: Y,
        estimatedRowHeight: D,
        headerWidth: M,
        height: F,
        width: A,
        getRowHeight: V,
        onScroll: Z
      } = e10, G = Ye(D), le = G ? OG : $G, X = i(c);
      return W("div", {
        role: "table",
        class: [o.e("table"), e10.class],
        style: P
      }, [W(le, {
        ref: r,
        data: E,
        useIsScrolling: O,
        itemKey: p,
        columnCache: 0,
        columnWidth: G ? y : Y,
        totalColumn: 1,
        totalRow: E.length,
        rowCache: _,
        rowHeight: G ? V : z,
        width: A,
        height: i(l),
        class: o.e("body"),
        role: "rowgroup",
        scrollbarStartGap: R,
        scrollbarEndGap: $,
        scrollbarAlwaysOn: N,
        onScroll: Z,
        onItemRendered: v,
        perfMode: false
      }, {
        default: (te) => {
          var ce;
          const pe = E[te.rowIndex];
          return (ce = t.row) == null ? void 0 : ce.call(t, {
            ...te,
            columns: C,
            rowData: pe
          });
        }
      }), i(s) && W(EG, {
        ref: u,
        class: o.e("header-wrapper"),
        columns: C,
        headerData: E,
        headerHeight: e10.headerHeight,
        fixedHeaderData: T,
        rowWidth: M,
        rowHeight: z,
        width: A,
        height: Math.min(X + i(a), F)
      }, {
        dynamic: t.header,
        fixed: t.row
      })]);
    };
  }
});
var ny = PG;
function RG(e10) {
  return typeof e10 == "function" || Object.prototype.toString.call(e10) === "[object Object]" && !Ut(e10);
}
const AG = (e10, {
  slots: t
}) => {
  const {
    mainTableRef: n,
    ...o
  } = e10;
  return W(ny, vt({
    ref: n
  }, o), RG(t) ? t : {
    default: () => [t]
  });
};
var LG = AG;
function xG(e10) {
  return typeof e10 == "function" || Object.prototype.toString.call(e10) === "[object Object]" && !Ut(e10);
}
const DG = (e10, {
  slots: t
}) => {
  if (!e10.columns.length)
    return;
  const {
    leftTableRef: n,
    ...o
  } = e10;
  return W(ny, vt({
    ref: n
  }, o), xG(t) ? t : {
    default: () => [t]
  });
};
var VG = DG;
function FG(e10) {
  return typeof e10 == "function" || Object.prototype.toString.call(e10) === "[object Object]" && !Ut(e10);
}
const BG = (e10, {
  slots: t
}) => {
  if (!e10.columns.length)
    return;
  const {
    rightTableRef: n,
    ...o
  } = e10;
  return W(ny, vt({
    ref: n
  }, o), FG(t) ? t : {
    default: () => [t]
  });
};
var HG = BG;
const zG = (e10) => {
  const {
    isScrolling: t
  } = Le(Qg), n = L(false), o = L(), r = S(() => Ye(e10.estimatedRowHeight) && e10.rowIndex >= 0), a = (u = false) => {
    const c = i(o);
    if (!c)
      return;
    const {
      columns: d,
      onRowHeightChange: f,
      rowKey: p,
      rowIndex: v,
      style: m
    } = e10, {
      height: h
    } = c.getBoundingClientRect();
    n.value = true, He(() => {
      if (u || h !== Number.parseInt(m.height)) {
        const b = d[0], g = (b == null ? void 0 : b.placeholderSign) === xu;
        f == null || f({
          rowKey: p,
          height: h,
          rowIndex: v
        }, b && !g && b.fixed);
      }
    });
  }, l = S(() => {
    const {
      rowData: u,
      rowIndex: c,
      rowKey: d,
      onRowHover: f
    } = e10, p = e10.rowEventHandlers || {}, v = {};
    return Object.entries(p).forEach(([m, h]) => {
      Fe(h) && (v[m] = (b) => {
        h({
          event: b,
          rowData: u,
          rowIndex: c,
          rowKey: d
        });
      });
    }), f && [{
      name: "onMouseleave",
      hovered: false
    }, {
      name: "onMouseenter",
      hovered: true
    }].forEach(({
      name: m,
      hovered: h
    }) => {
      const b = v[m];
      v[m] = (g) => {
        f({
          event: g,
          hovered: h,
          rowData: u,
          rowIndex: c,
          rowKey: d
        }), b == null || b(g);
      };
    }), v;
  }), s = (u) => {
    const {
      onRowExpand: c,
      rowData: d,
      rowIndex: f,
      rowKey: p
    } = e10;
    c == null || c({
      expanded: u,
      rowData: d,
      rowIndex: f,
      rowKey: p
    });
  };
  return dt(() => {
    i(r) && a(true);
  }), {
    isScrolling: t,
    measurable: r,
    measured: n,
    rowRef: o,
    eventHandlers: l,
    onExpand: s
  };
}, KG = "ElTableV2TableRow", WG = /* @__PURE__ */ j({
  name: KG,
  props: Pl,
  setup(e10, {
    expose: t,
    slots: n,
    attrs: o
  }) {
    const {
      eventHandlers: r,
      isScrolling: a,
      measurable: l,
      measured: s,
      rowRef: u,
      onExpand: c
    } = zG(e10);
    return t({
      onExpand: c
    }), () => {
      const {
        columns: d,
        columnsStyles: f,
        expandColumnKey: p,
        depth: v,
        rowData: m,
        rowIndex: h,
        style: b
      } = e10;
      let g = d.map((w, y) => {
        const _ = Se(m.children) && m.children.length > 0 && w.key === p;
        return n.cell({
          column: w,
          columns: d,
          columnIndex: y,
          depth: v,
          style: f[w.key],
          rowData: m,
          rowIndex: h,
          isScrolling: i(a),
          expandIconProps: _ ? {
            rowData: m,
            rowIndex: h,
            onExpand: c
          } : void 0
        });
      });
      if (n.row && (g = n.row({
        cells: g.map((w) => Se(w) && w.length === 1 ? w[0] : w),
        style: b,
        columns: d,
        depth: v,
        rowData: m,
        rowIndex: h,
        isScrolling: i(a)
      })), i(l)) {
        const {
          height: w,
          ...y
        } = b || {}, _ = i(s);
        return W("div", vt({
          ref: u,
          class: e10.class,
          style: _ ? b : y,
          role: "row"
        }, o, i(r)), [g]);
      }
      return W("div", vt(o, {
        ref: u,
        class: e10.class,
        style: b,
        role: "row"
      }, i(r)), [g]);
    };
  }
});
var jG = WG;
function UG(e10) {
  return typeof e10 == "function" || Object.prototype.toString.call(e10) === "[object Object]" && !Ut(e10);
}
const YG = (e10, {
  slots: t
}) => {
  const {
    columns: n,
    columnsStyles: o,
    depthMap: r,
    expandColumnKey: a,
    expandedRowKeys: l,
    estimatedRowHeight: s,
    hasFixedColumns: u,
    rowData: c,
    rowIndex: d,
    style: f,
    isScrolling: p,
    rowProps: v,
    rowClass: m,
    rowKey: h,
    rowEventHandlers: b,
    ns: g,
    onRowHovered: w,
    onRowExpanded: y
  } = e10, _ = Ql(m, {
    columns: n,
    rowData: c,
    rowIndex: d
  }, ""), C = Ql(v, {
    columns: n,
    rowData: c,
    rowIndex: d
  }), E = c[h], T = r[E] || 0, O = !!a, N = d < 0, $ = [g.e("row"), _, {
    [g.e(`row-depth-${T}`)]: O && d >= 0,
    [g.is("expanded")]: O && l.includes(E),
    [g.is("fixed")]: !T && N,
    [g.is("customized")]: !!t.row
  }], R = u ? w : void 0, P = {
    ...C,
    columns: n,
    columnsStyles: o,
    class: $,
    depth: T,
    expandColumnKey: a,
    estimatedRowHeight: N ? void 0 : s,
    isScrolling: p,
    rowIndex: d,
    rowData: c,
    rowKey: E,
    rowEventHandlers: b,
    style: f
  };
  return W(jG, vt(P, {
    onRowExpand: y,
    onMouseenter: (D) => {
      R == null || R({
        hovered: true,
        rowKey: E,
        event: D,
        rowData: c,
        rowIndex: d
      });
    },
    onMouseleave: (D) => {
      R == null || R({
        hovered: false,
        rowKey: E,
        event: D,
        rowData: c,
        rowIndex: d
      });
    },
    rowkey: E
  }), UG(t) ? t : {
    default: () => [t]
  });
};
var qG = YG;
const oy = (e10, {
  slots: t
}) => {
  var n;
  const {
    cellData: o,
    style: r
  } = e10, a = ((n = o == null ? void 0 : o.toString) == null ? void 0 : n.call(o)) || "", l = J(t, "default", e10, () => [a]);
  return W("div", {
    class: e10.class,
    title: a,
    style: r
  }, [l]);
};
oy.displayName = "ElTableV2Cell";
oy.inheritAttrs = false;
var GG = oy;
const XG = (e10) => {
  const {
    expanded: t,
    expandable: n,
    onExpand: o,
    style: r,
    size: a
  } = e10, l = {
    onClick: n ? () => o(!t) : void 0,
    class: e10.class
  };
  return W(Be, vt(l, {
    size: a,
    style: r
  }), {
    default: () => [W(oo, null, null)]
  });
};
var JG = XG;
const MN = ({
  columns: e10,
  column: t,
  columnIndex: n,
  depth: o,
  expandIconProps: r,
  isScrolling: a,
  rowData: l,
  rowIndex: s,
  style: u,
  expandedRowKeys: c,
  ns: d,
  cellProps: f,
  expandColumnKey: p,
  indentSize: v,
  iconSize: m,
  rowKey: h
}, {
  slots: b
}) => {
  const g = Za(u);
  if (t.placeholderSign === xu)
    return W("div", {
      class: d.em("row-cell", "placeholder"),
      style: g
    }, null);
  const {
    cellRenderer: w,
    dataKey: y,
    dataGetter: _
  } = t, C = Fe(_) ? _({
    columns: e10,
    column: t,
    columnIndex: n,
    rowData: l,
    rowIndex: s
  }) : hn(l, y != null ? y : ""), E = Ql(f, {
    cellData: C,
    columns: e10,
    column: t,
    columnIndex: n,
    rowIndex: s,
    rowData: l
  }), T = {
    class: d.e("cell-text"),
    columns: e10,
    column: t,
    columnIndex: n,
    cellData: C,
    isScrolling: a,
    rowData: l,
    rowIndex: s
  }, O = _N(w), N = O ? O(T) : J(b, "default", T, () => [W(GG, T, null)]), $ = [d.e("row-cell"), t.class, t.align === Lu.CENTER && d.is("align-center"), t.align === Lu.RIGHT && d.is("align-right")], R = s >= 0 && p && t.key === p, P = s >= 0 && c.includes(l[h]);
  let z;
  const Y = `margin-inline-start: ${o * v}px;`;
  return R && (at(r) ? z = W(JG, vt(r, {
    class: [d.e("expand-icon"), d.is("expanded", P)],
    size: m,
    expanded: P,
    style: Y,
    expandable: true
  }), null) : z = W("div", {
    style: [Y, `width: ${m}px; height: ${m}px;`].join(" ")
  }, null)), W("div", vt({
    class: $,
    style: g
  }, E, {
    role: "cell"
  }), [z, N]);
};
MN.inheritAttrs = false;
var f_ = MN;
const ZG = Oe({
  class: String,
  columns: vc,
  columnsStyles: {
    type: ne(Object),
    required: true
  },
  headerIndex: Number,
  style: { type: ne(Object) }
}), QG = /* @__PURE__ */ j({
  name: "ElTableV2HeaderRow",
  props: ZG,
  setup(e10, {
    slots: t
  }) {
    return () => {
      const {
        columns: n,
        columnsStyles: o,
        headerIndex: r,
        style: a
      } = e10;
      let l = n.map((s, u) => t.cell({
        columns: n,
        column: s,
        columnIndex: u,
        headerIndex: r,
        style: o[s.key]
      }));
      return t.header && (l = t.header({
        cells: l.map((s) => Se(s) && s.length === 1 ? s[0] : s),
        columns: n,
        headerIndex: r
      })), W("div", {
        class: e10.class,
        style: a,
        role: "row"
      }, [l]);
    };
  }
});
var eX = QG;
function tX(e10) {
  return typeof e10 == "function" || Object.prototype.toString.call(e10) === "[object Object]" && !Ut(e10);
}
const nX = ({
  columns: e10,
  columnsStyles: t,
  headerIndex: n,
  style: o,
  headerClass: r,
  headerProps: a,
  ns: l
}, {
  slots: s
}) => {
  const u = {
    columns: e10,
    headerIndex: n
  }, c = [l.e("header-row"), Ql(r, u, ""), {
    [l.is("customized")]: !!s.header
  }], d = {
    ...Ql(a, u),
    columnsStyles: t,
    class: c,
    columns: e10,
    headerIndex: n,
    style: o
  };
  return W(eX, d, tX(s) ? s : {
    default: () => [s]
  });
};
var oX = nX;
const ry = (e10, {
  slots: t
}) => J(t, "default", e10, () => {
  var n, o;
  return [W("div", {
    class: e10.class,
    title: (n = e10.column) == null ? void 0 : n.title
  }, [(o = e10.column) == null ? void 0 : o.title])];
});
ry.displayName = "ElTableV2HeaderCell";
ry.inheritAttrs = false;
var rX = ry;
const aX = (e10) => {
  const {
    sortOrder: t
  } = e10;
  return W(Be, {
    size: 14,
    class: e10.class
  }, {
    default: () => [t === Au.ASC ? W($8, null, null) : W(T8, null, null)]
  });
};
var lX = aX;
const sX = (e10, {
  slots: t
}) => {
  const {
    column: n,
    ns: o,
    style: r,
    onColumnSorted: a
  } = e10, l = Za(r);
  if (n.placeholderSign === xu)
    return W("div", {
      class: o.em("header-row-cell", "placeholder"),
      style: l
    }, null);
  const {
    headerCellRenderer: s,
    headerClass: u,
    sortable: c
  } = n, d = {
    ...e10,
    class: o.e("header-cell-text")
  }, f = _N(s), p = f ? f(d) : J(t, "default", d, () => [W(rX, d, null)]), {
    sortBy: v,
    sortState: m,
    headerCellProps: h
  } = e10;
  let b, g;
  if (m) {
    const _ = m[n.key];
    b = !!Rh[_], g = b ? _ : Au.ASC;
  } else
    b = n.key === v.key, g = b ? v.order : Au.ASC;
  const w = [o.e("header-cell"), Ql(u, e10, ""), n.align === Lu.CENTER && o.is("align-center"), n.align === Lu.RIGHT && o.is("align-right"), c && o.is("sortable")], y = {
    ...Ql(h, e10),
    onClick: n.sortable ? a : void 0,
    class: w,
    style: l,
    "data-key": n.key
  };
  return W("div", vt(y, {
    role: "columnheader"
  }), [p, c && W(lX, {
    class: [o.e("sort-icon"), b && o.is("sorting")],
    sortOrder: g
  }, null)]);
};
var p_ = sX;
const PN = (e10, {
  slots: t
}) => {
  var n;
  return W("div", {
    class: e10.class,
    style: e10.style
  }, [(n = t.default) == null ? void 0 : n.call(t)]);
};
PN.displayName = "ElTableV2Footer";
var iX = PN;
const RN = (e10, {
  slots: t
}) => {
  const n = J(t, "default", {}, () => [W(kk, null, null)]);
  return W("div", {
    class: e10.class,
    style: e10.style
  }, [n]);
};
RN.displayName = "ElTableV2Empty";
var uX = RN;
const AN = (e10, {
  slots: t
}) => {
  var n;
  return W("div", {
    class: e10.class,
    style: e10.style
  }, [(n = t.default) == null ? void 0 : n.call(t)]);
};
AN.displayName = "ElTableV2Overlay";
var cX = AN;
function zi(e10) {
  return typeof e10 == "function" || Object.prototype.toString.call(e10) === "[object Object]" && !Ut(e10);
}
const dX = "ElTableV2", fX = /* @__PURE__ */ j({
  name: dX,
  props: _G,
  setup(e10, {
    slots: t,
    expose: n
  }) {
    const o = we("table-v2"), {
      columnsStyles: r,
      fixedColumnsOnLeft: a,
      fixedColumnsOnRight: l,
      mainColumns: s,
      mainTableHeight: u,
      fixedTableHeight: c,
      leftTableWidth: d,
      rightTableWidth: f,
      data: p,
      depthMap: v,
      expandedRowKeys: m,
      hasFixedColumns: h,
      mainTableRef: b,
      leftTableRef: g,
      rightTableRef: w,
      isDynamic: y,
      isResetting: _,
      isScrolling: C,
      bodyWidth: E,
      emptyStyle: T,
      rootStyle: O,
      footerHeight: N,
      showEmpty: $,
      scrollTo: R,
      scrollToLeft: P,
      scrollToTop: z,
      scrollToRow: Y,
      getRowHeight: D,
      onColumnSorted: M,
      onRowHeightChange: F,
      onRowHovered: A,
      onRowExpanded: V,
      onRowsRendered: Z,
      onScroll: G,
      onVerticalScroll: le
    } = yG(e10);
    return n({
      scrollTo: R,
      scrollToLeft: P,
      scrollToTop: z,
      scrollToRow: Y
    }), yt(Qg, {
      ns: o,
      isResetting: _,
      isScrolling: C
    }), () => {
      const {
        cache: X,
        cellProps: te,
        estimatedRowHeight: ce,
        expandColumnKey: pe,
        fixedData: se,
        headerHeight: ve,
        headerClass: me,
        headerProps: De,
        headerCellProps: Te,
        sortBy: de,
        sortState: U,
        rowHeight: re,
        rowClass: he,
        rowEventHandlers: Ee,
        rowKey: ye,
        rowProps: K,
        scrollbarAlwaysOn: q,
        indentSize: ue,
        iconSize: be,
        useIsScrolling: ke,
        vScrollbarSize: Ae,
        width: fe
      } = e10, ie = i(p), Ce = {
        cache: X,
        class: o.e("main"),
        columns: i(s),
        data: ie,
        fixedData: se,
        estimatedRowHeight: ce,
        bodyWidth: i(E),
        headerHeight: ve,
        headerWidth: i(E),
        height: i(u),
        mainTableRef: b,
        rowKey: ye,
        rowHeight: re,
        scrollbarAlwaysOn: q,
        scrollbarStartGap: 2,
        scrollbarEndGap: Ae,
        useIsScrolling: ke,
        width: fe,
        getRowHeight: D,
        onRowsRendered: Z,
        onScroll: G
      }, qe = i(d), et = i(c), ft = {
        cache: X,
        class: o.e("left"),
        columns: i(a),
        data: ie,
        fixedData: se,
        estimatedRowHeight: ce,
        leftTableRef: g,
        rowHeight: re,
        bodyWidth: qe,
        headerWidth: qe,
        headerHeight: ve,
        height: et,
        rowKey: ye,
        scrollbarAlwaysOn: q,
        scrollbarStartGap: 2,
        scrollbarEndGap: Ae,
        useIsScrolling: ke,
        width: qe,
        getRowHeight: D,
        onScroll: le
      }, bt = i(f), zt = {
        cache: X,
        class: o.e("right"),
        columns: i(l),
        data: ie,
        fixedData: se,
        estimatedRowHeight: ce,
        rightTableRef: w,
        rowHeight: re,
        bodyWidth: bt,
        headerWidth: bt,
        headerHeight: ve,
        height: et,
        rowKey: ye,
        scrollbarAlwaysOn: q,
        scrollbarStartGap: 2,
        scrollbarEndGap: Ae,
        width: bt,
        style: `--${i(o.namespace)}-table-scrollbar-size: ${Ae}px`,
        useIsScrolling: ke,
        getRowHeight: D,
        onScroll: le
      }, We = i(r), ct = {
        ns: o,
        depthMap: i(v),
        columnsStyles: We,
        expandColumnKey: pe,
        expandedRowKeys: i(m),
        estimatedRowHeight: ce,
        hasFixedColumns: i(h),
        rowProps: K,
        rowClass: he,
        rowKey: ye,
        rowEventHandlers: Ee,
        onRowHovered: A,
        onRowExpanded: V,
        onRowHeightChange: F
      }, oe = {
        cellProps: te,
        expandColumnKey: pe,
        indentSize: ue,
        iconSize: be,
        rowKey: ye,
        expandedRowKeys: i(m),
        ns: o
      }, Ne = {
        ns: o,
        headerClass: me,
        headerProps: De,
        columnsStyles: We
      }, Q = {
        ns: o,
        sortBy: de,
        sortState: U,
        headerCellProps: Te,
        onColumnSorted: M
      }, Me = {
        row: (Kt) => W(qG, vt(Kt, ct), {
          row: t.row,
          cell: (pn) => {
            let on;
            return t.cell ? W(f_, vt(pn, oe, {
              style: We[pn.column.key]
            }), zi(on = t.cell(pn)) ? on : {
              default: () => [on]
            }) : W(f_, vt(pn, oe, {
              style: We[pn.column.key]
            }), null);
          }
        }),
        header: (Kt) => W(oX, vt(Kt, Ne), {
          header: t.header,
          cell: (pn) => {
            let on;
            return t["header-cell"] ? W(p_, vt(pn, Q, {
              style: We[pn.column.key]
            }), zi(on = t["header-cell"](pn)) ? on : {
              default: () => [on]
            }) : W(p_, vt(pn, Q, {
              style: We[pn.column.key]
            }), null);
          }
        })
      }, Qe = [e10.class, o.b(), o.e("root"), {
        [o.is("dynamic")]: i(y)
      }], Ct = {
        class: o.e("footer"),
        style: i(N)
      };
      return W("div", {
        class: Qe,
        style: i(O)
      }, [W(LG, Ce, zi(Me) ? Me : {
        default: () => [Me]
      }), W(VG, ft, zi(Me) ? Me : {
        default: () => [Me]
      }), W(HG, zt, zi(Me) ? Me : {
        default: () => [Me]
      }), t.footer && W(iX, Ct, {
        default: t.footer
      }), i($) && W(uX, {
        class: o.e("empty"),
        style: i(T)
      }, {
        default: t.empty
      }), t.overlay && W(cX, {
        class: o.e("overlay")
      }, {
        default: t.overlay
      })]);
    };
  }
});
var pX = fX;
const vX = Oe({
  disableWidth: Boolean,
  disableHeight: Boolean,
  onResize: {
    type: ne(Function)
  }
}), hX = (e10) => {
  const t = L(), n = L(0), o = L(0);
  let r;
  return dt(() => {
    r = en(t, ([a]) => {
      const { width: l, height: s } = a.contentRect, { paddingLeft: u, paddingRight: c, paddingTop: d, paddingBottom: f } = getComputedStyle(a.target), p = Number.parseInt(u) || 0, v = Number.parseInt(c) || 0, m = Number.parseInt(d) || 0, h = Number.parseInt(f) || 0;
      n.value = l - p - v, o.value = s - m - h;
    }).stop;
  }), jt(() => {
    r == null || r();
  }), ge([n, o], ([a, l]) => {
    var s;
    (s = e10.onResize) == null || s.call(e10, {
      width: a,
      height: l
    });
  }), {
    sizer: t,
    width: n,
    height: o
  };
}, mX = /* @__PURE__ */ j({
  name: "ElAutoResizer",
  props: vX,
  setup(e10, {
    slots: t
  }) {
    const n = we("auto-resizer"), {
      height: o,
      width: r,
      sizer: a
    } = hX(e10), l = {
      width: "100%",
      height: "100%"
    };
    return () => {
      var s;
      return W("div", {
        ref: a,
        class: n.b(),
        style: l
      }, [(s = t.default) == null ? void 0 : s.call(t, {
        height: o.value,
        width: r.value
      })]);
    };
  }
});
var gX = mX;
const yX = ut(pX), bX = ut(gX), fp = Symbol("tabsRootContextKey"), _X = Oe({
  tabs: {
    type: ne(Array),
    default: () => rn([])
  }
}), LN = "ElTabBar", wX = /* @__PURE__ */ j({
  name: LN
}), CX = /* @__PURE__ */ j({
  ...wX,
  props: _X,
  setup(e10, { expose: t }) {
    const n = e10, o = it(), r = Le(fp);
    r || Qt(LN, "<el-tabs><el-tab-bar /></el-tabs>");
    const a = we("tabs"), l = L(), s = L(), u = () => {
      let v = 0, m = 0;
      const h = ["top", "bottom"].includes(r.props.tabPosition) ? "width" : "height", b = h === "width" ? "x" : "y", g = b === "x" ? "left" : "top";
      return n.tabs.every((w) => {
        var y, _;
        const C = (_ = (y = o.parent) == null ? void 0 : y.refs) == null ? void 0 : _[`tab-${w.uid}`];
        if (!C)
          return false;
        if (!w.active)
          return true;
        v = C[`offset${xr(g)}`], m = C[`client${xr(h)}`];
        const E = window.getComputedStyle(C);
        return h === "width" && (m -= Number.parseFloat(E.paddingLeft) + Number.parseFloat(E.paddingRight), v += Number.parseFloat(E.paddingLeft)), false;
      }), {
        [h]: `${m}px`,
        transform: `translate${xr(b)}(${v}px)`
      };
    }, c = () => s.value = u(), d = [], f = () => {
      var v;
      d.forEach((h) => h.stop()), d.length = 0;
      const m = (v = o.parent) == null ? void 0 : v.refs;
      if (m) {
        for (const h in m)
          if (h.startsWith("tab-")) {
            const b = m[h];
            b && d.push(en(b, c));
          }
      }
    };
    ge(() => n.tabs, async () => {
      await He(), c(), f();
    }, { immediate: true });
    const p = en(l, () => c());
    return jt(() => {
      d.forEach((v) => v.stop()), d.length = 0, p.stop();
    }), t({
      ref: l,
      update: c
    }), (v, m) => (k(), x("div", {
      ref_key: "barRef",
      ref: l,
      class: I([i(a).e("active-bar"), i(a).is(i(r).props.tabPosition)]),
      style: ze(s.value)
    }, null, 6));
  }
});
var EX = /* @__PURE__ */ $e(CX, [["__file", "tab-bar.vue"]]);
const SX = Oe({
  panes: {
    type: ne(Array),
    default: () => rn([])
  },
  currentName: {
    type: [String, Number],
    default: ""
  },
  editable: Boolean,
  type: {
    type: String,
    values: ["card", "border-card", ""],
    default: ""
  },
  stretch: Boolean
}), kX = {
  tabClick: (e10, t, n) => n instanceof Event,
  tabRemove: (e10, t) => t instanceof Event
}, v_ = "ElTabNav", NX = /* @__PURE__ */ j({
  name: v_,
  props: SX,
  emits: kX,
  setup(e10, {
    expose: t,
    emit: n
  }) {
    const o = Le(fp);
    o || Qt(v_, "<el-tabs><tab-nav /></el-tabs>");
    const r = we("tabs"), a = jL(), l = rx(), s = L(), u = L(), c = L(), d = L(), f = L(false), p = L(0), v = L(false), m = L(true), h = S(() => ["top", "bottom"].includes(o.props.tabPosition) ? "width" : "height"), b = S(() => ({
      transform: `translate${h.value === "width" ? "X" : "Y"}(-${p.value}px)`
    })), g = () => {
      if (!s.value)
        return;
      const O = s.value[`offset${xr(h.value)}`], N = p.value;
      if (!N)
        return;
      const $ = N > O ? N - O : 0;
      p.value = $;
    }, w = () => {
      if (!s.value || !u.value)
        return;
      const O = u.value[`offset${xr(h.value)}`], N = s.value[`offset${xr(h.value)}`], $ = p.value;
      if (O - $ <= N)
        return;
      const R = O - $ > N * 2 ? $ + N : O - N;
      p.value = R;
    }, y = async () => {
      const O = u.value;
      if (!f.value || !c.value || !s.value || !O)
        return;
      await He();
      const N = c.value.querySelector(".is-active");
      if (!N)
        return;
      const $ = s.value, R = ["top", "bottom"].includes(o.props.tabPosition), P = N.getBoundingClientRect(), z = $.getBoundingClientRect(), Y = R ? O.offsetWidth - z.width : O.offsetHeight - z.height, D = p.value;
      let M = D;
      R ? (P.left < z.left && (M = D - (z.left - P.left)), P.right > z.right && (M = D + P.right - z.right)) : (P.top < z.top && (M = D - (z.top - P.top)), P.bottom > z.bottom && (M = D + (P.bottom - z.bottom))), M = Math.max(M, 0), p.value = Math.min(M, Y);
    }, _ = () => {
      var O;
      if (!u.value || !s.value)
        return;
      e10.stretch && ((O = d.value) == null || O.update());
      const N = u.value[`offset${xr(h.value)}`], $ = s.value[`offset${xr(h.value)}`], R = p.value;
      $ < N ? (f.value = f.value || {}, f.value.prev = R, f.value.next = R + $ < N, N - R < $ && (p.value = N - $)) : (f.value = false, R > 0 && (p.value = 0));
    }, C = (O) => {
      let N = 0;
      switch (O.code) {
        case xe.left:
        case xe.up:
          N = -1;
          break;
        case xe.right:
        case xe.down:
          N = 1;
          break;
        default:
          return;
      }
      const $ = Array.from(O.currentTarget.querySelectorAll("[role=tab]:not(.is-disabled)"));
      let P = $.indexOf(O.target) + N;
      P < 0 ? P = $.length - 1 : P >= $.length && (P = 0), $[P].focus({
        preventScroll: true
      }), $[P].click(), E();
    }, E = () => {
      m.value && (v.value = true);
    }, T = () => v.value = false;
    return ge(a, (O) => {
      O === "hidden" ? m.value = false : O === "visible" && setTimeout(() => m.value = true, 50);
    }), ge(l, (O) => {
      O ? setTimeout(() => m.value = true, 50) : m.value = false;
    }), en(c, _), dt(() => setTimeout(() => y(), 0)), wr(() => _()), t({
      scrollToActiveTab: y,
      removeFocus: T,
      tabListRef: u,
      tabBarRef: d
    }), () => {
      const O = f.value ? [W("span", {
        class: [r.e("nav-prev"), r.is("disabled", !f.value.prev)],
        onClick: g
      }, [W(Be, null, {
        default: () => [W(wa, null, null)]
      })]), W("span", {
        class: [r.e("nav-next"), r.is("disabled", !f.value.next)],
        onClick: w
      }, [W(Be, null, {
        default: () => [W(oo, null, null)]
      })])] : null, N = e10.panes.map(($, R) => {
        var P, z, Y, D;
        const M = $.uid, F = $.props.disabled, A = (z = (P = $.props.name) != null ? P : $.index) != null ? z : `${R}`, V = !F && ($.isClosable || e10.editable);
        $.index = `${R}`;
        const Z = V ? W(Be, {
          class: "is-icon-close",
          onClick: (X) => n("tabRemove", $, X)
        }, {
          default: () => [W(Jo, null, null)]
        }) : null, G = ((D = (Y = $.slots).label) == null ? void 0 : D.call(Y)) || $.props.label, le = !F && $.active ? 0 : -1;
        return W("div", {
          ref: `tab-${M}`,
          class: [r.e("item"), r.is(o.props.tabPosition), r.is("active", $.active), r.is("disabled", F), r.is("closable", V), r.is("focus", v.value)],
          id: `tab-${A}`,
          key: `tab-${M}`,
          "aria-controls": `pane-${A}`,
          role: "tab",
          "aria-selected": $.active,
          tabindex: le,
          onFocus: () => E(),
          onBlur: () => T(),
          onClick: (X) => {
            T(), n("tabClick", $, A, X);
          },
          onKeydown: (X) => {
            V && (X.code === xe.delete || X.code === xe.backspace) && n("tabRemove", $, X);
          }
        }, [G, Z]);
      });
      return W("div", {
        ref: c,
        class: [r.e("nav-wrap"), r.is("scrollable", !!f.value), r.is(o.props.tabPosition)]
      }, [O, W("div", {
        class: r.e("nav-scroll"),
        ref: s
      }, [W("div", {
        class: [r.e("nav"), r.is(o.props.tabPosition), r.is("stretch", e10.stretch && ["top", "bottom"].includes(o.props.tabPosition))],
        ref: u,
        style: b.value,
        role: "tablist",
        onKeydown: C
      }, [e10.type ? null : W(EX, {
        ref: d,
        tabs: [...e10.panes]
      }, null), N])])]);
    };
  }
}), TX = Oe({
  type: {
    type: String,
    values: ["card", "border-card", ""],
    default: ""
  },
  closable: Boolean,
  addable: Boolean,
  modelValue: {
    type: [String, Number]
  },
  editable: Boolean,
  tabPosition: {
    type: String,
    values: ["top", "right", "bottom", "left"],
    default: "top"
  },
  beforeLeave: {
    type: ne(Function),
    default: () => true
  },
  stretch: Boolean
}), vv = (e10) => Ve(e10) || Ye(e10), OX = {
  [nt]: (e10) => vv(e10),
  tabClick: (e10, t) => t instanceof Event,
  tabChange: (e10) => vv(e10),
  edit: (e10, t) => ["remove", "add"].includes(t),
  tabRemove: (e10) => vv(e10),
  tabAdd: () => true
}, $X = /* @__PURE__ */ j({
  name: "ElTabs",
  props: TX,
  emits: OX,
  setup(e10, {
    emit: t,
    slots: n,
    expose: o
  }) {
    var r;
    const a = we("tabs"), l = S(() => ["left", "right"].includes(e10.tabPosition)), {
      children: s,
      addChild: u,
      removeChild: c
    } = ap(it(), "ElTabPane"), d = L(), f = L((r = e10.modelValue) != null ? r : "0"), p = async (g, w = false) => {
      var y, _;
      if (!(f.value === g || St(g)))
        try {
          let C;
          if (e10.beforeLeave) {
            const E = e10.beforeLeave(g, f.value);
            C = E instanceof Promise ? await E : E;
          } else
            C = true;
          C !== false && (f.value = g, w && (t(nt, g), t("tabChange", g)), (_ = (y = d.value) == null ? void 0 : y.removeFocus) == null || _.call(y));
        } catch {
        }
    }, v = (g, w, y) => {
      g.props.disabled || (t("tabClick", g, y), p(w, true));
    }, m = (g, w) => {
      g.props.disabled || St(g.props.name) || (w.stopPropagation(), t("edit", g.props.name, "remove"), t("tabRemove", g.props.name));
    }, h = () => {
      t("edit", void 0, "add"), t("tabAdd");
    };
    ge(() => e10.modelValue, (g) => p(g)), ge(f, async () => {
      var g;
      await He(), (g = d.value) == null || g.scrollToActiveTab();
    }), yt(fp, {
      props: e10,
      currentName: f,
      registerPane: (g) => {
        s.value.push(g);
      },
      sortPane: u,
      unregisterPane: c
    }), o({
      currentName: f,
      tabNavRef: d
    });
    const b = ({
      render: g
    }) => g();
    return () => {
      const g = n["add-icon"], w = e10.editable || e10.addable ? W("div", {
        class: [a.e("new-tab"), l.value && a.e("new-tab-vertical")],
        tabindex: "0",
        onClick: h,
        onKeydown: (C) => {
          [xe.enter, xe.numpadEnter].includes(C.code) && h();
        }
      }, [g ? J(n, "add-icon") : W(Be, {
        class: a.is("icon-plus")
      }, {
        default: () => [W(RS, null, null)]
      })]) : null, y = W("div", {
        class: [a.e("header"), l.value && a.e("header-vertical"), a.is(e10.tabPosition)]
      }, [W(b, {
        render: () => {
          const C = s.value.some((E) => E.slots.label);
          return W(NX, {
            ref: d,
            currentName: f.value,
            editable: e10.editable,
            type: e10.type,
            panes: s.value,
            stretch: e10.stretch,
            onTabClick: v,
            onTabRemove: m
          }, {
            $stable: !C
          });
        }
      }, null), w]), _ = W("div", {
        class: a.e("content")
      }, [J(n, "default")]);
      return W("div", {
        class: [a.b(), a.m(e10.tabPosition), {
          [a.m("card")]: e10.type === "card",
          [a.m("border-card")]: e10.type === "border-card"
        }]
      }, [_, y]);
    };
  }
});
var IX = $X;
const MX = Oe({
  label: {
    type: String,
    default: ""
  },
  name: {
    type: [String, Number]
  },
  closable: Boolean,
  disabled: Boolean,
  lazy: Boolean
}), xN = "ElTabPane", PX = /* @__PURE__ */ j({
  name: xN
}), RX = /* @__PURE__ */ j({
  ...PX,
  props: MX,
  setup(e10) {
    const t = e10, n = it(), o = En(), r = Le(fp);
    r || Qt(xN, "usage: <el-tabs><el-tab-pane /></el-tabs/>");
    const a = we("tab-pane"), l = L(), s = S(() => t.closable || r.props.closable), u = Zd(() => {
      var v;
      return r.currentName.value === ((v = t.name) != null ? v : l.value);
    }), c = L(u.value), d = S(() => {
      var v;
      return (v = t.name) != null ? v : l.value;
    }), f = Zd(() => !t.lazy || c.value || u.value);
    ge(u, (v) => {
      v && (c.value = true);
    });
    const p = It({
      uid: n.uid,
      slots: o,
      props: t,
      paneName: d,
      active: u,
      index: l,
      isClosable: s
    });
    return r.registerPane(p), dt(() => {
      r.sortPane(p);
    }), Jr(() => {
      r.unregisterPane(p.uid);
    }), (v, m) => i(f) ? lt((k(), x("div", {
      key: 0,
      id: `pane-${i(d)}`,
      class: I(i(a).b()),
      role: "tabpanel",
      "aria-hidden": !i(u),
      "aria-labelledby": `tab-${i(d)}`
    }, [
      J(v.$slots, "default")
    ], 10, ["id", "aria-hidden", "aria-labelledby"])), [
      [Nt, i(u)]
    ]) : ee("v-if", true);
  }
});
var DN = /* @__PURE__ */ $e(RX, [["__file", "tab-pane.vue"]]);
const AX = ut(IX, {
  TabPane: DN
}), LX = nn(DN), xX = Oe({
  type: {
    type: String,
    values: ["primary", "success", "info", "warning", "danger", ""],
    default: ""
  },
  size: {
    type: String,
    values: Qr,
    default: ""
  },
  truncated: Boolean,
  lineClamp: {
    type: [String, Number]
  },
  tag: {
    type: String,
    default: "span"
  }
}), DX = /* @__PURE__ */ j({
  name: "ElText"
}), VX = /* @__PURE__ */ j({
  ...DX,
  props: xX,
  setup(e10) {
    const t = e10, n = L(), o = yn(), r = we("text"), a = S(() => [
      r.b(),
      r.m(t.type),
      r.m(o.value),
      r.is("truncated", t.truncated),
      r.is("line-clamp", !St(t.lineClamp))
    ]), l = () => {
      var s, u, c, d, f, p, v;
      if (Ta().title)
        return;
      let h = false;
      const b = ((s = n.value) == null ? void 0 : s.textContent) || "";
      if (t.truncated) {
        const g = (u = n.value) == null ? void 0 : u.offsetWidth, w = (c = n.value) == null ? void 0 : c.scrollWidth;
        g && w && w > g && (h = true);
      } else if (!St(t.lineClamp)) {
        const g = (d = n.value) == null ? void 0 : d.offsetHeight, w = (f = n.value) == null ? void 0 : f.scrollHeight;
        g && w && w > g && (h = true);
      }
      h ? (p = n.value) == null || p.setAttribute("title", b) : (v = n.value) == null || v.removeAttribute("title");
    };
    return dt(l), wr(l), (s, u) => (k(), ae(ht(s.tag), {
      ref_key: "textRef",
      ref: n,
      class: I(i(a)),
      style: ze({ "-webkit-line-clamp": s.lineClamp })
    }, {
      default: H(() => [
        J(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "style"]));
  }
});
var FX = /* @__PURE__ */ $e(VX, [["__file", "text.vue"]]);
const ay = ut(FX), BX = Oe({
  format: {
    type: String,
    default: "HH:mm"
  },
  modelValue: String,
  disabled: Boolean,
  editable: {
    type: Boolean,
    default: true
  },
  effect: {
    type: ne(String),
    default: "light"
  },
  clearable: {
    type: Boolean,
    default: true
  },
  size: _n,
  placeholder: String,
  start: {
    type: String,
    default: "09:00"
  },
  end: {
    type: String,
    default: "18:00"
  },
  step: {
    type: String,
    default: "00:30"
  },
  minTime: String,
  maxTime: String,
  includeEndTime: {
    type: Boolean,
    default: false
  },
  name: String,
  prefixIcon: {
    type: ne([String, Object]),
    default: () => PS
  },
  clearIcon: {
    type: ne([String, Object]),
    default: () => Ma
  },
  ...ki
}), ma = (e10) => {
  const t = (e10 || "").split(":");
  if (t.length >= 2) {
    let n = Number.parseInt(t[0], 10);
    const o = Number.parseInt(t[1], 10), r = e10.toUpperCase();
    return r.includes("AM") && n === 12 ? n = 0 : r.includes("PM") && n !== 12 && (n += 12), {
      hours: n,
      minutes: o
    };
  }
  return null;
}, hv = (e10, t) => {
  const n = ma(e10);
  if (!n)
    return -1;
  const o = ma(t);
  if (!o)
    return -1;
  const r = n.minutes + n.hours * 60, a = o.minutes + o.hours * 60;
  return r === a ? 0 : r > a ? 1 : -1;
}, h_ = (e10) => `${e10}`.padStart(2, "0"), Ts = (e10) => `${h_(e10.hours)}:${h_(e10.minutes)}`, HX = (e10, t) => {
  const n = ma(e10);
  if (!n)
    return "";
  const o = ma(t);
  if (!o)
    return "";
  const r = {
    hours: n.hours,
    minutes: n.minutes
  };
  return r.minutes += o.minutes, r.hours += o.hours, r.hours += Math.floor(r.minutes / 60), r.minutes = r.minutes % 60, Ts(r);
}, zX = /* @__PURE__ */ j({
  name: "ElTimeSelect"
}), KX = /* @__PURE__ */ j({
  ...zX,
  props: BX,
  emits: [gt, "blur", "focus", "clear", nt],
  setup(e10, { expose: t }) {
    const n = e10;
    rt.extend(kg);
    const { Option: o } = Zl, r = we("input"), a = L(), l = Hn(), { lang: s } = kt(), u = S(() => n.modelValue), c = S(() => {
      const g = ma(n.start);
      return g ? Ts(g) : null;
    }), d = S(() => {
      const g = ma(n.end);
      return g ? Ts(g) : null;
    }), f = S(() => {
      const g = ma(n.step);
      return g ? Ts(g) : null;
    }), p = S(() => {
      const g = ma(n.minTime || "");
      return g ? Ts(g) : null;
    }), v = S(() => {
      const g = ma(n.maxTime || "");
      return g ? Ts(g) : null;
    }), m = S(() => {
      var g;
      const w = [], y = (_, C) => {
        w.push({
          value: _,
          disabled: hv(C, p.value || "-1:-1") <= 0 || hv(C, v.value || "100:100") >= 0
        });
      };
      if (n.start && n.end && n.step) {
        let _ = c.value, C;
        for (; _ && d.value && hv(_, d.value) <= 0; )
          C = rt(_, "HH:mm").locale(s.value).format(n.format), y(C, _), _ = HX(_, f.value);
        if (n.includeEndTime && d.value && ((g = w[w.length - 1]) == null ? void 0 : g.value) !== d.value) {
          const E = rt(d.value, "HH:mm").locale(s.value).format(n.format);
          y(E, d.value);
        }
      }
      return w;
    });
    return t({
      blur: () => {
        var g, w;
        (w = (g = a.value) == null ? void 0 : g.blur) == null || w.call(g);
      },
      focus: () => {
        var g, w;
        (w = (g = a.value) == null ? void 0 : g.focus) == null || w.call(g);
      }
    }), (g, w) => (k(), ae(i(Zl), {
      ref_key: "select",
      ref: a,
      "model-value": i(u),
      disabled: i(l),
      clearable: g.clearable,
      "clear-icon": g.clearIcon,
      size: g.size,
      effect: g.effect,
      placeholder: g.placeholder,
      "default-first-option": "",
      filterable: g.editable,
      "empty-values": g.emptyValues,
      "value-on-clear": g.valueOnClear,
      "onUpdate:modelValue": (y) => g.$emit(i(nt), y),
      onChange: (y) => g.$emit(i(gt), y),
      onBlur: (y) => g.$emit("blur", y),
      onFocus: (y) => g.$emit("focus", y),
      onClear: () => g.$emit("clear")
    }, {
      prefix: H(() => [
        g.prefixIcon ? (k(), ae(i(Be), {
          key: 0,
          class: I(i(r).e("prefix-icon"))
        }, {
          default: H(() => [
            (k(), ae(ht(g.prefixIcon)))
          ]),
          _: 1
        }, 8, ["class"])) : ee("v-if", true)
      ]),
      default: H(() => [
        (k(true), x(Ie, null, st(i(m), (y) => (k(), ae(i(o), {
          key: y.value,
          label: y.value,
          value: y.value,
          disabled: y.disabled
        }, null, 8, ["label", "value", "disabled"]))), 128))
      ]),
      _: 1
    }, 8, ["model-value", "disabled", "clearable", "clear-icon", "size", "effect", "placeholder", "filterable", "empty-values", "value-on-clear", "onUpdate:modelValue", "onChange", "onBlur", "onFocus", "onClear"]));
  }
});
var WX = /* @__PURE__ */ $e(KX, [["__file", "time-select.vue"]]);
const jX = ut(WX), UX = "timeline", YX = /* @__PURE__ */ j({
  name: "ElTimeline",
  setup(e10, { slots: t }) {
    const n = we("timeline");
    return yt(UX, t), () => Ke("ul", { class: [n.b()] }, [J(t, "default")]);
  }
}), qX = Oe({
  timestamp: {
    type: String,
    default: ""
  },
  hideTimestamp: Boolean,
  center: Boolean,
  placement: {
    type: String,
    values: ["top", "bottom"],
    default: "bottom"
  },
  type: {
    type: String,
    values: ["primary", "success", "warning", "danger", "info"],
    default: ""
  },
  color: {
    type: String,
    default: ""
  },
  size: {
    type: String,
    values: ["normal", "large"],
    default: "normal"
  },
  icon: {
    type: Ht
  },
  hollow: Boolean
}), GX = /* @__PURE__ */ j({
  name: "ElTimelineItem"
}), XX = /* @__PURE__ */ j({
  ...GX,
  props: qX,
  setup(e10) {
    const t = e10, n = we("timeline-item"), o = S(() => [
      n.e("node"),
      n.em("node", t.size || ""),
      n.em("node", t.type || ""),
      n.is("hollow", t.hollow)
    ]);
    return (r, a) => (k(), x("li", {
      class: I([i(n).b(), { [i(n).e("center")]: r.center }])
    }, [
      B("div", {
        class: I(i(n).e("tail"))
      }, null, 2),
      r.$slots.dot ? ee("v-if", true) : (k(), x("div", {
        key: 0,
        class: I(i(o)),
        style: ze({
          backgroundColor: r.color
        })
      }, [
        r.icon ? (k(), ae(i(Be), {
          key: 0,
          class: I(i(n).e("icon"))
        }, {
          default: H(() => [
            (k(), ae(ht(r.icon)))
          ]),
          _: 1
        }, 8, ["class"])) : ee("v-if", true)
      ], 6)),
      r.$slots.dot ? (k(), x("div", {
        key: 1,
        class: I(i(n).e("dot"))
      }, [
        J(r.$slots, "dot")
      ], 2)) : ee("v-if", true),
      B("div", {
        class: I(i(n).e("wrapper"))
      }, [
        !r.hideTimestamp && r.placement === "top" ? (k(), x("div", {
          key: 0,
          class: I([i(n).e("timestamp"), i(n).is("top")])
        }, _e(r.timestamp), 3)) : ee("v-if", true),
        B("div", {
          class: I(i(n).e("content"))
        }, [
          J(r.$slots, "default")
        ], 2),
        !r.hideTimestamp && r.placement === "bottom" ? (k(), x("div", {
          key: 1,
          class: I([i(n).e("timestamp"), i(n).is("bottom")])
        }, _e(r.timestamp), 3)) : ee("v-if", true)
      ], 2)
    ], 2));
  }
});
var VN = /* @__PURE__ */ $e(XX, [["__file", "timeline-item.vue"]]);
const JX = ut(YX, {
  TimelineItem: VN
}), ZX = nn(VN), FN = Oe({
  nowrap: Boolean
});
var BN = /* @__PURE__ */ ((e10) => (e10.top = "top", e10.bottom = "bottom", e10.left = "left", e10.right = "right", e10))(BN || {});
const QX = Object.values(BN), ly = Oe({
  width: {
    type: Number,
    default: 10
  },
  height: {
    type: Number,
    default: 10
  },
  style: {
    type: ne(Object),
    default: null
  }
}), eJ = Oe({
  side: {
    type: ne(String),
    values: QX,
    required: true
  }
}), tJ = ["absolute", "fixed"], nJ = [
  "top-start",
  "top-end",
  "top",
  "bottom-start",
  "bottom-end",
  "bottom",
  "left-start",
  "left-end",
  "left",
  "right-start",
  "right-end",
  "right"
], sy = Oe({
  arrowPadding: {
    type: ne(Number),
    default: 5
  },
  effect: {
    type: ne(String),
    default: "light"
  },
  contentClass: String,
  placement: {
    type: ne(String),
    values: nJ,
    default: "bottom"
  },
  reference: {
    type: ne(Object),
    default: null
  },
  offset: {
    type: Number,
    default: 8
  },
  strategy: {
    type: ne(String),
    values: tJ,
    default: "absolute"
  },
  showArrow: Boolean,
  ...Bn(["ariaLabel"])
}), iy = Oe({
  delayDuration: {
    type: Number,
    default: 300
  },
  defaultOpen: Boolean,
  open: {
    type: Boolean,
    default: void 0
  },
  onOpenChange: {
    type: ne(Function)
  },
  "onUpdate:open": {
    type: ne(Function)
  }
}), _s = {
  type: ne(Function)
}, uy = Oe({
  onBlur: _s,
  onClick: _s,
  onFocus: _s,
  onMouseDown: _s,
  onMouseEnter: _s,
  onMouseLeave: _s
}), oJ = Oe({
  ...iy,
  ...ly,
  ...uy,
  ...sy,
  alwaysOn: Boolean,
  fullTransition: Boolean,
  transitionProps: {
    type: ne(Object),
    default: null
  },
  teleported: Boolean,
  to: {
    type: ne([String, Object]),
    default: "body"
  }
}), pp = Symbol("tooltipV2"), HN = Symbol("tooltipV2Content"), mv = "tooltip_v2.open", rJ = /* @__PURE__ */ j({
  name: "ElTooltipV2Root"
}), aJ = /* @__PURE__ */ j({
  ...rJ,
  props: iy,
  setup(e10, { expose: t }) {
    const n = e10, o = L(n.defaultOpen), r = L(null), a = S({
      get: () => So(n.open) ? o.value : n.open,
      set: (b) => {
        var g;
        o.value = b, (g = n["onUpdate:open"]) == null || g.call(n, b);
      }
    }), l = S(() => Ye(n.delayDuration) && n.delayDuration > 0), { start: s, stop: u } = Xl(() => {
      a.value = true;
    }, S(() => n.delayDuration), {
      immediate: false
    }), c = we("tooltip-v2"), d = Fn(), f = () => {
      u(), a.value = true;
    }, p = () => {
      i(l) ? s() : f();
    }, v = f, m = () => {
      u(), a.value = false;
    };
    return ge(a, (b) => {
      var g;
      b && (document.dispatchEvent(new CustomEvent(mv)), v()), (g = n.onOpenChange) == null || g.call(n, b);
    }), dt(() => {
      document.addEventListener(mv, m);
    }), jt(() => {
      u(), document.removeEventListener(mv, m);
    }), yt(pp, {
      contentId: d,
      triggerRef: r,
      ns: c,
      onClose: m,
      onDelayOpen: p,
      onOpen: v
    }), t({
      onOpen: v,
      onClose: m
    }), (b, g) => J(b.$slots, "default", { open: i(a) });
  }
});
var lJ = /* @__PURE__ */ $e(aJ, [["__file", "root.vue"]]);
const sJ = /* @__PURE__ */ j({
  name: "ElTooltipV2Arrow"
}), iJ = /* @__PURE__ */ j({
  ...sJ,
  props: {
    ...ly,
    ...eJ
  },
  setup(e10) {
    const t = e10, { ns: n } = Le(pp), { arrowRef: o } = Le(HN), r = S(() => {
      const { style: a, width: l, height: s } = t, u = n.namespace.value;
      return {
        [`--${u}-tooltip-v2-arrow-width`]: `${l}px`,
        [`--${u}-tooltip-v2-arrow-height`]: `${s}px`,
        [`--${u}-tooltip-v2-arrow-border-width`]: `${l / 2}px`,
        [`--${u}-tooltip-v2-arrow-cover-width`]: l / 2 - 1,
        ...a || {}
      };
    });
    return (a, l) => (k(), x("span", {
      ref_key: "arrowRef",
      ref: o,
      style: ze(i(r)),
      class: I(i(n).e("arrow"))
    }, null, 6));
  }
});
var m_ = /* @__PURE__ */ $e(iJ, [["__file", "arrow.vue"]]);
const di = Math.min, jl = Math.max, _f = Math.round, jc = Math.floor, zr = (e10) => ({
  x: e10,
  y: e10
}), uJ = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, cJ = {
  start: "end",
  end: "start"
};
function Lh(e10, t, n) {
  return jl(e10, di(t, n));
}
function hc(e10, t) {
  return typeof e10 == "function" ? e10(t) : e10;
}
function es(e10) {
  return e10.split("-")[0];
}
function mc(e10) {
  return e10.split("-")[1];
}
function zN(e10) {
  return e10 === "x" ? "y" : "x";
}
function cy(e10) {
  return e10 === "y" ? "height" : "width";
}
function Qa(e10) {
  return ["top", "bottom"].includes(es(e10)) ? "y" : "x";
}
function dy(e10) {
  return zN(Qa(e10));
}
function dJ(e10, t, n) {
  n === void 0 && (n = false);
  const o = mc(e10), r = dy(e10), a = cy(r);
  let l = r === "x" ? o === (n ? "end" : "start") ? "right" : "left" : o === "start" ? "bottom" : "top";
  return t.reference[a] > t.floating[a] && (l = wf(l)), [l, wf(l)];
}
function fJ(e10) {
  const t = wf(e10);
  return [xh(e10), t, xh(t)];
}
function xh(e10) {
  return e10.replace(/start|end/g, (t) => cJ[t]);
}
function pJ(e10, t, n) {
  const o = ["left", "right"], r = ["right", "left"], a = ["top", "bottom"], l = ["bottom", "top"];
  switch (e10) {
    case "top":
    case "bottom":
      return n ? t ? r : o : t ? o : r;
    case "left":
    case "right":
      return t ? a : l;
    default:
      return [];
  }
}
function vJ(e10, t, n, o) {
  const r = mc(e10);
  let a = pJ(es(e10), n === "start", o);
  return r && (a = a.map((l) => l + "-" + r), t && (a = a.concat(a.map(xh)))), a;
}
function wf(e10) {
  return e10.replace(/left|right|bottom|top/g, (t) => uJ[t]);
}
function hJ(e10) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e10
  };
}
function KN(e10) {
  return typeof e10 != "number" ? hJ(e10) : {
    top: e10,
    right: e10,
    bottom: e10,
    left: e10
  };
}
function Cf(e10) {
  const {
    x: t,
    y: n,
    width: o,
    height: r
  } = e10;
  return {
    width: o,
    height: r,
    top: n,
    left: t,
    right: t + o,
    bottom: n + r,
    x: t,
    y: n
  };
}
function g_(e10, t, n) {
  let {
    reference: o,
    floating: r
  } = e10;
  const a = Qa(t), l = dy(t), s = cy(l), u = es(t), c = a === "y", d = o.x + o.width / 2 - r.width / 2, f = o.y + o.height / 2 - r.height / 2, p = o[s] / 2 - r[s] / 2;
  let v;
  switch (u) {
    case "top":
      v = {
        x: d,
        y: o.y - r.height
      };
      break;
    case "bottom":
      v = {
        x: d,
        y: o.y + o.height
      };
      break;
    case "right":
      v = {
        x: o.x + o.width,
        y: f
      };
      break;
    case "left":
      v = {
        x: o.x - r.width,
        y: f
      };
      break;
    default:
      v = {
        x: o.x,
        y: o.y
      };
  }
  switch (mc(t)) {
    case "start":
      v[l] -= p * (n && c ? -1 : 1);
      break;
    case "end":
      v[l] += p * (n && c ? -1 : 1);
      break;
  }
  return v;
}
const mJ = async (e10, t, n) => {
  const {
    placement: o = "bottom",
    strategy: r = "absolute",
    middleware: a = [],
    platform: l
  } = n, s = a.filter(Boolean), u = await (l.isRTL == null ? void 0 : l.isRTL(t));
  let c = await l.getElementRects({
    reference: e10,
    floating: t,
    strategy: r
  }), {
    x: d,
    y: f
  } = g_(c, o, u), p = o, v = {}, m = 0;
  for (let h = 0; h < s.length; h++) {
    const {
      name: b,
      fn: g
    } = s[h], {
      x: w,
      y,
      data: _,
      reset: C
    } = await g({
      x: d,
      y: f,
      initialPlacement: o,
      placement: p,
      strategy: r,
      middlewareData: v,
      rects: c,
      platform: l,
      elements: {
        reference: e10,
        floating: t
      }
    });
    d = w != null ? w : d, f = y != null ? y : f, v = {
      ...v,
      [b]: {
        ...v[b],
        ..._
      }
    }, C && m <= 50 && (m++, typeof C == "object" && (C.placement && (p = C.placement), C.rects && (c = C.rects === true ? await l.getElementRects({
      reference: e10,
      floating: t,
      strategy: r
    }) : C.rects), {
      x: d,
      y: f
    } = g_(c, p, u)), h = -1);
  }
  return {
    x: d,
    y: f,
    placement: p,
    strategy: r,
    middlewareData: v
  };
};
async function fy(e10, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: o,
    y: r,
    platform: a,
    rects: l,
    elements: s,
    strategy: u
  } = e10, {
    boundary: c = "clippingAncestors",
    rootBoundary: d = "viewport",
    elementContext: f = "floating",
    altBoundary: p = false,
    padding: v = 0
  } = hc(t, e10), m = KN(v), b = s[p ? f === "floating" ? "reference" : "floating" : f], g = Cf(await a.getClippingRect({
    element: (n = await (a.isElement == null ? void 0 : a.isElement(b))) == null || n ? b : b.contextElement || await (a.getDocumentElement == null ? void 0 : a.getDocumentElement(s.floating)),
    boundary: c,
    rootBoundary: d,
    strategy: u
  })), w = f === "floating" ? {
    x: o,
    y: r,
    width: l.floating.width,
    height: l.floating.height
  } : l.reference, y = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(s.floating)), _ = await (a.isElement == null ? void 0 : a.isElement(y)) ? await (a.getScale == null ? void 0 : a.getScale(y)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, C = Cf(a.convertOffsetParentRelativeRectToViewportRelativeRect ? await a.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: s,
    rect: w,
    offsetParent: y,
    strategy: u
  }) : w);
  return {
    top: (g.top - C.top + m.top) / _.y,
    bottom: (C.bottom - g.bottom + m.bottom) / _.y,
    left: (g.left - C.left + m.left) / _.x,
    right: (C.right - g.right + m.right) / _.x
  };
}
const gJ = (e10) => ({
  name: "arrow",
  options: e10,
  async fn(t) {
    const {
      x: n,
      y: o,
      placement: r,
      rects: a,
      platform: l,
      elements: s,
      middlewareData: u
    } = t, {
      element: c,
      padding: d = 0
    } = hc(e10, t) || {};
    if (c == null)
      return {};
    const f = KN(d), p = {
      x: n,
      y: o
    }, v = dy(r), m = cy(v), h = await l.getDimensions(c), b = v === "y", g = b ? "top" : "left", w = b ? "bottom" : "right", y = b ? "clientHeight" : "clientWidth", _ = a.reference[m] + a.reference[v] - p[v] - a.floating[m], C = p[v] - a.reference[v], E = await (l.getOffsetParent == null ? void 0 : l.getOffsetParent(c));
    let T = E ? E[y] : 0;
    (!T || !await (l.isElement == null ? void 0 : l.isElement(E))) && (T = s.floating[y] || a.floating[m]);
    const O = _ / 2 - C / 2, N = T / 2 - h[m] / 2 - 1, $ = di(f[g], N), R = di(f[w], N), P = $, z = T - h[m] - R, Y = T / 2 - h[m] / 2 + O, D = Lh(P, Y, z), M = !u.arrow && mc(r) != null && Y !== D && a.reference[m] / 2 - (Y < P ? $ : R) - h[m] / 2 < 0, F = M ? Y < P ? Y - P : Y - z : 0;
    return {
      [v]: p[v] + F,
      data: {
        [v]: D,
        centerOffset: Y - D - F,
        ...M && {
          alignmentOffset: F
        }
      },
      reset: M
    };
  }
}), yJ = function(e10) {
  return e10 === void 0 && (e10 = {}), {
    name: "flip",
    options: e10,
    async fn(t) {
      var n, o;
      const {
        placement: r,
        middlewareData: a,
        rects: l,
        initialPlacement: s,
        platform: u,
        elements: c
      } = t, {
        mainAxis: d = true,
        crossAxis: f = true,
        fallbackPlacements: p,
        fallbackStrategy: v = "bestFit",
        fallbackAxisSideDirection: m = "none",
        flipAlignment: h = true,
        ...b
      } = hc(e10, t);
      if ((n = a.arrow) != null && n.alignmentOffset)
        return {};
      const g = es(r), w = Qa(s), y = es(s) === s, _ = await (u.isRTL == null ? void 0 : u.isRTL(c.floating)), C = p || (y || !h ? [wf(s)] : fJ(s)), E = m !== "none";
      !p && E && C.push(...vJ(s, h, m, _));
      const T = [s, ...C], O = await fy(t, b), N = [];
      let $ = ((o = a.flip) == null ? void 0 : o.overflows) || [];
      if (d && N.push(O[g]), f) {
        const Y = dJ(r, l, _);
        N.push(O[Y[0]], O[Y[1]]);
      }
      if ($ = [...$, {
        placement: r,
        overflows: N
      }], !N.every((Y) => Y <= 0)) {
        var R, P;
        const Y = (((R = a.flip) == null ? void 0 : R.index) || 0) + 1, D = T[Y];
        if (D && (!(f === "alignment" ? w !== Qa(D) : false) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        $.every((A) => A.overflows[0] > 0 && Qa(A.placement) === w)))
          return {
            data: {
              index: Y,
              overflows: $
            },
            reset: {
              placement: D
            }
          };
        let M = (P = $.filter((F) => F.overflows[0] <= 0).sort((F, A) => F.overflows[1] - A.overflows[1])[0]) == null ? void 0 : P.placement;
        if (!M)
          switch (v) {
            case "bestFit": {
              var z;
              const F = (z = $.filter((A) => {
                if (E) {
                  const V = Qa(A.placement);
                  return V === w || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  V === "y";
                }
                return true;
              }).map((A) => [A.placement, A.overflows.filter((V) => V > 0).reduce((V, Z) => V + Z, 0)]).sort((A, V) => A[1] - V[1])[0]) == null ? void 0 : z[0];
              F && (M = F);
              break;
            }
            case "initialPlacement":
              M = s;
              break;
          }
        if (r !== M)
          return {
            reset: {
              placement: M
            }
          };
      }
      return {};
    }
  };
};
async function bJ(e10, t) {
  const {
    placement: n,
    platform: o,
    elements: r
  } = e10, a = await (o.isRTL == null ? void 0 : o.isRTL(r.floating)), l = es(n), s = mc(n), u = Qa(n) === "y", c = ["left", "top"].includes(l) ? -1 : 1, d = a && u ? -1 : 1, f = hc(t, e10);
  let {
    mainAxis: p,
    crossAxis: v,
    alignmentAxis: m
  } = typeof f == "number" ? {
    mainAxis: f,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: f.mainAxis || 0,
    crossAxis: f.crossAxis || 0,
    alignmentAxis: f.alignmentAxis
  };
  return s && typeof m == "number" && (v = s === "end" ? m * -1 : m), u ? {
    x: v * d,
    y: p * c
  } : {
    x: p * c,
    y: v * d
  };
}
const _J = function(e10) {
  return e10 === void 0 && (e10 = 0), {
    name: "offset",
    options: e10,
    async fn(t) {
      var n, o;
      const {
        x: r,
        y: a,
        placement: l,
        middlewareData: s
      } = t, u = await bJ(t, e10);
      return l === ((n = s.offset) == null ? void 0 : n.placement) && (o = s.arrow) != null && o.alignmentOffset ? {} : {
        x: r + u.x,
        y: a + u.y,
        data: {
          ...u,
          placement: l
        }
      };
    }
  };
}, wJ = function(e10) {
  return e10 === void 0 && (e10 = {}), {
    name: "shift",
    options: e10,
    async fn(t) {
      const {
        x: n,
        y: o,
        placement: r
      } = t, {
        mainAxis: a = true,
        crossAxis: l = false,
        limiter: s = {
          fn: (b) => {
            let {
              x: g,
              y: w
            } = b;
            return {
              x: g,
              y: w
            };
          }
        },
        ...u
      } = hc(e10, t), c = {
        x: n,
        y: o
      }, d = await fy(t, u), f = Qa(es(r)), p = zN(f);
      let v = c[p], m = c[f];
      if (a) {
        const b = p === "y" ? "top" : "left", g = p === "y" ? "bottom" : "right", w = v + d[b], y = v - d[g];
        v = Lh(w, v, y);
      }
      if (l) {
        const b = f === "y" ? "top" : "left", g = f === "y" ? "bottom" : "right", w = m + d[b], y = m - d[g];
        m = Lh(w, m, y);
      }
      const h = s.fn({
        ...t,
        [p]: v,
        [f]: m
      });
      return {
        ...h,
        data: {
          x: h.x - n,
          y: h.y - o,
          enabled: {
            [p]: a,
            [f]: l
          }
        }
      };
    }
  };
};
function vp() {
  return typeof window < "u";
}
function Ii(e10) {
  return WN(e10) ? (e10.nodeName || "").toLowerCase() : "#document";
}
function Fo(e10) {
  var t;
  return (e10 == null || (t = e10.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function na(e10) {
  var t;
  return (t = (WN(e10) ? e10.ownerDocument : e10.document) || window.document) == null ? void 0 : t.documentElement;
}
function WN(e10) {
  return vp() ? e10 instanceof Node || e10 instanceof Fo(e10).Node : false;
}
function yr(e10) {
  return vp() ? e10 instanceof Element || e10 instanceof Fo(e10).Element : false;
}
function Xr(e10) {
  return vp() ? e10 instanceof HTMLElement || e10 instanceof Fo(e10).HTMLElement : false;
}
function y_(e10) {
  return !vp() || typeof ShadowRoot > "u" ? false : e10 instanceof ShadowRoot || e10 instanceof Fo(e10).ShadowRoot;
}
function gc(e10) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: o,
    display: r
  } = br(e10);
  return /auto|scroll|overlay|hidden|clip/.test(t + o + n) && !["inline", "contents"].includes(r);
}
function CJ(e10) {
  return ["table", "td", "th"].includes(Ii(e10));
}
function hp(e10) {
  return [":popover-open", ":modal"].some((t) => {
    try {
      return e10.matches(t);
    } catch {
      return false;
    }
  });
}
function py(e10) {
  const t = vy(), n = yr(e10) ? br(e10) : e10;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((o) => n[o] ? n[o] !== "none" : false) || (n.containerType ? n.containerType !== "normal" : false) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : false) || !t && (n.filter ? n.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((o) => (n.willChange || "").includes(o)) || ["paint", "layout", "strict", "content"].some((o) => (n.contain || "").includes(o));
}
function EJ(e10) {
  let t = dl(e10);
  for (; Xr(t) && !fi(t); ) {
    if (py(t))
      return t;
    if (hp(t))
      return null;
    t = dl(t);
  }
  return null;
}
function vy() {
  return typeof CSS > "u" || !CSS.supports ? false : CSS.supports("-webkit-backdrop-filter", "none");
}
function fi(e10) {
  return ["html", "body", "#document"].includes(Ii(e10));
}
function br(e10) {
  return Fo(e10).getComputedStyle(e10);
}
function mp(e10) {
  return yr(e10) ? {
    scrollLeft: e10.scrollLeft,
    scrollTop: e10.scrollTop
  } : {
    scrollLeft: e10.scrollX,
    scrollTop: e10.scrollY
  };
}
function dl(e10) {
  if (Ii(e10) === "html")
    return e10;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e10.assignedSlot || // DOM Element detected.
    e10.parentNode || // ShadowRoot detected.
    y_(e10) && e10.host || // Fallback.
    na(e10)
  );
  return y_(t) ? t.host : t;
}
function jN(e10) {
  const t = dl(e10);
  return fi(t) ? e10.ownerDocument ? e10.ownerDocument.body : e10.body : Xr(t) && gc(t) ? t : jN(t);
}
function Du(e10, t, n) {
  var o;
  t === void 0 && (t = []), n === void 0 && (n = true);
  const r = jN(e10), a = r === ((o = e10.ownerDocument) == null ? void 0 : o.body), l = Fo(r);
  if (a) {
    const s = Dh(l);
    return t.concat(l, l.visualViewport || [], gc(r) ? r : [], s && n ? Du(s) : []);
  }
  return t.concat(r, Du(r, [], n));
}
function Dh(e10) {
  return e10.parent && Object.getPrototypeOf(e10.parent) ? e10.frameElement : null;
}
function UN(e10) {
  const t = br(e10);
  let n = parseFloat(t.width) || 0, o = parseFloat(t.height) || 0;
  const r = Xr(e10), a = r ? e10.offsetWidth : n, l = r ? e10.offsetHeight : o, s = _f(n) !== a || _f(o) !== l;
  return s && (n = a, o = l), {
    width: n,
    height: o,
    $: s
  };
}
function hy(e10) {
  return yr(e10) ? e10 : e10.contextElement;
}
function Ks(e10) {
  const t = hy(e10);
  if (!Xr(t))
    return zr(1);
  const n = t.getBoundingClientRect(), {
    width: o,
    height: r,
    $: a
  } = UN(t);
  let l = (a ? _f(n.width) : n.width) / o, s = (a ? _f(n.height) : n.height) / r;
  return (!l || !Number.isFinite(l)) && (l = 1), (!s || !Number.isFinite(s)) && (s = 1), {
    x: l,
    y: s
  };
}
const SJ = /* @__PURE__ */ zr(0);
function YN(e10) {
  const t = Fo(e10);
  return !vy() || !t.visualViewport ? SJ : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function kJ(e10, t, n) {
  return t === void 0 && (t = false), !n || t && n !== Fo(e10) ? false : t;
}
function ts(e10, t, n, o) {
  t === void 0 && (t = false), n === void 0 && (n = false);
  const r = e10.getBoundingClientRect(), a = hy(e10);
  let l = zr(1);
  t && (o ? yr(o) && (l = Ks(o)) : l = Ks(e10));
  const s = kJ(a, n, o) ? YN(a) : zr(0);
  let u = (r.left + s.x) / l.x, c = (r.top + s.y) / l.y, d = r.width / l.x, f = r.height / l.y;
  if (a) {
    const p = Fo(a), v = o && yr(o) ? Fo(o) : o;
    let m = p, h = Dh(m);
    for (; h && o && v !== m; ) {
      const b = Ks(h), g = h.getBoundingClientRect(), w = br(h), y = g.left + (h.clientLeft + parseFloat(w.paddingLeft)) * b.x, _ = g.top + (h.clientTop + parseFloat(w.paddingTop)) * b.y;
      u *= b.x, c *= b.y, d *= b.x, f *= b.y, u += y, c += _, m = Fo(h), h = Dh(m);
    }
  }
  return Cf({
    width: d,
    height: f,
    x: u,
    y: c
  });
}
function my(e10, t) {
  const n = mp(e10).scrollLeft;
  return t ? t.left + n : ts(na(e10)).left + n;
}
function qN(e10, t, n) {
  n === void 0 && (n = false);
  const o = e10.getBoundingClientRect(), r = o.left + t.scrollLeft - (n ? 0 : (
    // RTL <body> scrollbar.
    my(e10, o)
  )), a = o.top + t.scrollTop;
  return {
    x: r,
    y: a
  };
}
function NJ(e10) {
  let {
    elements: t,
    rect: n,
    offsetParent: o,
    strategy: r
  } = e10;
  const a = r === "fixed", l = na(o), s = t ? hp(t.floating) : false;
  if (o === l || s && a)
    return n;
  let u = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = zr(1);
  const d = zr(0), f = Xr(o);
  if ((f || !f && !a) && ((Ii(o) !== "body" || gc(l)) && (u = mp(o)), Xr(o))) {
    const v = ts(o);
    c = Ks(o), d.x = v.x + o.clientLeft, d.y = v.y + o.clientTop;
  }
  const p = l && !f && !a ? qN(l, u, true) : zr(0);
  return {
    width: n.width * c.x,
    height: n.height * c.y,
    x: n.x * c.x - u.scrollLeft * c.x + d.x + p.x,
    y: n.y * c.y - u.scrollTop * c.y + d.y + p.y
  };
}
function TJ(e10) {
  return Array.from(e10.getClientRects());
}
function OJ(e10) {
  const t = na(e10), n = mp(e10), o = e10.ownerDocument.body, r = jl(t.scrollWidth, t.clientWidth, o.scrollWidth, o.clientWidth), a = jl(t.scrollHeight, t.clientHeight, o.scrollHeight, o.clientHeight);
  let l = -n.scrollLeft + my(e10);
  const s = -n.scrollTop;
  return br(o).direction === "rtl" && (l += jl(t.clientWidth, o.clientWidth) - r), {
    width: r,
    height: a,
    x: l,
    y: s
  };
}
function $J(e10, t) {
  const n = Fo(e10), o = na(e10), r = n.visualViewport;
  let a = o.clientWidth, l = o.clientHeight, s = 0, u = 0;
  if (r) {
    a = r.width, l = r.height;
    const c = vy();
    (!c || c && t === "fixed") && (s = r.offsetLeft, u = r.offsetTop);
  }
  return {
    width: a,
    height: l,
    x: s,
    y: u
  };
}
function IJ(e10, t) {
  const n = ts(e10, true, t === "fixed"), o = n.top + e10.clientTop, r = n.left + e10.clientLeft, a = Xr(e10) ? Ks(e10) : zr(1), l = e10.clientWidth * a.x, s = e10.clientHeight * a.y, u = r * a.x, c = o * a.y;
  return {
    width: l,
    height: s,
    x: u,
    y: c
  };
}
function b_(e10, t, n) {
  let o;
  if (t === "viewport")
    o = $J(e10, n);
  else if (t === "document")
    o = OJ(na(e10));
  else if (yr(t))
    o = IJ(t, n);
  else {
    const r = YN(e10);
    o = {
      x: t.x - r.x,
      y: t.y - r.y,
      width: t.width,
      height: t.height
    };
  }
  return Cf(o);
}
function GN(e10, t) {
  const n = dl(e10);
  return n === t || !yr(n) || fi(n) ? false : br(n).position === "fixed" || GN(n, t);
}
function MJ(e10, t) {
  const n = t.get(e10);
  if (n)
    return n;
  let o = Du(e10, [], false).filter((s) => yr(s) && Ii(s) !== "body"), r = null;
  const a = br(e10).position === "fixed";
  let l = a ? dl(e10) : e10;
  for (; yr(l) && !fi(l); ) {
    const s = br(l), u = py(l);
    !u && s.position === "fixed" && (r = null), (a ? !u && !r : !u && s.position === "static" && !!r && ["absolute", "fixed"].includes(r.position) || gc(l) && !u && GN(e10, l)) ? o = o.filter((d) => d !== l) : r = s, l = dl(l);
  }
  return t.set(e10, o), o;
}
function PJ(e10) {
  let {
    element: t,
    boundary: n,
    rootBoundary: o,
    strategy: r
  } = e10;
  const l = [...n === "clippingAncestors" ? hp(t) ? [] : MJ(t, this._c) : [].concat(n), o], s = l[0], u = l.reduce((c, d) => {
    const f = b_(t, d, r);
    return c.top = jl(f.top, c.top), c.right = di(f.right, c.right), c.bottom = di(f.bottom, c.bottom), c.left = jl(f.left, c.left), c;
  }, b_(t, s, r));
  return {
    width: u.right - u.left,
    height: u.bottom - u.top,
    x: u.left,
    y: u.top
  };
}
function RJ(e10) {
  const {
    width: t,
    height: n
  } = UN(e10);
  return {
    width: t,
    height: n
  };
}
function AJ(e10, t, n) {
  const o = Xr(t), r = na(t), a = n === "fixed", l = ts(e10, true, a, t);
  let s = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const u = zr(0);
  function c() {
    u.x = my(r);
  }
  if (o || !o && !a)
    if ((Ii(t) !== "body" || gc(r)) && (s = mp(t)), o) {
      const v = ts(t, true, a, t);
      u.x = v.x + t.clientLeft, u.y = v.y + t.clientTop;
    } else r && c();
  a && !o && r && c();
  const d = r && !o && !a ? qN(r, s) : zr(0), f = l.left + s.scrollLeft - u.x - d.x, p = l.top + s.scrollTop - u.y - d.y;
  return {
    x: f,
    y: p,
    width: l.width,
    height: l.height
  };
}
function gv(e10) {
  return br(e10).position === "static";
}
function __(e10, t) {
  if (!Xr(e10) || br(e10).position === "fixed")
    return null;
  if (t)
    return t(e10);
  let n = e10.offsetParent;
  return na(e10) === n && (n = n.ownerDocument.body), n;
}
function XN(e10, t) {
  const n = Fo(e10);
  if (hp(e10))
    return n;
  if (!Xr(e10)) {
    let r = dl(e10);
    for (; r && !fi(r); ) {
      if (yr(r) && !gv(r))
        return r;
      r = dl(r);
    }
    return n;
  }
  let o = __(e10, t);
  for (; o && CJ(o) && gv(o); )
    o = __(o, t);
  return o && fi(o) && gv(o) && !py(o) ? n : o || EJ(e10) || n;
}
const LJ = async function(e10) {
  const t = this.getOffsetParent || XN, n = this.getDimensions, o = await n(e10.floating);
  return {
    reference: AJ(e10.reference, await t(e10.floating), e10.strategy),
    floating: {
      x: 0,
      y: 0,
      width: o.width,
      height: o.height
    }
  };
};
function xJ(e10) {
  return br(e10).direction === "rtl";
}
const DJ = {
  convertOffsetParentRelativeRectToViewportRelativeRect: NJ,
  getDocumentElement: na,
  getClippingRect: PJ,
  getOffsetParent: XN,
  getElementRects: LJ,
  getClientRects: TJ,
  getDimensions: RJ,
  getScale: Ks,
  isElement: yr,
  isRTL: xJ
};
function JN(e10, t) {
  return e10.x === t.x && e10.y === t.y && e10.width === t.width && e10.height === t.height;
}
function VJ(e10, t) {
  let n = null, o;
  const r = na(e10);
  function a() {
    var s;
    clearTimeout(o), (s = n) == null || s.disconnect(), n = null;
  }
  function l(s, u) {
    s === void 0 && (s = false), u === void 0 && (u = 1), a();
    const c = e10.getBoundingClientRect(), {
      left: d,
      top: f,
      width: p,
      height: v
    } = c;
    if (s || t(), !p || !v)
      return;
    const m = jc(f), h = jc(r.clientWidth - (d + p)), b = jc(r.clientHeight - (f + v)), g = jc(d), y = {
      rootMargin: -m + "px " + -h + "px " + -b + "px " + -g + "px",
      threshold: jl(0, di(1, u)) || 1
    };
    let _ = true;
    function C(E) {
      const T = E[0].intersectionRatio;
      if (T !== u) {
        if (!_)
          return l();
        T ? l(false, T) : o = setTimeout(() => {
          l(false, 1e-7);
        }, 1e3);
      }
      T === 1 && !JN(c, e10.getBoundingClientRect()) && l(), _ = false;
    }
    try {
      n = new IntersectionObserver(C, {
        ...y,
        // Handle <iframe>s
        root: r.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(C, y);
    }
    n.observe(e10);
  }
  return l(true), a;
}
function FJ(e10, t, n, o) {
  o === void 0 && (o = {});
  const {
    ancestorScroll: r = true,
    ancestorResize: a = true,
    elementResize: l = typeof ResizeObserver == "function",
    layoutShift: s = typeof IntersectionObserver == "function",
    animationFrame: u = false
  } = o, c = hy(e10), d = r || a ? [...c ? Du(c) : [], ...Du(t)] : [];
  d.forEach((g) => {
    r && g.addEventListener("scroll", n, {
      passive: true
    }), a && g.addEventListener("resize", n);
  });
  const f = c && s ? VJ(c, n) : null;
  let p = -1, v = null;
  l && (v = new ResizeObserver((g) => {
    let [w] = g;
    w && w.target === c && v && (v.unobserve(t), cancelAnimationFrame(p), p = requestAnimationFrame(() => {
      var y;
      (y = v) == null || y.observe(t);
    })), n();
  }), c && !u && v.observe(c), v.observe(t));
  let m, h = u ? ts(e10) : null;
  u && b();
  function b() {
    const g = ts(e10);
    h && !JN(h, g) && n(), h = g, m = requestAnimationFrame(b);
  }
  return n(), () => {
    var g;
    d.forEach((w) => {
      r && w.removeEventListener("scroll", n), a && w.removeEventListener("resize", n);
    }), f == null || f(), (g = v) == null || g.disconnect(), v = null, u && cancelAnimationFrame(m);
  };
}
const BJ = fy, ZN = _J, HJ = wJ, zJ = yJ, QN = gJ, eT = (e10, t, n) => {
  const o = /* @__PURE__ */ new Map(), r = {
    platform: DJ,
    ...n
  }, a = {
    ...r.platform,
    _c: o
  };
  return mJ(e10, t, {
    ...r,
    platform: a
  });
}, KJ = Oe({
  style: {
    type: ne([String, Object, Array]),
    default: () => ({})
  }
}), WJ = /* @__PURE__ */ j({
  name: "ElVisuallyHidden"
}), jJ = /* @__PURE__ */ j({
  ...WJ,
  props: KJ,
  setup(e10) {
    const t = e10, n = S(() => [
      t.style,
      {
        position: "absolute",
        border: 0,
        width: 1,
        height: 1,
        padding: 0,
        margin: -1,
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal"
      }
    ]);
    return (o, r) => (k(), x("span", vt(o.$attrs, { style: i(n) }), [
      J(o.$slots, "default")
    ], 16));
  }
});
var UJ = /* @__PURE__ */ $e(jJ, [["__file", "visual-hidden.vue"]]);
Oe({});
const YJ = (e10) => {
  if (!Et)
    return;
  if (!e10)
    return e10;
  const t = xn(e10);
  return t || (Ot(e10) ? t : e10);
}, qJ = ({
  middleware: e10,
  placement: t,
  strategy: n
}) => {
  const o = L(), r = L(), a = L(), l = L(), s = L({}), u = {
    x: a,
    y: l,
    placement: t,
    strategy: n,
    middlewareData: s
  }, c = async () => {
    if (!Et)
      return;
    const d = YJ(o), f = xn(r);
    if (!d || !f)
      return;
    const p = await eT(d, f, {
      placement: i(t),
      strategy: i(n),
      middleware: i(e10)
    });
    Qs(u).forEach((v) => {
      u[v].value = p[v];
    });
  };
  return dt(() => {
    Vn(() => {
      c();
    });
  }), {
    ...u,
    update: c,
    referenceRef: o,
    contentRef: r
  };
}, GJ = ({
  arrowRef: e10,
  padding: t
}) => ({
  name: "arrow",
  options: {
    element: e10,
    padding: t
  },
  fn(n) {
    const o = i(e10);
    return o ? QN({
      element: o,
      padding: t
    }).fn(n) : {};
  }
}), XJ = /* @__PURE__ */ j({
  name: "ElTooltipV2Content"
}), JJ = /* @__PURE__ */ j({
  ...XJ,
  props: { ...sy, ...FN },
  setup(e10) {
    const t = e10, { triggerRef: n, contentId: o } = Le(pp), r = L(t.placement), a = L(t.strategy), l = L(null), { referenceRef: s, contentRef: u, middlewareData: c, x: d, y: f, update: p } = qJ({
      placement: r,
      strategy: a,
      middleware: S(() => {
        const y = [ZN(t.offset)];
        return t.showArrow && y.push(GJ({
          arrowRef: l
        })), y;
      })
    }), v = Si().nextZIndex(), m = we("tooltip-v2"), h = S(() => r.value.split("-")[0]), b = S(() => ({
      position: i(a),
      top: `${i(f) || 0}px`,
      left: `${i(d) || 0}px`,
      zIndex: v
    })), g = S(() => {
      if (!t.showArrow)
        return {};
      const { arrow: y } = i(c);
      return {
        [`--${m.namespace.value}-tooltip-v2-arrow-x`]: `${y == null ? void 0 : y.x}px` || "",
        [`--${m.namespace.value}-tooltip-v2-arrow-y`]: `${y == null ? void 0 : y.y}px` || ""
      };
    }), w = S(() => [
      m.e("content"),
      m.is("dark", t.effect === "dark"),
      m.is(i(a)),
      t.contentClass
    ]);
    return ge(l, () => p()), ge(() => t.placement, (y) => r.value = y), dt(() => {
      ge(() => t.reference || n.value, (y) => {
        s.value = y || void 0;
      }, {
        immediate: true
      });
    }), yt(HN, { arrowRef: l }), (y, _) => (k(), x("div", {
      ref_key: "contentRef",
      ref: u,
      style: ze(i(b)),
      "data-tooltip-v2-root": ""
    }, [
      y.nowrap ? ee("v-if", true) : (k(), x("div", {
        key: 0,
        "data-side": i(h),
        class: I(i(w))
      }, [
        J(y.$slots, "default", {
          contentStyle: i(b),
          contentClass: i(w)
        }),
        W(i(UJ), {
          id: i(o),
          role: "tooltip"
        }, {
          default: H(() => [
            y.ariaLabel ? (k(), x(Ie, { key: 0 }, [
              Ze(_e(y.ariaLabel), 1)
            ], 64)) : J(y.$slots, "default", { key: 1 })
          ]),
          _: 3
        }, 8, ["id"]),
        J(y.$slots, "arrow", {
          style: ze(i(g)),
          side: i(h)
        })
      ], 10, ["data-side"]))
    ], 4));
  }
});
var w_ = /* @__PURE__ */ $e(JJ, [["__file", "content.vue"]]);
const ZJ = Oe({
  setRef: {
    type: ne(Function),
    required: true
  },
  onlyChild: Boolean
});
var QJ = /* @__PURE__ */ j({
  props: ZJ,
  setup(e10, {
    slots: t
  }) {
    const n = L(), o = ip(n, (r) => {
      r ? e10.setRef(r.nextElementSibling) : e10.setRef(null);
    });
    return () => {
      var r;
      const [a] = ((r = t.default) == null ? void 0 : r.call(t)) || [], l = e10.onlyChild ? c5(a.children) : a.children;
      return W(Ie, {
        ref: o
      }, [l]);
    };
  }
});
const eZ = /* @__PURE__ */ j({
  name: "ElTooltipV2Trigger"
}), tZ = /* @__PURE__ */ j({
  ...eZ,
  props: {
    ...FN,
    ...uy
  },
  setup(e10) {
    const t = e10, { onClose: n, onOpen: o, onDelayOpen: r, triggerRef: a, contentId: l } = Le(pp);
    let s = false;
    const u = (w) => {
      a.value = w;
    }, c = () => {
      s = false;
    }, d = dn(t.onMouseEnter, r), f = dn(t.onMouseLeave, n), p = dn(t.onMouseDown, () => {
      n(), s = true, document.addEventListener("mouseup", c, { once: true });
    }), v = dn(t.onFocus, () => {
      s || o();
    }), m = dn(t.onBlur, n), h = dn(t.onClick, (w) => {
      w.detail === 0 && n();
    }), b = {
      blur: m,
      click: h,
      focus: v,
      mousedown: p,
      mouseenter: d,
      mouseleave: f
    }, g = (w, y, _) => {
      w && Object.entries(y).forEach(([C, E]) => {
        w[_](C, E);
      });
    };
    return ge(a, (w, y) => {
      g(w, b, "addEventListener"), g(y, b, "removeEventListener"), w && w.setAttribute("aria-describedby", l.value);
    }), jt(() => {
      g(a.value, b, "removeEventListener"), document.removeEventListener("mouseup", c);
    }), (w, y) => w.nowrap ? (k(), ae(i(QJ), {
      key: 0,
      "set-ref": u,
      "only-child": ""
    }, {
      default: H(() => [
        J(w.$slots, "default")
      ]),
      _: 3
    })) : (k(), x("button", vt({
      key: 1,
      ref_key: "triggerRef",
      ref: a
    }, w.$attrs), [
      J(w.$slots, "default")
    ], 16));
  }
});
var nZ = /* @__PURE__ */ $e(tZ, [["__file", "trigger.vue"]]);
const oZ = /* @__PURE__ */ j({
  name: "ElTooltipV2"
}), rZ = /* @__PURE__ */ j({
  ...oZ,
  props: oJ,
  setup(e10) {
    const n = Tn(e10), o = It(sr(n, Object.keys(ly))), r = It(sr(n, Object.keys(sy))), a = It(sr(n, Object.keys(iy))), l = It(sr(n, Object.keys(uy)));
    return (s, u) => (k(), ae(lJ, Ao(jr(a)), {
      default: H(({ open: c }) => [
        W(nZ, vt(l, { nowrap: "" }), {
          default: H(() => [
            J(s.$slots, "trigger")
          ]),
          _: 3
        }, 16),
        W(i(Ti), {
          to: s.to,
          disabled: !s.teleported
        }, {
          default: H(() => [
            s.fullTransition ? (k(), ae(Rn, Ao(vt({ key: 0 }, s.transitionProps)), {
              default: H(() => [
                s.alwaysOn || c ? (k(), ae(w_, Ao(vt({ key: 0 }, r)), {
                  arrow: H(({ style: d, side: f }) => [
                    s.showArrow ? (k(), ae(m_, vt({ key: 0 }, o, {
                      style: d,
                      side: f
                    }), null, 16, ["style", "side"])) : ee("v-if", true)
                  ]),
                  default: H(() => [
                    J(s.$slots, "default")
                  ]),
                  _: 3
                }, 16)) : ee("v-if", true)
              ]),
              _: 2
            }, 1040)) : (k(), x(Ie, { key: 1 }, [
              s.alwaysOn || c ? (k(), ae(w_, Ao(vt({ key: 0 }, r)), {
                arrow: H(({ style: d, side: f }) => [
                  s.showArrow ? (k(), ae(m_, vt({ key: 0 }, o, {
                    style: d,
                    side: f
                  }), null, 16, ["style", "side"])) : ee("v-if", true)
                ]),
                default: H(() => [
                  J(s.$slots, "default")
                ]),
                _: 3
              }, 16)) : ee("v-if", true)
            ], 64))
          ]),
          _: 2
        }, 1032, ["to", "disabled"])
      ]),
      _: 3
    }, 16));
  }
});
var aZ = /* @__PURE__ */ $e(rZ, [["__file", "tooltip.vue"]]);
const lZ = ut(aZ), tT = "left-check-change", nT = "right-check-change", Os = Oe({
  data: {
    type: ne(Array),
    default: () => []
  },
  titles: {
    type: ne(Array),
    default: () => []
  },
  buttonTexts: {
    type: ne(Array),
    default: () => []
  },
  filterPlaceholder: String,
  filterMethod: {
    type: ne(Function)
  },
  leftDefaultChecked: {
    type: ne(Array),
    default: () => []
  },
  rightDefaultChecked: {
    type: ne(Array),
    default: () => []
  },
  renderContent: {
    type: ne(Function)
  },
  modelValue: {
    type: ne(Array),
    default: () => []
  },
  format: {
    type: ne(Object),
    default: () => ({})
  },
  filterable: Boolean,
  props: {
    type: ne(Object),
    default: () => rn({
      label: "label",
      key: "key",
      disabled: "disabled"
    })
  },
  targetOrder: {
    type: String,
    values: ["original", "push", "unshift"],
    default: "original"
  },
  validateEvent: {
    type: Boolean,
    default: true
  }
}), Vh = (e10, t) => [e10, t].every(Se) || Se(e10) && Nn(t), sZ = {
  [gt]: (e10, t, n) => [e10, n].every(Se) && ["left", "right"].includes(t),
  [nt]: (e10) => Se(e10),
  [tT]: Vh,
  [nT]: Vh
}, Fh = "checked-change", iZ = Oe({
  data: Os.data,
  optionRender: {
    type: ne(Function)
  },
  placeholder: String,
  title: String,
  filterable: Boolean,
  format: Os.format,
  filterMethod: Os.filterMethod,
  defaultChecked: Os.leftDefaultChecked,
  props: Os.props
}), uZ = {
  [Fh]: Vh
}, yc = (e10) => {
  const t = {
    label: "label",
    key: "key",
    disabled: "disabled"
  };
  return S(() => ({
    ...t,
    ...e10.props
  }));
}, cZ = (e10, t, n) => {
  const o = yc(e10), r = S(() => e10.data.filter((d) => Fe(e10.filterMethod) ? e10.filterMethod(t.query, d) : String(d[o.value.label] || d[o.value.key]).toLowerCase().includes(t.query.toLowerCase()))), a = S(() => r.value.filter((d) => !d[o.value.disabled])), l = S(() => {
    const d = t.checked.length, f = e10.data.length, { noChecked: p, hasChecked: v } = e10.format;
    return p && v ? d > 0 ? v.replace(/\${checked}/g, d.toString()).replace(/\${total}/g, f.toString()) : p.replace(/\${total}/g, f.toString()) : `${d}/${f}`;
  }), s = S(() => {
    const d = t.checked.length;
    return d > 0 && d < a.value.length;
  }), u = () => {
    const d = a.value.map((f) => f[o.value.key]);
    t.allChecked = d.length > 0 && d.every((f) => t.checked.includes(f));
  }, c = (d) => {
    t.checked = d ? a.value.map((f) => f[o.value.key]) : [];
  };
  return ge(() => t.checked, (d, f) => {
    if (u(), t.checkChangeByUser) {
      const p = d.concat(f).filter((v) => !d.includes(v) || !f.includes(v));
      n(Fh, d, p);
    } else
      n(Fh, d), t.checkChangeByUser = true;
  }), ge(a, () => {
    u();
  }), ge(() => e10.data, () => {
    const d = [], f = r.value.map((p) => p[o.value.key]);
    t.checked.forEach((p) => {
      f.includes(p) && d.push(p);
    }), t.checkChangeByUser = false, t.checked = d;
  }), ge(() => e10.defaultChecked, (d, f) => {
    if (f && d.length === f.length && d.every((m) => f.includes(m)))
      return;
    const p = [], v = a.value.map((m) => m[o.value.key]);
    d.forEach((m) => {
      v.includes(m) && p.push(m);
    }), t.checkChangeByUser = false, t.checked = p;
  }, {
    immediate: true
  }), {
    filteredData: r,
    checkableData: a,
    checkedSummary: l,
    isIndeterminate: s,
    updateAllChecked: u,
    handleAllCheckedChange: c
  };
}, dZ = /* @__PURE__ */ j({
  name: "ElTransferPanel"
}), fZ = /* @__PURE__ */ j({
  ...dZ,
  props: iZ,
  emits: uZ,
  setup(e10, { expose: t, emit: n }) {
    const o = e10, r = En(), a = ({ option: y }) => y, { t: l } = kt(), s = we("transfer"), u = It({
      checked: [],
      allChecked: false,
      query: "",
      checkChangeByUser: true
    }), c = yc(o), {
      filteredData: d,
      checkedSummary: f,
      isIndeterminate: p,
      handleAllCheckedChange: v
    } = cZ(o, u, n), m = S(() => !Ro(u.query) && Ro(d.value)), h = S(() => !Ro(r.default()[0].children)), { checked: b, allChecked: g, query: w } = Tn(u);
    return t({
      query: w
    }), (y, _) => (k(), x("div", {
      class: I(i(s).b("panel"))
    }, [
      B("p", {
        class: I(i(s).be("panel", "header"))
      }, [
        W(i(er), {
          modelValue: i(g),
          "onUpdate:modelValue": (C) => Ot(g) ? g.value = C : null,
          indeterminate: i(p),
          "validate-event": false,
          onChange: i(v)
        }, {
          default: H(() => [
            Ze(_e(y.title) + " ", 1),
            B("span", null, _e(i(f)), 1)
          ]),
          _: 1
        }, 8, ["modelValue", "onUpdate:modelValue", "indeterminate", "onChange"])
      ], 2),
      B("div", {
        class: I([i(s).be("panel", "body"), i(s).is("with-footer", i(h))])
      }, [
        y.filterable ? (k(), ae(i(eo), {
          key: 0,
          modelValue: i(w),
          "onUpdate:modelValue": (C) => Ot(w) ? w.value = C : null,
          class: I(i(s).be("panel", "filter")),
          size: "default",
          placeholder: y.placeholder,
          "prefix-icon": i(k8),
          clearable: "",
          "validate-event": false
        }, null, 8, ["modelValue", "onUpdate:modelValue", "class", "placeholder", "prefix-icon"])) : ee("v-if", true),
        lt(W(i(R2), {
          modelValue: i(b),
          "onUpdate:modelValue": (C) => Ot(b) ? b.value = C : null,
          "validate-event": false,
          class: I([i(s).is("filterable", y.filterable), i(s).be("panel", "list")])
        }, {
          default: H(() => [
            (k(true), x(Ie, null, st(i(d), (C) => (k(), ae(i(er), {
              key: C[i(c).key],
              class: I(i(s).be("panel", "item")),
              value: C[i(c).key],
              disabled: C[i(c).disabled],
              "validate-event": false
            }, {
              default: H(() => {
                var E;
                return [
                  W(a, {
                    option: (E = y.optionRender) == null ? void 0 : E.call(y, C)
                  }, null, 8, ["option"])
                ];
              }),
              _: 2
            }, 1032, ["class", "value", "disabled"]))), 128))
          ]),
          _: 1
        }, 8, ["modelValue", "onUpdate:modelValue", "class"]), [
          [Nt, !i(m) && !i(Ro)(y.data)]
        ]),
        lt(B("div", {
          class: I(i(s).be("panel", "empty"))
        }, [
          J(y.$slots, "empty", {}, () => [
            Ze(_e(i(m) ? i(l)("el.transfer.noMatch") : i(l)("el.transfer.noData")), 1)
          ])
        ], 2), [
          [Nt, i(m) || i(Ro)(y.data)]
        ])
      ], 2),
      i(h) ? (k(), x("p", {
        key: 0,
        class: I(i(s).be("panel", "footer"))
      }, [
        J(y.$slots, "default")
      ], 2)) : ee("v-if", true)
    ], 2));
  }
});
var C_ = /* @__PURE__ */ $e(fZ, [["__file", "transfer-panel.vue"]]);
const pZ = (e10) => {
  const t = yc(e10), n = S(() => e10.data.reduce((a, l) => (a[l[t.value.key]] = l) && a, {})), o = S(() => e10.data.filter((a) => !e10.modelValue.includes(a[t.value.key]))), r = S(() => e10.targetOrder === "original" ? e10.data.filter((a) => e10.modelValue.includes(a[t.value.key])) : e10.modelValue.reduce((a, l) => {
    const s = n.value[l];
    return s && a.push(s), a;
  }, []));
  return {
    sourceData: o,
    targetData: r
  };
}, vZ = (e10, t, n) => {
  const o = yc(e10), r = (s, u, c) => {
    n(nt, s), n(gt, s, u, c);
  };
  return {
    addToLeft: () => {
      const s = e10.modelValue.slice();
      t.rightChecked.forEach((u) => {
        const c = s.indexOf(u);
        c > -1 && s.splice(c, 1);
      }), r(s, "left", t.rightChecked);
    },
    addToRight: () => {
      let s = e10.modelValue.slice();
      const u = e10.data.filter((c) => {
        const d = c[o.value.key];
        return t.leftChecked.includes(d) && !e10.modelValue.includes(d);
      }).map((c) => c[o.value.key]);
      s = e10.targetOrder === "unshift" ? u.concat(s) : s.concat(u), e10.targetOrder === "original" && (s = e10.data.filter((c) => s.includes(c[o.value.key])).map((c) => c[o.value.key])), r(s, "right", t.leftChecked);
    }
  };
}, hZ = (e10, t) => ({
  onSourceCheckedChange: (r, a) => {
    e10.leftChecked = r, a && t(tT, r, a);
  },
  onTargetCheckedChange: (r, a) => {
    e10.rightChecked = r, a && t(nT, r, a);
  }
}), mZ = /* @__PURE__ */ j({
  name: "ElTransfer"
}), gZ = /* @__PURE__ */ j({
  ...mZ,
  props: Os,
  emits: sZ,
  setup(e10, { expose: t, emit: n }) {
    const o = e10, r = En(), { t: a } = kt(), l = we("transfer"), { formItem: s } = Yn(), u = It({
      leftChecked: [],
      rightChecked: []
    }), c = yc(o), { sourceData: d, targetData: f } = pZ(o), { onSourceCheckedChange: p, onTargetCheckedChange: v } = hZ(u, n), { addToLeft: m, addToRight: h } = vZ(o, u, n), b = L(), g = L(), w = (O) => {
      switch (O) {
        case "left":
          b.value.query = "";
          break;
        case "right":
          g.value.query = "";
          break;
      }
    }, y = S(() => o.buttonTexts.length === 2), _ = S(() => o.titles[0] || a("el.transfer.titles.0")), C = S(() => o.titles[1] || a("el.transfer.titles.1")), E = S(() => o.filterPlaceholder || a("el.transfer.filterPlaceholder"));
    ge(() => o.modelValue, () => {
      var O;
      o.validateEvent && ((O = s == null ? void 0 : s.validate) == null || O.call(s, "change").catch((N) => _t(N)));
    });
    const T = S(() => (O) => {
      var N;
      if (o.renderContent)
        return o.renderContent(Ke, O);
      const $ = (((N = r.default) == null ? void 0 : N.call(r, { option: O })) || []).filter((R) => R.type !== tn);
      return $.length ? $ : Ke("span", O[c.value.label] || O[c.value.key]);
    });
    return t({
      clearQuery: w,
      leftPanel: b,
      rightPanel: g
    }), (O, N) => (k(), x("div", {
      class: I(i(l).b())
    }, [
      W(C_, {
        ref_key: "leftPanel",
        ref: b,
        data: i(d),
        "option-render": i(T),
        placeholder: i(E),
        title: i(_),
        filterable: O.filterable,
        format: O.format,
        "filter-method": O.filterMethod,
        "default-checked": O.leftDefaultChecked,
        props: o.props,
        onCheckedChange: i(p)
      }, {
        empty: H(() => [
          J(O.$slots, "left-empty")
        ]),
        default: H(() => [
          J(O.$slots, "left-footer")
        ]),
        _: 3
      }, 8, ["data", "option-render", "placeholder", "title", "filterable", "format", "filter-method", "default-checked", "props", "onCheckedChange"]),
      B("div", {
        class: I(i(l).e("buttons"))
      }, [
        W(i(Mn), {
          type: "primary",
          class: I([i(l).e("button"), i(l).is("with-texts", i(y))]),
          disabled: i(Ro)(u.rightChecked),
          onClick: i(m)
        }, {
          default: H(() => [
            W(i(Be), null, {
              default: H(() => [
                W(i(wa))
              ]),
              _: 1
            }),
            i(St)(O.buttonTexts[0]) ? ee("v-if", true) : (k(), x("span", { key: 0 }, _e(O.buttonTexts[0]), 1))
          ]),
          _: 1
        }, 8, ["class", "disabled", "onClick"]),
        W(i(Mn), {
          type: "primary",
          class: I([i(l).e("button"), i(l).is("with-texts", i(y))]),
          disabled: i(Ro)(u.leftChecked),
          onClick: i(h)
        }, {
          default: H(() => [
            i(St)(O.buttonTexts[1]) ? ee("v-if", true) : (k(), x("span", { key: 0 }, _e(O.buttonTexts[1]), 1)),
            W(i(Be), null, {
              default: H(() => [
                W(i(oo))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["class", "disabled", "onClick"])
      ], 2),
      W(C_, {
        ref_key: "rightPanel",
        ref: g,
        data: i(f),
        "option-render": i(T),
        placeholder: i(E),
        filterable: O.filterable,
        format: O.format,
        "filter-method": O.filterMethod,
        title: i(C),
        "default-checked": O.rightDefaultChecked,
        props: o.props,
        onCheckedChange: i(v)
      }, {
        empty: H(() => [
          J(O.$slots, "right-empty")
        ]),
        default: H(() => [
          J(O.$slots, "right-footer")
        ]),
        _: 3
      }, 8, ["data", "option-render", "placeholder", "filterable", "format", "filter-method", "title", "default-checked", "props", "onCheckedChange"])
    ], 2));
  }
});
var yZ = /* @__PURE__ */ $e(gZ, [["__file", "transfer.vue"]]);
const bZ = ut(yZ), Ws = "$treeNodeId", E_ = function(e10, t) {
  !t || t[Ws] || Object.defineProperty(t, Ws, {
    value: e10.id,
    enumerable: false,
    configurable: false,
    writable: false
  });
}, gy = (e10, t) => t == null ? void 0 : t[e10 || Ws], Bh = (e10, t, n) => {
  const o = e10.value.currentNode;
  n();
  const r = e10.value.currentNode;
  o !== r && t("current-change", r ? r.data : null, r);
}, Hh = (e10) => {
  let t = true, n = true, o = true;
  for (let r = 0, a = e10.length; r < a; r++) {
    const l = e10[r];
    (l.checked !== true || l.indeterminate) && (t = false, l.disabled || (o = false)), (l.checked !== false || l.indeterminate) && (n = false);
  }
  return { all: t, none: n, allWithoutDisable: o, half: !t && !n };
}, Yi = function(e10) {
  if (e10.childNodes.length === 0 || e10.loading)
    return;
  const { all: t, none: n, half: o } = Hh(e10.childNodes);
  t ? (e10.checked = true, e10.indeterminate = false) : o ? (e10.checked = false, e10.indeterminate = true) : n && (e10.checked = false, e10.indeterminate = false);
  const r = e10.parent;
  !r || r.level === 0 || e10.store.checkStrictly || Yi(r);
}, Uc = function(e10, t) {
  const n = e10.store.props, o = e10.data || {}, r = n[t];
  if (Fe(r))
    return r(o, e10);
  if (Ve(r))
    return o[r];
  if (St(r)) {
    const a = o[t];
    return St(a) ? "" : a;
  }
};
let _Z = 0, zh = class Td {
  constructor(t) {
    this.id = _Z++, this.text = null, this.checked = false, this.indeterminate = false, this.data = null, this.expanded = false, this.parent = null, this.visible = true, this.isCurrent = false, this.canFocus = false;
    for (const n in t)
      Tt(t, n) && (this[n] = t[n]);
    this.level = 0, this.loaded = false, this.childNodes = [], this.loading = false, this.parent && (this.level = this.parent.level + 1);
  }
  initialize() {
    const t = this.store;
    if (!t)
      throw new Error("[Node]store is required!");
    t.registerNode(this);
    const n = t.props;
    if (n && typeof n.isLeaf < "u") {
      const a = Uc(this, "isLeaf");
      Vt(a) && (this.isLeafByUser = a);
    }
    if (t.lazy !== true && this.data ? (this.setData(this.data), t.defaultExpandAll && (this.expanded = true, this.canFocus = true)) : this.level > 0 && t.lazy && t.defaultExpandAll && !this.isLeafByUser && this.expand(), Se(this.data) || E_(this, this.data), !this.data)
      return;
    const o = t.defaultExpandedKeys, r = t.key;
    r && o && o.includes(this.key) && this.expand(null, t.autoExpandParent), r && t.currentNodeKey !== void 0 && this.key === t.currentNodeKey && (t.currentNode = this, t.currentNode.isCurrent = true), t.lazy && t._initDefaultCheckedNode(this), this.updateLeafState(), this.parent && (this.level === 1 || this.parent.expanded === true) && (this.canFocus = true);
  }
  setData(t) {
    Se(t) || E_(this, t), this.data = t, this.childNodes = [];
    let n;
    this.level === 0 && Se(this.data) ? n = this.data : n = Uc(this, "children") || [];
    for (let o = 0, r = n.length; o < r; o++)
      this.insertChild({ data: n[o] });
  }
  get label() {
    return Uc(this, "label");
  }
  get key() {
    const t = this.store.key;
    return this.data ? this.data[t] : null;
  }
  get disabled() {
    return Uc(this, "disabled");
  }
  get nextSibling() {
    const t = this.parent;
    if (t) {
      const n = t.childNodes.indexOf(this);
      if (n > -1)
        return t.childNodes[n + 1];
    }
    return null;
  }
  get previousSibling() {
    const t = this.parent;
    if (t) {
      const n = t.childNodes.indexOf(this);
      if (n > -1)
        return n > 0 ? t.childNodes[n - 1] : null;
    }
    return null;
  }
  contains(t, n = true) {
    return (this.childNodes || []).some((o) => o === t || n && o.contains(t));
  }
  remove() {
    const t = this.parent;
    t && t.removeChild(this);
  }
  insertChild(t, n, o) {
    if (!t)
      throw new Error("InsertChild error: child is required.");
    if (!(t instanceof Td)) {
      if (!o) {
        const r = this.getChildren(true);
        r.includes(t.data) || (St(n) || n < 0 ? r.push(t.data) : r.splice(n, 0, t.data));
      }
      Object.assign(t, {
        parent: this,
        store: this.store
      }), t = It(new Td(t)), t instanceof Td && t.initialize();
    }
    t.level = this.level + 1, St(n) || n < 0 ? this.childNodes.push(t) : this.childNodes.splice(n, 0, t), this.updateLeafState();
  }
  insertBefore(t, n) {
    let o;
    n && (o = this.childNodes.indexOf(n)), this.insertChild(t, o);
  }
  insertAfter(t, n) {
    let o;
    n && (o = this.childNodes.indexOf(n), o !== -1 && (o += 1)), this.insertChild(t, o);
  }
  removeChild(t) {
    const n = this.getChildren() || [], o = n.indexOf(t.data);
    o > -1 && n.splice(o, 1);
    const r = this.childNodes.indexOf(t);
    r > -1 && (this.store && this.store.deregisterNode(t), t.parent = null, this.childNodes.splice(r, 1)), this.updateLeafState();
  }
  removeChildByData(t) {
    let n = null;
    for (let o = 0; o < this.childNodes.length; o++)
      if (this.childNodes[o].data === t) {
        n = this.childNodes[o];
        break;
      }
    n && this.removeChild(n);
  }
  expand(t, n) {
    const o = () => {
      if (n) {
        let r = this.parent;
        for (; r.level > 0; )
          r.expanded = true, r = r.parent;
      }
      this.expanded = true, t && t(), this.childNodes.forEach((r) => {
        r.canFocus = true;
      });
    };
    this.shouldLoadData() ? this.loadData((r) => {
      Se(r) && (this.checked ? this.setChecked(true, true) : this.store.checkStrictly || Yi(this), o());
    }) : o();
  }
  doCreateChildren(t, n = {}) {
    t.forEach((o) => {
      this.insertChild(Object.assign({ data: o }, n), void 0, true);
    });
  }
  collapse() {
    this.expanded = false, this.childNodes.forEach((t) => {
      t.canFocus = false;
    });
  }
  shouldLoadData() {
    return this.store.lazy === true && this.store.load && !this.loaded;
  }
  updateLeafState() {
    if (this.store.lazy === true && this.loaded !== true && typeof this.isLeafByUser < "u") {
      this.isLeaf = this.isLeafByUser;
      return;
    }
    const t = this.childNodes;
    if (!this.store.lazy || this.store.lazy === true && this.loaded === true) {
      this.isLeaf = !t || t.length === 0;
      return;
    }
    this.isLeaf = false;
  }
  setChecked(t, n, o, r) {
    if (this.indeterminate = t === "half", this.checked = t === true, this.store.checkStrictly)
      return;
    if (!(this.shouldLoadData() && !this.store.checkDescendants)) {
      const { all: l, allWithoutDisable: s } = Hh(this.childNodes);
      !this.isLeaf && !l && s && (this.checked = false, t = false);
      const u = () => {
        if (n) {
          const c = this.childNodes;
          for (let p = 0, v = c.length; p < v; p++) {
            const m = c[p];
            r = r || t !== false;
            const h = m.disabled ? m.checked : r;
            m.setChecked(h, n, true, r);
          }
          const { half: d, all: f } = Hh(c);
          f || (this.checked = f, this.indeterminate = d);
        }
      };
      if (this.shouldLoadData()) {
        this.loadData(() => {
          u(), Yi(this);
        }, {
          checked: t !== false
        });
        return;
      } else
        u();
    }
    const a = this.parent;
    !a || a.level === 0 || o || Yi(a);
  }
  getChildren(t = false) {
    if (this.level === 0)
      return this.data;
    const n = this.data;
    if (!n)
      return null;
    const o = this.store.props;
    let r = "children";
    return o && (r = o.children || "children"), St(n[r]) && (n[r] = null), t && !n[r] && (n[r] = []), n[r];
  }
  updateChildren() {
    const t = this.getChildren() || [], n = this.childNodes.map((a) => a.data), o = {}, r = [];
    t.forEach((a, l) => {
      const s = a[Ws];
      !!s && n.findIndex((c) => c[Ws] === s) >= 0 ? o[s] = { index: l, data: a } : r.push({ index: l, data: a });
    }), this.store.lazy || n.forEach((a) => {
      o[a[Ws]] || this.removeChildByData(a);
    }), r.forEach(({ index: a, data: l }) => {
      this.insertChild({ data: l }, a);
    }), this.updateLeafState();
  }
  loadData(t, n = {}) {
    if (this.store.lazy === true && this.store.load && !this.loaded && (!this.loading || Object.keys(n).length)) {
      this.loading = true;
      const o = (a) => {
        this.childNodes = [], this.doCreateChildren(a, n), this.loaded = true, this.loading = false, this.updateLeafState(), t && t.call(this, a);
      }, r = () => {
        this.loading = false;
      };
      this.store.load(this, o, r);
    } else
      t && t.call(this);
  }
  eachNode(t) {
    const n = [this];
    for (; n.length; ) {
      const o = n.shift();
      n.unshift(...o.childNodes), t(o);
    }
  }
  reInitChecked() {
    this.store.checkStrictly || Yi(this);
  }
};
class wZ {
  constructor(t) {
    this.currentNode = null, this.currentNodeKey = null;
    for (const n in t)
      Tt(t, n) && (this[n] = t[n]);
    this.nodesMap = {};
  }
  initialize() {
    if (this.root = new zh({
      data: this.data,
      store: this
    }), this.root.initialize(), this.lazy && this.load) {
      const t = this.load;
      t(this.root, (n) => {
        this.root.doCreateChildren(n), this._initDefaultCheckedNodes();
      });
    } else
      this._initDefaultCheckedNodes();
  }
  filter(t) {
    const n = this.filterNodeMethod, o = this.lazy, r = async function(a) {
      const l = a.root ? a.root.childNodes : a.childNodes;
      for (const [s, u] of l.entries())
        u.visible = n.call(u, t, u.data, u), s % 80 === 0 && s > 0 && await He(), await r(u);
      if (!a.visible && l.length) {
        let s = true;
        s = !l.some((u) => u.visible), a.root ? a.root.visible = s === false : a.visible = s === false;
      }
      t && a.visible && !a.isLeaf && (!o || a.loaded) && a.expand();
    };
    r(this);
  }
  setData(t) {
    t !== this.root.data ? (this.nodesMap = {}, this.root.setData(t), this._initDefaultCheckedNodes(), this.setCurrentNodeKey(this.currentNodeKey)) : this.root.updateChildren();
  }
  getNode(t) {
    if (t instanceof zh)
      return t;
    const n = at(t) ? gy(this.key, t) : t;
    return this.nodesMap[n] || null;
  }
  insertBefore(t, n) {
    const o = this.getNode(n);
    o.parent.insertBefore({ data: t }, o);
  }
  insertAfter(t, n) {
    const o = this.getNode(n);
    o.parent.insertAfter({ data: t }, o);
  }
  remove(t) {
    const n = this.getNode(t);
    n && n.parent && (n === this.currentNode && (this.currentNode = null), n.parent.removeChild(n));
  }
  append(t, n) {
    const o = So(n) ? this.root : this.getNode(n);
    o && o.insertChild({ data: t });
  }
  _initDefaultCheckedNodes() {
    const t = this.defaultCheckedKeys || [], n = this.nodesMap;
    t.forEach((o) => {
      const r = n[o];
      r && r.setChecked(true, !this.checkStrictly);
    });
  }
  _initDefaultCheckedNode(t) {
    (this.defaultCheckedKeys || []).includes(t.key) && t.setChecked(true, !this.checkStrictly);
  }
  setDefaultCheckedKey(t) {
    t !== this.defaultCheckedKeys && (this.defaultCheckedKeys = t, this._initDefaultCheckedNodes());
  }
  registerNode(t) {
    const n = this.key;
    !t || !t.data || (n ? t.key !== void 0 && (this.nodesMap[t.key] = t) : this.nodesMap[t.id] = t);
  }
  deregisterNode(t) {
    !this.key || !t || !t.data || (t.childNodes.forEach((o) => {
      this.deregisterNode(o);
    }), delete this.nodesMap[t.key]);
  }
  getCheckedNodes(t = false, n = false) {
    const o = [], r = function(a) {
      (a.root ? a.root.childNodes : a.childNodes).forEach((s) => {
        (s.checked || n && s.indeterminate) && (!t || t && s.isLeaf) && o.push(s.data), r(s);
      });
    };
    return r(this), o;
  }
  getCheckedKeys(t = false) {
    return this.getCheckedNodes(t).map((n) => (n || {})[this.key]);
  }
  getHalfCheckedNodes() {
    const t = [], n = function(o) {
      (o.root ? o.root.childNodes : o.childNodes).forEach((a) => {
        a.indeterminate && t.push(a.data), n(a);
      });
    };
    return n(this), t;
  }
  getHalfCheckedKeys() {
    return this.getHalfCheckedNodes().map((t) => (t || {})[this.key]);
  }
  _getAllNodes() {
    const t = [], n = this.nodesMap;
    for (const o in n)
      Tt(n, o) && t.push(n[o]);
    return t;
  }
  updateChildren(t, n) {
    const o = this.nodesMap[t];
    if (!o)
      return;
    const r = o.childNodes;
    for (let a = r.length - 1; a >= 0; a--) {
      const l = r[a];
      this.remove(l.data);
    }
    for (let a = 0, l = n.length; a < l; a++) {
      const s = n[a];
      this.append(s, o.data);
    }
  }
  _setCheckedKeys(t, n = false, o) {
    const r = this._getAllNodes().sort((u, c) => u.level - c.level), a = /* @__PURE__ */ Object.create(null), l = Object.keys(o);
    r.forEach((u) => u.setChecked(false, false));
    const s = (u) => {
      u.childNodes.forEach((c) => {
        var d;
        a[c.data[t]] = true, (d = c.childNodes) != null && d.length && s(c);
      });
    };
    for (let u = 0, c = r.length; u < c; u++) {
      const d = r[u], f = d.data[t].toString();
      if (!l.includes(f)) {
        d.checked && !a[f] && d.setChecked(false, false);
        continue;
      }
      if (d.childNodes.length && s(d), d.isLeaf || this.checkStrictly) {
        d.setChecked(true, false);
        continue;
      }
      if (d.setChecked(true, true), n) {
        d.setChecked(false, false);
        const v = function(m) {
          m.childNodes.forEach((b) => {
            b.isLeaf || b.setChecked(false, false), v(b);
          });
        };
        v(d);
      }
    }
  }
  setCheckedNodes(t, n = false) {
    const o = this.key, r = {};
    t.forEach((a) => {
      r[(a || {})[o]] = true;
    }), this._setCheckedKeys(o, n, r);
  }
  setCheckedKeys(t, n = false) {
    this.defaultCheckedKeys = t;
    const o = this.key, r = {};
    t.forEach((a) => {
      r[a] = true;
    }), this._setCheckedKeys(o, n, r);
  }
  setDefaultExpandedKeys(t) {
    t = t || [], this.defaultExpandedKeys = t, t.forEach((n) => {
      const o = this.getNode(n);
      o && o.expand(null, this.autoExpandParent);
    });
  }
  setChecked(t, n, o) {
    const r = this.getNode(t);
    r && r.setChecked(!!n, o);
  }
  getCurrentNode() {
    return this.currentNode;
  }
  setCurrentNode(t) {
    const n = this.currentNode;
    n && (n.isCurrent = false), this.currentNode = t, this.currentNode.isCurrent = true;
  }
  setUserCurrentNode(t, n = true) {
    const o = t[this.key], r = this.nodesMap[o];
    this.setCurrentNode(r), n && this.currentNode.level > 1 && this.currentNode.parent.expand(null, true);
  }
  setCurrentNodeKey(t, n = true) {
    if (this.currentNodeKey = t, So(t)) {
      this.currentNode && (this.currentNode.isCurrent = false), this.currentNode = null;
      return;
    }
    const o = this.getNode(t);
    o && (this.setCurrentNode(o), n && this.currentNode.level > 1 && this.currentNode.parent.expand(null, true));
  }
}
const yy = "RootTree", oT = "NodeInstance", S_ = "TreeNodeMap", CZ = /* @__PURE__ */ j({
  name: "ElTreeNodeContent",
  props: {
    node: {
      type: Object,
      required: true
    },
    renderContent: Function
  },
  setup(e10) {
    const t = we("tree"), n = Le(oT), o = Le(yy);
    return () => {
      const r = e10.node, { data: a, store: l } = r;
      return e10.renderContent ? e10.renderContent(Ke, { _self: n, node: r, data: a, store: l }) : J(o.ctx.slots, "default", { node: r, data: a }, () => [
        Ke(ay, { tag: "span", truncated: true, class: t.be("node", "label") }, () => [r.label])
      ]);
    };
  }
});
var EZ = /* @__PURE__ */ $e(CZ, [["__file", "tree-node-content.vue"]]);
function rT(e10) {
  const t = Le(S_, null), n = {
    treeNodeExpand: (o) => {
      e10.node !== o && e10.node.collapse();
    },
    children: []
  };
  return t && t.children.push(n), yt(S_, n), {
    broadcastExpanded: (o) => {
      if (e10.accordion)
        for (const r of n.children)
          r.treeNodeExpand(o);
    }
  };
}
const aT = Symbol("dragEvents");
function SZ({ props: e10, ctx: t, el$: n, dropIndicator$: o, store: r }) {
  const a = we("tree"), l = L({
    showDropIndicator: false,
    draggingNode: null,
    dropNode: null,
    allowDrop: true,
    dropType: null
  });
  return yt(aT, {
    treeNodeDragStart: ({ event: d, treeNode: f }) => {
      if (Fe(e10.allowDrag) && !e10.allowDrag(f.node))
        return d.preventDefault(), false;
      d.dataTransfer.effectAllowed = "move";
      try {
        d.dataTransfer.setData("text/plain", "");
      } catch {
      }
      l.value.draggingNode = f, t.emit("node-drag-start", f.node, d);
    },
    treeNodeDragOver: ({ event: d, treeNode: f }) => {
      const p = f, v = l.value.dropNode;
      v && v.node.id !== p.node.id && no(v.$el, a.is("drop-inner"));
      const m = l.value.draggingNode;
      if (!m || !p)
        return;
      let h = true, b = true, g = true, w = true;
      Fe(e10.allowDrop) && (h = e10.allowDrop(m.node, p.node, "prev"), w = b = e10.allowDrop(m.node, p.node, "inner"), g = e10.allowDrop(m.node, p.node, "next")), d.dataTransfer.dropEffect = b || h || g ? "move" : "none", (h || b || g) && (v == null ? void 0 : v.node.id) !== p.node.id && (v && t.emit("node-drag-leave", m.node, v.node, d), t.emit("node-drag-enter", m.node, p.node, d)), h || b || g ? l.value.dropNode = p : l.value.dropNode = null, p.node.nextSibling === m.node && (g = false), p.node.previousSibling === m.node && (h = false), p.node.contains(m.node, false) && (b = false), (m.node === p.node || m.node.contains(p.node)) && (h = false, b = false, g = false);
      const y = p.$el.querySelector(`.${a.be("node", "content")}`).getBoundingClientRect(), _ = n.value.getBoundingClientRect();
      let C;
      const E = h ? b ? 0.25 : g ? 0.45 : 1 : -1, T = g ? b ? 0.75 : h ? 0.55 : 0 : 1;
      let O = -9999;
      const N = d.clientY - y.top;
      N < y.height * E ? C = "before" : N > y.height * T ? C = "after" : b ? C = "inner" : C = "none";
      const $ = p.$el.querySelector(`.${a.be("node", "expand-icon")}`).getBoundingClientRect(), R = o.value;
      C === "before" ? O = $.top - _.top : C === "after" && (O = $.bottom - _.top), R.style.top = `${O}px`, R.style.left = `${$.right - _.left}px`, C === "inner" ? jo(p.$el, a.is("drop-inner")) : no(p.$el, a.is("drop-inner")), l.value.showDropIndicator = C === "before" || C === "after", l.value.allowDrop = l.value.showDropIndicator || w, l.value.dropType = C, t.emit("node-drag-over", m.node, p.node, d);
    },
    treeNodeDragEnd: (d) => {
      const { draggingNode: f, dropType: p, dropNode: v } = l.value;
      if (d.preventDefault(), d.dataTransfer && (d.dataTransfer.dropEffect = "move"), f && v) {
        const m = { data: f.node.data };
        p !== "none" && f.node.remove(), p === "before" ? v.node.parent.insertBefore(m, v.node) : p === "after" ? v.node.parent.insertAfter(m, v.node) : p === "inner" && v.node.insertChild(m), p !== "none" && (r.value.registerNode(m), r.value.key && f.node.eachNode((h) => {
          var b;
          (b = r.value.nodesMap[h.data[r.value.key]]) == null || b.setChecked(h.checked, !r.value.checkStrictly);
        })), no(v.$el, a.is("drop-inner")), t.emit("node-drag-end", f.node, v.node, p, d), p !== "none" && t.emit("node-drop", f.node, v.node, p, d);
      }
      f && !v && t.emit("node-drag-end", f.node, null, p, d), l.value.showDropIndicator = false, l.value.draggingNode = null, l.value.dropNode = null, l.value.allowDrop = true;
    }
  }), {
    dragState: l
  };
}
const kZ = /* @__PURE__ */ j({
  name: "ElTreeNode",
  components: {
    ElCollapseTransition: lp,
    ElCheckbox: er,
    NodeContent: EZ,
    ElIcon: Be,
    Loading: Yr
  },
  props: {
    node: {
      type: zh,
      default: () => ({})
    },
    props: {
      type: Object,
      default: () => ({})
    },
    accordion: Boolean,
    renderContent: Function,
    renderAfterExpand: Boolean,
    showCheckbox: {
      type: Boolean,
      default: false
    }
  },
  emits: ["node-expand"],
  setup(e10, t) {
    const n = we("tree"), { broadcastExpanded: o } = rT(e10), r = Le(yy), a = L(false), l = L(false), s = L(), u = L(), c = L(), d = Le(aT), f = it();
    yt(oT, f), r || _t("Tree", "Can not find node's tree."), e10.node.expanded && (a.value = true, l.value = true);
    const p = r.props.props.children || "children";
    ge(() => {
      var N;
      const $ = (N = e10.node.data) == null ? void 0 : N[p];
      return $ && [...$];
    }, () => {
      e10.node.updateChildren();
    }), ge(() => e10.node.indeterminate, (N) => {
      h(e10.node.checked, N);
    }), ge(() => e10.node.checked, (N) => {
      h(N, e10.node.indeterminate);
    }), ge(() => e10.node.childNodes.length, () => e10.node.reInitChecked()), ge(() => e10.node.expanded, (N) => {
      He(() => a.value = N), N && (l.value = true);
    });
    const v = (N) => gy(r.props.nodeKey, N.data), m = (N) => {
      const $ = e10.props.class;
      if (!$)
        return {};
      let R;
      if (Fe($)) {
        const { data: P } = N;
        R = $(P, N);
      } else
        R = $;
      return Ve(R) ? { [R]: true } : R;
    }, h = (N, $) => {
      (s.value !== N || u.value !== $) && r.ctx.emit("check-change", e10.node.data, N, $), s.value = N, u.value = $;
    }, b = (N) => {
      Bh(r.store, r.ctx.emit, () => {
        var $;
        if (($ = r == null ? void 0 : r.props) == null ? void 0 : $.nodeKey) {
          const P = v(e10.node);
          r.store.value.setCurrentNodeKey(P);
        } else
          r.store.value.setCurrentNode(e10.node);
      }), r.currentNode.value = e10.node, r.props.expandOnClickNode && w(), (r.props.checkOnClickNode || e10.node.isLeaf && r.props.checkOnClickLeaf && e10.showCheckbox) && !e10.node.disabled && y(!e10.node.checked), r.ctx.emit("node-click", e10.node.data, e10.node, f, N);
    }, g = (N) => {
      var $;
      ($ = r.instance.vnode.props) != null && $.onNodeContextmenu && (N.stopPropagation(), N.preventDefault()), r.ctx.emit("node-contextmenu", N, e10.node.data, e10.node, f);
    }, w = () => {
      e10.node.isLeaf || (a.value ? (r.ctx.emit("node-collapse", e10.node.data, e10.node, f), e10.node.collapse()) : e10.node.expand(() => {
        t.emit("node-expand", e10.node.data, e10.node, f);
      }));
    }, y = (N) => {
      e10.node.setChecked(N, !(r != null && r.props.checkStrictly)), He(() => {
        const $ = r.store.value;
        r.ctx.emit("check", e10.node.data, {
          checkedNodes: $.getCheckedNodes(),
          checkedKeys: $.getCheckedKeys(),
          halfCheckedNodes: $.getHalfCheckedNodes(),
          halfCheckedKeys: $.getHalfCheckedKeys()
        });
      });
    };
    return {
      ns: n,
      node$: c,
      tree: r,
      expanded: a,
      childNodeRendered: l,
      oldChecked: s,
      oldIndeterminate: u,
      getNodeKey: v,
      getNodeClass: m,
      handleSelectChange: h,
      handleClick: b,
      handleContextMenu: g,
      handleExpandIconClick: w,
      handleCheckChange: y,
      handleChildNodeExpand: (N, $, R) => {
        o($), r.ctx.emit("node-expand", N, $, R);
      },
      handleDragStart: (N) => {
        r.props.draggable && d.treeNodeDragStart({ event: N, treeNode: e10 });
      },
      handleDragOver: (N) => {
        N.preventDefault(), r.props.draggable && d.treeNodeDragOver({
          event: N,
          treeNode: { $el: c.value, node: e10.node }
        });
      },
      handleDrop: (N) => {
        N.preventDefault();
      },
      handleDragEnd: (N) => {
        r.props.draggable && d.treeNodeDragEnd(N);
      },
      CaretRight: MS
    };
  }
});
function NZ(e10, t, n, o, r, a) {
  const l = je("el-icon"), s = je("el-checkbox"), u = je("loading"), c = je("node-content"), d = je("el-tree-node"), f = je("el-collapse-transition");
  return lt((k(), x("div", {
    ref: "node$",
    class: I([
      e10.ns.b("node"),
      e10.ns.is("expanded", e10.expanded),
      e10.ns.is("current", e10.node.isCurrent),
      e10.ns.is("hidden", !e10.node.visible),
      e10.ns.is("focusable", !e10.node.disabled),
      e10.ns.is("checked", !e10.node.disabled && e10.node.checked),
      e10.getNodeClass(e10.node)
    ]),
    role: "treeitem",
    tabindex: "-1",
    "aria-expanded": e10.expanded,
    "aria-disabled": e10.node.disabled,
    "aria-checked": e10.node.checked,
    draggable: e10.tree.props.draggable,
    "data-key": e10.getNodeKey(e10.node),
    onClick: Xe(e10.handleClick, ["stop"]),
    onContextmenu: e10.handleContextMenu,
    onDragstart: Xe(e10.handleDragStart, ["stop"]),
    onDragover: Xe(e10.handleDragOver, ["stop"]),
    onDragend: Xe(e10.handleDragEnd, ["stop"]),
    onDrop: Xe(e10.handleDrop, ["stop"])
  }, [
    B("div", {
      class: I(e10.ns.be("node", "content")),
      style: ze({ paddingLeft: (e10.node.level - 1) * e10.tree.props.indent + "px" })
    }, [
      e10.tree.props.icon || e10.CaretRight ? (k(), ae(l, {
        key: 0,
        class: I([
          e10.ns.be("node", "expand-icon"),
          e10.ns.is("leaf", e10.node.isLeaf),
          {
            expanded: !e10.node.isLeaf && e10.expanded
          }
        ]),
        onClick: Xe(e10.handleExpandIconClick, ["stop"])
      }, {
        default: H(() => [
          (k(), ae(ht(e10.tree.props.icon || e10.CaretRight)))
        ]),
        _: 1
      }, 8, ["class", "onClick"])) : ee("v-if", true),
      e10.showCheckbox ? (k(), ae(s, {
        key: 1,
        "model-value": e10.node.checked,
        indeterminate: e10.node.indeterminate,
        disabled: !!e10.node.disabled,
        onClick: Xe(() => {
        }, ["stop"]),
        onChange: e10.handleCheckChange
      }, null, 8, ["model-value", "indeterminate", "disabled", "onClick", "onChange"])) : ee("v-if", true),
      e10.node.loading ? (k(), ae(l, {
        key: 2,
        class: I([e10.ns.be("node", "loading-icon"), e10.ns.is("loading")])
      }, {
        default: H(() => [
          W(u)
        ]),
        _: 1
      }, 8, ["class"])) : ee("v-if", true),
      W(c, {
        node: e10.node,
        "render-content": e10.renderContent
      }, null, 8, ["node", "render-content"])
    ], 6),
    W(f, null, {
      default: H(() => [
        !e10.renderAfterExpand || e10.childNodeRendered ? lt((k(), x("div", {
          key: 0,
          class: I(e10.ns.be("node", "children")),
          role: "group",
          "aria-expanded": e10.expanded,
          onClick: Xe(() => {
          }, ["stop"])
        }, [
          (k(true), x(Ie, null, st(e10.node.childNodes, (p) => (k(), ae(d, {
            key: e10.getNodeKey(p),
            "render-content": e10.renderContent,
            "render-after-expand": e10.renderAfterExpand,
            "show-checkbox": e10.showCheckbox,
            node: p,
            accordion: e10.accordion,
            props: e10.props,
            onNodeExpand: e10.handleChildNodeExpand
          }, null, 8, ["render-content", "render-after-expand", "show-checkbox", "node", "accordion", "props", "onNodeExpand"]))), 128))
        ], 10, ["aria-expanded", "onClick"])), [
          [Nt, e10.expanded]
        ]) : ee("v-if", true)
      ]),
      _: 1
    })
  ], 42, ["aria-expanded", "aria-disabled", "aria-checked", "draggable", "data-key", "onClick", "onContextmenu", "onDragstart", "onDragover", "onDragend", "onDrop"])), [
    [Nt, e10.node.visible]
  ]);
}
var TZ = /* @__PURE__ */ $e(kZ, [["render", NZ], ["__file", "tree-node.vue"]]);
function OZ({ el$: e10 }, t) {
  const n = we("tree");
  dt(() => {
    r();
  }), wr(() => {
    Array.from(e10.value.querySelectorAll("input[type=checkbox]")).forEach((l) => {
      l.setAttribute("tabindex", "-1");
    });
  }), Ft(e10, "keydown", (a) => {
    const l = a.target;
    if (!l.className.includes(n.b("node")))
      return;
    const s = a.code, u = Array.from(e10.value.querySelectorAll(`.${n.is("focusable")}[role=treeitem]`)), c = u.indexOf(l);
    let d;
    if ([xe.up, xe.down].includes(s)) {
      if (a.preventDefault(), s === xe.up) {
        d = c === -1 ? 0 : c !== 0 ? c - 1 : u.length - 1;
        const p = d;
        for (; !t.value.getNode(u[d].dataset.key).canFocus; ) {
          if (d--, d === p) {
            d = -1;
            break;
          }
          d < 0 && (d = u.length - 1);
        }
      } else {
        d = c === -1 ? 0 : c < u.length - 1 ? c + 1 : 0;
        const p = d;
        for (; !t.value.getNode(u[d].dataset.key).canFocus; ) {
          if (d++, d === p) {
            d = -1;
            break;
          }
          d >= u.length && (d = 0);
        }
      }
      d !== -1 && u[d].focus();
    }
    [xe.left, xe.right].includes(s) && (a.preventDefault(), l.click());
    const f = l.querySelector('[type="checkbox"]');
    [xe.enter, xe.numpadEnter, xe.space].includes(s) && f && (a.preventDefault(), f.click());
  });
  const r = () => {
    var a;
    const l = Array.from(e10.value.querySelectorAll(`.${n.is("focusable")}[role=treeitem]`));
    Array.from(e10.value.querySelectorAll("input[type=checkbox]")).forEach((c) => {
      c.setAttribute("tabindex", "-1");
    });
    const u = e10.value.querySelectorAll(`.${n.is("checked")}[role=treeitem]`);
    if (u.length) {
      u[0].setAttribute("tabindex", "0");
      return;
    }
    (a = l[0]) == null || a.setAttribute("tabindex", "0");
  };
}
const $Z = /* @__PURE__ */ j({
  name: "ElTree",
  components: { ElTreeNode: TZ },
  props: {
    data: {
      type: Array,
      default: () => []
    },
    emptyText: {
      type: String
    },
    renderAfterExpand: {
      type: Boolean,
      default: true
    },
    nodeKey: String,
    checkStrictly: Boolean,
    defaultExpandAll: Boolean,
    expandOnClickNode: {
      type: Boolean,
      default: true
    },
    checkOnClickNode: Boolean,
    checkOnClickLeaf: {
      type: Boolean,
      default: true
    },
    checkDescendants: {
      type: Boolean,
      default: false
    },
    autoExpandParent: {
      type: Boolean,
      default: true
    },
    defaultCheckedKeys: Array,
    defaultExpandedKeys: Array,
    currentNodeKey: [String, Number],
    renderContent: Function,
    showCheckbox: {
      type: Boolean,
      default: false
    },
    draggable: {
      type: Boolean,
      default: false
    },
    allowDrag: Function,
    allowDrop: Function,
    props: {
      type: Object,
      default: () => ({
        children: "children",
        label: "label",
        disabled: "disabled"
      })
    },
    lazy: {
      type: Boolean,
      default: false
    },
    highlightCurrent: Boolean,
    load: Function,
    filterNodeMethod: Function,
    accordion: Boolean,
    indent: {
      type: Number,
      default: 18
    },
    icon: {
      type: Ht
    }
  },
  emits: [
    "check-change",
    "current-change",
    "node-click",
    "node-contextmenu",
    "node-collapse",
    "node-expand",
    "check",
    "node-drag-start",
    "node-drag-end",
    "node-drop",
    "node-drag-leave",
    "node-drag-enter",
    "node-drag-over"
  ],
  setup(e10, t) {
    const { t: n } = kt(), o = we("tree"), r = Le($i, null), a = L(new wZ({
      key: e10.nodeKey,
      data: e10.data,
      lazy: e10.lazy,
      props: e10.props,
      load: e10.load,
      currentNodeKey: e10.currentNodeKey,
      checkStrictly: e10.checkStrictly,
      checkDescendants: e10.checkDescendants,
      defaultCheckedKeys: e10.defaultCheckedKeys,
      defaultExpandedKeys: e10.defaultExpandedKeys,
      autoExpandParent: e10.autoExpandParent,
      defaultExpandAll: e10.defaultExpandAll,
      filterNodeMethod: e10.filterNodeMethod
    }));
    a.value.initialize();
    const l = L(a.value.root), s = L(null), u = L(null), c = L(null), { broadcastExpanded: d } = rT(e10), { dragState: f } = SZ({
      props: e10,
      ctx: t,
      el$: u,
      dropIndicator$: c,
      store: a
    });
    OZ({ el$: u }, a);
    const p = S(() => {
      const { childNodes: A } = l.value, V = r ? r.hasFilteredOptions !== 0 : false;
      return (!A || A.length === 0 || A.every(({ visible: Z }) => !Z)) && !V;
    });
    ge(() => e10.currentNodeKey, (A) => {
      a.value.setCurrentNodeKey(A);
    }), ge(() => e10.defaultCheckedKeys, (A) => {
      a.value.setDefaultCheckedKey(A);
    }), ge(() => e10.defaultExpandedKeys, (A) => {
      a.value.setDefaultExpandedKeys(A);
    }), ge(() => e10.data, (A) => {
      a.value.setData(A);
    }, { deep: true }), ge(() => e10.checkStrictly, (A) => {
      a.value.checkStrictly = A;
    });
    const v = (A) => {
      if (!e10.filterNodeMethod)
        throw new Error("[Tree] filterNodeMethod is required when filter");
      a.value.filter(A);
    }, m = (A) => gy(e10.nodeKey, A.data), h = (A) => {
      if (!e10.nodeKey)
        throw new Error("[Tree] nodeKey is required in getNodePath");
      const V = a.value.getNode(A);
      if (!V)
        return [];
      const Z = [V.data];
      let G = V.parent;
      for (; G && G !== l.value; )
        Z.push(G.data), G = G.parent;
      return Z.reverse();
    }, b = (A, V) => a.value.getCheckedNodes(A, V), g = (A) => a.value.getCheckedKeys(A), w = () => {
      const A = a.value.getCurrentNode();
      return A ? A.data : null;
    }, y = () => {
      if (!e10.nodeKey)
        throw new Error("[Tree] nodeKey is required in getCurrentKey");
      const A = w();
      return A ? A[e10.nodeKey] : null;
    }, _ = (A, V) => {
      if (!e10.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCheckedNodes");
      a.value.setCheckedNodes(A, V);
    }, C = (A, V) => {
      if (!e10.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCheckedKeys");
      a.value.setCheckedKeys(A, V);
    }, E = (A, V, Z) => {
      a.value.setChecked(A, V, Z);
    }, T = () => a.value.getHalfCheckedNodes(), O = () => a.value.getHalfCheckedKeys(), N = (A, V = true) => {
      if (!e10.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCurrentNode");
      Bh(a, t.emit, () => {
        d(A), a.value.setUserCurrentNode(A, V);
      });
    }, $ = (A, V = true) => {
      if (!e10.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCurrentKey");
      Bh(a, t.emit, () => {
        d(), a.value.setCurrentNodeKey(A, V);
      });
    }, R = (A) => a.value.getNode(A), P = (A) => {
      a.value.remove(A);
    }, z = (A, V) => {
      a.value.append(A, V);
    }, Y = (A, V) => {
      a.value.insertBefore(A, V);
    }, D = (A, V) => {
      a.value.insertAfter(A, V);
    }, M = (A, V, Z) => {
      d(V), t.emit("node-expand", A, V, Z);
    }, F = (A, V) => {
      if (!e10.nodeKey)
        throw new Error("[Tree] nodeKey is required in updateKeyChild");
      a.value.updateChildren(A, V);
    };
    return yt(yy, {
      ctx: t,
      props: e10,
      store: a,
      root: l,
      currentNode: s,
      instance: it()
    }), yt(qr, void 0), {
      ns: o,
      store: a,
      root: l,
      currentNode: s,
      dragState: f,
      el$: u,
      dropIndicator$: c,
      isEmpty: p,
      filter: v,
      getNodeKey: m,
      getNodePath: h,
      getCheckedNodes: b,
      getCheckedKeys: g,
      getCurrentNode: w,
      getCurrentKey: y,
      setCheckedNodes: _,
      setCheckedKeys: C,
      setChecked: E,
      getHalfCheckedNodes: T,
      getHalfCheckedKeys: O,
      setCurrentNode: N,
      setCurrentKey: $,
      t: n,
      getNode: R,
      remove: P,
      append: z,
      insertBefore: Y,
      insertAfter: D,
      handleNodeExpand: M,
      updateKeyChildren: F
    };
  }
});
function IZ(e10, t, n, o, r, a) {
  const l = je("el-tree-node");
  return k(), x("div", {
    ref: "el$",
    class: I([
      e10.ns.b(),
      e10.ns.is("dragging", !!e10.dragState.draggingNode),
      e10.ns.is("drop-not-allow", !e10.dragState.allowDrop),
      e10.ns.is("drop-inner", e10.dragState.dropType === "inner"),
      { [e10.ns.m("highlight-current")]: e10.highlightCurrent }
    ]),
    role: "tree"
  }, [
    (k(true), x(Ie, null, st(e10.root.childNodes, (s) => (k(), ae(l, {
      key: e10.getNodeKey(s),
      node: s,
      props: e10.props,
      accordion: e10.accordion,
      "render-after-expand": e10.renderAfterExpand,
      "show-checkbox": e10.showCheckbox,
      "render-content": e10.renderContent,
      onNodeExpand: e10.handleNodeExpand
    }, null, 8, ["node", "props", "accordion", "render-after-expand", "show-checkbox", "render-content", "onNodeExpand"]))), 128)),
    e10.isEmpty ? (k(), x("div", {
      key: 0,
      class: I(e10.ns.e("empty-block"))
    }, [
      J(e10.$slots, "empty", {}, () => {
        var s;
        return [
          B("span", {
            class: I(e10.ns.e("empty-text"))
          }, _e((s = e10.emptyText) != null ? s : e10.t("el.tree.emptyText")), 3)
        ];
      })
    ], 2)) : ee("v-if", true),
    lt(B("div", {
      ref: "dropIndicator$",
      class: I(e10.ns.e("drop-indicator"))
    }, null, 2), [
      [Nt, e10.dragState.showDropIndicator]
    ])
  ], 2);
}
var MZ = /* @__PURE__ */ $e($Z, [["render", IZ], ["__file", "tree.vue"]]);
const Ef = ut(MZ), PZ = (e10, { attrs: t, emit: n }, {
  select: o,
  tree: r,
  key: a
}) => {
  const l = we("tree-select");
  return ge(() => e10.data, () => {
    e10.filterable && He(() => {
      var u, c;
      (c = r.value) == null || c.filter((u = o.value) == null ? void 0 : u.states.inputValue);
    });
  }, { flush: "post" }), {
    ...sr(Tn(e10), Object.keys(Zl.props)),
    ...t,
    class: S(() => t.class),
    style: S(() => t.style),
    "onUpdate:modelValue": (u) => n(nt, u),
    valueKey: a,
    popperClass: S(() => {
      const u = [l.e("popper")];
      return e10.popperClass && u.push(e10.popperClass), u.join(" ");
    }),
    filterMethod: (u = "") => {
      var c;
      e10.filterMethod ? e10.filterMethod(u) : e10.remoteMethod ? e10.remoteMethod(u) : (c = r.value) == null || c.filter(u);
    }
  };
}, RZ = /* @__PURE__ */ j({
  extends: df,
  setup(e10, t) {
    const n = df.setup(e10, t);
    delete n.selectOptionClick;
    const o = it().proxy;
    return He(() => {
      n.select.states.cachedOptions.get(o.value) || n.select.onOptionCreate(o);
    }), ge(() => t.attrs.visible, (r) => {
      He(() => {
        n.states.visible = r;
      });
    }, {
      immediate: true
    }), n;
  },
  methods: {
    selectOptionClick() {
      this.$el.parentElement.click();
    }
  }
});
function Kh(e10) {
  return e10 || e10 === 0;
}
function by(e10) {
  return Se(e10) && e10.length;
}
function ws(e10) {
  return Se(e10) ? e10 : Kh(e10) ? [e10] : [];
}
function Od(e10, t, n, o, r) {
  for (let a = 0; a < e10.length; a++) {
    const l = e10[a];
    if (t(l, a, e10, r))
      return o ? o(l, a, e10, r) : l;
    {
      const s = n(l);
      if (by(s)) {
        const u = Od(s, t, n, o, l);
        if (u)
          return u;
      }
    }
  }
}
function $d(e10, t, n, o) {
  for (let r = 0; r < e10.length; r++) {
    const a = e10[r];
    t(a, r, e10, o);
    const l = n(a);
    by(l) && $d(l, t, n, a);
  }
}
const AZ = (e10, { attrs: t, slots: n, emit: o }, {
  select: r,
  tree: a,
  key: l
}) => {
  ge([() => e10.modelValue, a], () => {
    e10.showCheckbox && He(() => {
      const p = a.value;
      p && !In(p.getCheckedKeys(), ws(e10.modelValue)) && p.setCheckedKeys(ws(e10.modelValue));
    });
  }, {
    immediate: true,
    deep: true
  });
  const s = S(() => ({
    value: l.value,
    label: "label",
    children: "children",
    disabled: "disabled",
    isLeaf: "isLeaf",
    ...e10.props
  })), u = (p, v) => {
    var m;
    const h = s.value[p];
    return Fe(h) ? h(v, (m = a.value) == null ? void 0 : m.getNode(u("value", v))) : v[h];
  }, c = ws(e10.modelValue).map((p) => Od(e10.data || [], (v) => u("value", v) === p, (v) => u("children", v), (v, m, h, b) => b && u("value", b))).filter((p) => Kh(p)), d = S(() => {
    if (!e10.renderAfterExpand && !e10.lazy)
      return [];
    const p = [];
    return $d(e10.data.concat(e10.cacheData), (v) => {
      const m = u("value", v);
      p.push({
        value: m,
        currentLabel: u("label", v),
        isDisabled: u("disabled", v)
      });
    }, (v) => u("children", v)), p;
  }), f = () => {
    var p;
    return (p = a.value) == null ? void 0 : p.getCheckedKeys().filter((v) => {
      var m;
      const h = (m = a.value) == null ? void 0 : m.getNode(v);
      return !Nn(h) && Ro(h.childNodes);
    });
  };
  return {
    ...sr(Tn(e10), Object.keys(Ef.props)),
    ...t,
    nodeKey: l,
    expandOnClickNode: S(() => !e10.checkStrictly && e10.expandOnClickNode),
    defaultExpandedKeys: S(() => e10.defaultExpandedKeys ? e10.defaultExpandedKeys.concat(c) : c),
    renderContent: (p, { node: v, data: m, store: h }) => p(RZ, {
      value: u("value", m),
      label: u("label", m),
      disabled: u("disabled", m),
      visible: v.visible
    }, e10.renderContent ? () => e10.renderContent(p, { node: v, data: m, store: h }) : n.default ? () => n.default({ node: v, data: m, store: h }) : void 0),
    filterNodeMethod: (p, v, m) => e10.filterNodeMethod ? e10.filterNodeMethod(p, v, m) : p ? new RegExp(Eg(p), "i").test(u("label", v) || "") : true,
    onNodeClick: (p, v, m) => {
      var h, b, g, w;
      if ((h = t.onNodeClick) == null || h.call(t, p, v, m), !(e10.showCheckbox && e10.checkOnClickNode)) {
        if (!e10.showCheckbox && (e10.checkStrictly || v.isLeaf)) {
          if (!u("disabled", p)) {
            const y = (b = r.value) == null ? void 0 : b.states.options.get(u("value", p));
            (g = r.value) == null || g.handleOptionSelect(y);
          }
        } else e10.expandOnClickNode && m.proxy.handleExpandIconClick();
        (w = r.value) == null || w.focus();
      }
    },
    onCheck: (p, v) => {
      var m;
      if (!e10.showCheckbox)
        return;
      const h = u("value", p), b = {};
      $d([a.value.store.root], (_) => b[_.key] = _, (_) => _.childNodes);
      const g = v.checkedKeys, w = e10.multiple ? ws(e10.modelValue).filter((_) => !(_ in b) && !g.includes(_)) : [], y = w.concat(g);
      if (e10.checkStrictly)
        o(nt, e10.multiple ? y : y.includes(h) ? h : void 0);
      else if (e10.multiple) {
        const _ = f();
        o(nt, w.concat(_));
      } else {
        const _ = Od([p], (T) => !by(u("children", T)) && !u("disabled", T), (T) => u("children", T)), C = _ ? u("value", _) : void 0, E = Kh(e10.modelValue) && !!Od([p], (T) => u("value", T) === e10.modelValue, (T) => u("children", T));
        o(nt, C === e10.modelValue || E ? void 0 : C);
      }
      He(() => {
        var _;
        const C = ws(e10.modelValue);
        a.value.setCheckedKeys(C), (_ = t.onCheck) == null || _.call(t, p, {
          checkedKeys: a.value.getCheckedKeys(),
          checkedNodes: a.value.getCheckedNodes(),
          halfCheckedKeys: a.value.getHalfCheckedKeys(),
          halfCheckedNodes: a.value.getHalfCheckedNodes()
        });
      }), (m = r.value) == null || m.focus();
    },
    onNodeExpand: (p, v, m) => {
      var h;
      (h = t.onNodeExpand) == null || h.call(t, p, v, m), He(() => {
        if (!e10.checkStrictly && e10.lazy && e10.multiple && v.checked) {
          const b = {}, g = a.value.getCheckedKeys();
          $d([a.value.store.root], (_) => b[_.key] = _, (_) => _.childNodes);
          const w = ws(e10.modelValue).filter((_) => !(_ in b) && !g.includes(_)), y = f();
          o(nt, w.concat(y));
        }
      });
    },
    cacheOptions: d
  };
};
var LZ = /* @__PURE__ */ j({
  props: {
    data: {
      type: Array,
      default: () => []
    }
  },
  setup(e10) {
    const t = Le($i);
    return ge(() => e10.data, () => {
      var n;
      e10.data.forEach((r) => {
        t.states.cachedOptions.has(r.value) || t.states.cachedOptions.set(r.value, r);
      });
      const o = ((n = t.selectRef) == null ? void 0 : n.querySelectorAll("input")) || [];
      Et && !Array.from(o).includes(document.activeElement) && t.setSelected();
    }, { flush: "post", immediate: true }), () => {
    };
  }
});
const xZ = /* @__PURE__ */ j({
  name: "ElTreeSelect",
  inheritAttrs: false,
  props: {
    ...Zl.props,
    ...Ef.props,
    cacheData: {
      type: Array,
      default: () => []
    }
  },
  setup(e10, t) {
    const { slots: n, expose: o } = t, r = L(), a = L(), l = S(() => e10.nodeKey || e10.valueKey || "value"), s = PZ(e10, t, { select: r, tree: a, key: l }), { cacheOptions: u, ...c } = AZ(e10, t, {
      select: r,
      tree: a,
      key: l
    }), d = It({});
    return o(d), dt(() => {
      Object.assign(d, {
        ...sr(a.value, [
          "filter",
          "updateKeyChildren",
          "getCheckedNodes",
          "setCheckedNodes",
          "getCheckedKeys",
          "setCheckedKeys",
          "setChecked",
          "getHalfCheckedNodes",
          "getHalfCheckedKeys",
          "getCurrentKey",
          "getCurrentNode",
          "setCurrentKey",
          "setCurrentNode",
          "getNode",
          "remove",
          "append",
          "insertBefore",
          "insertAfter"
        ]),
        ...sr(r.value, ["focus", "blur", "selectedLabel"])
      });
    }), () => Ke(Zl, It({
      ...s,
      ref: (f) => r.value = f
    }), {
      ...n,
      default: () => [
        Ke(LZ, { data: u.value }),
        Ke(Ef, It({
          ...c,
          ref: (f) => a.value = f
        }))
      ]
    });
  }
});
var DZ = /* @__PURE__ */ $e(xZ, [["__file", "tree-select.vue"]]);
const VZ = ut(DZ), _y = Symbol(), FZ = {
  key: -1,
  level: -1,
  data: {}
};
var qi = /* @__PURE__ */ ((e10) => (e10.KEY = "id", e10.LABEL = "label", e10.CHILDREN = "children", e10.DISABLED = "disabled", e10.CLASS = "", e10))(qi || {}), Wh = /* @__PURE__ */ ((e10) => (e10.ADD = "add", e10.DELETE = "delete", e10))(Wh || {});
const lT = {
  type: Number,
  default: 26
}, BZ = Oe({
  data: {
    type: ne(Array),
    default: () => rn([])
  },
  emptyText: {
    type: String
  },
  height: {
    type: Number,
    default: 200
  },
  props: {
    type: ne(Object),
    default: () => rn({
      children: "children",
      label: "label",
      disabled: "disabled",
      value: "id",
      class: ""
      /* CLASS */
    })
  },
  highlightCurrent: {
    type: Boolean,
    default: false
  },
  showCheckbox: {
    type: Boolean,
    default: false
  },
  defaultCheckedKeys: {
    type: ne(Array),
    default: () => rn([])
  },
  checkStrictly: {
    type: Boolean,
    default: false
  },
  defaultExpandedKeys: {
    type: ne(Array),
    default: () => rn([])
  },
  indent: {
    type: Number,
    default: 16
  },
  itemSize: lT,
  icon: {
    type: Ht
  },
  expandOnClickNode: {
    type: Boolean,
    default: true
  },
  checkOnClickNode: {
    type: Boolean,
    default: false
  },
  checkOnClickLeaf: {
    type: Boolean,
    default: true
  },
  currentNodeKey: {
    type: ne([String, Number])
  },
  accordion: {
    type: Boolean,
    default: false
  },
  filterMethod: {
    type: ne(Function)
  },
  perfMode: {
    type: Boolean,
    default: true
  }
}), HZ = Oe({
  node: {
    type: ne(Object),
    default: () => rn(FZ)
  },
  expanded: {
    type: Boolean,
    default: false
  },
  checked: {
    type: Boolean,
    default: false
  },
  indeterminate: {
    type: Boolean,
    default: false
  },
  showCheckbox: {
    type: Boolean,
    default: false
  },
  disabled: {
    type: Boolean,
    default: false
  },
  current: {
    type: Boolean,
    default: false
  },
  hiddenExpandIcon: {
    type: Boolean,
    default: false
  },
  itemSize: lT
}), zZ = Oe({
  node: {
    type: ne(Object),
    required: true
  }
}), sT = "node-click", iT = "node-drop", uT = "node-expand", cT = "node-collapse", dT = "current-change", fT = "check", pT = "check-change", vT = "node-contextmenu", KZ = {
  [sT]: (e10, t, n) => e10 && t && n,
  [iT]: (e10, t, n) => e10 && t && n,
  [uT]: (e10, t) => e10 && t,
  [cT]: (e10, t) => e10 && t,
  [dT]: (e10, t) => e10 && t,
  [fT]: (e10, t) => e10 && t,
  [pT]: (e10, t) => e10 && Vt(t),
  [vT]: (e10, t, n) => e10 && t && n
}, WZ = {
  click: (e10, t) => !!(e10 && t),
  drop: (e10, t) => !!(e10 && t),
  toggle: (e10) => !!e10,
  check: (e10, t) => e10 && Vt(t)
};
function jZ(e10, t) {
  const n = L(/* @__PURE__ */ new Set()), o = L(/* @__PURE__ */ new Set()), { emit: r } = it();
  ge([() => t.value, () => e10.defaultCheckedKeys], () => He(() => {
    w(e10.defaultCheckedKeys);
  }), {
    immediate: true
  });
  const a = () => {
    if (!t.value || !e10.showCheckbox || e10.checkStrictly)
      return;
    const { levelTreeNodeMap: y, maxLevel: _ } = t.value, C = n.value, E = /* @__PURE__ */ new Set();
    for (let T = _ - 1; T >= 1; --T) {
      const O = y.get(T);
      O && O.forEach((N) => {
        const $ = N.children;
        if ($) {
          let R = true, P = false;
          for (const z of $) {
            const Y = z.key;
            if (C.has(Y))
              P = true;
            else if (E.has(Y)) {
              R = false, P = true;
              break;
            } else
              R = false;
          }
          R ? C.add(N.key) : P ? (E.add(N.key), C.delete(N.key)) : (C.delete(N.key), E.delete(N.key));
        }
      });
    }
    o.value = E;
  }, l = (y) => n.value.has(y.key), s = (y) => o.value.has(y.key), u = (y, _, C = true, E = true) => {
    const T = n.value, O = (N, $) => {
      T[$ ? Wh.ADD : Wh.DELETE](N.key);
      const R = N.children;
      !e10.checkStrictly && R && R.forEach((P) => {
        P.disabled || O(P, $);
      });
    };
    O(y, _), E && a(), C && c(y, _);
  }, c = (y, _) => {
    const { checkedNodes: C, checkedKeys: E } = m(), { halfCheckedNodes: T, halfCheckedKeys: O } = h();
    r(fT, y.data, {
      checkedKeys: E,
      checkedNodes: C,
      halfCheckedKeys: O,
      halfCheckedNodes: T
    }), r(pT, y.data, _);
  };
  function d(y = false) {
    return m(y).checkedKeys;
  }
  function f(y = false) {
    return m(y).checkedNodes;
  }
  function p() {
    return h().halfCheckedKeys;
  }
  function v() {
    return h().halfCheckedNodes;
  }
  function m(y = false) {
    const _ = [], C = [];
    if (t != null && t.value && e10.showCheckbox) {
      const { treeNodeMap: E } = t.value;
      n.value.forEach((T) => {
        const O = E.get(T);
        O && (!y || y && O.isLeaf) && (C.push(T), _.push(O.data));
      });
    }
    return {
      checkedKeys: C,
      checkedNodes: _
    };
  }
  function h() {
    const y = [], _ = [];
    if (t != null && t.value && e10.showCheckbox) {
      const { treeNodeMap: C } = t.value;
      o.value.forEach((E) => {
        const T = C.get(E);
        T && (_.push(E), y.push(T.data));
      });
    }
    return {
      halfCheckedNodes: y,
      halfCheckedKeys: _
    };
  }
  function b(y) {
    n.value.clear(), o.value.clear(), He(() => {
      w(y);
    });
  }
  function g(y, _) {
    if (t != null && t.value && e10.showCheckbox) {
      const C = t.value.treeNodeMap.get(y);
      C && u(C, _, false);
    }
  }
  function w(y) {
    if (t != null && t.value) {
      const { treeNodeMap: _ } = t.value;
      if (e10.showCheckbox && _ && (y == null ? void 0 : y.length) > 0) {
        for (const C of y) {
          const E = _.get(C);
          E && !l(E) && u(E, true, false, false);
        }
        a();
      }
    }
  }
  return {
    updateCheckedKeys: a,
    toggleCheckbox: u,
    isChecked: l,
    isIndeterminate: s,
    getCheckedKeys: d,
    getCheckedNodes: f,
    getHalfCheckedKeys: p,
    getHalfCheckedNodes: v,
    setChecked: g,
    setCheckedKeys: b
  };
}
function UZ(e10, t) {
  const n = L(/* @__PURE__ */ new Set([])), o = L(/* @__PURE__ */ new Set([])), r = S(() => Fe(e10.filterMethod));
  function a(s) {
    var u;
    if (!r.value)
      return;
    const c = /* @__PURE__ */ new Set(), d = o.value, f = n.value, p = [], v = ((u = t.value) == null ? void 0 : u.treeNodes) || [], m = e10.filterMethod;
    f.clear();
    function h(b) {
      b.forEach((g) => {
        p.push(g), m != null && m(s, g.data, g) ? p.forEach((y) => {
          c.add(y.key);
        }) : g.isLeaf && f.add(g.key);
        const w = g.children;
        if (w && h(w), !g.isLeaf) {
          if (!c.has(g.key))
            f.add(g.key);
          else if (w) {
            let y = true;
            for (const _ of w)
              if (!f.has(_.key)) {
                y = false;
                break;
              }
            y ? d.add(g.key) : d.delete(g.key);
          }
        }
        p.pop();
      });
    }
    return h(v), c;
  }
  function l(s) {
    return o.value.has(s.key);
  }
  return {
    hiddenExpandIconKeySet: o,
    hiddenNodeKeySet: n,
    doFilter: a,
    isForceHiddenExpandIcon: l
  };
}
function YZ(e10, t) {
  const n = L(new Set(e10.defaultExpandedKeys)), o = L(), r = qt(), a = L(), {
    isIndeterminate: l,
    isChecked: s,
    toggleCheckbox: u,
    getCheckedKeys: c,
    getCheckedNodes: d,
    getHalfCheckedKeys: f,
    getHalfCheckedNodes: p,
    setChecked: v,
    setCheckedKeys: m
  } = jZ(e10, r), { doFilter: h, hiddenNodeKeySet: b, isForceHiddenExpandIcon: g } = UZ(e10, r), w = S(() => {
    var de;
    return ((de = e10.props) == null ? void 0 : de.value) || qi.KEY;
  }), y = S(() => {
    var de;
    return ((de = e10.props) == null ? void 0 : de.children) || qi.CHILDREN;
  }), _ = S(() => {
    var de;
    return ((de = e10.props) == null ? void 0 : de.disabled) || qi.DISABLED;
  }), C = S(() => {
    var de;
    return ((de = e10.props) == null ? void 0 : de.label) || qi.LABEL;
  }), E = S(() => {
    var de;
    const U = n.value, re = b.value, he = [], Ee = ((de = r.value) == null ? void 0 : de.treeNodes) || [], ye = [];
    for (let K = Ee.length - 1; K >= 0; --K)
      ye.push(Ee[K]);
    for (; ye.length; ) {
      const K = ye.pop();
      if (!re.has(K.key) && (he.push(K), K.children && U.has(K.key)))
        for (let q = K.children.length - 1; q >= 0; --q)
          ye.push(K.children[q]);
    }
    return he;
  }), T = S(() => E.value.length > 0);
  function O(de) {
    const U = /* @__PURE__ */ new Map(), re = /* @__PURE__ */ new Map();
    let he = 1;
    function Ee(K, q = 1, ue = void 0) {
      var be;
      const ke = [];
      for (const Ae of K) {
        const fe = R(Ae), ie = {
          level: q,
          key: fe,
          data: Ae
        };
        ie.label = z(Ae), ie.parent = ue;
        const Ce = $(Ae);
        ie.disabled = P(Ae), ie.isLeaf = !Ce || Ce.length === 0, Ce && Ce.length && (ie.children = Ee(Ce, q + 1, ie)), ke.push(ie), U.set(fe, ie), re.has(q) || re.set(q, []), (be = re.get(q)) == null || be.push(ie);
      }
      return q > he && (he = q), ke;
    }
    const ye = Ee(de);
    return {
      treeNodeMap: U,
      levelTreeNodeMap: re,
      maxLevel: he,
      treeNodes: ye
    };
  }
  function N(de) {
    const U = h(de);
    U && (n.value = U);
  }
  function $(de) {
    return de[y.value];
  }
  function R(de) {
    return de ? de[w.value] : "";
  }
  function P(de) {
    return de[_.value];
  }
  function z(de) {
    return de[C.value];
  }
  function Y(de) {
    n.value.has(de.key) ? G(de) : Z(de);
  }
  function D(de) {
    const U = /* @__PURE__ */ new Set(), re = r.value.treeNodeMap;
    de.forEach((he) => {
      let Ee = re.get(he);
      for (; Ee && !U.has(Ee.key); )
        U.add(Ee.key), Ee = Ee.parent;
    }), n.value = U;
  }
  function M(de, U) {
    t(sT, de.data, de, U), A(de), e10.expandOnClickNode && Y(de), e10.showCheckbox && (e10.checkOnClickNode || de.isLeaf && e10.checkOnClickLeaf) && !de.disabled && u(de, !s(de), true);
  }
  function F(de, U) {
    t(iT, de.data, de, U);
  }
  function A(de) {
    te(de) || (o.value = de.key, t(dT, de.data, de));
  }
  function V(de, U) {
    u(de, U);
  }
  function Z(de) {
    const U = n.value;
    if (r.value && e10.accordion) {
      const { treeNodeMap: re } = r.value;
      U.forEach((he) => {
        const Ee = re.get(he);
        de && de.level === (Ee == null ? void 0 : Ee.level) && U.delete(he);
      });
    }
    U.add(de.key), t(uT, de.data, de);
  }
  function G(de) {
    n.value.delete(de.key), t(cT, de.data, de);
  }
  function le(de) {
    return n.value.has(de.key);
  }
  function X(de) {
    return !!de.disabled;
  }
  function te(de) {
    const U = o.value;
    return U !== void 0 && U === de.key;
  }
  function ce() {
    var de, U;
    if (o.value)
      return (U = (de = r.value) == null ? void 0 : de.treeNodeMap.get(o.value)) == null ? void 0 : U.data;
  }
  function pe() {
    return o.value;
  }
  function se(de) {
    o.value = de;
  }
  function ve(de) {
    r.value = O(de);
  }
  function me(de) {
    var U;
    const re = at(de) ? R(de) : de;
    return (U = r.value) == null ? void 0 : U.treeNodeMap.get(re);
  }
  function De(de, U = "auto") {
    const re = me(de);
    re && a.value && a.value.scrollToItem(E.value.indexOf(re), U);
  }
  function Te(de) {
    var U;
    (U = a.value) == null || U.scrollTo(de);
  }
  return ge(() => e10.currentNodeKey, (de) => {
    o.value = de;
  }, {
    immediate: true
  }), ge(() => e10.data, (de) => {
    ve(de);
  }, {
    immediate: true
  }), {
    tree: r,
    flattenTree: E,
    isNotEmpty: T,
    listRef: a,
    getKey: R,
    getChildren: $,
    toggleExpand: Y,
    toggleCheckbox: u,
    isExpanded: le,
    isChecked: s,
    isIndeterminate: l,
    isDisabled: X,
    isCurrent: te,
    isForceHiddenExpandIcon: g,
    handleNodeClick: M,
    handleNodeDrop: F,
    handleNodeCheck: V,
    getCurrentNode: ce,
    getCurrentKey: pe,
    setCurrentKey: se,
    getCheckedKeys: c,
    getCheckedNodes: d,
    getHalfCheckedKeys: f,
    getHalfCheckedNodes: p,
    setChecked: v,
    setCheckedKeys: m,
    filter: N,
    setData: ve,
    getNode: me,
    expandNode: Z,
    collapseNode: G,
    setExpandedKeys: D,
    scrollToNode: De,
    scrollTo: Te
  };
}
var qZ = /* @__PURE__ */ j({
  name: "ElTreeNodeContent",
  props: zZ,
  setup(e10) {
    const t = Le(_y), n = we("tree");
    return () => {
      const o = e10.node, { data: r } = o;
      return t != null && t.ctx.slots.default ? t.ctx.slots.default({ node: o, data: r }) : Ke(ay, { tag: "span", truncated: true, class: n.be("node", "label") }, () => [o == null ? void 0 : o.label]);
    };
  }
});
const GZ = /* @__PURE__ */ j({
  name: "ElTreeNode"
}), XZ = /* @__PURE__ */ j({
  ...GZ,
  props: HZ,
  emits: WZ,
  setup(e10, { emit: t }) {
    const n = e10, o = Le(_y), r = we("tree"), a = S(() => {
      var v;
      return (v = o == null ? void 0 : o.props.indent) != null ? v : 16;
    }), l = S(() => {
      var v;
      return (v = o == null ? void 0 : o.props.icon) != null ? v : MS;
    }), s = (v) => {
      const m = o == null ? void 0 : o.props.props.class;
      if (!m)
        return {};
      let h;
      if (Fe(m)) {
        const { data: b } = v;
        h = m(b, v);
      } else
        h = m;
      return Ve(h) ? { [h]: true } : h;
    }, u = (v) => {
      t("click", n.node, v);
    }, c = (v) => {
      t("drop", n.node, v);
    }, d = () => {
      t("toggle", n.node);
    }, f = (v) => {
      t("check", n.node, v);
    }, p = (v) => {
      var m, h, b, g;
      (b = (h = (m = o == null ? void 0 : o.instance) == null ? void 0 : m.vnode) == null ? void 0 : h.props) != null && b.onNodeContextmenu && (v.stopPropagation(), v.preventDefault()), o == null || o.ctx.emit(vT, v, (g = n.node) == null ? void 0 : g.data, n.node);
    };
    return (v, m) => {
      var h, b, g;
      return k(), x("div", {
        ref: "node$",
        class: I([
          i(r).b("node"),
          i(r).is("expanded", v.expanded),
          i(r).is("current", v.current),
          i(r).is("focusable", !v.disabled),
          i(r).is("checked", !v.disabled && v.checked),
          s(v.node)
        ]),
        role: "treeitem",
        tabindex: "-1",
        "aria-expanded": v.expanded,
        "aria-disabled": v.disabled,
        "aria-checked": v.checked,
        "data-key": (h = v.node) == null ? void 0 : h.key,
        onClick: Xe(u, ["stop"]),
        onContextmenu: p,
        onDragover: Xe(() => {
        }, ["prevent"]),
        onDragenter: Xe(() => {
        }, ["prevent"]),
        onDrop: Xe(c, ["stop"])
      }, [
        B("div", {
          class: I(i(r).be("node", "content")),
          style: ze({
            paddingLeft: `${(v.node.level - 1) * i(a)}px`,
            height: v.itemSize + "px"
          })
        }, [
          i(l) ? (k(), ae(i(Be), {
            key: 0,
            class: I([
              i(r).is("leaf", !!((b = v.node) != null && b.isLeaf)),
              i(r).is("hidden", v.hiddenExpandIcon),
              {
                expanded: !((g = v.node) != null && g.isLeaf) && v.expanded
              },
              i(r).be("node", "expand-icon")
            ]),
            onClick: Xe(d, ["stop"])
          }, {
            default: H(() => [
              (k(), ae(ht(i(l))))
            ]),
            _: 1
          }, 8, ["class", "onClick"])) : ee("v-if", true),
          v.showCheckbox ? (k(), ae(i(er), {
            key: 1,
            "model-value": v.checked,
            indeterminate: v.indeterminate,
            disabled: v.disabled,
            onChange: f,
            onClick: Xe(() => {
            }, ["stop"])
          }, null, 8, ["model-value", "indeterminate", "disabled", "onClick"])) : ee("v-if", true),
          W(i(qZ), { node: v.node }, null, 8, ["node"])
        ], 6)
      ], 42, ["aria-expanded", "aria-disabled", "aria-checked", "data-key", "onClick", "onDragover", "onDragenter", "onDrop"]);
    };
  }
});
var JZ = /* @__PURE__ */ $e(XZ, [["__file", "tree-node.vue"]]);
const ZZ = /* @__PURE__ */ j({
  name: "ElTreeV2"
}), QZ = /* @__PURE__ */ j({
  ...ZZ,
  props: BZ,
  emits: KZ,
  setup(e10, { expose: t, emit: n }) {
    const o = e10, r = En(), a = S(() => o.itemSize);
    yt(_y, {
      ctx: {
        emit: n,
        slots: r
      },
      props: o,
      instance: it()
    }), yt(qr, void 0);
    const { t: l } = kt(), s = we("tree"), {
      flattenTree: u,
      isNotEmpty: c,
      listRef: d,
      toggleExpand: f,
      isExpanded: p,
      isIndeterminate: v,
      isChecked: m,
      isDisabled: h,
      isCurrent: b,
      isForceHiddenExpandIcon: g,
      handleNodeClick: w,
      handleNodeDrop: y,
      handleNodeCheck: _,
      toggleCheckbox: C,
      getCurrentNode: E,
      getCurrentKey: T,
      setCurrentKey: O,
      getCheckedKeys: N,
      getCheckedNodes: $,
      getHalfCheckedKeys: R,
      getHalfCheckedNodes: P,
      setChecked: z,
      setCheckedKeys: Y,
      filter: D,
      setData: M,
      getNode: F,
      expandNode: A,
      collapseNode: V,
      setExpandedKeys: Z,
      scrollToNode: G,
      scrollTo: le
    } = YZ(o, n);
    return t({
      toggleCheckbox: C,
      getCurrentNode: E,
      getCurrentKey: T,
      setCurrentKey: O,
      getCheckedKeys: N,
      getCheckedNodes: $,
      getHalfCheckedKeys: R,
      getHalfCheckedNodes: P,
      setChecked: z,
      setCheckedKeys: Y,
      filter: D,
      setData: M,
      getNode: F,
      expandNode: A,
      collapseNode: V,
      setExpandedKeys: Z,
      scrollToNode: G,
      scrollTo: le
    }), (X, te) => (k(), x("div", {
      class: I([i(s).b(), { [i(s).m("highlight-current")]: X.highlightCurrent }]),
      role: "tree"
    }, [
      i(c) ? (k(), ae(i(Gk), {
        key: 0,
        ref_key: "listRef",
        ref: d,
        "class-name": i(s).b("virtual-list"),
        data: i(u),
        total: i(u).length,
        height: X.height,
        "item-size": i(a),
        "perf-mode": X.perfMode
      }, {
        default: H(({ data: ce, index: pe, style: se }) => [
          (k(), ae(JZ, {
            key: ce[pe].key,
            style: ze(se),
            node: ce[pe],
            expanded: i(p)(ce[pe]),
            "show-checkbox": X.showCheckbox,
            checked: i(m)(ce[pe]),
            indeterminate: i(v)(ce[pe]),
            "item-size": i(a),
            disabled: i(h)(ce[pe]),
            current: i(b)(ce[pe]),
            "hidden-expand-icon": i(g)(ce[pe]),
            onClick: i(w),
            onToggle: i(f),
            onCheck: i(_),
            onDrop: i(y)
          }, null, 8, ["style", "node", "expanded", "show-checkbox", "checked", "indeterminate", "item-size", "disabled", "current", "hidden-expand-icon", "onClick", "onToggle", "onCheck", "onDrop"]))
        ]),
        _: 1
      }, 8, ["class-name", "data", "total", "height", "item-size", "perf-mode"])) : (k(), x("div", {
        key: 1,
        class: I(i(s).e("empty-block"))
      }, [
        J(X.$slots, "empty", {}, () => {
          var ce;
          return [
            B("span", {
              class: I(i(s).e("empty-text"))
            }, _e((ce = X.emptyText) != null ? ce : i(l)("el.tree.emptyText")), 3)
          ];
        })
      ], 2))
    ], 2));
  }
});
var eQ = /* @__PURE__ */ $e(QZ, [["__file", "tree.vue"]]);
const tQ = ut(eQ), hT = Symbol("uploadContextKey"), nQ = "ElUpload";
class oQ extends Error {
  constructor(t, n, o, r) {
    super(t), this.name = "UploadAjaxError", this.status = n, this.method = o, this.url = r;
  }
}
function k_(e10, t, n) {
  let o;
  return n.response ? o = `${n.response.error || n.response}` : n.responseText ? o = `${n.responseText}` : o = `fail to ${t.method} ${e10} ${n.status}`, new oQ(o, n.status, t.method, e10);
}
function rQ(e10) {
  const t = e10.responseText || e10.response;
  if (!t)
    return t;
  try {
    return JSON.parse(t);
  } catch {
    return t;
  }
}
const aQ = (e10) => {
  typeof XMLHttpRequest > "u" && Qt(nQ, "XMLHttpRequest is undefined");
  const t = new XMLHttpRequest(), n = e10.action;
  t.upload && t.upload.addEventListener("progress", (a) => {
    const l = a;
    l.percent = a.total > 0 ? a.loaded / a.total * 100 : 0, e10.onProgress(l);
  });
  const o = new FormData();
  if (e10.data)
    for (const [a, l] of Object.entries(e10.data))
      Se(l) && l.length ? o.append(a, ...l) : o.append(a, l);
  o.append(e10.filename, e10.file, e10.file.name), t.addEventListener("error", () => {
    e10.onError(k_(n, e10, t));
  }), t.addEventListener("load", () => {
    if (t.status < 200 || t.status >= 300)
      return e10.onError(k_(n, e10, t));
    e10.onSuccess(rQ(t));
  }), t.open(e10.method, n, true), e10.withCredentials && "withCredentials" in t && (t.withCredentials = true);
  const r = e10.headers || {};
  if (r instanceof Headers)
    r.forEach((a, l) => t.setRequestHeader(l, a));
  else
    for (const [a, l] of Object.entries(r))
      Nn(l) || t.setRequestHeader(a, String(l));
  return t.send(o), t;
}, mT = ["text", "picture", "picture-card"];
let lQ = 1;
const jh = () => Date.now() + lQ++, gT = Oe({
  action: {
    type: String,
    default: "#"
  },
  headers: {
    type: ne(Object)
  },
  method: {
    type: String,
    default: "post"
  },
  data: {
    type: ne([Object, Function, Promise]),
    default: () => rn({})
  },
  multiple: Boolean,
  name: {
    type: String,
    default: "file"
  },
  drag: Boolean,
  withCredentials: Boolean,
  showFileList: {
    type: Boolean,
    default: true
  },
  accept: {
    type: String,
    default: ""
  },
  fileList: {
    type: ne(Array),
    default: () => rn([])
  },
  autoUpload: {
    type: Boolean,
    default: true
  },
  listType: {
    type: String,
    values: mT,
    default: "text"
  },
  httpRequest: {
    type: ne(Function),
    default: aQ
  },
  disabled: Boolean,
  limit: Number
}), sQ = Oe({
  ...gT,
  beforeUpload: {
    type: ne(Function),
    default: Mt
  },
  beforeRemove: {
    type: ne(Function)
  },
  onRemove: {
    type: ne(Function),
    default: Mt
  },
  onChange: {
    type: ne(Function),
    default: Mt
  },
  onPreview: {
    type: ne(Function),
    default: Mt
  },
  onSuccess: {
    type: ne(Function),
    default: Mt
  },
  onProgress: {
    type: ne(Function),
    default: Mt
  },
  onError: {
    type: ne(Function),
    default: Mt
  },
  onExceed: {
    type: ne(Function),
    default: Mt
  },
  crossorigin: {
    type: ne(String)
  }
}), iQ = Oe({
  files: {
    type: ne(Array),
    default: () => rn([])
  },
  disabled: {
    type: Boolean,
    default: false
  },
  handlePreview: {
    type: ne(Function),
    default: Mt
  },
  listType: {
    type: String,
    values: mT,
    default: "text"
  },
  crossorigin: {
    type: ne(String)
  }
}), uQ = {
  remove: (e10) => !!e10
}, cQ = /* @__PURE__ */ j({
  name: "ElUploadList"
}), dQ = /* @__PURE__ */ j({
  ...cQ,
  props: iQ,
  emits: uQ,
  setup(e10, { emit: t }) {
    const n = e10, { t: o } = kt(), r = we("upload"), a = we("icon"), l = we("list"), s = Hn(), u = L(false), c = S(() => [
      r.b("list"),
      r.bm("list", n.listType),
      r.is("disabled", n.disabled)
    ]), d = (f) => {
      t("remove", f);
    };
    return (f, p) => (k(), ae(mE, {
      tag: "ul",
      class: I(i(c)),
      name: i(l).b()
    }, {
      default: H(() => [
        (k(true), x(Ie, null, st(f.files, (v, m) => (k(), x("li", {
          key: v.uid || v.name,
          class: I([
            i(r).be("list", "item"),
            i(r).is(v.status),
            { focusing: u.value }
          ]),
          tabindex: "0",
          onKeydown: Bt((h) => !i(s) && d(v), ["delete"]),
          onFocus: (h) => u.value = true,
          onBlur: (h) => u.value = false,
          onClick: (h) => u.value = false
        }, [
          J(f.$slots, "default", {
            file: v,
            index: m
          }, () => [
            f.listType === "picture" || v.status !== "uploading" && f.listType === "picture-card" ? (k(), x("img", {
              key: 0,
              class: I(i(r).be("list", "item-thumbnail")),
              src: v.url,
              crossorigin: f.crossorigin,
              alt: ""
            }, null, 10, ["src", "crossorigin"])) : ee("v-if", true),
            v.status === "uploading" || f.listType !== "picture-card" ? (k(), x("div", {
              key: 1,
              class: I(i(r).be("list", "item-info"))
            }, [
              B("a", {
                class: I(i(r).be("list", "item-name")),
                onClick: Xe((h) => f.handlePreview(v), ["prevent"])
              }, [
                W(i(Be), {
                  class: I(i(a).m("document"))
                }, {
                  default: H(() => [
                    W(i(t8))
                  ]),
                  _: 1
                }, 8, ["class"]),
                B("span", {
                  class: I(i(r).be("list", "item-file-name")),
                  title: v.name
                }, _e(v.name), 11, ["title"])
              ], 10, ["onClick"]),
              v.status === "uploading" ? (k(), ae(i(Fk), {
                key: 0,
                type: f.listType === "picture-card" ? "circle" : "line",
                "stroke-width": f.listType === "picture-card" ? 6 : 2,
                percentage: Number(v.percentage),
                style: ze(f.listType === "picture-card" ? "" : "margin-top: 0.5rem")
              }, null, 8, ["type", "stroke-width", "percentage", "style"])) : ee("v-if", true)
            ], 2)) : ee("v-if", true),
            B("label", {
              class: I(i(r).be("list", "item-status-label"))
            }, [
              f.listType === "text" ? (k(), ae(i(Be), {
                key: 0,
                class: I([i(a).m("upload-success"), i(a).m("circle-check")])
              }, {
                default: H(() => [
                  W(i(og))
                ]),
                _: 1
              }, 8, ["class"])) : ["picture-card", "picture"].includes(f.listType) ? (k(), ae(i(Be), {
                key: 1,
                class: I([i(a).m("upload-success"), i(a).m("check")])
              }, {
                default: H(() => [
                  W(i(sc))
                ]),
                _: 1
              }, 8, ["class"])) : ee("v-if", true)
            ], 2),
            i(s) ? ee("v-if", true) : (k(), ae(i(Be), {
              key: 2,
              class: I(i(a).m("close")),
              onClick: (h) => d(v)
            }, {
              default: H(() => [
                W(i(Jo))
              ]),
              _: 2
            }, 1032, ["class", "onClick"])),
            ee(" Due to close btn only appears when li gets focused disappears after li gets blurred, thus keyboard navigation can never reach close btn"),
            ee(" This is a bug which needs to be fixed "),
            ee(" TODO: Fix the incorrect navigation interaction "),
            i(s) ? ee("v-if", true) : (k(), x("i", {
              key: 3,
              class: I(i(a).m("close-tip"))
            }, _e(i(o)("el.upload.deleteTip")), 3)),
            f.listType === "picture-card" ? (k(), x("span", {
              key: 4,
              class: I(i(r).be("list", "item-actions"))
            }, [
              B("span", {
                class: I(i(r).be("list", "item-preview")),
                onClick: (h) => f.handlePreview(v)
              }, [
                W(i(Be), {
                  class: I(i(a).m("zoom-in"))
                }, {
                  default: H(() => [
                    W(i(LS))
                  ]),
                  _: 1
                }, 8, ["class"])
              ], 10, ["onClick"]),
              i(s) ? ee("v-if", true) : (k(), x("span", {
                key: 0,
                class: I(i(r).be("list", "item-delete")),
                onClick: (h) => d(v)
              }, [
                W(i(Be), {
                  class: I(i(a).m("delete"))
                }, {
                  default: H(() => [
                    W(i(Qx))
                  ]),
                  _: 1
                }, 8, ["class"])
              ], 10, ["onClick"]))
            ], 2)) : ee("v-if", true)
          ])
        ], 42, ["onKeydown", "onFocus", "onBlur", "onClick"]))), 128)),
        J(f.$slots, "append")
      ]),
      _: 3
    }, 8, ["class", "name"]));
  }
});
var N_ = /* @__PURE__ */ $e(dQ, [["__file", "upload-list.vue"]]);
const fQ = Oe({
  disabled: {
    type: Boolean,
    default: false
  }
}), pQ = {
  file: (e10) => Se(e10)
}, yT = "ElUploadDrag", vQ = /* @__PURE__ */ j({
  name: yT
}), hQ = /* @__PURE__ */ j({
  ...vQ,
  props: fQ,
  emits: pQ,
  setup(e10, { emit: t }) {
    Le(hT) || Qt(yT, "usage: <el-upload><el-upload-dragger /></el-upload>");
    const o = we("upload"), r = L(false), a = Hn(), l = (u) => {
      if (a.value)
        return;
      r.value = false, u.stopPropagation();
      const c = Array.from(u.dataTransfer.files), d = u.dataTransfer.items || [];
      c.forEach((f, p) => {
        var v;
        const m = d[p], h = (v = m == null ? void 0 : m.webkitGetAsEntry) == null ? void 0 : v.call(m);
        h && (f.isDirectory = h.isDirectory);
      }), t("file", c);
    }, s = () => {
      a.value || (r.value = true);
    };
    return (u, c) => (k(), x("div", {
      class: I([i(o).b("dragger"), i(o).is("dragover", r.value)]),
      onDrop: Xe(l, ["prevent"]),
      onDragover: Xe(s, ["prevent"]),
      onDragleave: Xe((d) => r.value = false, ["prevent"])
    }, [
      J(u.$slots, "default")
    ], 42, ["onDrop", "onDragover", "onDragleave"]));
  }
});
var mQ = /* @__PURE__ */ $e(hQ, [["__file", "upload-dragger.vue"]]);
const gQ = Oe({
  ...gT,
  beforeUpload: {
    type: ne(Function),
    default: Mt
  },
  onRemove: {
    type: ne(Function),
    default: Mt
  },
  onStart: {
    type: ne(Function),
    default: Mt
  },
  onSuccess: {
    type: ne(Function),
    default: Mt
  },
  onProgress: {
    type: ne(Function),
    default: Mt
  },
  onError: {
    type: ne(Function),
    default: Mt
  },
  onExceed: {
    type: ne(Function),
    default: Mt
  }
}), yQ = /* @__PURE__ */ j({
  name: "ElUploadContent",
  inheritAttrs: false
}), bQ = /* @__PURE__ */ j({
  ...yQ,
  props: gQ,
  setup(e10, { expose: t }) {
    const n = e10, o = we("upload"), r = Hn(), a = qt({}), l = qt(), s = (h) => {
      if (h.length === 0)
        return;
      const { autoUpload: b, limit: g, fileList: w, multiple: y, onStart: _, onExceed: C } = n;
      if (g && w.length + h.length > g) {
        C(h, w);
        return;
      }
      y || (h = h.slice(0, 1));
      for (const E of h) {
        const T = E;
        T.uid = jh(), _(T), b && u(T);
      }
    }, u = async (h) => {
      if (l.value.value = "", !n.beforeUpload)
        return d(h);
      let b, g = {};
      try {
        const y = n.data, _ = n.beforeUpload(h);
        g = iu(n.data) ? Jd(n.data) : n.data, b = await _, iu(n.data) && In(y, g) && (g = Jd(n.data));
      } catch {
        b = false;
      }
      if (b === false) {
        n.onRemove(h);
        return;
      }
      let w = h;
      b instanceof Blob && (b instanceof File ? w = b : w = new File([b], h.name, {
        type: h.type
      })), d(Object.assign(w, {
        uid: h.uid
      }), g);
    }, c = async (h, b) => Fe(h) ? h(b) : h, d = async (h, b) => {
      const {
        headers: g,
        data: w,
        method: y,
        withCredentials: _,
        name: C,
        action: E,
        onProgress: T,
        onSuccess: O,
        onError: N,
        httpRequest: $
      } = n;
      try {
        b = await c(b != null ? b : w, h);
      } catch {
        n.onRemove(h);
        return;
      }
      const { uid: R } = h, P = {
        headers: g || {},
        withCredentials: _,
        file: h,
        data: b,
        method: y,
        filename: C,
        action: E,
        onProgress: (Y) => {
          T(Y, h);
        },
        onSuccess: (Y) => {
          O(Y, h), delete a.value[R];
        },
        onError: (Y) => {
          N(Y, h), delete a.value[R];
        }
      }, z = $(P);
      a.value[R] = z, z instanceof Promise && z.then(P.onSuccess, P.onError);
    }, f = (h) => {
      const b = h.target.files;
      b && s(Array.from(b));
    }, p = () => {
      r.value || (l.value.value = "", l.value.click());
    }, v = () => {
      p();
    };
    return t({
      abort: (h) => {
        ES(a.value).filter(h ? ([g]) => String(h.uid) === g : () => true).forEach(([g, w]) => {
          w instanceof XMLHttpRequest && w.abort(), delete a.value[g];
        });
      },
      upload: u
    }), (h, b) => (k(), x("div", {
      class: I([
        i(o).b(),
        i(o).m(h.listType),
        i(o).is("drag", h.drag),
        i(o).is("disabled", i(r))
      ]),
      tabindex: i(r) ? "-1" : "0",
      onClick: p,
      onKeydown: Bt(Xe(v, ["self"]), ["enter", "space"])
    }, [
      h.drag ? (k(), ae(mQ, {
        key: 0,
        disabled: i(r),
        onFile: s
      }, {
        default: H(() => [
          J(h.$slots, "default")
        ]),
        _: 3
      }, 8, ["disabled"])) : J(h.$slots, "default", { key: 1 }),
      B("input", {
        ref_key: "inputRef",
        ref: l,
        class: I(i(o).e("input")),
        name: h.name,
        disabled: i(r),
        multiple: h.multiple,
        accept: h.accept,
        type: "file",
        onChange: f,
        onClick: Xe(() => {
        }, ["stop"])
      }, null, 42, ["name", "disabled", "multiple", "accept", "onClick"])
    ], 42, ["tabindex", "onKeydown"]));
  }
});
var T_ = /* @__PURE__ */ $e(bQ, [["__file", "upload-content.vue"]]);
const O_ = "ElUpload", $_ = (e10) => {
  var t;
  (t = e10.url) != null && t.startsWith("blob:") && URL.revokeObjectURL(e10.url);
}, _Q = (e10, t) => {
  const n = vS(e10, "fileList", void 0, { passive: true }), o = (v) => n.value.find((m) => m.uid === v.uid);
  function r(v) {
    var m;
    (m = t.value) == null || m.abort(v);
  }
  function a(v = ["ready", "uploading", "success", "fail"]) {
    n.value = n.value.filter((m) => !v.includes(m.status));
  }
  function l(v) {
    n.value = n.value.filter((m) => m.uid !== v.uid);
  }
  const s = (v, m) => {
    const h = o(m);
    h && (console.error(v), h.status = "fail", l(h), e10.onError(v, h, n.value), e10.onChange(h, n.value));
  }, u = (v, m) => {
    const h = o(m);
    h && (e10.onProgress(v, h, n.value), h.status = "uploading", h.percentage = Math.round(v.percent));
  }, c = (v, m) => {
    const h = o(m);
    h && (h.status = "success", h.response = v, e10.onSuccess(v, h, n.value), e10.onChange(h, n.value));
  }, d = (v) => {
    Nn(v.uid) && (v.uid = jh());
    const m = {
      name: v.name,
      percentage: 0,
      status: "ready",
      size: v.size,
      raw: v,
      uid: v.uid
    };
    if (e10.listType === "picture-card" || e10.listType === "picture")
      try {
        m.url = URL.createObjectURL(v);
      } catch (h) {
        _t(O_, h.message), e10.onError(h, m, n.value);
      }
    n.value = [...n.value, m], e10.onChange(m, n.value);
  }, f = async (v) => {
    const m = v instanceof File ? o(v) : v;
    m || Qt(O_, "file to be removed not found");
    const h = (b) => {
      r(b), l(b), e10.onRemove(b, n.value), $_(b);
    };
    e10.beforeRemove ? await e10.beforeRemove(m, n.value) !== false && h(m) : h(m);
  };
  function p() {
    n.value.filter(({ status: v }) => v === "ready").forEach(({ raw: v }) => {
      var m;
      return v && ((m = t.value) == null ? void 0 : m.upload(v));
    });
  }
  return ge(() => e10.listType, (v) => {
    v !== "picture-card" && v !== "picture" || (n.value = n.value.map((m) => {
      const { raw: h, url: b } = m;
      if (!b && h)
        try {
          m.url = URL.createObjectURL(h);
        } catch (g) {
          e10.onError(g, m, n.value);
        }
      return m;
    }));
  }), ge(n, (v) => {
    for (const m of v)
      m.uid || (m.uid = jh()), m.status || (m.status = "success");
  }, { immediate: true, deep: true }), {
    uploadFiles: n,
    abort: r,
    clearFiles: a,
    handleError: s,
    handleProgress: u,
    handleStart: d,
    handleSuccess: c,
    handleRemove: f,
    submit: p,
    revokeFileObjectURL: $_
  };
}, wQ = /* @__PURE__ */ j({
  name: "ElUpload"
}), CQ = /* @__PURE__ */ j({
  ...wQ,
  props: sQ,
  setup(e10, { expose: t }) {
    const n = e10, o = Hn(), r = qt(), {
      abort: a,
      submit: l,
      clearFiles: s,
      uploadFiles: u,
      handleStart: c,
      handleError: d,
      handleRemove: f,
      handleSuccess: p,
      handleProgress: v,
      revokeFileObjectURL: m
    } = _Q(n, r), h = S(() => n.listType === "picture-card"), b = S(() => ({
      ...n,
      fileList: u.value,
      onStart: c,
      onProgress: v,
      onSuccess: p,
      onError: d,
      onRemove: f
    }));
    return jt(() => {
      u.value.forEach(m);
    }), yt(hT, {
      accept: Lt(n, "accept")
    }), t({
      abort: a,
      submit: l,
      clearFiles: s,
      handleStart: c,
      handleRemove: f
    }), (g, w) => (k(), x("div", null, [
      i(h) && g.showFileList ? (k(), ae(N_, {
        key: 0,
        disabled: i(o),
        "list-type": g.listType,
        files: i(u),
        crossorigin: g.crossorigin,
        "handle-preview": g.onPreview,
        onRemove: i(f)
      }, ro({
        append: H(() => [
          W(T_, vt({
            ref_key: "uploadRef",
            ref: r
          }, i(b)), {
            default: H(() => [
              g.$slots.trigger ? J(g.$slots, "trigger", { key: 0 }) : ee("v-if", true),
              !g.$slots.trigger && g.$slots.default ? J(g.$slots, "default", { key: 1 }) : ee("v-if", true)
            ]),
            _: 3
          }, 16)
        ]),
        _: 2
      }, [
        g.$slots.file ? {
          name: "default",
          fn: H(({ file: y, index: _ }) => [
            J(g.$slots, "file", {
              file: y,
              index: _
            })
          ])
        } : void 0
      ]), 1032, ["disabled", "list-type", "files", "crossorigin", "handle-preview", "onRemove"])) : ee("v-if", true),
      !i(h) || i(h) && !g.showFileList ? (k(), ae(T_, vt({
        key: 1,
        ref_key: "uploadRef",
        ref: r
      }, i(b)), {
        default: H(() => [
          g.$slots.trigger ? J(g.$slots, "trigger", { key: 0 }) : ee("v-if", true),
          !g.$slots.trigger && g.$slots.default ? J(g.$slots, "default", { key: 1 }) : ee("v-if", true)
        ]),
        _: 3
      }, 16)) : ee("v-if", true),
      g.$slots.trigger ? J(g.$slots, "default", { key: 2 }) : ee("v-if", true),
      J(g.$slots, "tip"),
      !i(h) && g.showFileList ? (k(), ae(N_, {
        key: 3,
        disabled: i(o),
        "list-type": g.listType,
        files: i(u),
        crossorigin: g.crossorigin,
        "handle-preview": g.onPreview,
        onRemove: i(f)
      }, ro({
        _: 2
      }, [
        g.$slots.file ? {
          name: "default",
          fn: H(({ file: y, index: _ }) => [
            J(g.$slots, "file", {
              file: y,
              index: _
            })
          ])
        } : void 0
      ]), 1032, ["disabled", "list-type", "files", "crossorigin", "handle-preview", "onRemove"])) : ee("v-if", true)
    ]));
  }
});
var EQ = /* @__PURE__ */ $e(CQ, [["__file", "upload.vue"]]);
const SQ = ut(EQ), kQ = Oe({
  zIndex: {
    type: Number,
    default: 9
  },
  rotate: {
    type: Number,
    default: -22
  },
  width: Number,
  height: Number,
  image: String,
  content: {
    type: ne([String, Array]),
    default: "Element Plus"
  },
  font: {
    type: ne(Object)
  },
  gap: {
    type: ne(Array),
    default: () => [100, 100]
  },
  offset: {
    type: ne(Array)
  }
});
function NQ(e10) {
  return e10.replace(/([A-Z])/g, "-$1").toLowerCase();
}
function TQ(e10) {
  return Object.keys(e10).map((t) => `${NQ(t)}: ${e10[t]};`).join(" ");
}
function OQ() {
  return window.devicePixelRatio || 1;
}
const $Q = (e10, t) => {
  let n = false;
  return e10.removedNodes.length && t && (n = Array.from(e10.removedNodes).includes(t)), e10.type === "attributes" && e10.target === t && (n = true), n;
}, bT = 3;
function yv(e10, t, n = 1) {
  const o = document.createElement("canvas"), r = o.getContext("2d"), a = e10 * n, l = t * n;
  return o.setAttribute("width", `${a}px`), o.setAttribute("height", `${l}px`), r.save(), [r, o, a, l];
}
function IQ() {
  function e10(t, n, o, r, a, l, s, u) {
    const [c, d, f, p] = yv(r, a, o);
    if (t instanceof HTMLImageElement)
      c.drawImage(t, 0, 0, f, p);
    else {
      const {
        color: G,
        fontSize: le,
        fontStyle: X,
        fontWeight: te,
        fontFamily: ce,
        textAlign: pe,
        textBaseline: se
      } = l, ve = Number(le) * o;
      c.font = `${X} normal ${te} ${ve}px/${a}px ${ce}`, c.fillStyle = G, c.textAlign = pe, c.textBaseline = se;
      const me = Se(t) ? t : [t];
      me == null || me.forEach((De, Te) => {
        c.fillText(De != null ? De : "", f / 2, Te * (ve + bT * o));
      });
    }
    const v = Math.PI / 180 * Number(n), m = Math.max(r, a), [h, b, g] = yv(m, m, o);
    h.translate(g / 2, g / 2), h.rotate(v), f > 0 && p > 0 && h.drawImage(d, -f / 2, -p / 2);
    function w(G, le) {
      const X = G * Math.cos(v) - le * Math.sin(v), te = G * Math.sin(v) + le * Math.cos(v);
      return [X, te];
    }
    let y = 0, _ = 0, C = 0, E = 0;
    const T = f / 2, O = p / 2;
    [
      [0 - T, 0 - O],
      [0 + T, 0 - O],
      [0 + T, 0 + O],
      [0 - T, 0 + O]
    ].forEach(([G, le]) => {
      const [X, te] = w(G, le);
      y = Math.min(y, X), _ = Math.max(_, X), C = Math.min(C, te), E = Math.max(E, te);
    });
    const $ = y + g / 2, R = C + g / 2, P = _ - y, z = E - C, Y = s * o, D = u * o, M = (P + Y) * 2, F = z + D, [A, V] = yv(M, F);
    function Z(G = 0, le = 0) {
      A.drawImage(b, $, R, P, z, G, le, P, z);
    }
    return Z(), Z(P + Y, -z / 2 - D / 2), Z(P + Y, +z / 2 + D / 2), [V.toDataURL(), M / o, F / o];
  }
  return e10;
}
const MQ = /* @__PURE__ */ j({
  name: "ElWatermark"
}), PQ = /* @__PURE__ */ j({
  ...MQ,
  props: kQ,
  setup(e10) {
    const t = e10, n = {
      position: "relative"
    }, o = S(() => {
      var $, R;
      return (R = ($ = t.font) == null ? void 0 : $.color) != null ? R : "rgba(0,0,0,.15)";
    }), r = S(() => {
      var $, R;
      return (R = ($ = t.font) == null ? void 0 : $.fontSize) != null ? R : 16;
    }), a = S(() => {
      var $, R;
      return (R = ($ = t.font) == null ? void 0 : $.fontWeight) != null ? R : "normal";
    }), l = S(() => {
      var $, R;
      return (R = ($ = t.font) == null ? void 0 : $.fontStyle) != null ? R : "normal";
    }), s = S(() => {
      var $, R;
      return (R = ($ = t.font) == null ? void 0 : $.fontFamily) != null ? R : "sans-serif";
    }), u = S(() => {
      var $, R;
      return (R = ($ = t.font) == null ? void 0 : $.textAlign) != null ? R : "center";
    }), c = S(() => {
      var $, R;
      return (R = ($ = t.font) == null ? void 0 : $.textBaseline) != null ? R : "hanging";
    }), d = S(() => t.gap[0]), f = S(() => t.gap[1]), p = S(() => d.value / 2), v = S(() => f.value / 2), m = S(() => {
      var $, R;
      return (R = ($ = t.offset) == null ? void 0 : $[0]) != null ? R : p.value;
    }), h = S(() => {
      var $, R;
      return (R = ($ = t.offset) == null ? void 0 : $[1]) != null ? R : v.value;
    }), b = () => {
      const $ = {
        zIndex: t.zIndex,
        position: "absolute",
        left: 0,
        top: 0,
        width: "100%",
        height: "100%",
        pointerEvents: "none",
        backgroundRepeat: "repeat"
      };
      let R = m.value - p.value, P = h.value - v.value;
      return R > 0 && ($.left = `${R}px`, $.width = `calc(100% - ${R}px)`, R = 0), P > 0 && ($.top = `${P}px`, $.height = `calc(100% - ${P}px)`, P = 0), $.backgroundPosition = `${R}px ${P}px`, $;
    }, g = qt(null), w = qt(), y = L(false), _ = () => {
      w.value && (w.value.remove(), w.value = void 0);
    }, C = ($, R) => {
      var P;
      g.value && w.value && (y.value = true, w.value.setAttribute("style", TQ({
        ...b(),
        backgroundImage: `url('${$}')`,
        backgroundSize: `${Math.floor(R)}px`
      })), (P = g.value) == null || P.append(w.value), setTimeout(() => {
        y.value = false;
      }));
    }, E = ($) => {
      let R = 120, P = 64;
      const { image: z, content: Y, width: D, height: M, rotate: F } = t;
      if (!z && $.measureText) {
        $.font = `${Number(r.value)}px ${s.value}`;
        const A = Se(Y) ? Y : [Y];
        let V = 0, Z = 0;
        A.forEach((X) => {
          const {
            width: te,
            fontBoundingBoxAscent: ce,
            fontBoundingBoxDescent: pe,
            actualBoundingBoxAscent: se,
            actualBoundingBoxDescent: ve
          } = $.measureText(X), me = St(ce) ? se + ve : ce + pe;
          te > V && (V = Math.ceil(te)), me > Z && (Z = Math.ceil(me));
        }), R = V, P = Z * A.length + (A.length - 1) * bT;
        const G = Math.PI / 180 * Number(F), le = Math.ceil(Math.abs(Math.sin(G) * P) / 2);
        R += le;
      }
      return [D != null ? D : R, M != null ? M : P];
    }, T = IQ(), O = () => {
      const R = document.createElement("canvas").getContext("2d"), P = t.image, z = t.content, Y = t.rotate;
      if (R) {
        w.value || (w.value = document.createElement("div"));
        const D = OQ(), [M, F] = E(R), A = (V) => {
          const [Z, G] = T(V || "", Y, D, M, F, {
            color: o.value,
            fontSize: r.value,
            fontStyle: l.value,
            fontWeight: a.value,
            fontFamily: s.value,
            textAlign: u.value,
            textBaseline: c.value
          }, d.value, f.value);
          C(Z, G);
        };
        if (P) {
          const V = new Image();
          V.onload = () => {
            A(V);
          }, V.onerror = () => {
            A(z);
          }, V.crossOrigin = "anonymous", V.referrerPolicy = "no-referrer", V.src = P;
        } else
          A(z);
      }
    };
    return dt(() => {
      O();
    }), ge(() => t, () => {
      O();
    }, {
      deep: true,
      flush: "post"
    }), jt(() => {
      _();
    }), pS(g, ($) => {
      y.value || $.forEach((R) => {
        $Q(R, w.value) && (_(), O());
      });
    }, {
      attributes: true,
      subtree: true,
      childList: true
    }), ($, R) => (k(), x("div", {
      ref_key: "containerRef",
      ref: g,
      style: ze([n])
    }, [
      J($.$slots, "default")
    ], 4));
  }
});
var RQ = /* @__PURE__ */ $e(PQ, [["__file", "watermark.vue"]]);
const AQ = ut(RQ), LQ = Oe({
  zIndex: {
    type: Number,
    default: 1001
  },
  visible: Boolean,
  fill: {
    type: String,
    default: "rgba(0,0,0,0.5)"
  },
  pos: {
    type: ne(Object)
  },
  targetAreaClickable: {
    type: Boolean,
    default: true
  }
}), xQ = (e10, t, n, o, r) => {
  const a = L(null), l = () => {
    let f;
    return Ve(e10.value) ? f = document.querySelector(e10.value) : Fe(e10.value) ? f = e10.value() : f = e10.value, f;
  }, s = () => {
    const f = l();
    if (!f || !t.value) {
      a.value = null;
      return;
    }
    DQ(f) || f.scrollIntoView(r.value);
    const { left: p, top: v, width: m, height: h } = f.getBoundingClientRect();
    a.value = {
      left: p,
      top: v,
      width: m,
      height: h,
      radius: 0
    };
  };
  dt(() => {
    ge([t, e10], () => {
      s();
    }, {
      immediate: true
    }), window.addEventListener("resize", s);
  }), jt(() => {
    window.removeEventListener("resize", s);
  });
  const u = (f) => {
    var p;
    return (p = Se(n.value.offset) ? n.value.offset[f] : n.value.offset) != null ? p : 6;
  }, c = S(() => {
    var f;
    if (!a.value)
      return a.value;
    const p = u(0), v = u(1), m = ((f = n.value) == null ? void 0 : f.radius) || 2;
    return {
      left: a.value.left - p,
      top: a.value.top - v,
      width: a.value.width + p * 2,
      height: a.value.height + v * 2,
      radius: m
    };
  }), d = S(() => {
    const f = l();
    return !o.value || !f || !window.DOMRect ? f || void 0 : {
      getBoundingClientRect() {
        var p, v, m, h;
        return window.DOMRect.fromRect({
          width: ((p = c.value) == null ? void 0 : p.width) || 0,
          height: ((v = c.value) == null ? void 0 : v.height) || 0,
          x: ((m = c.value) == null ? void 0 : m.left) || 0,
          y: ((h = c.value) == null ? void 0 : h.top) || 0
        });
      }
    };
  });
  return {
    mergedPosInfo: c,
    triggerTarget: d
  };
}, gp = Symbol("ElTour");
function DQ(e10) {
  const t = window.innerWidth || document.documentElement.clientWidth, n = window.innerHeight || document.documentElement.clientHeight, { top: o, right: r, bottom: a, left: l } = e10.getBoundingClientRect();
  return o >= 0 && l >= 0 && r <= t && a <= n;
}
const VQ = (e10, t, n, o, r, a, l, s) => {
  const u = L(), c = L(), d = L({}), f = {
    x: u,
    y: c,
    placement: o,
    strategy: r,
    middlewareData: d
  }, p = S(() => {
    const g = [
      ZN(i(a)),
      zJ(),
      HJ(),
      FQ()
    ];
    return i(s) && i(n) && g.push(QN({
      element: i(n)
    })), g;
  }), v = async () => {
    if (!Et)
      return;
    const g = i(e10), w = i(t);
    if (!g || !w)
      return;
    const y = await eT(g, w, {
      placement: i(o),
      strategy: i(r),
      middleware: i(p)
    });
    Qs(f).forEach((_) => {
      f[_].value = y[_];
    });
  }, m = S(() => {
    if (!i(e10))
      return {
        position: "fixed",
        top: "50%",
        left: "50%",
        transform: "translate3d(-50%, -50%, 0)",
        maxWidth: "100vw",
        zIndex: i(l)
      };
    const { overflow: g } = i(d);
    return {
      position: i(r),
      zIndex: i(l),
      top: i(c) != null ? `${i(c)}px` : "",
      left: i(u) != null ? `${i(u)}px` : "",
      maxWidth: g != null && g.maxWidth ? `${g == null ? void 0 : g.maxWidth}px` : ""
    };
  }), h = S(() => {
    if (!i(s))
      return {};
    const { arrow: g } = i(d);
    return {
      left: (g == null ? void 0 : g.x) != null ? `${g == null ? void 0 : g.x}px` : "",
      top: (g == null ? void 0 : g.y) != null ? `${g == null ? void 0 : g.y}px` : ""
    };
  });
  let b;
  return dt(() => {
    const g = i(e10), w = i(t);
    g && w && (b = FJ(g, w, v)), Vn(() => {
      v();
    });
  }), jt(() => {
    b && b();
  }), {
    update: v,
    contentStyle: m,
    arrowStyle: h
  };
}, FQ = () => ({
  name: "overflow",
  async fn(e10) {
    const t = await BJ(e10);
    let n = 0;
    return t.left > 0 && (n = t.left), t.right > 0 && (n = t.right), {
      data: {
        maxWidth: e10.rects.floating.width - n
      }
    };
  }
}), BQ = /* @__PURE__ */ j({
  name: "ElTourMask",
  inheritAttrs: false
}), HQ = /* @__PURE__ */ j({
  ...BQ,
  props: LQ,
  setup(e10) {
    const t = e10, { ns: n } = Le(gp), o = S(() => {
      var s, u;
      return (u = (s = t.pos) == null ? void 0 : s.radius) != null ? u : 2;
    }), r = S(() => {
      const s = o.value, u = `a${s},${s} 0 0 1`;
      return {
        topRight: `${u} ${s},${s}`,
        bottomRight: `${u} ${-s},${s}`,
        bottomLeft: `${u} ${-s},${-s}`,
        topLeft: `${u} ${s},${-s}`
      };
    }), a = S(() => {
      const s = window.innerWidth, u = window.innerHeight, c = r.value, d = `M${s},0 L0,0 L0,${u} L${s},${u} L${s},0 Z`, f = o.value;
      return t.pos ? `${d} M${t.pos.left + f},${t.pos.top} h${t.pos.width - f * 2} ${c.topRight} v${t.pos.height - f * 2} ${c.bottomRight} h${-t.pos.width + f * 2} ${c.bottomLeft} v${-t.pos.height + f * 2} ${c.topLeft} z` : d;
    }), l = S(() => ({
      fill: t.fill,
      pointerEvents: "auto",
      cursor: "auto"
    }));
    return xg(Lt(t, "visible"), {
      ns: n
    }), (s, u) => s.visible ? (k(), x("div", vt({
      key: 0,
      class: i(n).e("mask"),
      style: {
        position: "fixed",
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        zIndex: s.zIndex,
        pointerEvents: s.pos && s.targetAreaClickable ? "none" : "auto"
      }
    }, s.$attrs), [
      (k(), x("svg", { style: {
        width: "100%",
        height: "100%"
      } }, [
        B("path", {
          class: I(i(n).e("hollow")),
          style: ze(i(l)),
          d: i(a)
        }, null, 14, ["d"])
      ]))
    ], 16)) : ee("v-if", true);
  }
});
var zQ = /* @__PURE__ */ $e(HQ, [["__file", "mask.vue"]]);
const KQ = ["absolute", "fixed"], WQ = [
  "top-start",
  "top-end",
  "top",
  "bottom-start",
  "bottom-end",
  "bottom",
  "left-start",
  "left-end",
  "left",
  "right-start",
  "right-end",
  "right"
], wy = Oe({
  placement: {
    type: ne(String),
    values: WQ,
    default: "bottom"
  },
  reference: {
    type: ne(Object),
    default: null
  },
  strategy: {
    type: ne(String),
    values: KQ,
    default: "absolute"
  },
  offset: {
    type: Number,
    default: 10
  },
  showArrow: Boolean,
  zIndex: {
    type: Number,
    default: 2001
  }
}), jQ = {
  close: () => true
}, UQ = /* @__PURE__ */ j({
  name: "ElTourContent"
}), YQ = /* @__PURE__ */ j({
  ...UQ,
  props: wy,
  emits: jQ,
  setup(e10, { emit: t }) {
    const n = e10, o = L(n.placement), r = L(n.strategy), a = L(null), l = L(null);
    ge(() => n.placement, () => {
      o.value = n.placement;
    });
    const { contentStyle: s, arrowStyle: u } = VQ(Lt(n, "reference"), a, l, o, r, Lt(n, "offset"), Lt(n, "zIndex"), Lt(n, "showArrow")), c = S(() => o.value.split("-")[0]), { ns: d } = Le(gp), f = () => {
      t("close");
    }, p = (v) => {
      v.detail.focusReason === "pointer" && v.preventDefault();
    };
    return (v, m) => (k(), x("div", {
      ref_key: "contentRef",
      ref: a,
      style: ze(i(s)),
      class: I(i(d).e("content")),
      "data-side": i(c),
      tabindex: "-1"
    }, [
      W(i(Ni), {
        loop: "",
        trapped: "",
        "focus-start-el": "container",
        "focus-trap-el": a.value || void 0,
        onReleaseRequested: f,
        onFocusoutPrevented: p
      }, {
        default: H(() => [
          J(v.$slots, "default")
        ]),
        _: 3
      }, 8, ["focus-trap-el"]),
      v.showArrow ? (k(), x("span", {
        key: 0,
        ref_key: "arrowRef",
        ref: l,
        style: ze(i(u)),
        class: I(i(d).e("arrow"))
      }, null, 6)) : ee("v-if", true)
    ], 14, ["data-side"]));
  }
});
var qQ = /* @__PURE__ */ $e(YQ, [["__file", "content.vue"]]), GQ = /* @__PURE__ */ j({
  name: "ElTourSteps",
  props: {
    current: {
      type: Number,
      default: 0
    }
  },
  emits: ["update-total"],
  setup(e10, { slots: t, emit: n }) {
    let o = 0;
    return () => {
      var r, a;
      const l = (r = t.default) == null ? void 0 : r.call(t), s = [];
      let u = 0;
      function c(d) {
        Se(d) && d.forEach((f) => {
          var p;
          ((p = (f == null ? void 0 : f.type) || {}) == null ? void 0 : p.name) === "ElTourStep" && (s.push(f), u += 1);
        });
      }
      return l.length && c(Fr((a = l[0]) == null ? void 0 : a.children)), o !== u && (o = u, n("update-total", u)), s.length ? s[e10.current] : null;
    };
  }
});
const XQ = Oe({
  modelValue: Boolean,
  current: {
    type: Number,
    default: 0
  },
  showArrow: {
    type: Boolean,
    default: true
  },
  showClose: {
    type: Boolean,
    default: true
  },
  closeIcon: {
    type: Ht
  },
  placement: wy.placement,
  contentStyle: {
    type: ne([Object])
  },
  mask: {
    type: ne([Boolean, Object]),
    default: true
  },
  gap: {
    type: ne(Object),
    default: () => ({
      offset: 6,
      radius: 2
    })
  },
  zIndex: {
    type: Number
  },
  scrollIntoViewOptions: {
    type: ne([Boolean, Object]),
    default: () => ({
      block: "center"
    })
  },
  type: {
    type: ne(String)
  },
  appendTo: {
    type: rp.to.type,
    default: "body"
  },
  closeOnPressEscape: {
    type: Boolean,
    default: true
  },
  targetAreaClickable: {
    type: Boolean,
    default: true
  }
}), JQ = {
  [nt]: (e10) => Vt(e10),
  "update:current": (e10) => Ye(e10),
  close: (e10) => Ye(e10),
  finish: () => true,
  change: (e10) => Ye(e10)
}, ZQ = /* @__PURE__ */ j({
  name: "ElTour"
}), QQ = /* @__PURE__ */ j({
  ...ZQ,
  props: XQ,
  emits: JQ,
  setup(e10, { emit: t }) {
    const n = e10, o = we("tour"), r = L(0), a = L(), l = vS(n, "current", t, {
      passive: true
    }), s = S(() => {
      var N;
      return (N = a.value) == null ? void 0 : N.target;
    }), u = S(() => [
      o.b(),
      b.value === "primary" ? o.m("primary") : ""
    ]), c = S(() => {
      var N;
      return ((N = a.value) == null ? void 0 : N.placement) || n.placement;
    }), d = S(() => {
      var N, $;
      return ($ = (N = a.value) == null ? void 0 : N.contentStyle) != null ? $ : n.contentStyle;
    }), f = S(() => {
      var N, $;
      return ($ = (N = a.value) == null ? void 0 : N.mask) != null ? $ : n.mask;
    }), p = S(() => !!f.value && n.modelValue), v = S(() => Vt(f.value) ? void 0 : f.value), m = S(() => {
      var N, $;
      return !!s.value && (($ = (N = a.value) == null ? void 0 : N.showArrow) != null ? $ : n.showArrow);
    }), h = S(() => {
      var N, $;
      return ($ = (N = a.value) == null ? void 0 : N.scrollIntoViewOptions) != null ? $ : n.scrollIntoViewOptions;
    }), b = S(() => {
      var N, $;
      return ($ = (N = a.value) == null ? void 0 : N.type) != null ? $ : n.type;
    }), { nextZIndex: g } = Si(), w = g(), y = S(() => {
      var N;
      return (N = n.zIndex) != null ? N : w;
    }), { mergedPosInfo: _, triggerTarget: C } = xQ(s, Lt(n, "modelValue"), Lt(n, "gap"), f, h);
    ge(() => n.modelValue, (N) => {
      N || (l.value = 0);
    });
    const E = () => {
      n.closeOnPressEscape && (t(nt, false), t("close", l.value));
    }, T = (N) => {
      r.value = N;
    }, O = En();
    return yt(gp, {
      currentStep: a,
      current: l,
      total: r,
      showClose: Lt(n, "showClose"),
      closeIcon: Lt(n, "closeIcon"),
      mergedType: b,
      ns: o,
      slots: O,
      updateModelValue(N) {
        t(nt, N);
      },
      onClose() {
        t("close", l.value);
      },
      onFinish() {
        t("finish");
      },
      onChange() {
        t(gt, l.value);
      }
    }), (N, $) => (k(), x(Ie, null, [
      W(i(Ti), { to: N.appendTo }, {
        default: H(() => {
          var R, P;
          return [
            B("div", vt({ class: i(u) }, N.$attrs), [
              W(zQ, {
                visible: i(p),
                fill: (R = i(v)) == null ? void 0 : R.color,
                style: ze((P = i(v)) == null ? void 0 : P.style),
                pos: i(_),
                "z-index": i(y),
                "target-area-clickable": N.targetAreaClickable
              }, null, 8, ["visible", "fill", "style", "pos", "z-index", "target-area-clickable"]),
              N.modelValue ? (k(), ae(qQ, {
                key: i(l),
                reference: i(C),
                placement: i(c),
                "show-arrow": i(m),
                "z-index": i(y),
                style: ze(i(d)),
                onClose: E
              }, {
                default: H(() => [
                  W(i(GQ), {
                    current: i(l),
                    onUpdateTotal: T
                  }, {
                    default: H(() => [
                      J(N.$slots, "default")
                    ]),
                    _: 3
                  }, 8, ["current"])
                ]),
                _: 3
              }, 8, ["reference", "placement", "show-arrow", "z-index", "style"])) : ee("v-if", true)
            ], 16)
          ];
        }),
        _: 3
      }, 8, ["to"]),
      ee(" just for IDE "),
      ee("v-if", true)
    ], 64));
  }
});
var eee = /* @__PURE__ */ $e(QQ, [["__file", "tour.vue"]]);
const tee = Oe({
  target: {
    type: ne([String, Object, Function])
  },
  title: String,
  description: String,
  showClose: {
    type: Boolean,
    default: void 0
  },
  closeIcon: {
    type: Ht
  },
  showArrow: {
    type: Boolean,
    default: void 0
  },
  placement: wy.placement,
  mask: {
    type: ne([Boolean, Object]),
    default: void 0
  },
  contentStyle: {
    type: ne([Object])
  },
  prevButtonProps: {
    type: ne(Object)
  },
  nextButtonProps: {
    type: ne(Object)
  },
  scrollIntoViewOptions: {
    type: ne([Boolean, Object]),
    default: void 0
  },
  type: {
    type: ne(String)
  }
}), nee = {
  close: () => true
}, oee = /* @__PURE__ */ j({
  name: "ElTourStep"
}), ree = /* @__PURE__ */ j({
  ...oee,
  props: tee,
  emits: nee,
  setup(e10, { emit: t }) {
    const n = e10, { Close: o } = xS, { t: r } = kt(), {
      currentStep: a,
      current: l,
      total: s,
      showClose: u,
      closeIcon: c,
      mergedType: d,
      ns: f,
      slots: p,
      updateModelValue: v,
      onClose: m,
      onFinish: h,
      onChange: b
    } = Le(gp);
    ge(n, (O) => {
      a.value = O;
    }, {
      immediate: true
    });
    const g = S(() => {
      var O;
      return (O = n.showClose) != null ? O : u.value;
    }), w = S(() => {
      var O, N;
      return (N = (O = n.closeIcon) != null ? O : c.value) != null ? N : o;
    }), y = (O) => {
      if (O)
        return mL(O, ["children", "onClick"]);
    }, _ = () => {
      var O, N;
      l.value -= 1, (O = n.prevButtonProps) != null && O.onClick && ((N = n.prevButtonProps) == null || N.onClick()), b();
    }, C = () => {
      var O;
      l.value >= s.value - 1 ? E() : l.value += 1, (O = n.nextButtonProps) != null && O.onClick && n.nextButtonProps.onClick(), b();
    }, E = () => {
      T(), h();
    }, T = () => {
      v(false), m(), t("close");
    };
    return (O, N) => (k(), x(Ie, null, [
      i(g) ? (k(), x("button", {
        key: 0,
        "aria-label": "Close",
        class: I(i(f).e("closebtn")),
        type: "button",
        onClick: T
      }, [
        W(i(Be), {
          class: I(i(f).e("close"))
        }, {
          default: H(() => [
            (k(), ae(ht(i(w))))
          ]),
          _: 1
        }, 8, ["class"])
      ], 2)) : ee("v-if", true),
      B("header", {
        class: I([i(f).e("header"), { "show-close": i(u) }])
      }, [
        J(O.$slots, "header", {}, () => [
          B("span", {
            role: "heading",
            class: I(i(f).e("title"))
          }, _e(O.title), 3)
        ])
      ], 2),
      B("div", {
        class: I(i(f).e("body"))
      }, [
        J(O.$slots, "default", {}, () => [
          B("span", null, _e(O.description), 1)
        ])
      ], 2),
      B("footer", {
        class: I(i(f).e("footer"))
      }, [
        B("div", {
          class: I(i(f).b("indicators"))
        }, [
          i(p).indicators ? (k(), ae(ht(i(p).indicators), {
            key: 0,
            current: i(l),
            total: i(s)
          }, null, 8, ["current", "total"])) : (k(true), x(Ie, { key: 1 }, st(i(s), ($, R) => (k(), x("span", {
            key: $,
            class: I([i(f).b("indicator"), R === i(l) ? "is-active" : ""])
          }, null, 2))), 128))
        ], 2),
        B("div", {
          class: I(i(f).b("buttons"))
        }, [
          i(l) > 0 ? (k(), ae(i(Mn), vt({
            key: 0,
            size: "small",
            type: i(d)
          }, y(O.prevButtonProps), { onClick: _ }), {
            default: H(() => {
              var $, R;
              return [
                Ze(_e((R = ($ = O.prevButtonProps) == null ? void 0 : $.children) != null ? R : i(r)("el.tour.previous")), 1)
              ];
            }),
            _: 1
          }, 16, ["type"])) : ee("v-if", true),
          i(l) <= i(s) - 1 ? (k(), ae(i(Mn), vt({
            key: 1,
            size: "small",
            type: i(d) === "primary" ? "default" : "primary"
          }, y(O.nextButtonProps), { onClick: C }), {
            default: H(() => {
              var $, R;
              return [
                Ze(_e((R = ($ = O.nextButtonProps) == null ? void 0 : $.children) != null ? R : i(l) === i(s) - 1 ? i(r)("el.tour.finish") : i(r)("el.tour.next")), 1)
              ];
            }),
            _: 1
          }, 16, ["type"])) : ee("v-if", true)
        ], 2)
      ], 2)
    ], 64));
  }
});
var _T = /* @__PURE__ */ $e(ree, [["__file", "step.vue"]]);
const aee = ut(eee, {
  TourStep: _T
}), lee = nn(_T), see = Oe({
  container: {
    type: ne([
      String,
      Object
    ])
  },
  offset: {
    type: Number,
    default: 0
  },
  bound: {
    type: Number,
    default: 15
  },
  duration: {
    type: Number,
    default: 300
  },
  marker: {
    type: Boolean,
    default: true
  },
  type: {
    type: ne(String),
    default: "default"
  },
  direction: {
    type: ne(String),
    default: "vertical"
  },
  selectScrollTop: {
    type: Boolean,
    default: false
  }
}), iee = {
  change: (e10) => Ve(e10),
  click: (e10, t) => e10 instanceof MouseEvent && (Ve(t) || St(t))
}, wT = Symbol("anchor"), Yc = (e10) => {
  if (!Et || e10 === "")
    return null;
  if (Ve(e10))
    try {
      return document.querySelector(e10);
    } catch {
      return null;
    }
  return e10;
};
function uee(e10) {
  let t = 0;
  const n = (...o) => {
    t && Jl(t), t = sl(() => {
      e10(...o), t = 0;
    });
  };
  return n.cancel = () => {
    Jl(t), t = 0;
  }, n;
}
const cee = /* @__PURE__ */ j({
  name: "ElAnchor"
}), dee = /* @__PURE__ */ j({
  ...cee,
  props: see,
  emits: iee,
  setup(e10, { expose: t, emit: n }) {
    const o = e10, r = L(""), a = L(null), l = L(null), s = L(), u = {};
    let c = false, d = 0;
    const f = we("anchor"), p = S(() => [
      f.b(),
      o.type === "underline" ? f.m("underline") : "",
      f.m(o.direction)
    ]), v = (O) => {
      u[O.href] = O.el;
    }, m = (O) => {
      delete u[O];
    }, h = (O) => {
      r.value !== O && (r.value = O, n(gt, O));
    };
    let b = null;
    const g = (O) => {
      if (!s.value)
        return;
      const N = Yc(O);
      if (!N)
        return;
      b && b(), c = true;
      const $ = M0(N, s.value), R = ah(N, $), P = $.scrollHeight - $.clientHeight, z = Math.min(R - o.offset, P);
      b = wx(s.value, d, z, o.duration, () => {
        setTimeout(() => {
          c = false;
        }, 20);
      });
    }, w = (O) => {
      O && (h(O), g(O));
    }, y = (O, N) => {
      n("click", O, N), w(N);
    }, _ = uee(() => {
      s.value && (d = P0(s.value));
      const O = C();
      c || St(O) || h(O);
    }), C = () => {
      if (!s.value)
        return;
      const O = P0(s.value), N = [];
      for (const $ of Object.keys(u)) {
        const R = Yc($);
        if (!R)
          continue;
        const P = M0(R, s.value), z = ah(R, P);
        N.push({
          top: z - o.offset - o.bound,
          href: $
        });
      }
      N.sort(($, R) => $.top - R.top);
      for (let $ = 0; $ < N.length; $++) {
        const R = N[$], P = N[$ + 1];
        if ($ === 0 && O === 0)
          return o.selectScrollTop ? R.href : "";
        if (R.top <= O && (!P || P.top > O))
          return R.href;
      }
    }, E = () => {
      const O = Yc(o.container);
      !O || Gf(O) ? s.value = window : s.value = O;
    };
    Ft(s, "scroll", _);
    const T = S(() => {
      if (!a.value || !l.value || !r.value)
        return {};
      const O = u[r.value];
      if (!O)
        return {};
      const N = a.value.getBoundingClientRect(), $ = l.value.getBoundingClientRect(), R = O.getBoundingClientRect();
      return o.direction === "horizontal" ? {
        left: `${R.left - N.left}px`,
        width: `${R.width}px`,
        opacity: 1
      } : {
        top: `${R.top - N.top + (R.height - $.height) / 2}px`,
        opacity: 1
      };
    });
    return dt(() => {
      E();
      const O = decodeURIComponent(window.location.hash);
      Yc(O) ? w(O) : _();
    }), ge(() => o.container, () => {
      E();
    }), yt(wT, {
      ns: f,
      direction: o.direction,
      currentAnchor: r,
      addLink: v,
      removeLink: m,
      handleClick: y
    }), t({
      scrollTo: w
    }), (O, N) => (k(), x("div", {
      ref_key: "anchorRef",
      ref: a,
      class: I(i(p))
    }, [
      O.marker ? (k(), x("div", {
        key: 0,
        ref_key: "markerRef",
        ref: l,
        class: I(i(f).e("marker")),
        style: ze(i(T))
      }, null, 6)) : ee("v-if", true),
      B("div", {
        class: I(i(f).e("list"))
      }, [
        J(O.$slots, "default")
      ], 2)
    ], 2));
  }
});
var fee = /* @__PURE__ */ $e(dee, [["__file", "anchor.vue"]]);
const pee = Oe({
  title: String,
  href: String
}), vee = /* @__PURE__ */ j({
  name: "ElAnchorLink"
}), hee = /* @__PURE__ */ j({
  ...vee,
  props: pee,
  setup(e10) {
    const t = e10, n = L(null), {
      ns: o,
      direction: r,
      currentAnchor: a,
      addLink: l,
      removeLink: s,
      handleClick: u
    } = Le(wT), c = S(() => [
      o.e("link"),
      o.is("active", a.value === t.href)
    ]), d = (f) => {
      u(f, t.href);
    };
    return ge(() => t.href, (f, p) => {
      He(() => {
        p && s(p), f && l({
          href: f,
          el: n.value
        });
      });
    }), dt(() => {
      const { href: f } = t;
      f && l({
        href: f,
        el: n.value
      });
    }), jt(() => {
      const { href: f } = t;
      f && s(f);
    }), (f, p) => (k(), x("div", {
      class: I(i(o).e("item"))
    }, [
      B("a", {
        ref_key: "linkRef",
        ref: n,
        class: I(i(c)),
        href: f.href,
        onClick: d
      }, [
        J(f.$slots, "default", {}, () => [
          Ze(_e(f.title), 1)
        ])
      ], 10, ["href"]),
      f.$slots["sub-link"] && i(r) === "vertical" ? (k(), x("div", {
        key: 0,
        class: I(i(o).e("list"))
      }, [
        J(f.$slots, "sub-link")
      ], 2)) : ee("v-if", true)
    ], 2));
  }
});
var CT = /* @__PURE__ */ $e(hee, [["__file", "anchor-link.vue"]]);
const mee = ut(fee, {
  AnchorLink: CT
}), gee = nn(CT), ET = {
  label: "label",
  value: "value",
  disabled: "disabled"
}, yee = Oe({
  direction: {
    type: ne(String),
    default: "horizontal"
  },
  options: {
    type: ne(Array),
    default: () => []
  },
  modelValue: {
    type: [String, Number, Boolean],
    default: void 0
  },
  props: {
    type: ne(Object),
    default: () => ET
  },
  block: Boolean,
  size: _n,
  disabled: Boolean,
  validateEvent: {
    type: Boolean,
    default: true
  },
  id: String,
  name: String,
  ...Bn(["ariaLabel"])
}), bee = {
  [nt]: (e10) => Ve(e10) || Ye(e10) || Vt(e10),
  [gt]: (e10) => Ve(e10) || Ye(e10) || Vt(e10)
}, _ee = /* @__PURE__ */ j({
  name: "ElSegmented"
}), wee = /* @__PURE__ */ j({
  ..._ee,
  props: yee,
  emits: bee,
  setup(e10, { emit: t }) {
    const n = e10, o = we("segmented"), r = Fn(), a = yn(), l = Hn(), { formItem: s } = Yn(), { inputId: u, isLabeledByFormItem: c } = tr(n, {
      formItemContext: s
    }), d = L(null), f = zL(), p = It({
      isInit: false,
      width: 0,
      height: 0,
      translateX: 0,
      translateY: 0,
      focusVisible: false
    }), v = ($) => {
      const R = h($);
      t(nt, R), t(gt, R);
    }, m = S(() => ({ ...ET, ...n.props })), h = ($) => at($) ? $[m.value.value] : $, b = ($) => at($) ? $[m.value.label] : $, g = ($) => !!(l.value || at($) && $[m.value.disabled]), w = ($) => n.modelValue === h($), y = ($) => n.options.find((R) => h(R) === $), _ = ($) => [
      o.e("item"),
      o.is("selected", w($)),
      o.is("disabled", g($))
    ], C = () => {
      if (!d.value)
        return;
      const $ = d.value.querySelector(".is-selected"), R = d.value.querySelector(".is-selected input");
      if (!$ || !R) {
        p.width = 0, p.height = 0, p.translateX = 0, p.translateY = 0, p.focusVisible = false;
        return;
      }
      const P = $.getBoundingClientRect();
      p.isInit = true, n.direction === "vertical" ? (p.height = P.height, p.translateY = $.offsetTop) : (p.width = P.width, p.translateX = $.offsetLeft);
      try {
        p.focusVisible = R.matches(":focus-visible");
      } catch {
      }
    }, E = S(() => [
      o.b(),
      o.m(a.value),
      o.is("block", n.block)
    ]), T = S(() => ({
      width: n.direction === "vertical" ? "100%" : `${p.width}px`,
      height: n.direction === "vertical" ? `${p.height}px` : "100%",
      transform: n.direction === "vertical" ? `translateY(${p.translateY}px)` : `translateX(${p.translateX}px)`,
      display: p.isInit ? "block" : "none"
    })), O = S(() => [
      o.e("item-selected"),
      o.is("disabled", g(y(n.modelValue))),
      o.is("focus-visible", p.focusVisible)
    ]), N = S(() => n.name || r.value);
    return en(d, C), ge(f, C), ge(() => n.modelValue, () => {
      var $;
      C(), n.validateEvent && (($ = s == null ? void 0 : s.validate) == null || $.call(s, "change").catch((R) => _t(R)));
    }, {
      flush: "post"
    }), ($, R) => $.options.length ? (k(), x("div", {
      key: 0,
      id: i(u),
      ref_key: "segmentedRef",
      ref: d,
      class: I(i(E)),
      role: "radiogroup",
      "aria-label": i(c) ? void 0 : $.ariaLabel || "segmented",
      "aria-labelledby": i(c) ? i(s).labelId : void 0
    }, [
      B("div", {
        class: I([i(o).e("group"), i(o).m(n.direction)])
      }, [
        B("div", {
          style: ze(i(T)),
          class: I(i(O))
        }, null, 6),
        (k(true), x(Ie, null, st($.options, (P, z) => (k(), x("label", {
          key: z,
          class: I(_(P))
        }, [
          B("input", {
            class: I(i(o).e("item-input")),
            type: "radio",
            name: i(N),
            disabled: g(P),
            checked: w(P),
            onChange: (Y) => v(P)
          }, null, 42, ["name", "disabled", "checked", "onChange"]),
          B("div", {
            class: I(i(o).e("item-label"))
          }, [
            J($.$slots, "default", { item: P }, () => [
              Ze(_e(b(P)), 1)
            ])
          ], 2)
        ], 2))), 128))
      ], 2)
    ], 10, ["id", "aria-label", "aria-labelledby"])) : ee("v-if", true);
  }
});
var Cee = /* @__PURE__ */ $e(wee, [["__file", "segmented.vue"]]);
const Eee = ut(Cee), See = (e10, t) => {
  const n = e10.toLowerCase();
  return (t.label || t.value).toLowerCase().includes(n);
}, kee = (e10, t, n) => {
  const { selectionEnd: o } = e10;
  if (o === null)
    return;
  const r = e10.value, a = Zn(t);
  let l = -1, s;
  for (let u = o - 1; u >= 0; --u) {
    const c = r[u];
    if (c === n || c === `
` || c === "\r") {
      l = u;
      continue;
    }
    if (a.includes(c)) {
      const d = l === -1 ? o : l;
      s = {
        pattern: r.slice(u + 1, d),
        start: u + 1,
        end: d,
        prefix: c,
        prefixIndex: u,
        splitIndex: l,
        selectionEnd: o
      };
      break;
    }
  }
  return s;
}, Nee = (e10, t = {
  debug: false,
  useSelectionEnd: false
}) => {
  const n = e10.selectionStart !== null ? e10.selectionStart : 0, o = e10.selectionEnd !== null ? e10.selectionEnd : 0, r = t.useSelectionEnd ? o : n, a = [
    "direction",
    "boxSizing",
    "width",
    "height",
    "overflowX",
    "overflowY",
    "borderTopWidth",
    "borderRightWidth",
    "borderBottomWidth",
    "borderLeftWidth",
    "borderStyle",
    "paddingTop",
    "paddingRight",
    "paddingBottom",
    "paddingLeft",
    "fontStyle",
    "fontVariant",
    "fontWeight",
    "fontStretch",
    "fontSize",
    "fontSizeAdjust",
    "lineHeight",
    "fontFamily",
    "textAlign",
    "textTransform",
    "textIndent",
    "textDecoration",
    "letterSpacing",
    "wordSpacing",
    "tabSize",
    "MozTabSize"
  ];
  if (t.debug) {
    const p = document.querySelector("#input-textarea-caret-position-mirror-div");
    p != null && p.parentNode && p.parentNode.removeChild(p);
  }
  const l = document.createElement("div");
  l.id = "input-textarea-caret-position-mirror-div", document.body.appendChild(l);
  const s = l.style, u = window.getComputedStyle(e10), c = e10.nodeName === "INPUT";
  s.whiteSpace = c ? "nowrap" : "pre-wrap", c || (s.wordWrap = "break-word"), s.position = "absolute", t.debug || (s.visibility = "hidden"), a.forEach((p) => {
    if (c && p === "lineHeight")
      if (u.boxSizing === "border-box") {
        const v = Number.parseInt(u.height), m = Number.parseInt(u.paddingTop) + Number.parseInt(u.paddingBottom) + Number.parseInt(u.borderTopWidth) + Number.parseInt(u.borderBottomWidth), h = m + Number.parseInt(u.lineHeight);
        v > h ? s.lineHeight = `${v - m}px` : v === h ? s.lineHeight = u.lineHeight : s.lineHeight = "0";
      } else
        s.lineHeight = u.height;
    else
      s[p] = u[p];
  }), lg() ? e10.scrollHeight > Number.parseInt(u.height) && (s.overflowY = "scroll") : s.overflow = "hidden", l.textContent = e10.value.slice(0, Math.max(0, r)), c && l.textContent && (l.textContent = l.textContent.replace(/\s/g, "\xA0"));
  const d = document.createElement("span");
  d.textContent = e10.value.slice(Math.max(0, r)) || ".", d.style.position = "relative", d.style.left = `${-e10.scrollLeft}px`, d.style.top = `${-e10.scrollTop}px`, l.appendChild(d);
  const f = {
    top: d.offsetTop + Number.parseInt(u.borderTopWidth),
    left: d.offsetLeft + Number.parseInt(u.borderLeftWidth),
    height: Number.parseInt(u.fontSize) * 1.5
  };
  return t.debug ? d.style.backgroundColor = "#aaa" : document.body.removeChild(l), f.left >= e10.clientWidth && (f.left = e10.clientWidth), f;
}, Tee = Oe({
  ...sg,
  options: {
    type: ne(Array),
    default: () => []
  },
  prefix: {
    type: ne([String, Array]),
    default: "@",
    validator: (e10) => Ve(e10) ? e10.length === 1 : e10.every((t) => Ve(t) && t.length === 1)
  },
  split: {
    type: String,
    default: " ",
    validator: (e10) => e10.length === 1
  },
  filterOption: {
    type: ne([Boolean, Function]),
    default: () => See,
    validator: (e10) => e10 === false ? true : Fe(e10)
  },
  placement: {
    type: ne(String),
    default: "bottom"
  },
  showArrow: Boolean,
  offset: {
    type: Number,
    default: 0
  },
  whole: Boolean,
  checkIsWhole: {
    type: ne(Function)
  },
  modelValue: String,
  loading: Boolean,
  popperClass: {
    type: String,
    default: ""
  },
  popperOptions: {
    type: ne(Object),
    default: () => ({})
  }
}), Oee = {
  [nt]: (e10) => Ve(e10),
  input: (e10) => Ve(e10),
  search: (e10, t) => Ve(e10) && Ve(t),
  select: (e10, t) => Ve(e10.value) && Ve(t),
  focus: (e10) => e10 instanceof FocusEvent,
  blur: (e10) => e10 instanceof FocusEvent
}, $ee = Oe({
  options: {
    type: ne(Array),
    default: () => []
  },
  loading: Boolean,
  disabled: Boolean,
  contentId: String,
  ariaLabel: String
}), Iee = {
  select: (e10) => Ve(e10.value)
}, Mee = /* @__PURE__ */ j({
  name: "ElMentionDropdown"
}), Pee = /* @__PURE__ */ j({
  ...Mee,
  props: $ee,
  emits: Iee,
  setup(e10, { expose: t, emit: n }) {
    const o = e10, r = we("mention"), { t: a } = kt(), l = L(-1), s = L(), u = L(), c = L(), d = (y, _) => [
      r.be("dropdown", "item"),
      r.is("hovering", l.value === _),
      r.is("disabled", y.disabled || o.disabled)
    ], f = (y) => {
      y.disabled || o.disabled || n("select", y);
    }, p = (y) => {
      l.value = y;
    }, v = S(() => o.disabled || o.options.every((y) => y.disabled)), m = S(() => o.options[l.value]), h = () => {
      m.value && n("select", m.value);
    }, b = (y) => {
      const { options: _ } = o;
      if (_.length === 0 || v.value)
        return;
      y === "next" ? (l.value++, l.value === _.length && (l.value = 0)) : y === "prev" && (l.value--, l.value < 0 && (l.value = _.length - 1));
      const C = _[l.value];
      if (C.disabled) {
        b(y);
        return;
      }
      He(() => g(C));
    }, g = (y) => {
      var _, C, E, T;
      const { options: O } = o, N = O.findIndex((R) => R.value === y.value), $ = (_ = u.value) == null ? void 0 : _[N];
      if ($) {
        const R = (E = (C = c.value) == null ? void 0 : C.querySelector) == null ? void 0 : E.call(C, `.${r.be("dropdown", "wrap")}`);
        R && ng(R, $);
      }
      (T = s.value) == null || T.handleScroll();
    };
    return ge(() => o.options, () => {
      v.value || o.options.length === 0 ? l.value = -1 : l.value = 0;
    }, {
      immediate: true
    }), t({
      hoveringIndex: l,
      navigateOptions: b,
      selectHoverOption: h,
      hoverOption: m
    }), (y, _) => (k(), x("div", {
      ref_key: "dropdownRef",
      ref: c,
      class: I(i(r).b("dropdown"))
    }, [
      y.$slots.header ? (k(), x("div", {
        key: 0,
        class: I(i(r).be("dropdown", "header"))
      }, [
        J(y.$slots, "header")
      ], 2)) : ee("v-if", true),
      lt(W(i(ta), {
        id: y.contentId,
        ref_key: "scrollbarRef",
        ref: s,
        tag: "ul",
        "wrap-class": i(r).be("dropdown", "wrap"),
        "view-class": i(r).be("dropdown", "list"),
        role: "listbox",
        "aria-label": y.ariaLabel,
        "aria-orientation": "vertical"
      }, {
        default: H(() => [
          (k(true), x(Ie, null, st(y.options, (C, E) => (k(), x("li", {
            id: `${y.contentId}-${E}`,
            ref_for: true,
            ref_key: "optionRefs",
            ref: u,
            key: E,
            class: I(d(C, E)),
            role: "option",
            "aria-disabled": C.disabled || y.disabled || void 0,
            "aria-selected": l.value === E,
            onMousemove: (T) => p(E),
            onClick: Xe((T) => f(C), ["stop"])
          }, [
            J(y.$slots, "label", {
              item: C,
              index: E
            }, () => {
              var T;
              return [
                B("span", null, _e((T = C.label) != null ? T : C.value), 1)
              ];
            })
          ], 42, ["id", "aria-disabled", "aria-selected", "onMousemove", "onClick"]))), 128))
        ]),
        _: 3
      }, 8, ["id", "wrap-class", "view-class", "aria-label"]), [
        [Nt, y.options.length > 0 && !y.loading]
      ]),
      y.loading ? (k(), x("div", {
        key: 1,
        class: I(i(r).be("dropdown", "loading"))
      }, [
        J(y.$slots, "loading", {}, () => [
          Ze(_e(i(a)("el.mention.loading")), 1)
        ])
      ], 2)) : ee("v-if", true),
      y.$slots.footer ? (k(), x("div", {
        key: 2,
        class: I(i(r).be("dropdown", "footer"))
      }, [
        J(y.$slots, "footer")
      ], 2)) : ee("v-if", true)
    ], 2));
  }
});
var Ree = /* @__PURE__ */ $e(Pee, [["__file", "mention-dropdown.vue"]]);
const Aee = /* @__PURE__ */ j({
  name: "ElMention",
  inheritAttrs: false
}), Lee = /* @__PURE__ */ j({
  ...Aee,
  props: Tee,
  emits: Oee,
  setup(e10, { expose: t, emit: n }) {
    const o = e10, r = S(() => sr(o, Object.keys(sg))), a = we("mention"), l = Hn(), s = Fn(), u = L(), c = L(), d = L(), f = L(false), p = L(), v = L(), m = S(() => o.showArrow ? o.placement : `${o.placement}-start`), h = S(() => o.showArrow ? ["bottom", "top"] : ["bottom-start", "top-start"]), b = S(() => {
      const { filterOption: P, options: z } = o;
      return !v.value || !P ? z : z.filter((Y) => P(v.value.pattern, Y));
    }), g = S(() => f.value && (!!b.value.length || o.loading)), w = S(() => {
      var P;
      return `${s.value}-${(P = d.value) == null ? void 0 : P.hoveringIndex}`;
    }), y = (P) => {
      n(nt, P), n(bn, P), N();
    }, _ = (P) => {
      var z, Y, D, M;
      if (!(!("code" in P) || (z = u.value) != null && z.isComposing))
        switch (P.code) {
          case xe.left:
          case xe.right:
            N();
            break;
          case xe.up:
          case xe.down:
            if (!f.value)
              return;
            P.preventDefault(), (Y = d.value) == null || Y.navigateOptions(P.code === xe.up ? "prev" : "next");
            break;
          case xe.enter:
          case xe.numpadEnter:
            if (!f.value)
              return;
            P.preventDefault(), (D = d.value) != null && D.hoverOption ? (M = d.value) == null || M.selectHoverOption() : f.value = false;
            break;
          case xe.esc:
            if (!f.value)
              return;
            P.preventDefault(), f.value = false;
            break;
          case xe.backspace:
            if (o.whole && v.value) {
              const { splitIndex: F, selectionEnd: A, pattern: V, prefixIndex: Z, prefix: G } = v.value, le = O();
              if (!le)
                return;
              const X = le.value, te = o.options.find((pe) => pe.value === V);
              if ((Fe(o.checkIsWhole) ? o.checkIsWhole(V, G) : te) && F !== -1 && F + 1 === A) {
                P.preventDefault();
                const pe = X.slice(0, Z) + X.slice(F + 1);
                n(nt, pe), n(bn, pe);
                const se = Z;
                He(() => {
                  le.selectionStart = se, le.selectionEnd = se, R();
                });
              }
            }
        }
    }, { wrapperRef: C } = pl(u, {
      beforeFocus() {
        return l.value;
      },
      afterFocus() {
        N();
      },
      beforeBlur(P) {
        var z;
        return (z = c.value) == null ? void 0 : z.isFocusInsideContent(P);
      },
      afterBlur() {
        f.value = false;
      }
    }), E = () => {
      N();
    }, T = (P) => {
      if (!v.value)
        return;
      const z = O();
      if (!z)
        return;
      const Y = z.value, { split: D } = o, M = Y.slice(v.value.end), F = M.startsWith(D), A = `${P.value}${F ? "" : D}`, V = Y.slice(0, v.value.start) + A + M;
      n(nt, V), n(bn, V), n("select", P, v.value.prefix);
      const Z = v.value.start + A.length + (F ? 1 : 0);
      He(() => {
        z.selectionStart = Z, z.selectionEnd = Z, z.focus(), R();
      });
    }, O = () => {
      var P, z;
      return o.type === "textarea" ? (P = u.value) == null ? void 0 : P.textarea : (z = u.value) == null ? void 0 : z.input;
    }, N = () => {
      setTimeout(() => {
        $(), R(), He(() => {
          var P;
          return (P = c.value) == null ? void 0 : P.updatePopper();
        });
      }, 0);
    }, $ = () => {
      const P = O();
      if (!P)
        return;
      const z = Nee(P), Y = P.getBoundingClientRect(), D = u.value.$el.getBoundingClientRect();
      p.value = {
        position: "absolute",
        width: 0,
        height: `${z.height}px`,
        left: `${z.left + Y.left - D.left}px`,
        top: `${z.top + Y.top - D.top}px`
      };
    }, R = () => {
      const P = O();
      if (document.activeElement !== P) {
        f.value = false;
        return;
      }
      const { prefix: z, split: Y } = o;
      if (v.value = kee(P, z, Y), v.value && v.value.splitIndex === -1) {
        f.value = true, n("search", v.value.pattern, v.value.prefix);
        return;
      }
      f.value = false;
    };
    return t({
      input: u,
      tooltip: c,
      dropdownVisible: g
    }), (P, z) => (k(), x("div", {
      ref_key: "wrapperRef",
      ref: C,
      class: I(i(a).b())
    }, [
      W(i(eo), vt(vt(i(r), P.$attrs), {
        ref_key: "elInputRef",
        ref: u,
        "model-value": P.modelValue,
        disabled: i(l),
        role: i(g) ? "combobox" : void 0,
        "aria-activedescendant": i(g) ? i(w) || "" : void 0,
        "aria-controls": i(g) ? i(s) : void 0,
        "aria-expanded": i(g) || void 0,
        "aria-label": P.ariaLabel,
        "aria-autocomplete": i(g) ? "none" : void 0,
        "aria-haspopup": i(g) ? "listbox" : void 0,
        onInput: y,
        onKeydown: _,
        onMousedown: E
      }), ro({
        _: 2
      }, [
        st(P.$slots, (Y, D) => ({
          name: D,
          fn: H((M) => [
            J(P.$slots, D, Ao(jr(M)))
          ])
        }))
      ]), 1040, ["model-value", "disabled", "role", "aria-activedescendant", "aria-controls", "aria-expanded", "aria-label", "aria-autocomplete", "aria-haspopup"]),
      W(i(Un), {
        ref_key: "tooltipRef",
        ref: c,
        visible: i(g),
        "popper-class": [i(a).e("popper"), P.popperClass],
        "popper-options": P.popperOptions,
        placement: i(m),
        "fallback-placements": i(h),
        effect: "light",
        pure: "",
        offset: P.offset,
        "show-arrow": P.showArrow
      }, {
        default: H(() => [
          B("div", {
            style: ze(p.value)
          }, null, 4)
        ]),
        content: H(() => {
          var Y;
          return [
            W(Ree, {
              ref_key: "dropdownRef",
              ref: d,
              options: i(b),
              disabled: i(l),
              loading: P.loading,
              "content-id": i(s),
              "aria-label": P.ariaLabel,
              onSelect: T,
              onClick: Xe((Y = u.value) == null ? void 0 : Y.focus, ["stop"])
            }, ro({
              _: 2
            }, [
              st(P.$slots, (D, M) => ({
                name: M,
                fn: H((F) => [
                  J(P.$slots, M, Ao(jr(F)))
                ])
              }))
            ]), 1032, ["options", "disabled", "loading", "content-id", "aria-label", "onClick"])
          ];
        }),
        _: 3
      }, 8, ["visible", "popper-class", "popper-options", "placement", "fallback-placements", "offset", "show-arrow"])
    ], 2));
  }
});
var xee = /* @__PURE__ */ $e(Lee, [["__file", "mention.vue"]]);
const Dee = ut(xee), Vee = Oe({
  layout: {
    type: String,
    default: "horizontal",
    values: ["horizontal", "vertical"]
  }
}), ST = Symbol("splitterRootContextKey");
function Fee(e10) {
  const t = L(), { width: n, height: o } = GL(t), r = S(() => e10.value === "horizontal" ? n.value : o.value);
  return { containerEl: t, containerSize: r };
}
function Cy(e10) {
  return Number(e10.slice(0, -1)) / 100;
}
function Ey(e10) {
  return Number(e10.slice(0, -2));
}
function Sy(e10) {
  return Ve(e10) && e10.endsWith("%");
}
function ky(e10) {
  return Ve(e10) && e10.endsWith("px");
}
function Bee(e10, t) {
  const n = S(() => e10.value.map((s) => s.size)), o = S(() => e10.value.length), r = L([]);
  ge([n, o, t], () => {
    var s;
    let u = [], c = 0;
    for (let f = 0; f < o.value; f += 1) {
      const p = (s = e10.value[f]) == null ? void 0 : s.size;
      if (Sy(p))
        u[f] = Cy(p);
      else if (ky(p))
        u[f] = Ey(p) / t.value;
      else if (p || p === 0) {
        const v = Number(p);
        Number.isNaN(v) || (u[f] = v / t.value);
      } else
        c += 1, u[f] = void 0;
    }
    const d = u.reduce((f, p) => f + (p || 0), 0);
    if (d > 1 || !c) {
      const f = 1 / d;
      u = u.map((p) => p === void 0 ? 0 : p * f);
    } else {
      const f = (1 - d) / c;
      u = u.map((p) => p === void 0 ? f : p);
    }
    r.value = u;
  });
  const a = (s) => s * t.value, l = S(() => r.value.map(a));
  return { percentSizes: r, pxSizes: l };
}
function Hee(e10, t, n) {
  const o = (v) => v * t.value || 0;
  function r(v, m) {
    return Sy(v) ? o(Cy(v)) : ky(v) ? Ey(v) : v != null ? v : m;
  }
  const a = L(null);
  let l = [];
  const s = S(() => e10.value.map((v) => [v.min, v.max])), u = (v) => {
    a.value = { index: v, confirmed: false }, l = n.value;
  }, c = (v, m) => {
    var h, b;
    let g = null;
    if ((!a.value || !a.value.confirmed) && m !== 0) {
      if (m > 0)
        g = v, a.value = { index: v, confirmed: true };
      else
        for (let $ = v; $ >= 0; $ -= 1)
          if (l[$] > 0) {
            g = $, a.value = { index: $, confirmed: true };
            break;
          }
    }
    const w = (b = g != null ? g : (h = a.value) == null ? void 0 : h.index) != null ? b : v, y = [...l], _ = w + 1, C = r(s.value[w][0], 0), E = r(s.value[_][0], 0), T = r(s.value[w][1], t.value || 0), O = r(s.value[_][1], t.value || 0);
    let N = m;
    y[w] + N < C && (N = C - y[w]), y[_] - N < E && (N = y[_] - E), y[w] + N > T && (N = T - y[w]), y[_] - N > O && (N = y[_] - O), y[w] += N, y[_] -= N, e10.value.forEach(($, R) => {
      $.size = y[R];
    });
  }, d = () => {
    a.value = null, l = [];
  }, f = [];
  return { onMoveStart: u, onMoving: c, onMoveEnd: d, movingIndex: a, onCollapse: (v, m) => {
    const h = n.value, b = m === "start" ? v : v + 1, g = m === "start" ? v + 1 : v, w = h[b], y = h[g];
    if (w !== 0 && y !== 0)
      h[b] = 0, h[g] += w, f[v] = w;
    else {
      const _ = w + y, C = f[v], E = _ - C;
      h[g] = C, h[b] = E;
    }
    e10.value.forEach((_, C) => {
      _.size = h[C];
    });
  } };
}
const zee = /* @__PURE__ */ j({
  name: "ElSplitter"
}), Kee = /* @__PURE__ */ j({
  ...zee,
  props: Vee,
  emits: ["resizeStart", "resize", "resizeEnd"],
  setup(e10, { emit: t }) {
    const n = e10, o = we("splitter"), { containerEl: r, containerSize: a } = Fee(Lt(n, "layout")), {
      removeChild: l,
      children: s,
      addChild: u
    } = ap(it(), "ElSplitterPanel");
    ge(s, () => {
      s.value.forEach((y, _) => {
        y.setIndex(_);
      });
    });
    const { percentSizes: c, pxSizes: d } = Bee(s, a), { onMoveStart: f, onMoving: p, onMoveEnd: v, onCollapse: m, movingIndex: h } = Hee(s, a, d), b = (y) => {
      f(y), t("resizeStart", y, d.value);
    }, g = (y, _) => {
      p(y, _), t("resize", y, d.value);
    }, w = (y) => {
      v(), t("resizeEnd", y, d.value);
    };
    return yt(ST, It({
      panels: s,
      percentSizes: c,
      pxSizes: d,
      layout: n.layout,
      movingIndex: h,
      containerSize: a,
      onMoveStart: b,
      onMoving: g,
      onMoveEnd: w,
      onCollapse: m,
      registerPanel: (y) => {
        s.value.push(y);
      },
      sortPanel: u,
      unregisterPanel: l
    })), (y, _) => (k(), x("div", {
      ref_key: "containerEl",
      ref: r,
      class: I([i(o).b(), i(o).e(y.layout)])
    }, [
      J(y.$slots, "default"),
      ee(" Prevent iframe touch events from breaking "),
      i(h) ? (k(), x("div", {
        key: 0,
        class: I([i(o).e("mask"), i(o).e(`mask-${y.layout}`)])
      }, null, 2)) : ee("v-if", true)
    ], 2));
  }
});
var Wee = /* @__PURE__ */ $e(Kee, [["__file", "splitter.vue"]]);
function jee(e10) {
  return e10 && at(e10) ? e10 : {
    start: !!e10,
    end: !!e10
  };
}
function I_(e10, t, n, o) {
  return !!(e10 != null && e10.collapsible.end && t > 0 || n != null && n.collapsible.start && o === 0 && t > 0);
}
const Uee = /* @__PURE__ */ j({
  name: "ElSplitterBar"
}), Yee = /* @__PURE__ */ j({
  ...Uee,
  props: {
    index: {
      type: Number,
      required: true
    },
    layout: {
      type: String,
      values: ["horizontal", "vertical"],
      default: "horizontal"
    },
    resizable: {
      type: Boolean,
      default: true
    },
    startCollapsible: {
      type: Boolean
    },
    endCollapsible: {
      type: Boolean
    }
  },
  emits: ["moveStart", "moving", "moveEnd", "collapse"],
  setup(e10, { emit: t }) {
    const n = e10, o = we("splitter-bar"), r = S(() => n.layout === "horizontal"), a = S(() => r.value ? { width: 0 } : { height: 0 }), l = S(() => ({
      width: r.value ? "16px" : "100%",
      height: r.value ? "100%" : "16px",
      cursor: r.value ? "col-resize" : "row-resize",
      touchAction: "none"
    })), s = S(() => {
      const g = o.e("dragger");
      let w = r.value ? `${g}-horizontal` : `${g}-vertical`;
      return u.value && (w += ` ${g}-active`), w;
    }), u = L(null), c = (g) => {
      n.resizable && (u.value = [g.pageX, g.pageY], t("moveStart", n.index), window.addEventListener("mouseup", v), window.addEventListener("mousemove", f));
    }, d = (g) => {
      if (n.resizable && g.touches.length === 1) {
        g.preventDefault();
        const w = g.touches[0];
        u.value = [w.pageX, w.pageY], t("moveStart", n.index), window.addEventListener("touchend", m), window.addEventListener("touchmove", p);
      }
    }, f = (g) => {
      const { pageX: w, pageY: y } = g, _ = w - u.value[0], C = y - u.value[1], E = r.value ? _ : C;
      t("moving", n.index, E);
    }, p = (g) => {
      if (g.touches.length === 1) {
        g.preventDefault();
        const w = g.touches[0], y = w.pageX - u.value[0], _ = w.pageY - u.value[1], C = r.value ? y : _;
        t("moving", n.index, C);
      }
    }, v = () => {
      u.value = null, window.removeEventListener("mouseup", v), window.removeEventListener("mousemove", f), t("moveEnd", n.index);
    }, m = () => {
      u.value = null, window.removeEventListener("touchend", m), window.removeEventListener("touchmove", p), t("moveEnd", n.index);
    }, h = S(() => r.value ? wa : Zf), b = S(() => r.value ? oo : ea);
    return (g, w) => (k(), x("div", {
      class: I([i(o).b()]),
      style: ze(i(a))
    }, [
      e10.startCollapsible ? (k(), x("div", {
        key: 0,
        class: I([i(o).e("collapse-icon"), i(o).e(`${e10.layout}-collapse-icon-start`)]),
        onClick: (y) => t("collapse", e10.index, "start")
      }, [
        J(g.$slots, "start-collapsible", {}, () => [
          (k(), ae(ht(i(h)), { style: { width: "12px", height: "12px" } }))
        ])
      ], 10, ["onClick"])) : ee("v-if", true),
      B("div", {
        class: I([
          i(o).e("dragger"),
          i(s),
          e10.resizable ? "" : i(o).e("disable")
        ]),
        style: ze(i(l)),
        onMousedown: c,
        onTouchstart: d
      }, null, 38),
      e10.endCollapsible ? (k(), x("div", {
        key: 1,
        class: I([i(o).e("collapse-icon"), i(o).e(`${e10.layout}-collapse-icon-end`)]),
        onClick: (y) => t("collapse", e10.index, "end")
      }, [
        J(g.$slots, "end-collapsible", {}, () => [
          (k(), ae(ht(i(b)), { style: { width: "12px", height: "12px" } }))
        ])
      ], 10, ["onClick"])) : ee("v-if", true)
    ], 6));
  }
});
var qee = /* @__PURE__ */ $e(Yee, [["__file", "split-bar.vue"]]);
const Gee = Oe({
  min: {
    type: [String, Number]
  },
  max: {
    type: [String, Number]
  },
  size: {
    type: [String, Number]
  },
  resizable: {
    type: Boolean,
    default: true
  },
  collapsible: {
    type: Boolean,
    default: false
  }
}), kT = "ElSplitterPanel", Xee = /* @__PURE__ */ j({
  name: kT
}), Jee = /* @__PURE__ */ j({
  ...Xee,
  props: Gee,
  emits: ["update:size"],
  setup(e10, { emit: t }) {
    const n = e10, o = we("splitter-panel"), r = Le(ST);
    r || Qt(kT, "usage: <el-splitter><el-splitter-panel /></el-splitter/>");
    const { panels: a, layout: l, containerSize: s, pxSizes: u } = Tn(r), {
      registerPanel: c,
      sortPanel: d,
      unregisterPanel: f,
      onCollapse: p,
      onMoveEnd: v,
      onMoveStart: m,
      onMoving: h
    } = r, b = L(), g = it().uid, w = L(0), y = S(() => a.value[w.value]), _ = (D) => {
      w.value = D;
    }, C = S(() => {
      var D;
      return y.value && (D = u.value[w.value]) != null ? D : 0;
    }), E = S(() => {
      var D;
      return y.value && (D = u.value[w.value + 1]) != null ? D : 0;
    }), T = S(() => y.value ? a.value[w.value + 1] : null), O = S(() => {
      var D;
      return T.value ? n.resizable && ((D = T.value) == null ? void 0 : D.resizable) && (C.value !== 0 || !n.min) && (E.value !== 0 || !T.value.min) : false;
    }), N = S(() => y.value ? w.value !== a.value.length - 1 : false), $ = S(() => I_(y.value, C.value, T.value, E.value)), R = S(() => I_(T.value, E.value, y.value, C.value));
    function P(D) {
      return Sy(D) ? Cy(D) * s.value || 0 : ky(D) ? Ey(D) : D != null ? D : 0;
    }
    let z = false;
    ge(() => n.size, () => {
      if (y.value) {
        const D = P(n.size), M = P(n.max), F = P(n.min), A = Math.min(Math.max(D, F || 0), M || D);
        A !== D && (z = true, t("update:size", A)), y.value.size = A, He(() => z = false);
      }
    }), ge(() => {
      var D;
      return (D = y.value) == null ? void 0 : D.size;
    }, (D) => {
      !z && D !== n.size && t("update:size", D);
    }), ge(() => n.resizable, (D) => {
      y.value && (y.value.resizable = D);
    });
    const Y = It({
      el: b.value,
      uid: g,
      setIndex: _,
      ...n,
      collapsible: jee(n.collapsible)
    });
    return c(Y), dt(() => {
      d(Y);
    }), Jr(() => f == null ? void 0 : f(g)), (D, M) => (k(), x(Ie, null, [
      B("div", vt({
        ref_key: "panelEl",
        ref: b,
        class: [i(o).b()],
        style: { flexBasis: `${i(C)}px` }
      }, D.$attrs), [
        J(D.$slots, "default")
      ], 16),
      i(N) ? (k(), ae(qee, {
        key: 0,
        index: w.value,
        layout: i(l),
        resizable: i(O),
        "start-collapsible": i($),
        "end-collapsible": i(R),
        onMoveStart: i(m),
        onMoving: i(h),
        onMoveEnd: i(v),
        onCollapse: i(p)
      }, {
        "start-collapsible": H(() => [
          J(D.$slots, "start-collapsible")
        ]),
        "end-collapsible": H(() => [
          J(D.$slots, "end-collapsible")
        ]),
        _: 3
      }, 8, ["index", "layout", "resizable", "start-collapsible", "end-collapsible", "onMoveStart", "onMoving", "onMoveEnd", "onCollapse"])) : ee("v-if", true)
    ], 64));
  }
});
var NT = /* @__PURE__ */ $e(Jee, [["__file", "split-panel.vue"]]);
const Zee = ut(Wee, {
  SplitPanel: NT
}), Qee = nn(NT);
var ete = [
  Nx,
  U8,
  R6,
  bX,
  F6,
  U6,
  v2,
  rF,
  aF,
  Mn,
  _2,
  ZF,
  o5,
  _5,
  w5,
  CB,
  z2,
  OB,
  er,
  L5,
  R2,
  RB,
  GB,
  XB,
  lp,
  bH,
  CH,
  AH,
  LH,
  xH,
  DH,
  VH,
  c9,
  _9,
  w9,
  R9,
  hk,
  K9,
  P7,
  R7,
  A7,
  kk,
  PK,
  RK,
  Be,
  WK,
  $k,
  eo,
  Ik,
  aW,
  dW,
  IW,
  MW,
  PW,
  RW,
  FW,
  Ij,
  xj,
  jj,
  c2,
  Fk,
  B2,
  q5,
  Y5,
  tU,
  lU,
  pU,
  ta,
  Zl,
  df,
  cj,
  UU,
  tY,
  nY,
  wY,
  NY,
  Zk,
  DY,
  UY,
  YY,
  QY,
  uG,
  cG,
  yX,
  AX,
  LX,
  ai,
  ay,
  $z,
  jX,
  JX,
  ZX,
  Un,
  lZ,
  bZ,
  Ef,
  VZ,
  tQ,
  SQ,
  AQ,
  aee,
  lee,
  mee,
  gee,
  Eee,
  Dee,
  Zee,
  Qee
];
const Ko = "ElInfiniteScroll", tte = 50, nte = 200, ote = 0, rte = {
  delay: {
    type: Number,
    default: nte
  },
  distance: {
    type: Number,
    default: ote
  },
  disabled: {
    type: Boolean,
    default: false
  },
  immediate: {
    type: Boolean,
    default: true
  }
}, Ny = (e10, t) => Object.entries(rte).reduce((n, [o, r]) => {
  var a, l;
  const { type: s, default: u } = r, c = e10.getAttribute(`infinite-scroll-${o}`);
  let d = (l = (a = t[c]) != null ? a : c) != null ? l : u;
  return d = d === "false" ? false : d, d = s(d), n[o] = Number.isNaN(d) ? u : d, n;
}, {}), TT = (e10) => {
  const { observer: t } = e10[Ko];
  t && (t.disconnect(), delete e10[Ko].observer);
}, ate = (e10, t) => {
  const { container: n, containerEl: o, instance: r, observer: a, lastScrollTop: l } = e10[Ko], { disabled: s, distance: u } = Ny(e10, r), { clientHeight: c, scrollHeight: d, scrollTop: f } = o, p = f - l;
  if (e10[Ko].lastScrollTop = f, a || s || p < 0)
    return;
  let v = false;
  if (n === e10)
    v = d - (c + f) <= u;
  else {
    const { clientTop: m, scrollHeight: h } = e10, b = ah(e10, o);
    v = f + c >= b + m + h - u;
  }
  v && t.call(r);
};
function bv(e10, t) {
  const { containerEl: n, instance: o } = e10[Ko], { disabled: r } = Ny(e10, o);
  r || n.clientHeight === 0 || (n.scrollHeight <= n.clientHeight ? t.call(o) : TT(e10));
}
const lte = {
  async mounted(e10, t) {
    const { instance: n, value: o } = t;
    Fe(o) || Qt(Ko, "'v-infinite-scroll' binding value must be a function"), await He();
    const { delay: r, immediate: a } = Ny(e10, n), l = tg(e10, true), s = l === window ? document.documentElement : l, u = zl(ate.bind(null, e10, o), r);
    if (l) {
      if (e10[Ko] = {
        instance: n,
        container: l,
        containerEl: s,
        delay: r,
        cb: o,
        onScroll: u,
        lastScrollTop: s.scrollTop
      }, a) {
        const c = new MutationObserver(zl(bv.bind(null, e10, o), tte));
        e10[Ko].observer = c, c.observe(e10, { childList: true, subtree: true }), bv(e10, o);
      }
      l.addEventListener("scroll", u);
    }
  },
  unmounted(e10) {
    if (!e10[Ko])
      return;
    const { container: t, onScroll: n } = e10[Ko];
    t == null || t.removeEventListener("scroll", n), TT(e10);
  },
  async updated(e10) {
    if (!e10[Ko])
      await He();
    else {
      const { containerEl: t, cb: n, observer: o } = e10[Ko];
      t.clientHeight && o && bv(e10, n);
    }
  }
}, Uh = lte;
Uh.install = (e10) => {
  e10.directive("InfiniteScroll", Uh);
};
const ste = Uh;
function ite(e10, t) {
  let n;
  const o = L(false), r = It({
    ...e10,
    originalPosition: "",
    originalOverflow: "",
    visible: false
  });
  function a(v) {
    r.text = v;
  }
  function l() {
    const v = r.parent, m = p.ns;
    if (!v.vLoadingAddClassList) {
      let h = v.getAttribute("loading-number");
      h = Number.parseInt(h) - 1, h ? v.setAttribute("loading-number", h.toString()) : (no(v, m.bm("parent", "relative")), v.removeAttribute("loading-number")), no(v, m.bm("parent", "hidden"));
    }
    s(), f.unmount();
  }
  function s() {
    var v, m;
    (m = (v = p.$el) == null ? void 0 : v.parentNode) == null || m.removeChild(p.$el);
  }
  function u() {
    var v;
    e10.beforeClose && !e10.beforeClose() || (o.value = true, clearTimeout(n), n = setTimeout(c, 400), r.visible = false, (v = e10.closed) == null || v.call(e10));
  }
  function c() {
    if (!o.value)
      return;
    const v = r.parent;
    o.value = false, v.vLoadingAddClassList = void 0, l();
  }
  const f = wE(/* @__PURE__ */ j({
    name: "ElLoading",
    setup(v, { expose: m }) {
      const { ns: h, zIndex: b } = Jf("loading");
      return m({
        ns: h,
        zIndex: b
      }), () => {
        const g = r.spinner || r.svg, w = Ke("svg", {
          class: "circular",
          viewBox: r.svgViewBox ? r.svgViewBox : "0 0 50 50",
          ...g ? { innerHTML: g } : {}
        }, [
          Ke("circle", {
            class: "path",
            cx: "25",
            cy: "25",
            r: "20",
            fill: "none"
          })
        ]), y = r.text ? Ke("p", { class: h.b("text") }, [r.text]) : void 0;
        return Ke(Rn, {
          name: h.b("fade"),
          onAfterLeave: c
        }, {
          default: H(() => [
            lt(W("div", {
              style: {
                backgroundColor: r.background || ""
              },
              class: [
                h.b("mask"),
                r.customClass,
                r.fullscreen ? "is-fullscreen" : ""
              ]
            }, [
              Ke("div", {
                class: h.b("spinner")
              }, [w, y])
            ]), [[Nt, r.visible]])
          ])
        });
      };
    }
  }));
  Object.assign(f._context, t != null ? t : {});
  const p = f.mount(document.createElement("div"));
  return {
    ...Tn(r),
    setText: a,
    removeElLoadingChild: s,
    close: u,
    handleAfterLeave: c,
    vm: p,
    get $el() {
      return p.$el;
    }
  };
}
let qc;
const js = function(e10 = {}) {
  if (!Et)
    return;
  const t = ute(e10);
  if (t.fullscreen && qc)
    return qc;
  const n = ite({
    ...t,
    closed: () => {
      var r;
      (r = t.closed) == null || r.call(t), t.fullscreen && (qc = void 0);
    }
  }, js._context);
  cte(t, t.parent, n), M_(t, t.parent, n), t.parent.vLoadingAddClassList = () => M_(t, t.parent, n);
  let o = t.parent.getAttribute("loading-number");
  return o ? o = `${Number.parseInt(o) + 1}` : o = "1", t.parent.setAttribute("loading-number", o), t.parent.appendChild(n.$el), He(() => n.visible.value = t.visible), t.fullscreen && (qc = n), n;
}, ute = (e10) => {
  var t, n, o, r;
  let a;
  return Ve(e10.target) ? a = (t = document.querySelector(e10.target)) != null ? t : document.body : a = e10.target || document.body, {
    parent: a === document.body || e10.body ? document.body : a,
    background: e10.background || "",
    svg: e10.svg || "",
    svgViewBox: e10.svgViewBox || "",
    spinner: e10.spinner || false,
    text: e10.text || "",
    fullscreen: a === document.body && ((n = e10.fullscreen) != null ? n : true),
    lock: (o = e10.lock) != null ? o : false,
    customClass: e10.customClass || "",
    visible: (r = e10.visible) != null ? r : true,
    beforeClose: e10.beforeClose,
    closed: e10.closed,
    target: a
  };
}, cte = async (e10, t, n) => {
  const { nextZIndex: o } = n.vm.zIndex || n.vm._.exposed.zIndex, r = {};
  if (e10.fullscreen)
    n.originalPosition.value = ha(document.body, "position"), n.originalOverflow.value = ha(document.body, "overflow"), r.zIndex = o();
  else if (e10.parent === document.body) {
    n.originalPosition.value = ha(document.body, "position"), await He();
    for (const a of ["top", "left"]) {
      const l = a === "top" ? "scrollTop" : "scrollLeft";
      r[a] = `${e10.target.getBoundingClientRect()[a] + document.body[l] + document.documentElement[l] - Number.parseInt(ha(document.body, `margin-${a}`), 10)}px`;
    }
    for (const a of ["height", "width"])
      r[a] = `${e10.target.getBoundingClientRect()[a]}px`;
  } else
    n.originalPosition.value = ha(t, "position");
  for (const [a, l] of Object.entries(r))
    n.$el.style[a] = l;
}, M_ = (e10, t, n) => {
  const o = n.vm.ns || n.vm._.exposed.ns;
  ["absolute", "fixed", "sticky"].includes(n.originalPosition.value) ? no(t, o.bm("parent", "relative")) : jo(t, o.bm("parent", "relative")), e10.fullscreen && e10.lock ? jo(t, o.bm("parent", "hidden")) : no(t, o.bm("parent", "hidden"));
};
js._context = null;
const Id = Symbol("ElLoading"), P_ = (e10, t) => {
  var n, o, r, a;
  const l = t.instance, s = (v) => at(t.value) ? t.value[v] : void 0, u = (v) => {
    const m = Ve(v) && (l == null ? void 0 : l[v]) || v;
    return m && L(m);
  }, c = (v) => u(s(v) || e10.getAttribute(`element-loading-${Kr(v)}`)), d = (n = s("fullscreen")) != null ? n : t.modifiers.fullscreen, f = {
    text: c("text"),
    svg: c("svg"),
    svgViewBox: c("svgViewBox"),
    spinner: c("spinner"),
    background: c("background"),
    customClass: c("customClass"),
    fullscreen: d,
    target: (o = s("target")) != null ? o : d ? void 0 : e10,
    body: (r = s("body")) != null ? r : t.modifiers.body,
    lock: (a = s("lock")) != null ? a : t.modifiers.lock
  }, p = js(f);
  p._context = su._context, e10[Id] = {
    options: f,
    instance: p
  };
}, dte = (e10, t) => {
  for (const n of Object.keys(t))
    Ot(t[n]) && (t[n].value = e10[n]);
}, su = {
  mounted(e10, t) {
    t.value && P_(e10, t);
  },
  updated(e10, t) {
    const n = e10[Id];
    t.oldValue !== t.value && (t.value && !t.oldValue ? P_(e10, t) : t.value && t.oldValue ? at(t.value) && dte(t.value, n.options) : n == null || n.instance.close());
  },
  unmounted(e10) {
    var t;
    (t = e10[Id]) == null || t.instance.close(), e10[Id] = null;
  }
};
su._context = null;
const fte = {
  install(e10) {
    js._context = e10._context, su._context = e10._context, e10.directive("loading", su), e10.config.globalProperties.$loading = js;
  },
  directive: su,
  service: js
}, OT = [
  "primary",
  "success",
  "info",
  "warning",
  "error"
], io = rn({
  customClass: "",
  dangerouslyUseHTMLString: false,
  duration: 3e3,
  icon: void 0,
  id: "",
  message: "",
  onClose: void 0,
  showClose: false,
  type: "info",
  plain: false,
  offset: 16,
  zIndex: 0,
  grouping: false,
  repeatNum: 1,
  appendTo: Et ? document.body : void 0
}), pte = Oe({
  customClass: {
    type: String,
    default: io.customClass
  },
  dangerouslyUseHTMLString: {
    type: Boolean,
    default: io.dangerouslyUseHTMLString
  },
  duration: {
    type: Number,
    default: io.duration
  },
  icon: {
    type: Ht,
    default: io.icon
  },
  id: {
    type: String,
    default: io.id
  },
  message: {
    type: ne([
      String,
      Object,
      Function
    ]),
    default: io.message
  },
  onClose: {
    type: ne(Function),
    default: io.onClose
  },
  showClose: {
    type: Boolean,
    default: io.showClose
  },
  type: {
    type: String,
    values: OT,
    default: io.type
  },
  plain: {
    type: Boolean,
    default: io.plain
  },
  offset: {
    type: Number,
    default: io.offset
  },
  zIndex: {
    type: Number,
    default: io.zIndex
  },
  grouping: {
    type: Boolean,
    default: io.grouping
  },
  repeatNum: {
    type: Number,
    default: io.repeatNum
  }
}), vte = {
  destroy: () => true
}, ir = aC([]), hte = (e10) => {
  const t = ir.findIndex((r) => r.id === e10), n = ir[t];
  let o;
  return t > 0 && (o = ir[t - 1]), { current: n, prev: o };
}, mte = (e10) => {
  const { prev: t } = hte(e10);
  return t ? t.vm.exposed.bottom.value : 0;
}, gte = (e10, t) => ir.findIndex((o) => o.id === e10) > 0 ? 16 : t, yte = /* @__PURE__ */ j({
  name: "ElMessage"
}), bte = /* @__PURE__ */ j({
  ...yte,
  props: pte,
  emits: vte,
  setup(e10, { expose: t, emit: n }) {
    const o = e10, { Close: r } = ag, a = L(false), { ns: l, zIndex: s } = Jf("message"), { currentZIndex: u, nextZIndex: c } = s, d = L(), f = L(false), p = L(0);
    let v;
    const m = S(() => o.type ? o.type === "error" ? "danger" : o.type : "info"), h = S(() => {
      const N = o.type;
      return { [l.bm("icon", N)]: N && cl[N] };
    }), b = S(() => o.icon || cl[o.type] || ""), g = S(() => mte(o.id)), w = S(() => gte(o.id, o.offset) + g.value), y = S(() => p.value + w.value), _ = S(() => ({
      top: `${w.value}px`,
      zIndex: u.value
    }));
    function C() {
      o.duration !== 0 && ({ stop: v } = Xl(() => {
        T();
      }, o.duration));
    }
    function E() {
      v == null || v();
    }
    function T() {
      f.value = false, He(() => {
        var N;
        a.value || ((N = o.onClose) == null || N.call(o), n("destroy"));
      });
    }
    function O({ code: N }) {
      N === xe.esc && T();
    }
    return dt(() => {
      C(), c(), f.value = true;
    }), ge(() => o.repeatNum, () => {
      E(), C();
    }), Ft(document, "keydown", O), en(d, () => {
      p.value = d.value.getBoundingClientRect().height;
    }), t({
      visible: f,
      bottom: y,
      close: T
    }), (N, $) => (k(), ae(Rn, {
      name: i(l).b("fade"),
      onBeforeEnter: (R) => a.value = true,
      onBeforeLeave: N.onClose,
      onAfterLeave: (R) => N.$emit("destroy"),
      persisted: ""
    }, {
      default: H(() => [
        lt(B("div", {
          id: N.id,
          ref_key: "messageRef",
          ref: d,
          class: I([
            i(l).b(),
            { [i(l).m(N.type)]: N.type },
            i(l).is("closable", N.showClose),
            i(l).is("plain", N.plain),
            N.customClass
          ]),
          style: ze(i(_)),
          role: "alert",
          onMouseenter: E,
          onMouseleave: C
        }, [
          N.repeatNum > 1 ? (k(), ae(i(v2), {
            key: 0,
            value: N.repeatNum,
            type: i(m),
            class: I(i(l).e("badge"))
          }, null, 8, ["value", "type", "class"])) : ee("v-if", true),
          i(b) ? (k(), ae(i(Be), {
            key: 1,
            class: I([i(l).e("icon"), i(h)])
          }, {
            default: H(() => [
              (k(), ae(ht(i(b))))
            ]),
            _: 1
          }, 8, ["class"])) : ee("v-if", true),
          J(N.$slots, "default", {}, () => [
            N.dangerouslyUseHTMLString ? (k(), x(Ie, { key: 1 }, [
              ee(" Caution here, message could've been compromised, never use user's input as message "),
              B("p", {
                class: I(i(l).e("content")),
                innerHTML: N.message
              }, null, 10, ["innerHTML"])
            ], 2112)) : (k(), x("p", {
              key: 0,
              class: I(i(l).e("content"))
            }, _e(N.message), 3))
          ]),
          N.showClose ? (k(), ae(i(Be), {
            key: 2,
            class: I(i(l).e("closeBtn")),
            onClick: Xe(T, ["stop"])
          }, {
            default: H(() => [
              W(i(r))
            ]),
            _: 1
          }, 8, ["class", "onClick"])) : ee("v-if", true)
        ], 46, ["id"]), [
          [Nt, f.value]
        ])
      ]),
      _: 3
    }, 8, ["name", "onBeforeEnter", "onBeforeLeave", "onAfterLeave"]));
  }
});
var _te = /* @__PURE__ */ $e(bte, [["__file", "message.vue"]]);
let wte = 1;
const $T = (e10) => {
  const t = !e10 || Ve(e10) || Ut(e10) || Fe(e10) ? { message: e10 } : e10, n = {
    ...io,
    ...t
  };
  if (!n.appendTo)
    n.appendTo = document.body;
  else if (Ve(n.appendTo)) {
    let o = document.querySelector(n.appendTo);
    to(o) || (_t("ElMessage", "the appendTo option is not an HTMLElement. Falling back to document.body."), o = document.body), n.appendTo = o;
  }
  return Vt(Po.grouping) && !n.grouping && (n.grouping = Po.grouping), Ye(Po.duration) && n.duration === 3e3 && (n.duration = Po.duration), Ye(Po.offset) && n.offset === 16 && (n.offset = Po.offset), Vt(Po.showClose) && !n.showClose && (n.showClose = Po.showClose), Vt(Po.plain) && !n.plain && (n.plain = Po.plain), n;
}, Cte = (e10) => {
  const t = ir.indexOf(e10);
  if (t === -1)
    return;
  ir.splice(t, 1);
  const { handler: n } = e10;
  n.close();
}, Ete = ({ appendTo: e10, ...t }, n) => {
  const o = `message_${wte++}`, r = t.onClose, a = document.createElement("div"), l = {
    ...t,
    id: o,
    onClose: () => {
      r == null || r(), Cte(d);
    },
    onDestroy: () => {
      al(null, a);
    }
  }, s = W(_te, l, Fe(l.message) || Ut(l.message) ? {
    default: Fe(l.message) ? l.message : () => l.message
  } : null);
  s.appContext = n || pi._context, al(s, a), e10.appendChild(a.firstElementChild);
  const u = s.component, d = {
    id: o,
    vnode: s,
    vm: u,
    handler: {
      close: () => {
        u.exposed.close();
      }
    },
    props: s.component.props
  };
  return d;
}, pi = (e10 = {}, t) => {
  if (!Et)
    return { close: () => {
    } };
  const n = $T(e10);
  if (n.grouping && ir.length) {
    const r = ir.find(({ vnode: a }) => {
      var l;
      return ((l = a.props) == null ? void 0 : l.message) === n.message;
    });
    if (r)
      return r.props.repeatNum += 1, r.props.type = n.type, r.handler;
  }
  if (Ye(Po.max) && ir.length >= Po.max)
    return { close: () => {
    } };
  const o = Ete(n, t);
  return ir.push(o), o.handler;
};
OT.forEach((e10) => {
  pi[e10] = (t = {}, n) => {
    const o = $T(t);
    return pi({ ...o, type: e10 }, n);
  };
});
function Ste(e10) {
  const t = [...ir];
  for (const n of t)
    (!e10 || e10 === n.props.type) && n.handler.close();
}
pi.closeAll = Ste;
pi._context = null;
const IT = OS(pi, "$message"), Yh = "_trap-focus-children", Rl = [], R_ = (e10) => {
  var t;
  if (Rl.length === 0)
    return;
  const n = Rl[Rl.length - 1][Yh];
  if (n.length > 0 && e10.code === xe.tab) {
    if (n.length === 1) {
      e10.preventDefault(), document.activeElement !== n[0] && n[0].focus();
      return;
    }
    const o = e10.shiftKey, r = e10.target === n[0], a = e10.target === n[n.length - 1];
    if (r && o && (e10.preventDefault(), n[n.length - 1].focus()), a && !o && (e10.preventDefault(), n[0].focus()), "development" === "test") {
      const l = n.indexOf(e10.target);
      l !== -1 && ((t = n[o ? l - 1 : l + 1]) == null || t.focus());
    }
  }
}, kte = {
  beforeMount(e10) {
    e10[Yh] = D0(e10), Rl.push(e10), Rl.length <= 1 && document.addEventListener("keydown", R_);
  },
  updated(e10) {
    He(() => {
      e10[Yh] = D0(e10);
    });
  },
  unmounted() {
    Rl.shift(), Rl.length === 0 && document.removeEventListener("keydown", R_);
  }
}, Nte = /* @__PURE__ */ j({
  name: "ElMessageBox",
  directives: {
    TrapFocus: kte
  },
  components: {
    ElButton: Mn,
    ElFocusTrap: Ni,
    ElInput: eo,
    ElOverlay: Lg,
    ElIcon: Be,
    ...ag
  },
  inheritAttrs: false,
  props: {
    buttonSize: {
      type: String,
      validator: tN
    },
    modal: {
      type: Boolean,
      default: true
    },
    lockScroll: {
      type: Boolean,
      default: true
    },
    showClose: {
      type: Boolean,
      default: true
    },
    closeOnClickModal: {
      type: Boolean,
      default: true
    },
    closeOnPressEscape: {
      type: Boolean,
      default: true
    },
    closeOnHashChange: {
      type: Boolean,
      default: true
    },
    center: Boolean,
    draggable: Boolean,
    overflow: Boolean,
    roundButton: {
      default: false,
      type: Boolean
    },
    container: {
      type: String,
      default: "body"
    },
    boxType: {
      type: String,
      default: ""
    }
  },
  emits: ["vanish", "action"],
  setup(e10, { emit: t }) {
    const {
      locale: n,
      zIndex: o,
      ns: r,
      size: a
    } = Jf("message-box", S(() => e10.buttonSize)), { t: l } = n, { nextZIndex: s } = o, u = L(false), c = It({
      autofocus: true,
      beforeClose: null,
      callback: null,
      cancelButtonText: "",
      cancelButtonClass: "",
      confirmButtonText: "",
      confirmButtonClass: "",
      customClass: "",
      customStyle: {},
      dangerouslyUseHTMLString: false,
      distinguishCancelAndClose: false,
      icon: "",
      closeIcon: "",
      inputPattern: null,
      inputPlaceholder: "",
      inputType: "text",
      inputValue: "",
      inputValidator: void 0,
      inputErrorMessage: "",
      message: "",
      modalFade: true,
      modalClass: "",
      showCancelButton: false,
      showConfirmButton: true,
      type: "",
      title: void 0,
      showInput: false,
      action: "",
      confirmButtonLoading: false,
      cancelButtonLoading: false,
      confirmButtonLoadingIcon: ya(Yr),
      cancelButtonLoadingIcon: ya(Yr),
      confirmButtonDisabled: false,
      editorErrorMessage: "",
      validateError: false,
      zIndex: s()
    }), d = S(() => {
      const M = c.type;
      return { [r.bm("icon", M)]: M && cl[M] };
    }), f = Fn(), p = Fn(), v = S(() => {
      const M = c.type;
      return c.icon || M && cl[M] || "";
    }), m = S(() => !!c.message), h = L(), b = L(), g = L(), w = L(), y = L(), _ = S(() => c.confirmButtonClass);
    ge(() => c.inputValue, async (M) => {
      await He(), e10.boxType === "prompt" && M && P();
    }, { immediate: true }), ge(() => u.value, (M) => {
      var F, A;
      M && (e10.boxType !== "prompt" && (c.autofocus ? g.value = (A = (F = y.value) == null ? void 0 : F.$el) != null ? A : h.value : g.value = h.value), c.zIndex = s()), e10.boxType === "prompt" && (M ? He().then(() => {
        var V;
        w.value && w.value.$el && (c.autofocus ? g.value = (V = z()) != null ? V : h.value : g.value = h.value);
      }) : (c.editorErrorMessage = "", c.validateError = false));
    });
    const C = S(() => e10.draggable), E = S(() => e10.overflow);
    dk(h, b, C, E), dt(async () => {
      await He(), e10.closeOnHashChange && window.addEventListener("hashchange", T);
    }), jt(() => {
      e10.closeOnHashChange && window.removeEventListener("hashchange", T);
    });
    function T() {
      u.value && (u.value = false, He(() => {
        c.action && t("action", c.action);
      }));
    }
    const O = () => {
      e10.closeOnClickModal && R(c.distinguishCancelAndClose ? "close" : "cancel");
    }, N = Ag(O), $ = (M) => {
      if (c.inputType !== "textarea")
        return M.preventDefault(), R("confirm");
    }, R = (M) => {
      var F;
      e10.boxType === "prompt" && M === "confirm" && !P() || (c.action = M, c.beforeClose ? (F = c.beforeClose) == null || F.call(c, M, c, T) : T());
    }, P = () => {
      if (e10.boxType === "prompt") {
        const M = c.inputPattern;
        if (M && !M.test(c.inputValue || ""))
          return c.editorErrorMessage = c.inputErrorMessage || l("el.messagebox.error"), c.validateError = true, false;
        const F = c.inputValidator;
        if (Fe(F)) {
          const A = F(c.inputValue);
          if (A === false)
            return c.editorErrorMessage = c.inputErrorMessage || l("el.messagebox.error"), c.validateError = true, false;
          if (Ve(A))
            return c.editorErrorMessage = A, c.validateError = true, false;
        }
      }
      return c.editorErrorMessage = "", c.validateError = false, true;
    }, z = () => {
      var M, F;
      const A = (M = w.value) == null ? void 0 : M.$refs;
      return (F = A == null ? void 0 : A.input) != null ? F : A == null ? void 0 : A.textarea;
    }, Y = () => {
      R("close");
    }, D = () => {
      e10.closeOnPressEscape && Y();
    };
    return e10.lockScroll && xg(u), {
      ...Tn(c),
      ns: r,
      overlayEvent: N,
      visible: u,
      hasMessage: m,
      typeClass: d,
      contentId: f,
      inputId: p,
      btnSize: a,
      iconComponent: v,
      confirmButtonClasses: _,
      rootRef: h,
      focusStartRef: g,
      headerRef: b,
      inputRef: w,
      confirmRef: y,
      doClose: T,
      handleClose: Y,
      onCloseRequested: D,
      handleWrapperClick: O,
      handleInputEnter: $,
      handleAction: R,
      t: l
    };
  }
});
function Tte(e10, t, n, o, r, a) {
  const l = je("el-icon"), s = je("el-input"), u = je("el-button"), c = je("el-focus-trap"), d = je("el-overlay");
  return k(), ae(Rn, {
    name: "fade-in-linear",
    onAfterLeave: (f) => e10.$emit("vanish"),
    persisted: ""
  }, {
    default: H(() => [
      lt(W(d, {
        "z-index": e10.zIndex,
        "overlay-class": [e10.ns.is("message-box"), e10.modalClass],
        mask: e10.modal
      }, {
        default: H(() => [
          B("div", {
            role: "dialog",
            "aria-label": e10.title,
            "aria-modal": "true",
            "aria-describedby": e10.showInput ? void 0 : e10.contentId,
            class: I(`${e10.ns.namespace.value}-overlay-message-box`),
            onClick: e10.overlayEvent.onClick,
            onMousedown: e10.overlayEvent.onMousedown,
            onMouseup: e10.overlayEvent.onMouseup
          }, [
            W(c, {
              loop: "",
              trapped: e10.visible,
              "focus-trap-el": e10.rootRef,
              "focus-start-el": e10.focusStartRef,
              onReleaseRequested: e10.onCloseRequested
            }, {
              default: H(() => [
                B("div", {
                  ref: "rootRef",
                  class: I([
                    e10.ns.b(),
                    e10.customClass,
                    e10.ns.is("draggable", e10.draggable),
                    { [e10.ns.m("center")]: e10.center }
                  ]),
                  style: ze(e10.customStyle),
                  tabindex: "-1",
                  onClick: Xe(() => {
                  }, ["stop"])
                }, [
                  e10.title !== null && e10.title !== void 0 ? (k(), x("div", {
                    key: 0,
                    ref: "headerRef",
                    class: I([e10.ns.e("header"), { "show-close": e10.showClose }])
                  }, [
                    B("div", {
                      class: I(e10.ns.e("title"))
                    }, [
                      e10.iconComponent && e10.center ? (k(), ae(l, {
                        key: 0,
                        class: I([e10.ns.e("status"), e10.typeClass])
                      }, {
                        default: H(() => [
                          (k(), ae(ht(e10.iconComponent)))
                        ]),
                        _: 1
                      }, 8, ["class"])) : ee("v-if", true),
                      B("span", null, _e(e10.title), 1)
                    ], 2),
                    e10.showClose ? (k(), x("button", {
                      key: 0,
                      type: "button",
                      class: I(e10.ns.e("headerbtn")),
                      "aria-label": e10.t("el.messagebox.close"),
                      onClick: (f) => e10.handleAction(e10.distinguishCancelAndClose ? "close" : "cancel"),
                      onKeydown: Bt(Xe((f) => e10.handleAction(e10.distinguishCancelAndClose ? "close" : "cancel"), ["prevent"]), ["enter"])
                    }, [
                      W(l, {
                        class: I(e10.ns.e("close"))
                      }, {
                        default: H(() => [
                          (k(), ae(ht(e10.closeIcon || "close")))
                        ]),
                        _: 1
                      }, 8, ["class"])
                    ], 42, ["aria-label", "onClick", "onKeydown"])) : ee("v-if", true)
                  ], 2)) : ee("v-if", true),
                  B("div", {
                    id: e10.contentId,
                    class: I(e10.ns.e("content"))
                  }, [
                    B("div", {
                      class: I(e10.ns.e("container"))
                    }, [
                      e10.iconComponent && !e10.center && e10.hasMessage ? (k(), ae(l, {
                        key: 0,
                        class: I([e10.ns.e("status"), e10.typeClass])
                      }, {
                        default: H(() => [
                          (k(), ae(ht(e10.iconComponent)))
                        ]),
                        _: 1
                      }, 8, ["class"])) : ee("v-if", true),
                      e10.hasMessage ? (k(), x("div", {
                        key: 1,
                        class: I(e10.ns.e("message"))
                      }, [
                        J(e10.$slots, "default", {}, () => [
                          e10.dangerouslyUseHTMLString ? (k(), ae(ht(e10.showInput ? "label" : "p"), {
                            key: 1,
                            for: e10.showInput ? e10.inputId : void 0,
                            innerHTML: e10.message
                          }, null, 8, ["for", "innerHTML"])) : (k(), ae(ht(e10.showInput ? "label" : "p"), {
                            key: 0,
                            for: e10.showInput ? e10.inputId : void 0
                          }, {
                            default: H(() => [
                              Ze(_e(e10.dangerouslyUseHTMLString ? "" : e10.message), 1)
                            ]),
                            _: 1
                          }, 8, ["for"]))
                        ])
                      ], 2)) : ee("v-if", true)
                    ], 2),
                    lt(B("div", {
                      class: I(e10.ns.e("input"))
                    }, [
                      W(s, {
                        id: e10.inputId,
                        ref: "inputRef",
                        modelValue: e10.inputValue,
                        "onUpdate:modelValue": (f) => e10.inputValue = f,
                        type: e10.inputType,
                        placeholder: e10.inputPlaceholder,
                        "aria-invalid": e10.validateError,
                        class: I({ invalid: e10.validateError }),
                        onKeydown: Bt(e10.handleInputEnter, ["enter"])
                      }, null, 8, ["id", "modelValue", "onUpdate:modelValue", "type", "placeholder", "aria-invalid", "class", "onKeydown"]),
                      B("div", {
                        class: I(e10.ns.e("errormsg")),
                        style: ze({
                          visibility: e10.editorErrorMessage ? "visible" : "hidden"
                        })
                      }, _e(e10.editorErrorMessage), 7)
                    ], 2), [
                      [Nt, e10.showInput]
                    ])
                  ], 10, ["id"]),
                  B("div", {
                    class: I(e10.ns.e("btns"))
                  }, [
                    e10.showCancelButton ? (k(), ae(u, {
                      key: 0,
                      loading: e10.cancelButtonLoading,
                      "loading-icon": e10.cancelButtonLoadingIcon,
                      class: I([e10.cancelButtonClass]),
                      round: e10.roundButton,
                      size: e10.btnSize,
                      onClick: (f) => e10.handleAction("cancel"),
                      onKeydown: Bt(Xe((f) => e10.handleAction("cancel"), ["prevent"]), ["enter"])
                    }, {
                      default: H(() => [
                        Ze(_e(e10.cancelButtonText || e10.t("el.messagebox.cancel")), 1)
                      ]),
                      _: 1
                    }, 8, ["loading", "loading-icon", "class", "round", "size", "onClick", "onKeydown"])) : ee("v-if", true),
                    lt(W(u, {
                      ref: "confirmRef",
                      type: "primary",
                      loading: e10.confirmButtonLoading,
                      "loading-icon": e10.confirmButtonLoadingIcon,
                      class: I([e10.confirmButtonClasses]),
                      round: e10.roundButton,
                      disabled: e10.confirmButtonDisabled,
                      size: e10.btnSize,
                      onClick: (f) => e10.handleAction("confirm"),
                      onKeydown: Bt(Xe((f) => e10.handleAction("confirm"), ["prevent"]), ["enter"])
                    }, {
                      default: H(() => [
                        Ze(_e(e10.confirmButtonText || e10.t("el.messagebox.confirm")), 1)
                      ]),
                      _: 1
                    }, 8, ["loading", "loading-icon", "class", "round", "disabled", "size", "onClick", "onKeydown"]), [
                      [Nt, e10.showConfirmButton]
                    ])
                  ], 2)
                ], 14, ["onClick"])
              ]),
              _: 3
            }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onReleaseRequested"])
          ], 42, ["aria-label", "aria-describedby", "onClick", "onMousedown", "onMouseup"])
        ]),
        _: 3
      }, 8, ["z-index", "overlay-class", "mask"]), [
        [Nt, e10.visible]
      ])
    ]),
    _: 3
  }, 8, ["onAfterLeave"]);
}
var Ote = /* @__PURE__ */ $e(Nte, [["render", Tte], ["__file", "index.vue"]]);
const Vu = /* @__PURE__ */ new Map(), $te = (e10) => {
  let t = document.body;
  return e10.appendTo && (Ve(e10.appendTo) && (t = document.querySelector(e10.appendTo)), to(e10.appendTo) && (t = e10.appendTo), to(t) || (_t("ElMessageBox", "the appendTo option is not an HTMLElement. Falling back to document.body."), t = document.body)), t;
}, Ite = (e10, t, n = null) => {
  const o = W(Ote, e10, Fe(e10.message) || Ut(e10.message) ? {
    default: Fe(e10.message) ? e10.message : () => e10.message
  } : null);
  return o.appContext = n, al(o, t), $te(e10).appendChild(t.firstElementChild), o.component;
}, Mte = () => document.createElement("div"), Pte = (e10, t) => {
  const n = Mte();
  e10.onVanish = () => {
    al(null, n), Vu.delete(r);
  }, e10.onAction = (a) => {
    const l = Vu.get(r);
    let s;
    e10.showInput ? s = { value: r.inputValue, action: a } : s = a, e10.callback ? e10.callback(s, o.proxy) : a === "cancel" || a === "close" ? e10.distinguishCancelAndClose && a !== "cancel" ? l.reject("close") : l.reject("cancel") : l.resolve(s);
  };
  const o = Ite(e10, n, t), r = o.proxy;
  for (const a in e10)
    Tt(e10, a) && !Tt(r.$props, a) && (a === "closeIcon" && at(e10[a]) ? r[a] = ya(e10[a]) : r[a] = e10[a]);
  return r.visible = true, r;
};
function Mi(e10, t = null) {
  if (!Et)
    return Promise.reject();
  let n;
  return Ve(e10) || Ut(e10) ? e10 = {
    message: e10
  } : n = e10.callback, new Promise((o, r) => {
    const a = Pte(e10, t != null ? t : Mi._context);
    Vu.set(a, {
      options: e10,
      callback: n,
      resolve: o,
      reject: r
    });
  });
}
const Rte = ["alert", "confirm", "prompt"], Ate = {
  alert: { closeOnPressEscape: false, closeOnClickModal: false },
  confirm: { showCancelButton: true },
  prompt: { showCancelButton: true, showInput: true }
};
Rte.forEach((e10) => {
  Mi[e10] = Lte(e10);
});
function Lte(e10) {
  return (t, n, o, r) => {
    let a = "";
    return at(n) ? (o = n, a = "") : St(n) ? a = "" : a = n, Mi(Object.assign({
      title: a,
      message: t,
      type: "",
      ...Ate[e10]
    }, o, {
      boxType: e10
    }), r);
  };
}
Mi.close = () => {
  Vu.forEach((e10, t) => {
    t.doClose();
  }), Vu.clear();
};
Mi._context = null;
const ja = Mi;
ja.install = (e10) => {
  ja._context = e10._context, e10.config.globalProperties.$msgbox = ja, e10.config.globalProperties.$messageBox = ja, e10.config.globalProperties.$alert = ja.alert, e10.config.globalProperties.$confirm = ja.confirm, e10.config.globalProperties.$prompt = ja.prompt;
};
const xte = ja, MT = [
  "primary",
  "success",
  "info",
  "warning",
  "error"
], Dte = Oe({
  customClass: {
    type: String,
    default: ""
  },
  dangerouslyUseHTMLString: Boolean,
  duration: {
    type: Number,
    default: 4500
  },
  icon: {
    type: Ht
  },
  id: {
    type: String,
    default: ""
  },
  message: {
    type: ne([
      String,
      Object,
      Function
    ]),
    default: ""
  },
  offset: {
    type: Number,
    default: 0
  },
  onClick: {
    type: ne(Function),
    default: () => {
    }
  },
  onClose: {
    type: ne(Function),
    required: true
  },
  position: {
    type: String,
    values: ["top-right", "top-left", "bottom-right", "bottom-left"],
    default: "top-right"
  },
  showClose: {
    type: Boolean,
    default: true
  },
  title: {
    type: String,
    default: ""
  },
  type: {
    type: String,
    values: [...MT, ""],
    default: ""
  },
  zIndex: Number,
  closeIcon: {
    type: Ht,
    default: Jo
  }
}), Vte = {
  destroy: () => true
}, Fte = /* @__PURE__ */ j({
  name: "ElNotification"
}), Bte = /* @__PURE__ */ j({
  ...Fte,
  props: Dte,
  emits: Vte,
  setup(e10, { expose: t }) {
    const n = e10, { ns: o, zIndex: r } = Jf("notification"), { nextZIndex: a, currentZIndex: l } = r, s = L(false);
    let u;
    const c = S(() => {
      const w = n.type;
      return w && cl[n.type] ? o.m(w) : "";
    }), d = S(() => n.type && cl[n.type] || n.icon), f = S(() => n.position.endsWith("right") ? "right" : "left"), p = S(() => n.position.startsWith("top") ? "top" : "bottom"), v = S(() => {
      var w;
      return {
        [p.value]: `${n.offset}px`,
        zIndex: (w = n.zIndex) != null ? w : l.value
      };
    });
    function m() {
      n.duration > 0 && ({ stop: u } = Xl(() => {
        s.value && b();
      }, n.duration));
    }
    function h() {
      u == null || u();
    }
    function b() {
      s.value = false;
    }
    function g({ code: w }) {
      w === xe.delete || w === xe.backspace ? h() : w === xe.esc ? s.value && b() : m();
    }
    return dt(() => {
      m(), a(), s.value = true;
    }), Ft(document, "keydown", g), t({
      visible: s,
      close: b
    }), (w, y) => (k(), ae(Rn, {
      name: i(o).b("fade"),
      onBeforeLeave: w.onClose,
      onAfterLeave: (_) => w.$emit("destroy"),
      persisted: ""
    }, {
      default: H(() => [
        lt(B("div", {
          id: w.id,
          class: I([i(o).b(), w.customClass, i(f)]),
          style: ze(i(v)),
          role: "alert",
          onMouseenter: h,
          onMouseleave: m,
          onClick: w.onClick
        }, [
          i(d) ? (k(), ae(i(Be), {
            key: 0,
            class: I([i(o).e("icon"), i(c)])
          }, {
            default: H(() => [
              (k(), ae(ht(i(d))))
            ]),
            _: 1
          }, 8, ["class"])) : ee("v-if", true),
          B("div", {
            class: I(i(o).e("group"))
          }, [
            B("h2", {
              class: I(i(o).e("title")),
              textContent: _e(w.title)
            }, null, 10, ["textContent"]),
            lt(B("div", {
              class: I(i(o).e("content")),
              style: ze(w.title ? void 0 : { margin: 0 })
            }, [
              J(w.$slots, "default", {}, () => [
                w.dangerouslyUseHTMLString ? (k(), x(Ie, { key: 1 }, [
                  ee(" Caution here, message could've been compromised, never use user's input as message "),
                  B("p", { innerHTML: w.message }, null, 8, ["innerHTML"])
                ], 2112)) : (k(), x("p", { key: 0 }, _e(w.message), 1))
              ])
            ], 6), [
              [Nt, w.message]
            ]),
            w.showClose ? (k(), ae(i(Be), {
              key: 0,
              class: I(i(o).e("closeBtn")),
              onClick: Xe(b, ["stop"])
            }, {
              default: H(() => [
                (k(), ae(ht(w.closeIcon)))
              ]),
              _: 1
            }, 8, ["class", "onClick"])) : ee("v-if", true)
          ], 2)
        ], 46, ["id", "onClick"]), [
          [Nt, s.value]
        ])
      ]),
      _: 3
    }, 8, ["name", "onBeforeLeave", "onAfterLeave"]));
  }
});
var Hte = /* @__PURE__ */ $e(Bte, [["__file", "notification.vue"]]);
const Sf = {
  "top-left": [],
  "top-right": [],
  "bottom-left": [],
  "bottom-right": []
}, qh = 16;
let zte = 1;
const vi = function(e10 = {}, t) {
  if (!Et)
    return { close: () => {
    } };
  (Ve(e10) || Ut(e10)) && (e10 = { message: e10 });
  const n = e10.position || "top-right";
  let o = e10.offset || 0;
  Sf[n].forEach(({ vm: d }) => {
    var f;
    o += (((f = d.el) == null ? void 0 : f.offsetHeight) || 0) + qh;
  }), o += qh;
  const r = `notification_${zte++}`, a = e10.onClose, l = {
    ...e10,
    offset: o,
    id: r,
    onClose: () => {
      Kte(r, n, a);
    }
  };
  let s = document.body;
  to(e10.appendTo) ? s = e10.appendTo : Ve(e10.appendTo) && (s = document.querySelector(e10.appendTo)), to(s) || (_t("ElNotification", "the appendTo option is not an HTMLElement. Falling back to document.body."), s = document.body);
  const u = document.createElement("div"), c = W(Hte, l, Fe(l.message) ? l.message : Ut(l.message) ? () => l.message : null);
  return c.appContext = St(t) ? vi._context : t, c.props.onDestroy = () => {
    al(null, u);
  }, al(c, u), Sf[n].push({ vm: c }), s.appendChild(u.firstElementChild), {
    close: () => {
      c.component.exposed.visible.value = false;
    }
  };
};
MT.forEach((e10) => {
  vi[e10] = (t = {}, n) => ((Ve(t) || Ut(t)) && (t = {
    message: t
  }), vi({ ...t, type: e10 }, n));
});
function Kte(e10, t, n) {
  const o = Sf[t], r = o.findIndex(({ vm: c }) => {
    var d;
    return ((d = c.component) == null ? void 0 : d.props.id) === e10;
  });
  if (r === -1)
    return;
  const { vm: a } = o[r];
  if (!a)
    return;
  n == null || n(a);
  const l = a.el.offsetHeight, s = t.split("-")[0];
  o.splice(r, 1);
  const u = o.length;
  if (!(u < 1))
    for (let c = r; c < u; c++) {
      const { el: d, component: f } = o[c].vm, p = Number.parseInt(d.style[s], 10) - l - qh;
      f.props.offset = p;
    }
}
function Wte() {
  for (const e10 of Object.values(Sf))
    e10.forEach(({ vm: t }) => {
      t.component.exposed.visible.value = false;
    });
}
vi.closeAll = Wte;
vi._context = null;
const jte = OS(vi, "$notify");
var Ute = [
  ste,
  fte,
  IT,
  xte,
  jte,
  Vk
], Yte = hx([...ete, ...Ute]), qte = Object.defineProperty, xt = (e10, t) => qte(e10, "name", { value: t, configurable: true });
function Gte() {
}
xt(Gte, "noop");
function vo(e10) {
  return e10 == null;
}
xt(vo, "isNullable");
function Xte(e10) {
  return !vo(e10);
}
xt(Xte, "isNonNullable");
function Jte(e10) {
  return e10 && typeof e10 == "object" && !Array.isArray(e10);
}
xt(Jte, "isPlainObject");
function Zte(e10, t) {
  return Object.fromEntries(Object.entries(e10).filter(([n, o]) => t(n, o)));
}
xt(Zte, "filterKeys");
function PT(e10, t) {
  return Object.fromEntries(Object.entries(e10).map(([n, o]) => [n, t(o, n)]));
}
xt(PT, "mapValues");
function Qte(e10, t, n) {
  if (!t) return { ...e10 };
  const o = {};
  for (const r of t)
    (n || e10[r] !== void 0) && (o[r] = e10[r]);
  return o;
}
xt(Qte, "pick");
function ene(e10, t) {
  if (!t) return { ...e10 };
  const n = { ...e10 };
  for (const o of t)
    Reflect.deleteProperty(n, o);
  return n;
}
xt(ene, "omit");
function tne(e10, t, n) {
  return Object.defineProperty(e10, t, { writable: true, value: n, enumerable: false });
}
xt(tne, "defineProperty");
function nne(e10, t) {
  return t.every((n) => e10.includes(n));
}
xt(nne, "contain");
function one(e10, t) {
  return e10.filter((n) => t.includes(n));
}
xt(one, "intersection");
function RT(e10, t) {
  return e10.filter((n) => !t.includes(n));
}
xt(RT, "difference");
function AT(e10, t) {
  return Array.from(/* @__PURE__ */ new Set([...e10, ...t]));
}
xt(AT, "union");
function rne(e10) {
  return [...new Set(e10)];
}
xt(rne, "deduplicate");
function ane(e10, t) {
  const n = e10 == null ? void 0 : e10.indexOf(t);
  return n >= 0 ? (e10.splice(n, 1), true) : false;
}
xt(ane, "remove");
function lne(e10) {
  return Array.isArray(e10) ? e10 : vo(e10) ? [] : [e10];
}
xt(lne, "makeArray");
function fl(e10, t) {
  return arguments.length === 1 ? (n) => fl(e10, n) : e10 in globalThis && t instanceof globalThis[e10] || Object.prototype.toString.call(t).slice(8, -1) === e10;
}
xt(fl, "is");
function bc(e10) {
  return fl("ArrayBuffer", e10) || fl("SharedArrayBuffer", e10);
}
xt(bc, "isArrayBufferLike");
function LT(e10) {
  return bc(e10) || ArrayBuffer.isView(e10);
}
xt(LT, "isArrayBufferSource");
var hi;
((e10) => {
  e10.is = bc, e10.isSource = LT;
  function t(l) {
    return ArrayBuffer.isView(l) ? l.buffer.slice(l.byteOffset, l.byteOffset + l.byteLength) : l;
  }
  e10.fromSource = t, xt(t, "fromSource");
  function n(l) {
    if (typeof Buffer < "u")
      return Buffer.from(l).toString("base64");
    let s = "";
    const u = new Uint8Array(l);
    for (let c = 0; c < u.byteLength; c++)
      s += String.fromCharCode(u[c]);
    return btoa(s);
  }
  e10.toBase64 = n, xt(n, "toBase64");
  function o(l) {
    return typeof Buffer < "u" ? t(Buffer.from(l, "base64")) : Uint8Array.from(atob(l), (s) => s.charCodeAt(0));
  }
  e10.fromBase64 = o, xt(o, "fromBase64");
  function r(l) {
    return typeof Buffer < "u" ? Buffer.from(l).toString("hex") : Array.from(new Uint8Array(l), (s) => s.toString(16).padStart(2, "0")).join("");
  }
  e10.toHex = r, xt(r, "toHex");
  function a(l) {
    if (typeof Buffer < "u") return t(Buffer.from(l, "hex"));
    const s = l.length % 2 === 0 ? l : l.slice(0, l.length - 1), u = [];
    for (let c = 0; c < s.length; c += 2)
      u.push(parseInt(`${s[c]}${s[c + 1]}`, 16));
    return Uint8Array.from(u).buffer;
  }
  e10.fromHex = a, xt(a, "fromHex");
})(hi || (hi = {}));
hi.fromBase64;
hi.toBase64;
hi.fromHex;
hi.toHex;
function Fu(e10, t = /* @__PURE__ */ new Map()) {
  if (!e10 || typeof e10 != "object") return e10;
  if (fl("Date", e10)) return new Date(e10.valueOf());
  if (fl("RegExp", e10)) return new RegExp(e10.source, e10.flags);
  if (bc(e10)) return e10.slice(0);
  if (ArrayBuffer.isView(e10)) return e10.buffer.slice(e10.byteOffset, e10.byteOffset + e10.byteLength);
  const n = t.get(e10);
  if (n) return n;
  if (Array.isArray(e10)) {
    const r = [];
    return t.set(e10, r), e10.forEach((a, l) => {
      r[l] = Reflect.apply(Fu, null, [a, t]);
    }), r;
  }
  const o = Object.create(Object.getPrototypeOf(e10));
  t.set(e10, o);
  for (const r of Reflect.ownKeys(e10)) {
    const a = { ...Reflect.getOwnPropertyDescriptor(e10, r) };
    "value" in a && (a.value = Reflect.apply(Fu, null, [a.value, t])), Reflect.defineProperty(o, r, a);
  }
  return o;
}
xt(Fu, "clone");
function ns(e10, t, n) {
  var _a2, _b2, _c2, _d2;
  if (e10 === t || !n && vo(e10) && vo(t)) return true;
  if (typeof e10 != typeof t || typeof e10 != "object" || !e10 || !t) return false;
  function o(r, a) {
    return r(e10) ? r(t) ? a(e10, t) : false : r(t) ? false : void 0;
  }
  return xt(o, "check"), (_d2 = (_c2 = (_b2 = (_a2 = o(Array.isArray, (r, a) => r.length === a.length && r.every((l, s) => ns(l, a[s])))) != null ? _a2 : o(fl("Date"), (r, a) => r.valueOf() === a.valueOf())) != null ? _b2 : o(fl("RegExp"), (r, a) => r.source === a.source && r.flags === a.flags)) != null ? _c2 : o(bc, (r, a) => {
    if (r.byteLength !== a.byteLength) return false;
    const l = new Uint8Array(r), s = new Uint8Array(a);
    for (let u = 0; u < l.length; u++)
      if (l[u] !== s[u]) return false;
    return true;
  })) != null ? _d2 : Object.keys({ ...e10, ...t }).every((r) => ns(e10[r], t[r], n));
}
xt(ns, "deepEqual");
function sne(e10) {
  return e10.charAt(0).toUpperCase() + e10.slice(1);
}
xt(sne, "capitalize");
function Ty(e10) {
  return e10.charAt(0).toLowerCase() + e10.slice(1);
}
xt(Ty, "uncapitalize");
function ine(e10) {
  return e10.replace(/[_-][a-z]/g, (t) => t.slice(1).toUpperCase());
}
xt(ine, "camelCase");
function une(e10) {
  return Ty(e10).replace(/_/g, "-").replace(/.[A-Z]+/g, (t) => t[0] + "-" + t.slice(1).toLowerCase());
}
xt(une, "paramCase");
function cne(e10) {
  return Ty(e10).replace(/-/g, "_").replace(/.[A-Z]+/g, (t) => t[0] + "_" + t.slice(1).toLowerCase());
}
xt(cne, "snakeCase");
function xT(e10) {
  return e10.replace(/\/$/, "");
}
xt(xT, "trimSlash");
function dne(e10) {
  return e10.startsWith("/") || (e10 = "/" + e10), xT(e10);
}
xt(dne, "sanitize");
var A_;
((e10) => {
  e10.millisecond = 1, e10.second = 1e3, e10.minute = e10.second * 60, e10.hour = e10.minute * 60, e10.day = e10.hour * 24, e10.week = e10.day * 7;
  let t = (/* @__PURE__ */ new Date()).getTimezoneOffset();
  function n(v) {
    t = v;
  }
  e10.setTimezoneOffset = n, xt(n, "setTimezoneOffset");
  function o() {
    return t;
  }
  e10.getTimezoneOffset = o, xt(o, "getTimezoneOffset");
  function r(v = /* @__PURE__ */ new Date(), m) {
    return typeof v == "number" && (v = new Date(v)), m === void 0 && (m = t), Math.floor((v.valueOf() / e10.minute - m) / 1440);
  }
  e10.getDateNumber = r, xt(r, "getDateNumber");
  function a(v, m) {
    const h = new Date(v * e10.day);
    return m === void 0 && (m = t), new Date(+h + m * e10.minute);
  }
  e10.fromDateNumber = a, xt(a, "fromDateNumber");
  const l = /\d+(?:\.\d+)?/.source, s = new RegExp(`^${[
    "w(?:eek(?:s)?)?",
    "d(?:ay(?:s)?)?",
    "h(?:our(?:s)?)?",
    "m(?:in(?:ute)?(?:s)?)?",
    "s(?:ec(?:ond)?(?:s)?)?"
  ].map((v) => `(${l}${v})?`).join("")}$`);
  function u(v) {
    const m = s.exec(v);
    return m ? (parseFloat(m[1]) * e10.week || 0) + (parseFloat(m[2]) * e10.day || 0) + (parseFloat(m[3]) * e10.hour || 0) + (parseFloat(m[4]) * e10.minute || 0) + (parseFloat(m[5]) * e10.second || 0) : 0;
  }
  e10.parseTime = u, xt(u, "parseTime");
  function c(v) {
    const m = u(v);
    return m ? v = Date.now() + m : /^\d{1,2}(:\d{1,2}){1,2}$/.test(v) ? v = `${(/* @__PURE__ */ new Date()).toLocaleDateString()}-${v}` : /^\d{1,2}-\d{1,2}-\d{1,2}(:\d{1,2}){1,2}$/.test(v) && (v = `${(/* @__PURE__ */ new Date()).getFullYear()}-${v}`), v ? new Date(v) : /* @__PURE__ */ new Date();
  }
  e10.parseDate = c, xt(c, "parseDate");
  function d(v) {
    const m = Math.abs(v);
    return m >= e10.day - e10.hour / 2 ? Math.round(v / e10.day) + "d" : m >= e10.hour - e10.minute / 2 ? Math.round(v / e10.hour) + "h" : m >= e10.minute - e10.second / 2 ? Math.round(v / e10.minute) + "m" : m >= e10.second ? Math.round(v / e10.second) + "s" : v + "ms";
  }
  e10.format = d, xt(d, "format");
  function f(v, m = 2) {
    return v.toString().padStart(m, "0");
  }
  e10.toDigits = f, xt(f, "toDigits");
  function p(v, m = /* @__PURE__ */ new Date()) {
    return v.replace("yyyy", m.getFullYear().toString()).replace("yy", m.getFullYear().toString().slice(2)).replace("MM", f(m.getMonth() + 1)).replace("dd", f(m.getDate())).replace("hh", f(m.getHours())).replace("mm", f(m.getMinutes())).replace("ss", f(m.getSeconds())).replace("SSS", f(m.getMilliseconds(), 3));
  }
  e10.template = p, xt(p, "template");
})(A_ || (A_ = {}));
/*!
  * shared v11.1.5
  * (c) 2025 kazuya kawaguchi
  * Released under the MIT License.
  */
const _r = typeof window < "u";
let Do, os;
if (true) {
  const e10 = _r && window.performance;
  e10 && e10.mark && e10.measure && e10.clearMarks && // @ts-ignore browser compat
  e10.clearMeasures && (Do = (t) => {
    e10.mark(t);
  }, os = (t, n, o) => {
    e10.measure(t, n, o), e10.clearMarks(n), e10.clearMarks(o);
  });
}
const fne = /\{([0-9a-zA-Z]+)\}/g;
function yp(e10, ...t) {
  return t.length === 1 && Gt(t[0]) && (t = t[0]), (!t || !t.hasOwnProperty) && (t = {}), e10.replace(fne, (n, o) => t.hasOwnProperty(o) ? t[o] : "");
}
const oa = (e10, t = false) => t ? Symbol.for(e10) : Symbol(e10), pne = (e10, t, n) => vne({ l: e10, k: t, s: n }), vne = (e10) => JSON.stringify(e10).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027"), kn = (e10) => typeof e10 == "number" && isFinite(e10), hne = (e10) => Oy(e10) === "[object Date]", mi = (e10) => Oy(e10) === "[object RegExp]", bp = (e10) => Wt(e10) && Object.keys(e10).length === 0, Pn = Object.assign, mne = Object.create, an = (e10 = null) => mne(e10);
let L_;
const Al = () => L_ || (L_ = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof __webpack_require__.g < "u" ? __webpack_require__.g : an());
function x_(e10) {
  return e10.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
const gne = Object.prototype.hasOwnProperty;
function ur(e10, t) {
  return gne.call(e10, t);
}
const mn = Array.isArray, ln = (e10) => typeof e10 == "function", pt = (e10) => typeof e10 == "string", Xt = (e10) => typeof e10 == "boolean", Gt = (e10) => e10 !== null && typeof e10 == "object", yne = (e10) => Gt(e10) && ln(e10.then) && ln(e10.catch), DT = Object.prototype.toString, Oy = (e10) => DT.call(e10), Wt = (e10) => Oy(e10) === "[object Object]", bne = (e10) => e10 == null ? "" : mn(e10) || Wt(e10) && e10.toString === DT ? JSON.stringify(e10, null, 2) : String(e10);
function $y(e10, t = "") {
  return e10.reduce((n, o, r) => r === 0 ? n + o : n + t + o, "");
}
const D_ = 2;
function _ne(e10, t = 0, n = e10.length) {
  const o = e10.split(/\r?\n/);
  let r = 0;
  const a = [];
  for (let l = 0; l < o.length; l++)
    if (r += o[l].length + 1, r >= t) {
      for (let s = l - D_; s <= l + D_ || n > r; s++) {
        if (s < 0 || s >= o.length)
          continue;
        const u = s + 1;
        a.push(`${u}${" ".repeat(3 - String(u).length)}|  ${o[s]}`);
        const c = o[s].length;
        if (s === l) {
          const d = t - (r - c) + 1, f = Math.max(1, n > r ? c - d : n - t);
          a.push("   |  " + " ".repeat(d) + "^".repeat(f));
        } else if (s > l) {
          if (n > r) {
            const d = Math.max(Math.min(n - r, c), 1);
            a.push("   |  " + "^".repeat(d));
          }
          r += c + 1;
        }
      }
      break;
    }
  return a.join(`
`);
}
function hl(e10, t) {
  typeof console < "u" && (console.warn("[intlify] " + e10), t && console.warn(t.stack));
}
const V_ = {};
function Iy(e10) {
  V_[e10] || (V_[e10] = true, hl(e10));
}
function My() {
  const e10 = /* @__PURE__ */ new Map();
  return {
    events: e10,
    on(n, o) {
      const r = e10.get(n);
      r && r.push(o) || e10.set(n, [o]);
    },
    off(n, o) {
      const r = e10.get(n);
      r && r.splice(r.indexOf(o) >>> 0, 1);
    },
    emit(n, o) {
      (e10.get(n) || []).slice().map((r) => r(o)), (e10.get("*") || []).slice().map((r) => r(n, o));
    }
  };
}
const Gc = (e10) => !Gt(e10) || mn(e10);
function Md(e10, t) {
  if (Gc(e10) || Gc(t))
    throw new Error("Invalid value");
  const n = [{ src: e10, des: t }];
  for (; n.length; ) {
    const { src: o, des: r } = n.pop();
    Object.keys(o).forEach((a) => {
      a !== "__proto__" && (Gt(o[a]) && !Gt(r[a]) && (r[a] = Array.isArray(o[a]) ? [] : an()), Gc(r[a]) || Gc(o[a]) ? r[a] = o[a] : n.push({ src: o[a], des: r[a] }));
    });
  }
}
/*!
  * message-compiler v11.1.5
  * (c) 2025 kazuya kawaguchi
  * Released under the MIT License.
  */
function wne(e10, t, n) {
  return { line: e10, column: t, offset: n };
}
function Gh(e10, t, n) {
  return { start: e10, end: t };
}
const Pt = {
  // tokenizer error codes
  EXPECTED_TOKEN: 1,
  INVALID_TOKEN_IN_PLACEHOLDER: 2,
  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
  UNKNOWN_ESCAPE_SEQUENCE: 4,
  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
  UNBALANCED_CLOSING_BRACE: 6,
  UNTERMINATED_CLOSING_BRACE: 7,
  EMPTY_PLACEHOLDER: 8,
  NOT_ALLOW_NEST_PLACEHOLDER: 9,
  INVALID_LINKED_FORMAT: 10,
  // parser error codes
  MUST_HAVE_MESSAGES_IN_PLURAL: 11,
  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
  UNEXPECTED_EMPTY_LINKED_KEY: 13,
  UNEXPECTED_LEXICAL_ANALYSIS: 14,
  // generator error codes
  UNHANDLED_CODEGEN_NODE_TYPE: 15,
  // minifier error codes
  UNHANDLED_MINIFIER_NODE_TYPE: 16
}, Cne = 17, Ene = {
  // tokenizer error messages
  [Pt.EXPECTED_TOKEN]: "Expected token: '{0}'",
  [Pt.INVALID_TOKEN_IN_PLACEHOLDER]: "Invalid token in placeholder: '{0}'",
  [Pt.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: "Unterminated single quote in placeholder",
  [Pt.UNKNOWN_ESCAPE_SEQUENCE]: "Unknown escape sequence: \\{0}",
  [Pt.INVALID_UNICODE_ESCAPE_SEQUENCE]: "Invalid unicode escape sequence: {0}",
  [Pt.UNBALANCED_CLOSING_BRACE]: "Unbalanced closing brace",
  [Pt.UNTERMINATED_CLOSING_BRACE]: "Unterminated closing brace",
  [Pt.EMPTY_PLACEHOLDER]: "Empty placeholder",
  [Pt.NOT_ALLOW_NEST_PLACEHOLDER]: "Not allowed nest placeholder",
  [Pt.INVALID_LINKED_FORMAT]: "Invalid linked format",
  // parser error messages
  [Pt.MUST_HAVE_MESSAGES_IN_PLURAL]: "Plural must have messages",
  [Pt.UNEXPECTED_EMPTY_LINKED_MODIFIER]: "Unexpected empty linked modifier",
  [Pt.UNEXPECTED_EMPTY_LINKED_KEY]: "Unexpected empty linked key",
  [Pt.UNEXPECTED_LEXICAL_ANALYSIS]: "Unexpected lexical analysis in token: '{0}'",
  // generator error messages
  [Pt.UNHANDLED_CODEGEN_NODE_TYPE]: "unhandled codegen node type: '{0}'",
  // minimizer error messages
  [Pt.UNHANDLED_MINIFIER_NODE_TYPE]: "unhandled mimifier node type: '{0}'"
};
function Pi(e10, t, n = {}) {
  const { domain: o, messages: r, args: a } = n, l =  true ? yp((r || Ene)[e10] || "", ...a || []) : 0, s = new SyntaxError(String(l));
  return s.code = e10, t && (s.location = t), s.domain = o, s;
}
function Sne(e10) {
  throw e10;
}
const kne = /<\/?[\w\s="/.':;#-\/]+>/, Nne = (e10) => kne.test(e10), ia = " ", Tne = "\r", uo = `
`, One = "\u2028", $ne = "\u2029";
function Ine(e10) {
  const t = e10;
  let n = 0, o = 1, r = 1, a = 0;
  const l = (T) => t[T] === Tne && t[T + 1] === uo, s = (T) => t[T] === uo, u = (T) => t[T] === $ne, c = (T) => t[T] === One, d = (T) => l(T) || s(T) || u(T) || c(T), f = () => n, p = () => o, v = () => r, m = () => a, h = (T) => l(T) || u(T) || c(T) ? uo : t[T], b = () => h(n), g = () => h(n + a);
  function w() {
    return a = 0, d(n) && (o++, r = 0), l(n) && n++, n++, r++, t[n];
  }
  function y() {
    return l(n + a) && a++, a++, t[n + a];
  }
  function _() {
    n = 0, o = 1, r = 1, a = 0;
  }
  function C(T = 0) {
    a = T;
  }
  function E() {
    const T = n + a;
    for (; T !== n; )
      w();
    a = 0;
  }
  return {
    index: f,
    line: p,
    column: v,
    peekOffset: m,
    charAt: h,
    currentChar: b,
    currentPeek: g,
    next: w,
    peek: y,
    reset: _,
    resetPeek: C,
    skipToPeek: E
  };
}
const za = void 0, Mne = ".", F_ = "'", Pne = "tokenizer";
function Rne(e10, t = {}) {
  const n = t.location !== false, o = Ine(e10), r = () => o.index(), a = () => wne(o.line(), o.column(), o.index()), l = a(), s = r(), u = {
    currentType: 13,
    offset: s,
    startLoc: l,
    endLoc: l,
    lastType: 13,
    lastOffset: s,
    lastStartLoc: l,
    lastEndLoc: l,
    braceNest: 0,
    inLinked: false,
    text: ""
  }, c = () => u, { onError: d } = t;
  function f(K, q, ue, ...be) {
    const ke = c();
    if (q.column += ue, q.offset += ue, d) {
      const Ae = n ? Gh(ke.startLoc, q) : null, fe = Pi(K, Ae, {
        domain: Pne,
        args: be
      });
      d(fe);
    }
  }
  function p(K, q, ue) {
    K.endLoc = a(), K.currentType = q;
    const be = { type: q };
    return n && (be.loc = Gh(K.startLoc, K.endLoc)), ue != null && (be.value = ue), be;
  }
  const v = (K) => p(
    K,
    13
    /* TokenTypes.EOF */
  );
  function m(K, q) {
    return K.currentChar() === q ? (K.next(), q) : (f(Pt.EXPECTED_TOKEN, a(), 0, q), "");
  }
  function h(K) {
    let q = "";
    for (; K.currentPeek() === ia || K.currentPeek() === uo; )
      q += K.currentPeek(), K.peek();
    return q;
  }
  function b(K) {
    const q = h(K);
    return K.skipToPeek(), q;
  }
  function g(K) {
    if (K === za)
      return false;
    const q = K.charCodeAt(0);
    return q >= 97 && q <= 122 || // a-z
    q >= 65 && q <= 90 || // A-Z
    q === 95;
  }
  function w(K) {
    if (K === za)
      return false;
    const q = K.charCodeAt(0);
    return q >= 48 && q <= 57;
  }
  function y(K, q) {
    const { currentType: ue } = q;
    if (ue !== 2)
      return false;
    h(K);
    const be = g(K.currentPeek());
    return K.resetPeek(), be;
  }
  function _(K, q) {
    const { currentType: ue } = q;
    if (ue !== 2)
      return false;
    h(K);
    const be = K.currentPeek() === "-" ? K.peek() : K.currentPeek(), ke = w(be);
    return K.resetPeek(), ke;
  }
  function C(K, q) {
    const { currentType: ue } = q;
    if (ue !== 2)
      return false;
    h(K);
    const be = K.currentPeek() === F_;
    return K.resetPeek(), be;
  }
  function E(K, q) {
    const { currentType: ue } = q;
    if (ue !== 7)
      return false;
    h(K);
    const be = K.currentPeek() === ".";
    return K.resetPeek(), be;
  }
  function T(K, q) {
    const { currentType: ue } = q;
    if (ue !== 8)
      return false;
    h(K);
    const be = g(K.currentPeek());
    return K.resetPeek(), be;
  }
  function O(K, q) {
    const { currentType: ue } = q;
    if (!(ue === 7 || ue === 11))
      return false;
    h(K);
    const be = K.currentPeek() === ":";
    return K.resetPeek(), be;
  }
  function N(K, q) {
    const { currentType: ue } = q;
    if (ue !== 9)
      return false;
    const be = () => {
      const Ae = K.currentPeek();
      return Ae === "{" ? g(K.peek()) : Ae === "@" || Ae === "|" || Ae === ":" || Ae === "." || Ae === ia || !Ae ? false : Ae === uo ? (K.peek(), be()) : R(K, false);
    }, ke = be();
    return K.resetPeek(), ke;
  }
  function $(K) {
    h(K);
    const q = K.currentPeek() === "|";
    return K.resetPeek(), q;
  }
  function R(K, q = true) {
    const ue = (ke = false, Ae = "") => {
      const fe = K.currentPeek();
      return fe === "{" || fe === "@" || !fe ? ke : fe === "|" ? !(Ae === ia || Ae === uo) : fe === ia ? (K.peek(), ue(true, ia)) : fe === uo ? (K.peek(), ue(true, uo)) : true;
    }, be = ue();
    return q && K.resetPeek(), be;
  }
  function P(K, q) {
    const ue = K.currentChar();
    return ue === za ? za : q(ue) ? (K.next(), ue) : null;
  }
  function z(K) {
    const q = K.charCodeAt(0);
    return q >= 97 && q <= 122 || // a-z
    q >= 65 && q <= 90 || // A-Z
    q >= 48 && q <= 57 || // 0-9
    q === 95 || // _
    q === 36;
  }
  function Y(K) {
    return P(K, z);
  }
  function D(K) {
    const q = K.charCodeAt(0);
    return q >= 97 && q <= 122 || // a-z
    q >= 65 && q <= 90 || // A-Z
    q >= 48 && q <= 57 || // 0-9
    q === 95 || // _
    q === 36 || // $
    q === 45;
  }
  function M(K) {
    return P(K, D);
  }
  function F(K) {
    const q = K.charCodeAt(0);
    return q >= 48 && q <= 57;
  }
  function A(K) {
    return P(K, F);
  }
  function V(K) {
    const q = K.charCodeAt(0);
    return q >= 48 && q <= 57 || // 0-9
    q >= 65 && q <= 70 || // A-F
    q >= 97 && q <= 102;
  }
  function Z(K) {
    return P(K, V);
  }
  function G(K) {
    let q = "", ue = "";
    for (; q = A(K); )
      ue += q;
    return ue;
  }
  function le(K) {
    let q = "";
    for (; ; ) {
      const ue = K.currentChar();
      if (ue === "{" || ue === "}" || ue === "@" || ue === "|" || !ue)
        break;
      if (ue === ia || ue === uo)
        if (R(K))
          q += ue, K.next();
        else {
          if ($(K))
            break;
          q += ue, K.next();
        }
      else
        q += ue, K.next();
    }
    return q;
  }
  function X(K) {
    b(K);
    let q = "", ue = "";
    for (; q = M(K); )
      ue += q;
    return K.currentChar() === za && f(Pt.UNTERMINATED_CLOSING_BRACE, a(), 0), ue;
  }
  function te(K) {
    b(K);
    let q = "";
    return K.currentChar() === "-" ? (K.next(), q += `-${G(K)}`) : q += G(K), K.currentChar() === za && f(Pt.UNTERMINATED_CLOSING_BRACE, a(), 0), q;
  }
  function ce(K) {
    return K !== F_ && K !== uo;
  }
  function pe(K) {
    b(K), m(K, "'");
    let q = "", ue = "";
    for (; q = P(K, ce); )
      q === "\\" ? ue += se(K) : ue += q;
    const be = K.currentChar();
    return be === uo || be === za ? (f(Pt.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, a(), 0), be === uo && (K.next(), m(K, "'")), ue) : (m(K, "'"), ue);
  }
  function se(K) {
    const q = K.currentChar();
    switch (q) {
      case "\\":
      case "'":
        return K.next(), `\\${q}`;
      case "u":
        return ve(K, q, 4);
      case "U":
        return ve(K, q, 6);
      default:
        return f(Pt.UNKNOWN_ESCAPE_SEQUENCE, a(), 0, q), "";
    }
  }
  function ve(K, q, ue) {
    m(K, q);
    let be = "";
    for (let ke = 0; ke < ue; ke++) {
      const Ae = Z(K);
      if (!Ae) {
        f(Pt.INVALID_UNICODE_ESCAPE_SEQUENCE, a(), 0, `\\${q}${be}${K.currentChar()}`);
        break;
      }
      be += Ae;
    }
    return `\\${q}${be}`;
  }
  function me(K) {
    return K !== "{" && K !== "}" && K !== ia && K !== uo;
  }
  function De(K) {
    b(K);
    let q = "", ue = "";
    for (; q = P(K, me); )
      ue += q;
    return ue;
  }
  function Te(K) {
    let q = "", ue = "";
    for (; q = Y(K); )
      ue += q;
    return ue;
  }
  function de(K) {
    const q = (ue) => {
      const be = K.currentChar();
      return be === "{" || be === "@" || be === "|" || be === "(" || be === ")" || !be || be === ia ? ue : (ue += be, K.next(), q(ue));
    };
    return q("");
  }
  function U(K) {
    b(K);
    const q = m(
      K,
      "|"
      /* TokenChars.Pipe */
    );
    return b(K), q;
  }
  function re(K, q) {
    let ue = null;
    switch (K.currentChar()) {
      case "{":
        return q.braceNest >= 1 && f(Pt.NOT_ALLOW_NEST_PLACEHOLDER, a(), 0), K.next(), ue = p(
          q,
          2,
          "{"
          /* TokenChars.BraceLeft */
        ), b(K), q.braceNest++, ue;
      case "}":
        return q.braceNest > 0 && q.currentType === 2 && f(Pt.EMPTY_PLACEHOLDER, a(), 0), K.next(), ue = p(
          q,
          3,
          "}"
          /* TokenChars.BraceRight */
        ), q.braceNest--, q.braceNest > 0 && b(K), q.inLinked && q.braceNest === 0 && (q.inLinked = false), ue;
      case "@":
        return q.braceNest > 0 && f(Pt.UNTERMINATED_CLOSING_BRACE, a(), 0), ue = he(K, q) || v(q), q.braceNest = 0, ue;
      default: {
        let ke = true, Ae = true, fe = true;
        if ($(K))
          return q.braceNest > 0 && f(Pt.UNTERMINATED_CLOSING_BRACE, a(), 0), ue = p(q, 1, U(K)), q.braceNest = 0, q.inLinked = false, ue;
        if (q.braceNest > 0 && (q.currentType === 4 || q.currentType === 5 || q.currentType === 6))
          return f(Pt.UNTERMINATED_CLOSING_BRACE, a(), 0), q.braceNest = 0, Ee(K, q);
        if (ke = y(K, q))
          return ue = p(q, 4, X(K)), b(K), ue;
        if (Ae = _(K, q))
          return ue = p(q, 5, te(K)), b(K), ue;
        if (fe = C(K, q))
          return ue = p(q, 6, pe(K)), b(K), ue;
        if (!ke && !Ae && !fe)
          return ue = p(q, 12, De(K)), f(Pt.INVALID_TOKEN_IN_PLACEHOLDER, a(), 0, ue.value), b(K), ue;
        break;
      }
    }
    return ue;
  }
  function he(K, q) {
    const { currentType: ue } = q;
    let be = null;
    const ke = K.currentChar();
    switch ((ue === 7 || ue === 8 || ue === 11 || ue === 9) && (ke === uo || ke === ia) && f(Pt.INVALID_LINKED_FORMAT, a(), 0), ke) {
      case "@":
        return K.next(), be = p(
          q,
          7,
          "@"
          /* TokenChars.LinkedAlias */
        ), q.inLinked = true, be;
      case ".":
        return b(K), K.next(), p(
          q,
          8,
          "."
          /* TokenChars.LinkedDot */
        );
      case ":":
        return b(K), K.next(), p(
          q,
          9,
          ":"
          /* TokenChars.LinkedDelimiter */
        );
      default:
        return $(K) ? (be = p(q, 1, U(K)), q.braceNest = 0, q.inLinked = false, be) : E(K, q) || O(K, q) ? (b(K), he(K, q)) : T(K, q) ? (b(K), p(q, 11, Te(K))) : N(K, q) ? (b(K), ke === "{" ? re(K, q) || be : p(q, 10, de(K))) : (ue === 7 && f(Pt.INVALID_LINKED_FORMAT, a(), 0), q.braceNest = 0, q.inLinked = false, Ee(K, q));
    }
  }
  function Ee(K, q) {
    let ue = {
      type: 13
      /* TokenTypes.EOF */
    };
    if (q.braceNest > 0)
      return re(K, q) || v(q);
    if (q.inLinked)
      return he(K, q) || v(q);
    switch (K.currentChar()) {
      case "{":
        return re(K, q) || v(q);
      case "}":
        return f(Pt.UNBALANCED_CLOSING_BRACE, a(), 0), K.next(), p(
          q,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
      case "@":
        return he(K, q) || v(q);
      default: {
        if ($(K))
          return ue = p(q, 1, U(K)), q.braceNest = 0, q.inLinked = false, ue;
        if (R(K))
          return p(q, 0, le(K));
        break;
      }
    }
    return ue;
  }
  function ye() {
    const { currentType: K, offset: q, startLoc: ue, endLoc: be } = u;
    return u.lastType = K, u.lastOffset = q, u.lastStartLoc = ue, u.lastEndLoc = be, u.offset = r(), u.startLoc = a(), o.currentChar() === za ? p(
      u,
      13
      /* TokenTypes.EOF */
    ) : Ee(o, u);
  }
  return {
    nextToken: ye,
    currentOffset: r,
    currentPosition: a,
    context: c
  };
}
const Ane = "parser", Lne = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function xne(e10, t, n) {
  switch (e10) {
    case "\\\\":
      return "\\";
    // eslint-disable-next-line no-useless-escape
    case "\\'":
      return "'";
    default: {
      const o = parseInt(t || n, 16);
      return o <= 55295 || o >= 57344 ? String.fromCodePoint(o) : "\uFFFD";
    }
  }
}
function Dne(e10 = {}) {
  const t = e10.location !== false, { onError: n } = e10;
  function o(g, w, y, _, ...C) {
    const E = g.currentPosition();
    if (E.offset += _, E.column += _, n) {
      const T = t ? Gh(y, E) : null, O = Pi(w, T, {
        domain: Ane,
        args: C
      });
      n(O);
    }
  }
  function r(g, w, y) {
    const _ = { type: g };
    return t && (_.start = w, _.end = w, _.loc = { start: y, end: y }), _;
  }
  function a(g, w, y, _) {
    t && (g.end = w, g.loc && (g.loc.end = y));
  }
  function l(g, w) {
    const y = g.context(), _ = r(3, y.offset, y.startLoc);
    return _.value = w, a(_, g.currentOffset(), g.currentPosition()), _;
  }
  function s(g, w) {
    const y = g.context(), { lastOffset: _, lastStartLoc: C } = y, E = r(5, _, C);
    return E.index = parseInt(w, 10), g.nextToken(), a(E, g.currentOffset(), g.currentPosition()), E;
  }
  function u(g, w) {
    const y = g.context(), { lastOffset: _, lastStartLoc: C } = y, E = r(4, _, C);
    return E.key = w, g.nextToken(), a(E, g.currentOffset(), g.currentPosition()), E;
  }
  function c(g, w) {
    const y = g.context(), { lastOffset: _, lastStartLoc: C } = y, E = r(9, _, C);
    return E.value = w.replace(Lne, xne), g.nextToken(), a(E, g.currentOffset(), g.currentPosition()), E;
  }
  function d(g) {
    const w = g.nextToken(), y = g.context(), { lastOffset: _, lastStartLoc: C } = y, E = r(8, _, C);
    return w.type !== 11 ? (o(g, Pt.UNEXPECTED_EMPTY_LINKED_MODIFIER, y.lastStartLoc, 0), E.value = "", a(E, _, C), {
      nextConsumeToken: w,
      node: E
    }) : (w.value == null && o(g, Pt.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Pr(w)), E.value = w.value || "", a(E, g.currentOffset(), g.currentPosition()), {
      node: E
    });
  }
  function f(g, w) {
    const y = g.context(), _ = r(7, y.offset, y.startLoc);
    return _.value = w, a(_, g.currentOffset(), g.currentPosition()), _;
  }
  function p(g) {
    const w = g.context(), y = r(6, w.offset, w.startLoc);
    let _ = g.nextToken();
    if (_.type === 8) {
      const C = d(g);
      y.modifier = C.node, _ = C.nextConsumeToken || g.nextToken();
    }
    switch (_.type !== 9 && o(g, Pt.UNEXPECTED_LEXICAL_ANALYSIS, w.lastStartLoc, 0, Pr(_)), _ = g.nextToken(), _.type === 2 && (_ = g.nextToken()), _.type) {
      case 10:
        _.value == null && o(g, Pt.UNEXPECTED_LEXICAL_ANALYSIS, w.lastStartLoc, 0, Pr(_)), y.key = f(g, _.value || "");
        break;
      case 4:
        _.value == null && o(g, Pt.UNEXPECTED_LEXICAL_ANALYSIS, w.lastStartLoc, 0, Pr(_)), y.key = u(g, _.value || "");
        break;
      case 5:
        _.value == null && o(g, Pt.UNEXPECTED_LEXICAL_ANALYSIS, w.lastStartLoc, 0, Pr(_)), y.key = s(g, _.value || "");
        break;
      case 6:
        _.value == null && o(g, Pt.UNEXPECTED_LEXICAL_ANALYSIS, w.lastStartLoc, 0, Pr(_)), y.key = c(g, _.value || "");
        break;
      default: {
        o(g, Pt.UNEXPECTED_EMPTY_LINKED_KEY, w.lastStartLoc, 0);
        const C = g.context(), E = r(7, C.offset, C.startLoc);
        return E.value = "", a(E, C.offset, C.startLoc), y.key = E, a(y, C.offset, C.startLoc), {
          nextConsumeToken: _,
          node: y
        };
      }
    }
    return a(y, g.currentOffset(), g.currentPosition()), {
      node: y
    };
  }
  function v(g) {
    const w = g.context(), y = w.currentType === 1 ? g.currentOffset() : w.offset, _ = w.currentType === 1 ? w.endLoc : w.startLoc, C = r(2, y, _);
    C.items = [];
    let E = null;
    do {
      const N = E || g.nextToken();
      switch (E = null, N.type) {
        case 0:
          N.value == null && o(g, Pt.UNEXPECTED_LEXICAL_ANALYSIS, w.lastStartLoc, 0, Pr(N)), C.items.push(l(g, N.value || ""));
          break;
        case 5:
          N.value == null && o(g, Pt.UNEXPECTED_LEXICAL_ANALYSIS, w.lastStartLoc, 0, Pr(N)), C.items.push(s(g, N.value || ""));
          break;
        case 4:
          N.value == null && o(g, Pt.UNEXPECTED_LEXICAL_ANALYSIS, w.lastStartLoc, 0, Pr(N)), C.items.push(u(g, N.value || ""));
          break;
        case 6:
          N.value == null && o(g, Pt.UNEXPECTED_LEXICAL_ANALYSIS, w.lastStartLoc, 0, Pr(N)), C.items.push(c(g, N.value || ""));
          break;
        case 7: {
          const $ = p(g);
          C.items.push($.node), E = $.nextConsumeToken || null;
          break;
        }
      }
    } while (w.currentType !== 13 && w.currentType !== 1);
    const T = w.currentType === 1 ? w.lastOffset : g.currentOffset(), O = w.currentType === 1 ? w.lastEndLoc : g.currentPosition();
    return a(C, T, O), C;
  }
  function m(g, w, y, _) {
    const C = g.context();
    let E = _.items.length === 0;
    const T = r(1, w, y);
    T.cases = [], T.cases.push(_);
    do {
      const O = v(g);
      E || (E = O.items.length === 0), T.cases.push(O);
    } while (C.currentType !== 13);
    return E && o(g, Pt.MUST_HAVE_MESSAGES_IN_PLURAL, y, 0), a(T, g.currentOffset(), g.currentPosition()), T;
  }
  function h(g) {
    const w = g.context(), { offset: y, startLoc: _ } = w, C = v(g);
    return w.currentType === 13 ? C : m(g, y, _, C);
  }
  function b(g) {
    const w = Rne(g, Pn({}, e10)), y = w.context(), _ = r(0, y.offset, y.startLoc);
    return t && _.loc && (_.loc.source = g), _.body = h(w), e10.onCacheKey && (_.cacheKey = e10.onCacheKey(g)), y.currentType !== 13 && o(w, Pt.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, g[y.offset] || ""), a(_, w.currentOffset(), w.currentPosition()), _;
  }
  return { parse: b };
}
function Pr(e10) {
  if (e10.type === 13)
    return "EOF";
  const t = (e10.value || "").replace(/\r?\n/gu, "\\n");
  return t.length > 10 ? t.slice(0, 9) + "\u2026" : t;
}
function Vne(e10, t = {}) {
  const n = {
    ast: e10,
    helpers: /* @__PURE__ */ new Set()
  };
  return { context: () => n, helper: (a) => (n.helpers.add(a), a) };
}
function B_(e10, t) {
  for (let n = 0; n < e10.length; n++)
    Py(e10[n], t);
}
function Py(e10, t) {
  switch (e10.type) {
    case 1:
      B_(e10.cases, t), t.helper(
        "plural"
        /* HelperNameMap.PLURAL */
      );
      break;
    case 2:
      B_(e10.items, t);
      break;
    case 6: {
      Py(e10.key, t), t.helper(
        "linked"
        /* HelperNameMap.LINKED */
      ), t.helper(
        "type"
        /* HelperNameMap.TYPE */
      );
      break;
    }
    case 5:
      t.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      ), t.helper(
        "list"
        /* HelperNameMap.LIST */
      );
      break;
    case 4:
      t.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      ), t.helper(
        "named"
        /* HelperNameMap.NAMED */
      );
      break;
  }
}
function Fne(e10, t = {}) {
  const n = Vne(e10);
  n.helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  ), e10.body && Py(e10.body, n);
  const o = n.context();
  e10.helpers = Array.from(o.helpers);
}
function Bne(e10) {
  const t = e10.body;
  return t.type === 2 ? H_(t) : t.cases.forEach((n) => H_(n)), e10;
}
function H_(e10) {
  if (e10.items.length === 1) {
    const t = e10.items[0];
    (t.type === 3 || t.type === 9) && (e10.static = t.value, delete t.value);
  } else {
    const t = [];
    for (let n = 0; n < e10.items.length; n++) {
      const o = e10.items[n];
      if (!(o.type === 3 || o.type === 9) || o.value == null)
        break;
      t.push(o.value);
    }
    if (t.length === e10.items.length) {
      e10.static = $y(t);
      for (let n = 0; n < e10.items.length; n++) {
        const o = e10.items[n];
        (o.type === 3 || o.type === 9) && delete o.value;
      }
    }
  }
}
const Hne = "minifier";
function $s(e10) {
  switch (e10.t = e10.type, e10.type) {
    case 0: {
      const t = e10;
      $s(t.body), t.b = t.body, delete t.body;
      break;
    }
    case 1: {
      const t = e10, n = t.cases;
      for (let o = 0; o < n.length; o++)
        $s(n[o]);
      t.c = n, delete t.cases;
      break;
    }
    case 2: {
      const t = e10, n = t.items;
      for (let o = 0; o < n.length; o++)
        $s(n[o]);
      t.i = n, delete t.items, t.static && (t.s = t.static, delete t.static);
      break;
    }
    case 3:
    case 9:
    case 8:
    case 7: {
      const t = e10;
      t.value && (t.v = t.value, delete t.value);
      break;
    }
    case 6: {
      const t = e10;
      $s(t.key), t.k = t.key, delete t.key, t.modifier && ($s(t.modifier), t.m = t.modifier, delete t.modifier);
      break;
    }
    case 5: {
      const t = e10;
      t.i = t.index, delete t.index;
      break;
    }
    case 4: {
      const t = e10;
      t.k = t.key, delete t.key;
      break;
    }
    default:
      if (true)
        throw Pi(Pt.UNHANDLED_MINIFIER_NODE_TYPE, null, {
          domain: Hne,
          args: [e10.type]
        });
  }
  delete e10.type;
}
const zne = "parser";
function Kne(e10, t) {
  const { filename: n, breakLineCode: o, needIndent: r } = t, a = t.location !== false, l = {
    filename: n,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    map: void 0,
    breakLineCode: o,
    needIndent: r,
    indentLevel: 0
  };
  a && e10.loc && (l.source = e10.loc.source);
  const s = () => l;
  function u(h, b) {
    l.code += h;
  }
  function c(h, b = true) {
    const g = b ? o : "";
    u(r ? g + "  ".repeat(h) : g);
  }
  function d(h = true) {
    const b = ++l.indentLevel;
    h && c(b);
  }
  function f(h = true) {
    const b = --l.indentLevel;
    h && c(b);
  }
  function p() {
    c(l.indentLevel);
  }
  return {
    context: s,
    push: u,
    indent: d,
    deindent: f,
    newline: p,
    helper: (h) => `_${h}`,
    needIndent: () => l.needIndent
  };
}
function Wne(e10, t) {
  const { helper: n } = e10;
  e10.push(`${n(
    "linked"
    /* HelperNameMap.LINKED */
  )}(`), gi(e10, t.key), t.modifier ? (e10.push(", "), gi(e10, t.modifier), e10.push(", _type")) : e10.push(", undefined, _type"), e10.push(")");
}
function jne(e10, t) {
  const { helper: n, needIndent: o } = e10;
  e10.push(`${n(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  )}([`), e10.indent(o());
  const r = t.items.length;
  for (let a = 0; a < r && (gi(e10, t.items[a]), a !== r - 1); a++)
    e10.push(", ");
  e10.deindent(o()), e10.push("])");
}
function Une(e10, t) {
  const { helper: n, needIndent: o } = e10;
  if (t.cases.length > 1) {
    e10.push(`${n(
      "plural"
      /* HelperNameMap.PLURAL */
    )}([`), e10.indent(o());
    const r = t.cases.length;
    for (let a = 0; a < r && (gi(e10, t.cases[a]), a !== r - 1); a++)
      e10.push(", ");
    e10.deindent(o()), e10.push("])");
  }
}
function Yne(e10, t) {
  t.body ? gi(e10, t.body) : e10.push("null");
}
function gi(e10, t) {
  const { helper: n } = e10;
  switch (t.type) {
    case 0:
      Yne(e10, t);
      break;
    case 1:
      Une(e10, t);
      break;
    case 2:
      jne(e10, t);
      break;
    case 6:
      Wne(e10, t);
      break;
    case 8:
      e10.push(JSON.stringify(t.value), t);
      break;
    case 7:
      e10.push(JSON.stringify(t.value), t);
      break;
    case 5:
      e10.push(`${n(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${n(
        "list"
        /* HelperNameMap.LIST */
      )}(${t.index}))`, t);
      break;
    case 4:
      e10.push(`${n(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${n(
        "named"
        /* HelperNameMap.NAMED */
      )}(${JSON.stringify(t.key)}))`, t);
      break;
    case 9:
      e10.push(JSON.stringify(t.value), t);
      break;
    case 3:
      e10.push(JSON.stringify(t.value), t);
      break;
    default:
      if (true)
        throw Pi(Pt.UNHANDLED_CODEGEN_NODE_TYPE, null, {
          domain: zne,
          args: [t.type]
        });
  }
}
const qne = (e10, t = {}) => {
  const n = pt(t.mode) ? t.mode : "normal", o = pt(t.filename) ? t.filename : "message.intl";
  t.sourceMap;
  const r = t.breakLineCode != null ? t.breakLineCode : n === "arrow" ? ";" : `
`, a = t.needIndent ? t.needIndent : n !== "arrow", l = e10.helpers || [], s = Kne(e10, {
    filename: o,
    breakLineCode: r,
    needIndent: a
  });
  s.push(n === "normal" ? "function __msg__ (ctx) {" : "(ctx) => {"), s.indent(a), l.length > 0 && (s.push(`const { ${$y(l.map((d) => `${d}: _${d}`), ", ")} } = ctx`), s.newline()), s.push("return "), gi(s, e10), s.deindent(a), s.push("}"), delete e10.helpers;
  const { code: u, map: c } = s.context();
  return {
    ast: e10,
    code: u,
    map: c ? c.toJSON() : void 0
    // eslint-disable-line @typescript-eslint/no-explicit-any
  };
};
function Gne(e10, t = {}) {
  const n = Pn({}, t), o = !!n.jit, r = !!n.minify, a = n.optimize == null ? true : n.optimize, s = Dne(n).parse(e10);
  return o ? (a && Bne(s), r && $s(s), { ast: s, code: "" }) : (Fne(s, n), qne(s, n));
}
/*!
  * core-base v11.1.5
  * (c) 2025 kazuya kawaguchi
  * Released under the MIT License.
  */
function Xne() {
  typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (Al().__INTLIFY_PROD_DEVTOOLS__ = false), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (Al().__INTLIFY_DROP_MESSAGE_COMPILER__ = false);
}
function qo(e10) {
  return Gt(e10) && Ry(e10) === 0 && (ur(e10, "b") || ur(e10, "body"));
}
const VT = ["b", "body"];
function Jne(e10) {
  return ml(e10, VT);
}
const FT = ["c", "cases"];
function Zne(e10) {
  return ml(e10, FT, []);
}
const BT = ["s", "static"];
function Qne(e10) {
  return ml(e10, BT);
}
const HT = ["i", "items"];
function eoe(e10) {
  return ml(e10, HT, []);
}
const zT = ["t", "type"];
function Ry(e10) {
  return ml(e10, zT);
}
const KT = ["v", "value"];
function Xc(e10, t) {
  const n = ml(e10, KT);
  if (n != null)
    return n;
  throw Bu(t);
}
const WT = ["m", "modifier"];
function toe(e10) {
  return ml(e10, WT);
}
const jT = ["k", "key"];
function noe(e10) {
  const t = ml(e10, jT);
  if (t)
    return t;
  throw Bu(
    6
    /* NodeTypes.Linked */
  );
}
function ml(e10, t, n) {
  for (let o = 0; o < t.length; o++) {
    const r = t[o];
    if (ur(e10, r) && e10[r] != null)
      return e10[r];
  }
  return n;
}
const UT = [
  ...VT,
  ...FT,
  ...BT,
  ...HT,
  ...jT,
  ...WT,
  ...KT,
  ...zT
];
function Bu(e10) {
  return new Error(`unhandled node type: ${e10}`);
}
function _v(e10) {
  return (n) => ooe(n, e10);
}
function ooe(e10, t) {
  const n = Jne(t);
  if (n == null)
    throw Bu(
      0
      /* NodeTypes.Resource */
    );
  if (Ry(n) === 1) {
    const a = Zne(n);
    return e10.plural(a.reduce((l, s) => [
      ...l,
      z_(e10, s)
    ], []));
  } else
    return z_(e10, n);
}
function z_(e10, t) {
  const n = Qne(t);
  if (n != null)
    return e10.type === "text" ? n : e10.normalize([n]);
  {
    const o = eoe(t).reduce((r, a) => [...r, Xh(e10, a)], []);
    return e10.normalize(o);
  }
}
function Xh(e10, t) {
  const n = Ry(t);
  switch (n) {
    case 3:
      return Xc(t, n);
    case 9:
      return Xc(t, n);
    case 4: {
      const o = t;
      if (ur(o, "k") && o.k)
        return e10.interpolate(e10.named(o.k));
      if (ur(o, "key") && o.key)
        return e10.interpolate(e10.named(o.key));
      throw Bu(n);
    }
    case 5: {
      const o = t;
      if (ur(o, "i") && kn(o.i))
        return e10.interpolate(e10.list(o.i));
      if (ur(o, "index") && kn(o.index))
        return e10.interpolate(e10.list(o.index));
      throw Bu(n);
    }
    case 6: {
      const o = t, r = toe(o), a = noe(o);
      return e10.linked(Xh(e10, a), r ? Xh(e10, r) : void 0, e10.type);
    }
    case 7:
      return Xc(t, n);
    case 8:
      return Xc(t, n);
    default:
      throw new Error(`unhandled node on format message part: ${n}`);
  }
}
const roe = "Detected HTML in '{source}' message. Recommend not using HTML messages to avoid XSS.";
function aoe(e10, t) {
  t && Nne(e10) && hl(yp(roe, { source: e10 }));
}
const loe = (e10) => e10;
let Jc = an();
function soe(e10, t = {}) {
  let n = false;
  const o = t.onError || Sne;
  return t.onError = (r) => {
    n = true, o(r);
  }, { ...Gne(e10, t), detectError: n };
}
// @__NO_SIDE_EFFECTS__
function ioe(e10, t) {
  if (!__INTLIFY_DROP_MESSAGE_COMPILER__ && pt(e10)) {
    const n = Xt(t.warnHtmlMessage) ? t.warnHtmlMessage : true;
     true && aoe(e10, n);
    const r = (t.onCacheKey || loe)(e10), a = Jc[r];
    if (a)
      return a;
    const { ast: l, detectError: s } = soe(e10, {
      ...t,
      location: "development" !== "production",
      jit: true
    }), u = _v(l);
    return s ? u : Jc[r] = u;
  } else {
    if ( true && !qo(e10))
      return hl(`the message that is resolve with key '${t.key}' is not supported for jit compilation`), () => e10;
    const n = e10.cacheKey;
    if (n) {
      const o = Jc[n];
      return o || (Jc[n] = _v(e10));
    } else
      return _v(e10);
  }
}
let Hu = null;
function uoe(e10) {
  Hu = e10;
}
function coe(e10, t, n) {
  Hu && Hu.emit("i18n:init", {
    timestamp: Date.now(),
    i18n: e10,
    version: t,
    meta: n
  });
}
const doe = /* @__PURE__ */ foe("function:translate");
function foe(e10) {
  return (t) => Hu && Hu.emit(e10, t);
}
const Jn = {
  INVALID_ARGUMENT: Cne,
  // 17
  INVALID_DATE_ARGUMENT: 18,
  INVALID_ISO_DATE_ARGUMENT: 19,
  NOT_SUPPORT_NON_STRING_MESSAGE: 20,
  NOT_SUPPORT_LOCALE_PROMISE_VALUE: 21,
  NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: 22,
  NOT_SUPPORT_LOCALE_TYPE: 23
}, poe = 24;
function ga(e10) {
  return Pi(e10, null,  true ? { messages: voe } : 0);
}
const voe = {
  [Jn.INVALID_ARGUMENT]: "Invalid arguments",
  [Jn.INVALID_DATE_ARGUMENT]: "The date provided is an invalid Date object.Make sure your Date represents a valid date.",
  [Jn.INVALID_ISO_DATE_ARGUMENT]: "The argument provided is not a valid ISO date string",
  [Jn.NOT_SUPPORT_NON_STRING_MESSAGE]: "Not support non-string message",
  [Jn.NOT_SUPPORT_LOCALE_PROMISE_VALUE]: "cannot support promise value",
  [Jn.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION]: "cannot support async function",
  [Jn.NOT_SUPPORT_LOCALE_TYPE]: "cannot support locale type"
};
function Ay(e10, t) {
  return t.locale != null ? K_(t.locale) : K_(e10.locale);
}
let wv;
function K_(e10) {
  if (pt(e10))
    return e10;
  if (ln(e10)) {
    if (e10.resolvedOnce && wv != null)
      return wv;
    if (e10.constructor.name === "Function") {
      const t = e10();
      if (yne(t))
        throw ga(Jn.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
      return wv = t;
    } else
      throw ga(Jn.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
  } else
    throw ga(Jn.NOT_SUPPORT_LOCALE_TYPE);
}
function hoe(e10, t, n) {
  return [.../* @__PURE__ */ new Set([
    n,
    ...mn(t) ? t : Gt(t) ? Object.keys(t) : pt(t) ? [t] : [n]
  ])];
}
function Ly(e10, t, n) {
  const o = pt(n) ? n : zu, r = e10;
  r.__localeChainCache || (r.__localeChainCache = /* @__PURE__ */ new Map());
  let a = r.__localeChainCache.get(o);
  if (!a) {
    a = [];
    let l = [n];
    for (; mn(l); )
      l = W_(a, l, t);
    const s = mn(t) || !Wt(t) ? t : t.default ? t.default : null;
    l = pt(s) ? [s] : s, mn(l) && W_(a, l, false), r.__localeChainCache.set(o, a);
  }
  return a;
}
function W_(e10, t, n) {
  let o = true;
  for (let r = 0; r < t.length && Xt(o); r++) {
    const a = t[r];
    pt(a) && (o = moe(e10, t[r], n));
  }
  return o;
}
function moe(e10, t, n) {
  let o;
  const r = t.split("-");
  do {
    const a = r.join("-");
    o = goe(e10, a, n), r.splice(-1, 1);
  } while (r.length && o === true);
  return o;
}
function goe(e10, t, n) {
  let o = false;
  if (!e10.includes(t) && (o = true, t)) {
    o = t[t.length - 1] !== "!";
    const r = t.replace(/!/g, "");
    e10.push(r), (mn(n) || Wt(n)) && n[r] && (o = n[r]);
  }
  return o;
}
const gl = [];
gl[
  0
  /* States.BEFORE_PATH */
] = {
  w: [
    0
    /* States.BEFORE_PATH */
  ],
  i: [
    3,
    0
    /* Actions.APPEND */
  ],
  "[": [
    4
    /* States.IN_SUB_PATH */
  ],
  o: [
    7
    /* States.AFTER_PATH */
  ]
};
gl[
  1
  /* States.IN_PATH */
] = {
  w: [
    1
    /* States.IN_PATH */
  ],
  ".": [
    2
    /* States.BEFORE_IDENT */
  ],
  "[": [
    4
    /* States.IN_SUB_PATH */
  ],
  o: [
    7
    /* States.AFTER_PATH */
  ]
};
gl[
  2
  /* States.BEFORE_IDENT */
] = {
  w: [
    2
    /* States.BEFORE_IDENT */
  ],
  i: [
    3,
    0
    /* Actions.APPEND */
  ],
  0: [
    3,
    0
    /* Actions.APPEND */
  ]
};
gl[
  3
  /* States.IN_IDENT */
] = {
  i: [
    3,
    0
    /* Actions.APPEND */
  ],
  0: [
    3,
    0
    /* Actions.APPEND */
  ],
  w: [
    1,
    1
    /* Actions.PUSH */
  ],
  ".": [
    2,
    1
    /* Actions.PUSH */
  ],
  "[": [
    4,
    1
    /* Actions.PUSH */
  ],
  o: [
    7,
    1
    /* Actions.PUSH */
  ]
};
gl[
  4
  /* States.IN_SUB_PATH */
] = {
  "'": [
    5,
    0
    /* Actions.APPEND */
  ],
  '"': [
    6,
    0
    /* Actions.APPEND */
  ],
  "[": [
    4,
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ],
  "]": [
    1,
    3
    /* Actions.PUSH_SUB_PATH */
  ],
  o: 8,
  l: [
    4,
    0
    /* Actions.APPEND */
  ]
};
gl[
  5
  /* States.IN_SINGLE_QUOTE */
] = {
  "'": [
    4,
    0
    /* Actions.APPEND */
  ],
  o: 8,
  l: [
    5,
    0
    /* Actions.APPEND */
  ]
};
gl[
  6
  /* States.IN_DOUBLE_QUOTE */
] = {
  '"': [
    4,
    0
    /* Actions.APPEND */
  ],
  o: 8,
  l: [
    6,
    0
    /* Actions.APPEND */
  ]
};
const yoe = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function boe(e10) {
  return yoe.test(e10);
}
function _oe(e10) {
  const t = e10.charCodeAt(0), n = e10.charCodeAt(e10.length - 1);
  return t === n && (t === 34 || t === 39) ? e10.slice(1, -1) : e10;
}
function woe(e10) {
  if (e10 == null)
    return "o";
  switch (e10.charCodeAt(0)) {
    case 91:
    // [
    case 93:
    // ]
    case 46:
    // .
    case 34:
    // "
    case 39:
      return e10;
    case 95:
    // _
    case 36:
    // $
    case 45:
      return "i";
    case 9:
    // Tab (HT)
    case 10:
    // Newline (LF)
    case 13:
    // Return (CR)
    case 160:
    // No-break space (NBSP)
    case 65279:
    // Byte Order Mark (BOM)
    case 8232:
    // Line Separator (LS)
    case 8233:
      return "w";
  }
  return "i";
}
function Coe(e10) {
  const t = e10.trim();
  return e10.charAt(0) === "0" && isNaN(parseInt(e10)) ? false : boe(t) ? _oe(t) : "*" + t;
}
function Eoe(e10) {
  const t = [];
  let n = -1, o = 0, r = 0, a, l, s, u, c, d, f;
  const p = [];
  p[
    0
    /* Actions.APPEND */
  ] = () => {
    l === void 0 ? l = s : l += s;
  }, p[
    1
    /* Actions.PUSH */
  ] = () => {
    l !== void 0 && (t.push(l), l = void 0);
  }, p[
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ] = () => {
    p[
      0
      /* Actions.APPEND */
    ](), r++;
  }, p[
    3
    /* Actions.PUSH_SUB_PATH */
  ] = () => {
    if (r > 0)
      r--, o = 4, p[
        0
        /* Actions.APPEND */
      ]();
    else {
      if (r = 0, l === void 0 || (l = Coe(l), l === false))
        return false;
      p[
        1
        /* Actions.PUSH */
      ]();
    }
  };
  function v() {
    const m = e10[n + 1];
    if (o === 5 && m === "'" || o === 6 && m === '"')
      return n++, s = "\\" + m, p[
        0
        /* Actions.APPEND */
      ](), true;
  }
  for (; o !== null; )
    if (n++, a = e10[n], !(a === "\\" && v())) {
      if (u = woe(a), f = gl[o], c = f[u] || f.l || 8, c === 8 || (o = c[0], c[1] !== void 0 && (d = p[c[1]], d && (s = a, d() === false))))
        return;
      if (o === 7)
        return t;
    }
}
const j_ = /* @__PURE__ */ new Map();
function Soe(e10, t) {
  return Gt(e10) ? e10[t] : null;
}
function koe(e10, t) {
  if (!Gt(e10))
    return null;
  let n = j_.get(t);
  if (n || (n = Eoe(t), n && j_.set(t, n)), !n)
    return null;
  const o = n.length;
  let r = e10, a = 0;
  for (; a < o; ) {
    const l = n[a];
    if (UT.includes(l) && qo(r))
      return null;
    const s = r[l];
    if (s === void 0 || ln(r))
      return null;
    r = s, a++;
  }
  return r;
}
const Co = {
  NOT_FOUND_KEY: 1,
  FALLBACK_TO_TRANSLATE: 2,
  CANNOT_FORMAT_NUMBER: 3,
  FALLBACK_TO_NUMBER_FORMAT: 4,
  CANNOT_FORMAT_DATE: 5,
  FALLBACK_TO_DATE_FORMAT: 6,
  EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: 7
}, Noe = 8, Toe = {
  [Co.NOT_FOUND_KEY]: "Not found '{key}' key in '{locale}' locale messages.",
  [Co.FALLBACK_TO_TRANSLATE]: "Fall back to translate '{key}' key with '{target}' locale.",
  [Co.CANNOT_FORMAT_NUMBER]: "Cannot format a number value due to not supported Intl.NumberFormat.",
  [Co.FALLBACK_TO_NUMBER_FORMAT]: "Fall back to number format '{key}' key with '{target}' locale.",
  [Co.CANNOT_FORMAT_DATE]: "Cannot format a date value due to not supported Intl.DateTimeFormat.",
  [Co.FALLBACK_TO_DATE_FORMAT]: "Fall back to datetime format '{key}' key with '{target}' locale.",
  [Co.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER]: "This project is using Custom Message Compiler, which is an experimental feature. It may receive breaking changes or be removed in the future."
};
function rs(e10, ...t) {
  return yp(Toe[e10], ...t);
}
const Ooe = "11.1.5", _p = -1, zu = "en-US", kf = "", U_ = (e10) => `${e10.charAt(0).toLocaleUpperCase()}${e10.substr(1)}`;
function $oe() {
  return {
    upper: (e10, t) => t === "text" && pt(e10) ? e10.toUpperCase() : t === "vnode" && Gt(e10) && "__v_isVNode" in e10 ? e10.children.toUpperCase() : e10,
    lower: (e10, t) => t === "text" && pt(e10) ? e10.toLowerCase() : t === "vnode" && Gt(e10) && "__v_isVNode" in e10 ? e10.children.toLowerCase() : e10,
    capitalize: (e10, t) => t === "text" && pt(e10) ? U_(e10) : t === "vnode" && Gt(e10) && "__v_isVNode" in e10 ? U_(e10.children) : e10
  };
}
let YT;
function Ioe(e10) {
  YT = e10;
}
let qT;
function Moe(e10) {
  qT = e10;
}
let GT;
function Poe(e10) {
  GT = e10;
}
let XT = null;
const Roe = /* @__NO_SIDE_EFFECTS__ */ (e10) => {
  XT = e10;
}, Aoe = /* @__NO_SIDE_EFFECTS__ */ () => XT;
let JT = null;
const Y_ = (e10) => {
  JT = e10;
}, Loe = () => JT;
let q_ = 0;
function xoe(e10 = {}) {
  const t = ln(e10.onWarn) ? e10.onWarn : hl, n = pt(e10.version) ? e10.version : Ooe, o = pt(e10.locale) || ln(e10.locale) ? e10.locale : zu, r = ln(o) ? zu : o, a = mn(e10.fallbackLocale) || Wt(e10.fallbackLocale) || pt(e10.fallbackLocale) || e10.fallbackLocale === false ? e10.fallbackLocale : r, l = Wt(e10.messages) ? e10.messages : Cv(r), s = Wt(e10.datetimeFormats) ? e10.datetimeFormats : Cv(r), u = Wt(e10.numberFormats) ? e10.numberFormats : Cv(r), c = Pn(an(), e10.modifiers, $oe()), d = e10.pluralRules || an(), f = ln(e10.missing) ? e10.missing : null, p = Xt(e10.missingWarn) || mi(e10.missingWarn) ? e10.missingWarn : true, v = Xt(e10.fallbackWarn) || mi(e10.fallbackWarn) ? e10.fallbackWarn : true, m = !!e10.fallbackFormat, h = !!e10.unresolving, b = ln(e10.postTranslation) ? e10.postTranslation : null, g = Wt(e10.processor) ? e10.processor : null, w = Xt(e10.warnHtmlMessage) ? e10.warnHtmlMessage : true, y = !!e10.escapeParameter, _ = ln(e10.messageCompiler) ? e10.messageCompiler : YT;
   true && ln(e10.messageCompiler) && Iy(rs(Co.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER));
  const C = ln(e10.messageResolver) ? e10.messageResolver : qT || Soe, E = ln(e10.localeFallbacker) ? e10.localeFallbacker : GT || hoe, T = Gt(e10.fallbackContext) ? e10.fallbackContext : void 0, O = e10, N = Gt(O.__datetimeFormatters) ? O.__datetimeFormatters : /* @__PURE__ */ new Map(), $ = Gt(O.__numberFormatters) ? O.__numberFormatters : /* @__PURE__ */ new Map(), R = Gt(O.__meta) ? O.__meta : {};
  q_++;
  const P = {
    version: n,
    cid: q_,
    locale: o,
    fallbackLocale: a,
    messages: l,
    modifiers: c,
    pluralRules: d,
    missing: f,
    missingWarn: p,
    fallbackWarn: v,
    fallbackFormat: m,
    unresolving: h,
    postTranslation: b,
    processor: g,
    warnHtmlMessage: w,
    escapeParameter: y,
    messageCompiler: _,
    messageResolver: C,
    localeFallbacker: E,
    fallbackContext: T,
    onWarn: t,
    __meta: R
  };
  return P.datetimeFormats = s, P.numberFormats = u, P.__datetimeFormatters = N, P.__numberFormatters = $,  true && (P.__v_emitter = O.__v_emitter != null ? O.__v_emitter : void 0), ( true) && coe(P, n, R), P;
}
const Cv = (e10) => ({ [e10]: an() });
function wp(e10, t) {
  return e10 instanceof RegExp ? e10.test(t) : e10;
}
function ZT(e10, t) {
  return e10 instanceof RegExp ? e10.test(t) : e10;
}
function xy(e10, t, n, o, r) {
  const { missing: a, onWarn: l } = e10;
  if (true) {
    const s = e10.__v_emitter;
    s && s.emit("missing", {
      locale: n,
      key: t,
      type: r,
      groupId: `${r}:${t}`
    });
  }
  if (a !== null) {
    const s = a(e10, n, t, r);
    return pt(s) ? s : t;
  } else
    return  true && ZT(o, t) && l(rs(Co.NOT_FOUND_KEY, { key: t, locale: n })), t;
}
function Ki(e10, t, n) {
  const o = e10;
  o.__localeChainCache = /* @__PURE__ */ new Map(), e10.localeFallbacker(e10, n, t);
}
function QT(e10, t) {
  return e10 === t ? false : e10.split("-")[0] === t.split("-")[0];
}
function Doe(e10, t) {
  const n = t.indexOf(e10);
  if (n === -1)
    return false;
  for (let o = n + 1; o < t.length; o++)
    if (QT(e10, t[o]))
      return true;
  return false;
}
const G_ = typeof Intl < "u", eO = {
  dateTimeFormat: G_ && typeof Intl.DateTimeFormat < "u",
  numberFormat: G_ && typeof Intl.NumberFormat < "u"
};
function X_(e10, ...t) {
  const { datetimeFormats: n, unresolving: o, fallbackLocale: r, onWarn: a, localeFallbacker: l } = e10, { __datetimeFormatters: s } = e10;
  if ( true && !eO.dateTimeFormat)
    return a(rs(Co.CANNOT_FORMAT_DATE)), kf;
  const [u, c, d, f] = Jh(...t), p = Xt(d.missingWarn) ? d.missingWarn : e10.missingWarn, v = Xt(d.fallbackWarn) ? d.fallbackWarn : e10.fallbackWarn, m = !!d.part, h = Ay(e10, d), b = l(
    e10,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    r,
    h
  );
  if (!pt(u) || u === "")
    return new Intl.DateTimeFormat(h, f).format(c);
  let g = {}, w, y = null, _ = h, C = null;
  const E = "datetime format";
  for (let N = 0; N < b.length; N++) {
    if (w = C = b[N],  true && h !== w && wp(v, u) && a(rs(Co.FALLBACK_TO_DATE_FORMAT, {
      key: u,
      target: w
    })),  true && h !== w) {
      const $ = e10.__v_emitter;
      $ && $.emit("fallback", {
        type: E,
        key: u,
        from: _,
        to: C,
        groupId: `${E}:${u}`
      });
    }
    if (g = n[w] || {}, y = g[u], Wt(y))
      break;
    xy(e10, u, w, p, E), _ = C;
  }
  if (!Wt(y) || !pt(w))
    return o ? _p : u;
  let T = `${w}__${u}`;
  bp(f) || (T = `${T}__${JSON.stringify(f)}`);
  let O = s.get(T);
  return O || (O = new Intl.DateTimeFormat(w, Pn({}, y, f)), s.set(T, O)), m ? O.formatToParts(c) : O.format(c);
}
const tO = [
  "localeMatcher",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "formatMatcher",
  "hour12",
  "timeZone",
  "dateStyle",
  "timeStyle",
  "calendar",
  "dayPeriod",
  "numberingSystem",
  "hourCycle",
  "fractionalSecondDigits"
];
function Jh(...e10) {
  const [t, n, o, r] = e10, a = an();
  let l = an(), s;
  if (pt(t)) {
    const u = t.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!u)
      throw ga(Jn.INVALID_ISO_DATE_ARGUMENT);
    const c = u[3] ? u[3].trim().startsWith("T") ? `${u[1].trim()}${u[3].trim()}` : `${u[1].trim()}T${u[3].trim()}` : u[1].trim();
    s = new Date(c);
    try {
      s.toISOString();
    } catch {
      throw ga(Jn.INVALID_ISO_DATE_ARGUMENT);
    }
  } else if (hne(t)) {
    if (isNaN(t.getTime()))
      throw ga(Jn.INVALID_DATE_ARGUMENT);
    s = t;
  } else if (kn(t))
    s = t;
  else
    throw ga(Jn.INVALID_ARGUMENT);
  return pt(n) ? a.key = n : Wt(n) && Object.keys(n).forEach((u) => {
    tO.includes(u) ? l[u] = n[u] : a[u] = n[u];
  }), pt(o) ? a.locale = o : Wt(o) && (l = o), Wt(r) && (l = r), [a.key || "", s, a, l];
}
function J_(e10, t, n) {
  const o = e10;
  for (const r in n) {
    const a = `${t}__${r}`;
    o.__datetimeFormatters.has(a) && o.__datetimeFormatters.delete(a);
  }
}
function Z_(e10, ...t) {
  const { numberFormats: n, unresolving: o, fallbackLocale: r, onWarn: a, localeFallbacker: l } = e10, { __numberFormatters: s } = e10;
  if ( true && !eO.numberFormat)
    return a(rs(Co.CANNOT_FORMAT_NUMBER)), kf;
  const [u, c, d, f] = Zh(...t), p = Xt(d.missingWarn) ? d.missingWarn : e10.missingWarn, v = Xt(d.fallbackWarn) ? d.fallbackWarn : e10.fallbackWarn, m = !!d.part, h = Ay(e10, d), b = l(
    e10,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    r,
    h
  );
  if (!pt(u) || u === "")
    return new Intl.NumberFormat(h, f).format(c);
  let g = {}, w, y = null, _ = h, C = null;
  const E = "number format";
  for (let N = 0; N < b.length; N++) {
    if (w = C = b[N],  true && h !== w && wp(v, u) && a(rs(Co.FALLBACK_TO_NUMBER_FORMAT, {
      key: u,
      target: w
    })),  true && h !== w) {
      const $ = e10.__v_emitter;
      $ && $.emit("fallback", {
        type: E,
        key: u,
        from: _,
        to: C,
        groupId: `${E}:${u}`
      });
    }
    if (g = n[w] || {}, y = g[u], Wt(y))
      break;
    xy(e10, u, w, p, E), _ = C;
  }
  if (!Wt(y) || !pt(w))
    return o ? _p : u;
  let T = `${w}__${u}`;
  bp(f) || (T = `${T}__${JSON.stringify(f)}`);
  let O = s.get(T);
  return O || (O = new Intl.NumberFormat(w, Pn({}, y, f)), s.set(T, O)), m ? O.formatToParts(c) : O.format(c);
}
const nO = [
  "localeMatcher",
  "style",
  "currency",
  "currencyDisplay",
  "currencySign",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  "compactDisplay",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "roundingMode",
  "roundingPriority",
  "roundingIncrement",
  "trailingZeroDisplay"
];
function Zh(...e10) {
  const [t, n, o, r] = e10, a = an();
  let l = an();
  if (!kn(t))
    throw ga(Jn.INVALID_ARGUMENT);
  const s = t;
  return pt(n) ? a.key = n : Wt(n) && Object.keys(n).forEach((u) => {
    nO.includes(u) ? l[u] = n[u] : a[u] = n[u];
  }), pt(o) ? a.locale = o : Wt(o) && (l = o), Wt(r) && (l = r), [a.key || "", s, a, l];
}
function Q_(e10, t, n) {
  const o = e10;
  for (const r in n) {
    const a = `${t}__${r}`;
    o.__numberFormatters.has(a) && o.__numberFormatters.delete(a);
  }
}
const Voe = (e10) => e10, Foe = (e10) => "", Boe = "text", Hoe = (e10) => e10.length === 0 ? "" : $y(e10), zoe = bne;
function ew(e10, t) {
  return e10 = Math.abs(e10), t === 2 ? e10 ? e10 > 1 ? 1 : 0 : 1 : e10 ? Math.min(e10, 2) : 0;
}
function Koe(e10) {
  const t = kn(e10.pluralIndex) ? e10.pluralIndex : -1;
  return e10.named && (kn(e10.named.count) || kn(e10.named.n)) ? kn(e10.named.count) ? e10.named.count : kn(e10.named.n) ? e10.named.n : t : t;
}
function Woe(e10, t) {
  t.count || (t.count = e10), t.n || (t.n = e10);
}
function joe(e10 = {}) {
  const t = e10.locale, n = Koe(e10), o = Gt(e10.pluralRules) && pt(t) && ln(e10.pluralRules[t]) ? e10.pluralRules[t] : ew, r = Gt(e10.pluralRules) && pt(t) && ln(e10.pluralRules[t]) ? ew : void 0, a = (g) => g[o(n, g.length, r)], l = e10.list || [], s = (g) => l[g], u = e10.named || an();
  kn(e10.pluralIndex) && Woe(n, u);
  const c = (g) => u[g];
  function d(g, w) {
    const y = ln(e10.messages) ? e10.messages(g, !!w) : Gt(e10.messages) ? e10.messages[g] : false;
    return y || (e10.parent ? e10.parent.message(g) : Foe);
  }
  const f = (g) => e10.modifiers ? e10.modifiers[g] : Voe, p = Wt(e10.processor) && ln(e10.processor.normalize) ? e10.processor.normalize : Hoe, v = Wt(e10.processor) && ln(e10.processor.interpolate) ? e10.processor.interpolate : zoe, m = Wt(e10.processor) && pt(e10.processor.type) ? e10.processor.type : Boe, b = {
    list: s,
    named: c,
    plural: a,
    linked: (g, ...w) => {
      const [y, _] = w;
      let C = "text", E = "";
      w.length === 1 ? Gt(y) ? (E = y.modifier || E, C = y.type || C) : pt(y) && (E = y || E) : w.length === 2 && (pt(y) && (E = y || E), pt(_) && (C = _ || C));
      const T = d(g, true)(b), O = (
        // The message in vnode resolved with linked are returned as an array by processor.nomalize
        C === "vnode" && mn(T) && E ? T[0] : T
      );
      return E ? f(E)(O, C) : O;
    },
    message: d,
    type: m,
    interpolate: v,
    normalize: p,
    values: Pn(an(), l, u)
  };
  return b;
}
const tw = () => "", Wo = (e10) => ln(e10);
function nw(e10, ...t) {
  const { fallbackFormat: n, postTranslation: o, unresolving: r, messageCompiler: a, fallbackLocale: l, messages: s } = e10, [u, c] = Qh(...t), d = Xt(c.missingWarn) ? c.missingWarn : e10.missingWarn, f = Xt(c.fallbackWarn) ? c.fallbackWarn : e10.fallbackWarn, p = Xt(c.escapeParameter) ? c.escapeParameter : e10.escapeParameter, v = !!c.resolvedMessage, m = pt(c.default) || Xt(c.default) ? Xt(c.default) ? a ? u : () => u : c.default : n ? a ? u : () => u : null, h = n || m != null && (pt(m) || ln(m)), b = Ay(e10, c);
  p && Uoe(c);
  let [g, w, y] = v ? [
    u,
    b,
    s[b] || an()
  ] : oO(e10, u, b, l, f, d), _ = g, C = u;
  if (!v && !(pt(_) || qo(_) || Wo(_)) && h && (_ = m, C = _), !v && (!(pt(_) || qo(_) || Wo(_)) || !pt(w)))
    return r ? _p : u;
  if ( true && pt(_) && e10.messageCompiler == null)
    return hl(`The message format compilation is not supported in this build. Because message compiler isn't included. You need to pre-compilation all message format. So translate function return '${u}'.`), u;
  let E = false;
  const T = () => {
    E = true;
  }, O = Wo(_) ? _ : rO(e10, u, w, _, C, T);
  if (E)
    return _;
  const N = Xoe(e10, w, y, c), $ = joe(N), R = Yoe(e10, O, $), P = o ? o(R, u) : R;
  if (true) {
    const z = {
      timestamp: Date.now(),
      key: pt(u) ? u : Wo(_) ? _.key : "",
      locale: w || (Wo(_) ? _.locale : ""),
      format: pt(_) ? _ : Wo(_) ? _.source : "",
      message: P
    };
    z.meta = Pn({}, e10.__meta, /* @__PURE__ */ Aoe() || {}), doe(z);
  }
  return P;
}
function Uoe(e10) {
  mn(e10.list) ? e10.list = e10.list.map((t) => pt(t) ? x_(t) : t) : Gt(e10.named) && Object.keys(e10.named).forEach((t) => {
    pt(e10.named[t]) && (e10.named[t] = x_(e10.named[t]));
  });
}
function oO(e10, t, n, o, r, a) {
  const { messages: l, onWarn: s, messageResolver: u, localeFallbacker: c } = e10, d = c(e10, o, n);
  let f = an(), p, v = null, m = n, h = null;
  const b = "translate";
  for (let g = 0; g < d.length; g++) {
    if (p = h = d[g],  true && n !== p && !QT(n, p) && wp(r, t) && s(rs(Co.FALLBACK_TO_TRANSLATE, {
      key: t,
      target: p
    })),  true && n !== p) {
      const C = e10.__v_emitter;
      C && C.emit("fallback", {
        type: b,
        key: t,
        from: m,
        to: h,
        groupId: `${b}:${t}`
      });
    }
    f = l[p] || an();
    let w = null, y, _;
    if ( true && _r && (w = window.performance.now(), y = "intlify-message-resolve-start", _ = "intlify-message-resolve-end", Do && Do(y)), (v = u(f, t)) === null && (v = f[t]),  true && _r) {
      const C = window.performance.now(), E = e10.__v_emitter;
      E && w && v && E.emit("message-resolve", {
        type: "message-resolve",
        key: t,
        message: v,
        time: C - w,
        groupId: `${b}:${t}`
      }), y && _ && Do && os && (Do(_), os("intlify message resolve", y, _));
    }
    if (pt(v) || qo(v) || Wo(v))
      break;
    if (!Doe(p, d)) {
      const C = xy(
        e10,
        // eslint-disable-line @typescript-eslint/no-explicit-any
        t,
        p,
        a,
        b
      );
      C !== t && (v = C);
    }
    m = h;
  }
  return [v, p, f];
}
function rO(e10, t, n, o, r, a) {
  const { messageCompiler: l, warnHtmlMessage: s } = e10;
  if (Wo(o)) {
    const p = o;
    return p.locale = p.locale || n, p.key = p.key || t, p;
  }
  if (l == null) {
    const p = () => o;
    return p.locale = n, p.key = t, p;
  }
  let u = null, c, d;
   true && _r && (u = window.performance.now(), c = "intlify-message-compilation-start", d = "intlify-message-compilation-end", Do && Do(c));
  const f = l(o, qoe(e10, n, r, o, s, a));
  if ( true && _r) {
    const p = window.performance.now(), v = e10.__v_emitter;
    v && u && v.emit("message-compilation", {
      type: "message-compilation",
      message: o,
      time: p - u,
      groupId: `translate:${t}`
    }), c && d && Do && os && (Do(d), os("intlify message compilation", c, d));
  }
  return f.locale = n, f.key = t, f.source = o, f;
}
function Yoe(e10, t, n) {
  let o = null, r, a;
   true && _r && (o = window.performance.now(), r = "intlify-message-evaluation-start", a = "intlify-message-evaluation-end", Do && Do(r));
  const l = t(n);
  if ( true && _r) {
    const s = window.performance.now(), u = e10.__v_emitter;
    u && o && u.emit("message-evaluation", {
      type: "message-evaluation",
      value: l,
      time: s - o,
      groupId: `translate:${t.key}`
    }), r && a && Do && os && (Do(a), os("intlify message evaluation", r, a));
  }
  return l;
}
function Qh(...e10) {
  const [t, n, o] = e10, r = an();
  if (!pt(t) && !kn(t) && !Wo(t) && !qo(t))
    throw ga(Jn.INVALID_ARGUMENT);
  const a = kn(t) ? String(t) : (Wo(t), t);
  return kn(n) ? r.plural = n : pt(n) ? r.default = n : Wt(n) && !bp(n) ? r.named = n : mn(n) && (r.list = n), kn(o) ? r.plural = o : pt(o) ? r.default = o : Wt(o) && Pn(r, o), [a, r];
}
function qoe(e10, t, n, o, r, a) {
  return {
    locale: t,
    key: n,
    warnHtmlMessage: r,
    onError: (l) => {
      if (a && a(l), "development" !== "production") {
        const s = Goe(o), u = `Message compilation error: ${l.message}`, c = l.location && s && _ne(s, l.location.start.offset, l.location.end.offset), d = e10.__v_emitter;
        d && s && d.emit("compile-error", {
          message: s,
          error: l.message,
          start: l.location && l.location.start.offset,
          end: l.location && l.location.end.offset,
          groupId: `translate:${n}`
        }), console.error(c ? `${u}
${c}` : u);
      } else
        throw l;
    },
    onCacheKey: (l) => pne(t, n, l)
  };
}
function Goe(e10) {
  if (pt(e10))
    return e10;
  if (e10.loc && e10.loc.source)
    return e10.loc.source;
}
function Xoe(e10, t, n, o) {
  const { modifiers: r, pluralRules: a, messageResolver: l, fallbackLocale: s, fallbackWarn: u, missingWarn: c, fallbackContext: d } = e10, p = {
    locale: t,
    modifiers: r,
    pluralRules: a,
    messages: (v, m) => {
      let h = l(n, v);
      if (h == null && (d || m)) {
        const [, , b] = oO(
          d || e10,
          // NOTE: if has fallbackContext, fallback to root, else if use linked, fallback to local context
          v,
          t,
          s,
          u,
          c
        );
        h = l(b, v);
      }
      if (pt(h) || qo(h)) {
        let b = false;
        const w = rO(e10, v, t, h, v, () => {
          b = true;
        });
        return b ? tw : w;
      } else return Wo(h) ? h : tw;
    }
  };
  return e10.processor && (p.processor = e10.processor), o.list && (p.list = o.list), o.named && (p.named = o.named), kn(o.plural) && (p.pluralIndex = o.plural), p;
}
Xne();
function Joe() {
  return aO().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function aO() {
  return typeof navigator < "u" && typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : {};
}
const Zoe = typeof Proxy == "function", Qoe = "devtools-plugin:setup", ere = "plugin:settings:set";
let Cs, em;
function tre() {
  var e10;
  return Cs !== void 0 || (typeof window < "u" && window.performance ? (Cs = true, em = window.performance) : typeof globalThis < "u" && (!((e10 = globalThis.perf_hooks) === null || e10 === void 0) && e10.performance) ? (Cs = true, em = globalThis.perf_hooks.performance) : Cs = false), Cs;
}
function nre() {
  return tre() ? em.now() : Date.now();
}
class ore {
  constructor(t, n) {
    this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = t, this.hook = n;
    const o = {};
    if (t.settings)
      for (const l in t.settings) {
        const s = t.settings[l];
        o[l] = s.defaultValue;
      }
    const r = `__vue-devtools-plugin-settings__${t.id}`;
    let a = Object.assign({}, o);
    try {
      const l = localStorage.getItem(r), s = JSON.parse(l);
      Object.assign(a, s);
    } catch {
    }
    this.fallbacks = {
      getSettings() {
        return a;
      },
      setSettings(l) {
        try {
          localStorage.setItem(r, JSON.stringify(l));
        } catch {
        }
        a = l;
      },
      now() {
        return nre();
      }
    }, n && n.on(ere, (l, s) => {
      l === this.plugin.id && this.fallbacks.setSettings(s);
    }), this.proxiedOn = new Proxy({}, {
      get: (l, s) => this.target ? this.target.on[s] : (...u) => {
        this.onQueue.push({
          method: s,
          args: u
        });
      }
    }), this.proxiedTarget = new Proxy({}, {
      get: (l, s) => this.target ? this.target[s] : s === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(s) ? (...u) => (this.targetQueue.push({
        method: s,
        args: u,
        resolve: () => {
        }
      }), this.fallbacks[s](...u)) : (...u) => new Promise((c) => {
        this.targetQueue.push({
          method: s,
          args: u,
          resolve: c
        });
      })
    });
  }
  async setRealTarget(t) {
    this.target = t;
    for (const n of this.onQueue)
      this.target.on[n.method](...n.args);
    for (const n of this.targetQueue)
      n.resolve(await this.target[n.method](...n.args));
  }
}
function rre(e10, t) {
  const n = e10, o = aO(), r = Joe(), a = Zoe && n.enableEarlyProxy;
  if (r && (o.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !a))
    r.emit(Qoe, e10, t);
  else {
    const l = a ? new ore(n, r) : null;
    (o.__VUE_DEVTOOLS_PLUGINS__ = o.__VUE_DEVTOOLS_PLUGINS__ || []).push({
      pluginDescriptor: n,
      setupFn: t,
      proxy: l
    }), l && t(l.proxiedTarget);
  }
}
/*!
  * vue-i18n v11.1.5
  * (c) 2025 kazuya kawaguchi
  * Released under the MIT License.
  */
const are = "11.1.5";
function lre() {
  typeof __VUE_I18N_FULL_INSTALL__ != "boolean" && (Al().__VUE_I18N_FULL_INSTALL__ = true), typeof __VUE_I18N_LEGACY_API__ != "boolean" && (Al().__VUE_I18N_LEGACY_API__ = true), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (Al().__INTLIFY_DROP_MESSAGE_COMPILER__ = false), typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (Al().__INTLIFY_PROD_DEVTOOLS__ = false);
}
const cn = {
  // composer module errors
  UNEXPECTED_RETURN_TYPE: poe,
  // 24
  // legacy module errors
  INVALID_ARGUMENT: 25,
  // i18n module errors
  MUST_BE_CALL_SETUP_TOP: 26,
  NOT_INSTALLED: 27,
  // directive module errors
  REQUIRED_VALUE: 28,
  INVALID_VALUE: 29,
  // vue-devtools errors
  CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: 30,
  NOT_INSTALLED_WITH_PROVIDE: 31,
  // unexpected error
  UNEXPECTED_ERROR: 32,
  // not compatible legacy vue-i18n constructor
  NOT_COMPATIBLE_LEGACY_VUE_I18N: 33,
  // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
  NOT_AVAILABLE_COMPOSITION_IN_LEGACY: 34
};
function $o(e10, ...t) {
  return Pi(e10, null,  true ? { messages: sre, args: t } : 0);
}
const sre = {
  [cn.UNEXPECTED_RETURN_TYPE]: "Unexpected return type in composer",
  [cn.INVALID_ARGUMENT]: "Invalid argument",
  [cn.MUST_BE_CALL_SETUP_TOP]: "Must be called at the top of a `setup` function",
  [cn.NOT_INSTALLED]: "Need to install with `app.use` function",
  [cn.UNEXPECTED_ERROR]: "Unexpected error",
  [cn.REQUIRED_VALUE]: "Required in value: {0}",
  [cn.INVALID_VALUE]: "Invalid value",
  [cn.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN]: "Cannot setup vue-devtools plugin",
  [cn.NOT_INSTALLED_WITH_PROVIDE]: "Need to install with `provide` function",
  [cn.NOT_COMPATIBLE_LEGACY_VUE_I18N]: "Not compatible legacy VueI18n.",
  [cn.NOT_AVAILABLE_COMPOSITION_IN_LEGACY]: "Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly"
}, tm = /* @__PURE__ */ oa("__translateVNode"), nm = /* @__PURE__ */ oa("__datetimeParts"), om = /* @__PURE__ */ oa("__numberParts"), as = /* @__PURE__ */ oa("__enableEmitter"), Ku = /* @__PURE__ */ oa("__disableEmitter"), lO = oa("__setPluralRules"), sO = /* @__PURE__ */ oa("__injectWithOption"), rm = /* @__PURE__ */ oa("__dispose"), Dr = {
  FALLBACK_TO_ROOT: Noe,
  // 8
  NOT_FOUND_PARENT_SCOPE: 9,
  IGNORE_OBJ_FLATTEN: 10,
  /**
   * @deprecated will be removed at vue-i18n v12
   */
  DEPRECATE_LEGACY_MODE: 11,
  /**
   * @deprecated will be removed at vue-i18n v12
   */
  DEPRECATE_TRANSLATE_CUSTOME_DIRECTIVE: 12
}, ire = {
  [Dr.FALLBACK_TO_ROOT]: "Fall back to {type} '{key}' with root locale.",
  [Dr.NOT_FOUND_PARENT_SCOPE]: "Not found parent scope. use the global scope.",
  [Dr.IGNORE_OBJ_FLATTEN]: "Ignore object flatten: '{key}' key has an string value",
  /**
   * @deprecated will be removed at vue-i18n v12
   */
  [Dr.DEPRECATE_LEGACY_MODE]: `Legacy API mode has been deprecated in v11. Use Composition API mode instead.
About how to use the Composition API mode, see https://vue-i18n.intlify.dev/guide/advanced/composition.html`,
  /**
   * @deprecated will be removed at vue-i18n v12
   */
  [Dr.DEPRECATE_TRANSLATE_CUSTOME_DIRECTIVE]: "'v-t' has been deprecated in v11. Use translate APIs ('t' or '$t') instead."
};
function _c(e10, ...t) {
  return yp(ire[e10], ...t);
}
function Wu(e10) {
  if (!Gt(e10) || qo(e10))
    return e10;
  for (const t in e10)
    if (ur(e10, t))
      if (!t.includes("."))
        Gt(e10[t]) && Wu(e10[t]);
      else {
        const n = t.split("."), o = n.length - 1;
        let r = e10, a = false;
        for (let l = 0; l < o; l++) {
          if (n[l] === "__proto__")
            throw new Error(`unsafe key: ${n[l]}`);
          if (n[l] in r || (r[n[l]] = an()), !Gt(r[n[l]])) {
             true && hl(_c(Dr.IGNORE_OBJ_FLATTEN, {
              key: n[l]
            })), a = true;
            break;
          }
          r = r[n[l]];
        }
        if (a || (qo(r) ? UT.includes(n[o]) || delete e10[t] : (r[n[o]] = e10[t], delete e10[t])), !qo(r)) {
          const l = r[n[o]];
          Gt(l) && Wu(l);
        }
      }
  return e10;
}
function Dy(e10, t) {
  const { messages: n, __i18n: o, messageResolver: r, flatJson: a } = t, l = Wt(n) ? n : mn(o) ? an() : { [e10]: an() };
  if (mn(o) && o.forEach((s) => {
    if ("locale" in s && "resource" in s) {
      const { locale: u, resource: c } = s;
      u ? (l[u] = l[u] || an(), Md(c, l[u])) : Md(c, l);
    } else
      pt(s) && Md(JSON.parse(s), l);
  }), r == null && a)
    for (const s in l)
      ur(l, s) && Wu(l[s]);
  return l;
}
function iO(e10) {
  return e10.type;
}
function uO(e10, t, n) {
  let o = Gt(t.messages) ? t.messages : an();
  "__i18nGlobal" in n && (o = Dy(e10.locale.value, {
    messages: o,
    __i18n: n.__i18nGlobal
  }));
  const r = Object.keys(o);
  r.length && r.forEach((a) => {
    e10.mergeLocaleMessage(a, o[a]);
  });
  {
    if (Gt(t.datetimeFormats)) {
      const a = Object.keys(t.datetimeFormats);
      a.length && a.forEach((l) => {
        e10.mergeDateTimeFormat(l, t.datetimeFormats[l]);
      });
    }
    if (Gt(t.numberFormats)) {
      const a = Object.keys(t.numberFormats);
      a.length && a.forEach((l) => {
        e10.mergeNumberFormat(l, t.numberFormats[l]);
      });
    }
  }
}
function ow(e10) {
  return W(Zr, null, e10, 0);
}
const rw = "__INTLIFY_META__", aw = () => [], ure = () => false;
let lw = 0;
function sw(e10) {
  return (t, n, o, r) => e10(n, o, it() || void 0, r);
}
const cre = /* @__NO_SIDE_EFFECTS__ */ () => {
  const e10 = it();
  let t = null;
  return e10 && (t = iO(e10)[rw]) ? { [rw]: t } : null;
};
function Vy(e10 = {}) {
  const { __root: t, __injectWithOption: n } = e10, o = t === void 0, r = e10.flatJson, a = _r ? L : qt;
  let l = Xt(e10.inheritLocale) ? e10.inheritLocale : true;
  const s = a(
    // prettier-ignore
    t && l ? t.locale.value : pt(e10.locale) ? e10.locale : zu
  ), u = a(
    // prettier-ignore
    t && l ? t.fallbackLocale.value : pt(e10.fallbackLocale) || mn(e10.fallbackLocale) || Wt(e10.fallbackLocale) || e10.fallbackLocale === false ? e10.fallbackLocale : s.value
  ), c = a(Dy(s.value, e10)), d = a(Wt(e10.datetimeFormats) ? e10.datetimeFormats : { [s.value]: {} }), f = a(Wt(e10.numberFormats) ? e10.numberFormats : { [s.value]: {} });
  let p = t ? t.missingWarn : Xt(e10.missingWarn) || mi(e10.missingWarn) ? e10.missingWarn : true, v = t ? t.fallbackWarn : Xt(e10.fallbackWarn) || mi(e10.fallbackWarn) ? e10.fallbackWarn : true, m = t ? t.fallbackRoot : Xt(e10.fallbackRoot) ? e10.fallbackRoot : true, h = !!e10.fallbackFormat, b = ln(e10.missing) ? e10.missing : null, g = ln(e10.missing) ? sw(e10.missing) : null, w = ln(e10.postTranslation) ? e10.postTranslation : null, y = t ? t.warnHtmlMessage : Xt(e10.warnHtmlMessage) ? e10.warnHtmlMessage : true, _ = !!e10.escapeParameter;
  const C = t ? t.modifiers : Wt(e10.modifiers) ? e10.modifiers : {};
  let E = e10.pluralRules || t && t.pluralRules, T;
  T = (() => {
    o && Y_(null);
    const ie = {
      version: are,
      locale: s.value,
      fallbackLocale: u.value,
      messages: c.value,
      modifiers: C,
      pluralRules: E,
      missing: g === null ? void 0 : g,
      missingWarn: p,
      fallbackWarn: v,
      fallbackFormat: h,
      unresolving: true,
      postTranslation: w === null ? void 0 : w,
      warnHtmlMessage: y,
      escapeParameter: _,
      messageResolver: e10.messageResolver,
      messageCompiler: e10.messageCompiler,
      __meta: { framework: "vue" }
    };
    ie.datetimeFormats = d.value, ie.numberFormats = f.value, ie.__datetimeFormatters = Wt(T) ? T.__datetimeFormatters : void 0, ie.__numberFormatters = Wt(T) ? T.__numberFormatters : void 0,  true && (ie.__v_emitter = Wt(T) ? T.__v_emitter : void 0);
    const Ce = xoe(ie);
    return o && Y_(Ce), Ce;
  })(), Ki(T, s.value, u.value);
  function N() {
    return [
      s.value,
      u.value,
      c.value,
      d.value,
      f.value
    ];
  }
  const $ = S({
    get: () => s.value,
    set: (ie) => {
      T.locale = ie, s.value = ie;
    }
  }), R = S({
    get: () => u.value,
    set: (ie) => {
      T.fallbackLocale = ie, u.value = ie, Ki(T, s.value, ie);
    }
  }), P = S(() => c.value), z = /* @__PURE__ */ S(() => d.value), Y = /* @__PURE__ */ S(() => f.value);
  function D() {
    return ln(w) ? w : null;
  }
  function M(ie) {
    w = ie, T.postTranslation = ie;
  }
  function F() {
    return b;
  }
  function A(ie) {
    ie !== null && (g = sw(ie)), b = ie, T.missing = g;
  }
  function V(ie, Ce) {
    return ie !== "translate" || !Ce.resolvedMessage;
  }
  const Z = (ie, Ce, qe, et, ft, bt) => {
    N();
    let zt;
    try {
       true || 0, o || (T.fallbackContext = t ? Loe() : void 0), zt = ie(T);
    } finally {
       true || 0, o || (T.fallbackContext = void 0);
    }
    if (qe !== "translate exists" && // for not `te` (e.g `t`)
    kn(zt) && zt === _p || qe === "translate exists" && !zt) {
      const [We, ct] = Ce();
      if ( true && t && pt(We) && V(qe, ct) && (m && (wp(v, We) || ZT(p, We)) && hl(_c(Dr.FALLBACK_TO_ROOT, {
        key: We,
        type: qe
      })), "development" !== "production")) {
        const { __v_emitter: oe } = T;
        oe && m && oe.emit("fallback", {
          type: qe,
          key: We,
          to: "global",
          groupId: `${qe}:${We}`
        });
      }
      return t && m ? et(t) : ft(We);
    } else {
      if (bt(zt))
        return zt;
      throw $o(cn.UNEXPECTED_RETURN_TYPE);
    }
  };
  function G(...ie) {
    return Z((Ce) => Reflect.apply(nw, null, [Ce, ...ie]), () => Qh(...ie), "translate", (Ce) => Reflect.apply(Ce.t, Ce, [...ie]), (Ce) => Ce, (Ce) => pt(Ce));
  }
  function le(...ie) {
    const [Ce, qe, et] = ie;
    if (et && !Gt(et))
      throw $o(cn.INVALID_ARGUMENT);
    return G(Ce, qe, Pn({ resolvedMessage: true }, et || {}));
  }
  function X(...ie) {
    return Z((Ce) => Reflect.apply(X_, null, [Ce, ...ie]), () => Jh(...ie), "datetime format", (Ce) => Reflect.apply(Ce.d, Ce, [...ie]), () => kf, (Ce) => pt(Ce) || mn(Ce));
  }
  function te(...ie) {
    return Z((Ce) => Reflect.apply(Z_, null, [Ce, ...ie]), () => Zh(...ie), "number format", (Ce) => Reflect.apply(Ce.n, Ce, [...ie]), () => kf, (Ce) => pt(Ce) || mn(Ce));
  }
  function ce(ie) {
    return ie.map((Ce) => pt(Ce) || kn(Ce) || Xt(Ce) ? ow(String(Ce)) : Ce);
  }
  const se = {
    normalize: ce,
    interpolate: (ie) => ie,
    type: "vnode"
  };
  function ve(...ie) {
    return Z((Ce) => {
      let qe;
      const et = Ce;
      try {
        et.processor = se, qe = Reflect.apply(nw, null, [et, ...ie]);
      } finally {
        et.processor = null;
      }
      return qe;
    }, () => Qh(...ie), "translate", (Ce) => Ce[tm](...ie), (Ce) => [ow(Ce)], (Ce) => mn(Ce));
  }
  function me(...ie) {
    return Z((Ce) => Reflect.apply(Z_, null, [Ce, ...ie]), () => Zh(...ie), "number format", (Ce) => Ce[om](...ie), aw, (Ce) => pt(Ce) || mn(Ce));
  }
  function De(...ie) {
    return Z((Ce) => Reflect.apply(X_, null, [Ce, ...ie]), () => Jh(...ie), "datetime format", (Ce) => Ce[nm](...ie), aw, (Ce) => pt(Ce) || mn(Ce));
  }
  function Te(ie) {
    E = ie, T.pluralRules = E;
  }
  function de(ie, Ce) {
    return Z(() => {
      if (!ie)
        return false;
      const qe = pt(Ce) ? Ce : s.value, et = he(qe), ft = T.messageResolver(et, ie);
      return qo(ft) || Wo(ft) || pt(ft);
    }, () => [ie], "translate exists", (qe) => Reflect.apply(qe.te, qe, [ie, Ce]), ure, (qe) => Xt(qe));
  }
  function U(ie) {
    let Ce = null;
    const qe = Ly(T, u.value, s.value);
    for (let et = 0; et < qe.length; et++) {
      const ft = c.value[qe[et]] || {}, bt = T.messageResolver(ft, ie);
      if (bt != null) {
        Ce = bt;
        break;
      }
    }
    return Ce;
  }
  function re(ie) {
    const Ce = U(ie);
    return Ce != null ? Ce : t ? t.tm(ie) || {} : {};
  }
  function he(ie) {
    return c.value[ie] || {};
  }
  function Ee(ie, Ce) {
    if (r) {
      const qe = { [ie]: Ce };
      for (const et in qe)
        ur(qe, et) && Wu(qe[et]);
      Ce = qe[ie];
    }
    c.value[ie] = Ce, T.messages = c.value;
  }
  function ye(ie, Ce) {
    c.value[ie] = c.value[ie] || {};
    const qe = { [ie]: Ce };
    if (r)
      for (const et in qe)
        ur(qe, et) && Wu(qe[et]);
    Ce = qe[ie], Md(Ce, c.value[ie]), T.messages = c.value;
  }
  function K(ie) {
    return d.value[ie] || {};
  }
  function q(ie, Ce) {
    d.value[ie] = Ce, T.datetimeFormats = d.value, J_(T, ie, Ce);
  }
  function ue(ie, Ce) {
    d.value[ie] = Pn(d.value[ie] || {}, Ce), T.datetimeFormats = d.value, J_(T, ie, Ce);
  }
  function be(ie) {
    return f.value[ie] || {};
  }
  function ke(ie, Ce) {
    f.value[ie] = Ce, T.numberFormats = f.value, Q_(T, ie, Ce);
  }
  function Ae(ie, Ce) {
    f.value[ie] = Pn(f.value[ie] || {}, Ce), T.numberFormats = f.value, Q_(T, ie, Ce);
  }
  lw++, t && _r && (ge(t.locale, (ie) => {
    l && (s.value = ie, T.locale = ie, Ki(T, s.value, u.value));
  }), ge(t.fallbackLocale, (ie) => {
    l && (u.value = ie, T.fallbackLocale = ie, Ki(T, s.value, u.value));
  }));
  const fe = {
    id: lw,
    locale: $,
    fallbackLocale: R,
    get inheritLocale() {
      return l;
    },
    set inheritLocale(ie) {
      l = ie, ie && t && (s.value = t.locale.value, u.value = t.fallbackLocale.value, Ki(T, s.value, u.value));
    },
    get availableLocales() {
      return Object.keys(c.value).sort();
    },
    messages: P,
    get modifiers() {
      return C;
    },
    get pluralRules() {
      return E || {};
    },
    get isGlobal() {
      return o;
    },
    get missingWarn() {
      return p;
    },
    set missingWarn(ie) {
      p = ie, T.missingWarn = p;
    },
    get fallbackWarn() {
      return v;
    },
    set fallbackWarn(ie) {
      v = ie, T.fallbackWarn = v;
    },
    get fallbackRoot() {
      return m;
    },
    set fallbackRoot(ie) {
      m = ie;
    },
    get fallbackFormat() {
      return h;
    },
    set fallbackFormat(ie) {
      h = ie, T.fallbackFormat = h;
    },
    get warnHtmlMessage() {
      return y;
    },
    set warnHtmlMessage(ie) {
      y = ie, T.warnHtmlMessage = ie;
    },
    get escapeParameter() {
      return _;
    },
    set escapeParameter(ie) {
      _ = ie, T.escapeParameter = ie;
    },
    t: G,
    getLocaleMessage: he,
    setLocaleMessage: Ee,
    mergeLocaleMessage: ye,
    getPostTranslationHandler: D,
    setPostTranslationHandler: M,
    getMissingHandler: F,
    setMissingHandler: A,
    [lO]: Te
  };
  return fe.datetimeFormats = z, fe.numberFormats = Y, fe.rt = le, fe.te = de, fe.tm = re, fe.d = X, fe.n = te, fe.getDateTimeFormat = K, fe.setDateTimeFormat = q, fe.mergeDateTimeFormat = ue, fe.getNumberFormat = be, fe.setNumberFormat = ke, fe.mergeNumberFormat = Ae, fe[sO] = n, fe[tm] = ve, fe[nm] = De, fe[om] = me,  true && (fe[as] = (ie) => {
    T.__v_emitter = ie;
  }, fe[Ku] = () => {
    T.__v_emitter = void 0;
  }), fe;
}
const cO = "vue-i18n: composer properties", Ev = {
  "vue-devtools-plugin-vue-i18n": "Vue I18n DevTools",
  "vue-i18n-resource-inspector": "Vue I18n DevTools",
  "vue-i18n-timeline": "Vue I18n"
}, dre = {
  "vue-i18n-resource-inspector": "Search for scopes ..."
}, fre = {
  "vue-i18n-timeline": 16764185
};
let am;
async function pre(e10, t) {
  return new Promise((n, o) => {
    try {
      rre({
        id: "vue-devtools-plugin-vue-i18n",
        label: Ev["vue-devtools-plugin-vue-i18n"],
        packageName: "vue-i18n",
        homepage: "https://vue-i18n.intlify.dev",
        logo: "https://vue-i18n.intlify.dev/vue-i18n-devtools-logo.png",
        componentStateTypes: [cO],
        app: e10
        // eslint-disable-line @typescript-eslint/no-explicit-any
      }, (r) => {
        am = r, r.on.visitComponentTree(({ componentInstance: l, treeNode: s }) => {
          vre(l, s, t);
        }), r.on.inspectComponent(({ componentInstance: l, instanceData: s }) => {
          l.vnode.el && l.vnode.el.__VUE_I18N__ && s && (t.mode === "legacy" ? l.vnode.el.__VUE_I18N__ !== t.global.__composer && iw(s, l.vnode.el.__VUE_I18N__) : iw(s, l.vnode.el.__VUE_I18N__));
        }), r.addInspector({
          id: "vue-i18n-resource-inspector",
          label: Ev["vue-i18n-resource-inspector"],
          icon: "language",
          treeFilterPlaceholder: dre["vue-i18n-resource-inspector"]
        }), r.on.getInspectorTree((l) => {
          l.app === e10 && l.inspectorId === "vue-i18n-resource-inspector" && bre(l, t);
        });
        const a = /* @__PURE__ */ new Map();
        r.on.getInspectorState(async (l) => {
          if (l.app === e10 && l.inspectorId === "vue-i18n-resource-inspector")
            if (r.unhighlightElement(), wre(l, t), l.nodeId === "global") {
              if (!a.has(l.app)) {
                const [s] = await r.getComponentInstances(l.app);
                a.set(l.app, s);
              }
              r.highlightElement(a.get(l.app));
            } else {
              const s = _re(l.nodeId, t);
              s && r.highlightElement(s);
            }
        }), r.on.editInspectorState((l) => {
          l.app === e10 && l.inspectorId === "vue-i18n-resource-inspector" && Ere(l, t);
        }), r.addTimelineLayer({
          id: "vue-i18n-timeline",
          label: Ev["vue-i18n-timeline"],
          color: fre["vue-i18n-timeline"]
        }), n(true);
      });
    } catch (r) {
      console.error(r), o(false);
    }
  });
}
function dO(e10) {
  return e10.type.name || e10.type.displayName || e10.type.__file || "Anonymous";
}
function vre(e10, t, n) {
  const o = n.mode === "composition" ? n.global : n.global.__composer;
  if (e10 && e10.vnode.el && e10.vnode.el.__VUE_I18N__ && e10.vnode.el.__VUE_I18N__ !== o) {
    const r = {
      label: `i18n (${dO(e10)} Scope)`,
      textColor: 0,
      backgroundColor: 16764185
    };
    t.tags.push(r);
  }
}
function iw(e10, t) {
  const n = cO;
  e10.state.push({
    type: n,
    key: "locale",
    editable: true,
    value: t.locale.value
  }), e10.state.push({
    type: n,
    key: "availableLocales",
    editable: false,
    value: t.availableLocales
  }), e10.state.push({
    type: n,
    key: "fallbackLocale",
    editable: true,
    value: t.fallbackLocale.value
  }), e10.state.push({
    type: n,
    key: "inheritLocale",
    editable: true,
    value: t.inheritLocale
  }), e10.state.push({
    type: n,
    key: "messages",
    editable: false,
    value: Fy(t.messages.value)
  }), e10.state.push({
    type: n,
    key: "datetimeFormats",
    editable: false,
    value: t.datetimeFormats.value
  }), e10.state.push({
    type: n,
    key: "numberFormats",
    editable: false,
    value: t.numberFormats.value
  });
}
function Fy(e10) {
  const t = {};
  return Object.keys(e10).forEach((n) => {
    const o = e10[n];
    ln(o) && "source" in o ? t[n] = yre(o) : qo(o) && o.loc && o.loc.source ? t[n] = o.loc.source : Gt(o) ? t[n] = Fy(o) : t[n] = o;
  }), t;
}
const hre = {
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "&": "&amp;"
};
function mre(e10) {
  return e10.replace(/[<>"&]/g, gre);
}
function gre(e10) {
  return hre[e10] || e10;
}
function yre(e10) {
  return {
    _custom: {
      type: "function",
      display: `<span>\u0192</span> ${e10.source ? `("${mre(e10.source)}")` : "(?)"}`
    }
  };
}
function bre(e10, t) {
  e10.rootNodes.push({
    id: "global",
    label: "Global Scope"
  });
  const n = t.mode === "composition" ? t.global : t.global.__composer;
  for (const [o, r] of t.__instances) {
    const a = t.mode === "composition" ? r : r.__composer;
    n !== a && e10.rootNodes.push({
      id: a.id.toString(),
      label: `${dO(o)} Scope`
    });
  }
}
function _re(e10, t) {
  let n = null;
  if (e10 !== "global") {
    for (const [o, r] of t.__instances.entries())
      if (r.id.toString() === e10) {
        n = o;
        break;
      }
  }
  return n;
}
function fO(e10, t) {
  if (e10 === "global")
    return t.mode === "composition" ? t.global : t.global.__composer;
  {
    const n = Array.from(t.__instances.values()).find((o) => o.id.toString() === e10);
    return n ? t.mode === "composition" ? n : n.__composer : null;
  }
}
function wre(e10, t) {
  const n = fO(e10.nodeId, t);
  return n && (e10.state = Cre(n)), null;
}
function Cre(e10) {
  const t = {}, n = "Locale related info", o = [
    {
      type: n,
      key: "locale",
      editable: true,
      value: e10.locale.value
    },
    {
      type: n,
      key: "fallbackLocale",
      editable: true,
      value: e10.fallbackLocale.value
    },
    {
      type: n,
      key: "availableLocales",
      editable: false,
      value: e10.availableLocales
    },
    {
      type: n,
      key: "inheritLocale",
      editable: true,
      value: e10.inheritLocale
    }
  ];
  t[n] = o;
  const r = "Locale messages info", a = [
    {
      type: r,
      key: "messages",
      editable: false,
      value: Fy(e10.messages.value)
    }
  ];
  t[r] = a;
  {
    const l = "Datetime formats info", s = [
      {
        type: l,
        key: "datetimeFormats",
        editable: false,
        value: e10.datetimeFormats.value
      }
    ];
    t[l] = s;
    const u = "Datetime formats info", c = [
      {
        type: u,
        key: "numberFormats",
        editable: false,
        value: e10.numberFormats.value
      }
    ];
    t[u] = c;
  }
  return t;
}
function ju(e10, t) {
  if (am) {
    let n;
    t && "groupId" in t && (n = t.groupId, delete t.groupId), am.addTimelineEvent({
      layerId: "vue-i18n-timeline",
      event: {
        title: e10,
        groupId: n,
        time: Date.now(),
        meta: {},
        data: t || {},
        logType: e10 === "compile-error" ? "error" : e10 === "fallback" || e10 === "missing" ? "warning" : "default"
      }
    });
  }
}
function Ere(e10, t) {
  const n = fO(e10.nodeId, t);
  if (n) {
    const [o] = e10.path;
    o === "locale" && pt(e10.state.value) ? n.locale.value = e10.state.value : o === "fallbackLocale" && (pt(e10.state.value) || mn(e10.state.value) || Gt(e10.state.value)) ? n.fallbackLocale.value = e10.state.value : o === "inheritLocale" && Xt(e10.state.value) && (n.inheritLocale = e10.state.value);
  }
}
function Sre(e10) {
  const t = pt(e10.locale) ? e10.locale : zu, n = pt(e10.fallbackLocale) || mn(e10.fallbackLocale) || Wt(e10.fallbackLocale) || e10.fallbackLocale === false ? e10.fallbackLocale : t, o = ln(e10.missing) ? e10.missing : void 0, r = Xt(e10.silentTranslationWarn) || mi(e10.silentTranslationWarn) ? !e10.silentTranslationWarn : true, a = Xt(e10.silentFallbackWarn) || mi(e10.silentFallbackWarn) ? !e10.silentFallbackWarn : true, l = Xt(e10.fallbackRoot) ? e10.fallbackRoot : true, s = !!e10.formatFallbackMessages, u = Wt(e10.modifiers) ? e10.modifiers : {}, c = e10.pluralizationRules, d = ln(e10.postTranslation) ? e10.postTranslation : void 0, f = pt(e10.warnHtmlInMessage) ? e10.warnHtmlInMessage !== "off" : true, p = !!e10.escapeParameterHtml, v = Xt(e10.sync) ? e10.sync : true;
  let m = e10.messages;
  if (Wt(e10.sharedMessages)) {
    const C = e10.sharedMessages;
    m = Object.keys(C).reduce((T, O) => {
      const N = T[O] || (T[O] = {});
      return Pn(N, C[O]), T;
    }, m || {});
  }
  const { __i18n: h, __root: b, __injectWithOption: g } = e10, w = e10.datetimeFormats, y = e10.numberFormats, _ = e10.flatJson;
  return {
    locale: t,
    fallbackLocale: n,
    messages: m,
    flatJson: _,
    datetimeFormats: w,
    numberFormats: y,
    missing: o,
    missingWarn: r,
    fallbackWarn: a,
    fallbackRoot: l,
    fallbackFormat: s,
    modifiers: u,
    pluralRules: c,
    postTranslation: d,
    warnHtmlMessage: f,
    escapeParameter: p,
    messageResolver: e10.messageResolver,
    inheritLocale: v,
    __i18n: h,
    __root: b,
    __injectWithOption: g
  };
}
function lm(e10 = {}) {
  const t = Vy(Sre(e10)), { __extender: n } = e10, o = {
    // id
    id: t.id,
    // locale
    get locale() {
      return t.locale.value;
    },
    set locale(r) {
      t.locale.value = r;
    },
    // fallbackLocale
    get fallbackLocale() {
      return t.fallbackLocale.value;
    },
    set fallbackLocale(r) {
      t.fallbackLocale.value = r;
    },
    // messages
    get messages() {
      return t.messages.value;
    },
    // datetimeFormats
    get datetimeFormats() {
      return t.datetimeFormats.value;
    },
    // numberFormats
    get numberFormats() {
      return t.numberFormats.value;
    },
    // availableLocales
    get availableLocales() {
      return t.availableLocales;
    },
    // missing
    get missing() {
      return t.getMissingHandler();
    },
    set missing(r) {
      t.setMissingHandler(r);
    },
    // silentTranslationWarn
    get silentTranslationWarn() {
      return Xt(t.missingWarn) ? !t.missingWarn : t.missingWarn;
    },
    set silentTranslationWarn(r) {
      t.missingWarn = Xt(r) ? !r : r;
    },
    // silentFallbackWarn
    get silentFallbackWarn() {
      return Xt(t.fallbackWarn) ? !t.fallbackWarn : t.fallbackWarn;
    },
    set silentFallbackWarn(r) {
      t.fallbackWarn = Xt(r) ? !r : r;
    },
    // modifiers
    get modifiers() {
      return t.modifiers;
    },
    // formatFallbackMessages
    get formatFallbackMessages() {
      return t.fallbackFormat;
    },
    set formatFallbackMessages(r) {
      t.fallbackFormat = r;
    },
    // postTranslation
    get postTranslation() {
      return t.getPostTranslationHandler();
    },
    set postTranslation(r) {
      t.setPostTranslationHandler(r);
    },
    // sync
    get sync() {
      return t.inheritLocale;
    },
    set sync(r) {
      t.inheritLocale = r;
    },
    // warnInHtmlMessage
    get warnHtmlInMessage() {
      return t.warnHtmlMessage ? "warn" : "off";
    },
    set warnHtmlInMessage(r) {
      t.warnHtmlMessage = r !== "off";
    },
    // escapeParameterHtml
    get escapeParameterHtml() {
      return t.escapeParameter;
    },
    set escapeParameterHtml(r) {
      t.escapeParameter = r;
    },
    // pluralizationRules
    get pluralizationRules() {
      return t.pluralRules || {};
    },
    // for internal
    __composer: t,
    // t
    t(...r) {
      return Reflect.apply(t.t, t, [...r]);
    },
    // rt
    rt(...r) {
      return Reflect.apply(t.rt, t, [...r]);
    },
    // te
    te(r, a) {
      return t.te(r, a);
    },
    // tm
    tm(r) {
      return t.tm(r);
    },
    // getLocaleMessage
    getLocaleMessage(r) {
      return t.getLocaleMessage(r);
    },
    // setLocaleMessage
    setLocaleMessage(r, a) {
      t.setLocaleMessage(r, a);
    },
    // mergeLocaleMessage
    mergeLocaleMessage(r, a) {
      t.mergeLocaleMessage(r, a);
    },
    // d
    d(...r) {
      return Reflect.apply(t.d, t, [...r]);
    },
    // getDateTimeFormat
    getDateTimeFormat(r) {
      return t.getDateTimeFormat(r);
    },
    // setDateTimeFormat
    setDateTimeFormat(r, a) {
      t.setDateTimeFormat(r, a);
    },
    // mergeDateTimeFormat
    mergeDateTimeFormat(r, a) {
      t.mergeDateTimeFormat(r, a);
    },
    // n
    n(...r) {
      return Reflect.apply(t.n, t, [...r]);
    },
    // getNumberFormat
    getNumberFormat(r) {
      return t.getNumberFormat(r);
    },
    // setNumberFormat
    setNumberFormat(r, a) {
      t.setNumberFormat(r, a);
    },
    // mergeNumberFormat
    mergeNumberFormat(r, a) {
      t.mergeNumberFormat(r, a);
    }
  };
  return o.__extender = n,  true && (o.__enableEmitter = (r) => {
    const a = t;
    a[as] && a[as](r);
  }, o.__disableEmitter = () => {
    const r = t;
    r[Ku] && r[Ku]();
  }), o;
}
function kre(e10, t, n) {
  return {
    beforeCreate() {
      const o = it();
      if (!o)
        throw $o(cn.UNEXPECTED_ERROR);
      const r = this.$options;
      if (r.i18n) {
        const a = r.i18n;
        if (r.__i18n && (a.__i18n = r.__i18n), a.__root = t, this === this.$root)
          this.$i18n = uw(e10, a);
        else {
          a.__injectWithOption = true, a.__extender = n.__vueI18nExtend, this.$i18n = lm(a);
          const l = this.$i18n;
          l.__extender && (l.__disposer = l.__extender(this.$i18n));
        }
      } else if (r.__i18n)
        if (this === this.$root)
          this.$i18n = uw(e10, r);
        else {
          this.$i18n = lm({
            __i18n: r.__i18n,
            __injectWithOption: true,
            __extender: n.__vueI18nExtend,
            __root: t
          });
          const a = this.$i18n;
          a.__extender && (a.__disposer = a.__extender(this.$i18n));
        }
      else
        this.$i18n = e10;
      r.__i18nGlobal && uO(t, r, r), this.$t = (...a) => this.$i18n.t(...a), this.$rt = (...a) => this.$i18n.rt(...a), this.$te = (a, l) => this.$i18n.te(a, l), this.$d = (...a) => this.$i18n.d(...a), this.$n = (...a) => this.$i18n.n(...a), this.$tm = (a) => this.$i18n.tm(a), n.__setInstance(o, this.$i18n);
    },
    mounted() {
      if ( true && this.$el && this.$i18n) {
        const o = this.$i18n;
        this.$el.__VUE_I18N__ = o.__composer;
        const r = this.__v_emitter = My();
        o.__enableEmitter && o.__enableEmitter(r), r.on("*", ju);
      }
    },
    unmounted() {
      const o = it();
      if (!o)
        throw $o(cn.UNEXPECTED_ERROR);
      const r = this.$i18n;
       true && this.$el && this.$el.__VUE_I18N__ && (this.__v_emitter && (this.__v_emitter.off("*", ju), delete this.__v_emitter), this.$i18n && (r.__disableEmitter && r.__disableEmitter(), delete this.$el.__VUE_I18N__)), delete this.$t, delete this.$rt, delete this.$te, delete this.$d, delete this.$n, delete this.$tm, r.__disposer && (r.__disposer(), delete r.__disposer, delete r.__extender), n.__deleteInstance(o), delete this.$i18n;
    }
  };
}
function uw(e10, t) {
  e10.locale = t.locale || e10.locale, e10.fallbackLocale = t.fallbackLocale || e10.fallbackLocale, e10.missing = t.missing || e10.missing, e10.silentTranslationWarn = t.silentTranslationWarn || e10.silentFallbackWarn, e10.silentFallbackWarn = t.silentFallbackWarn || e10.silentFallbackWarn, e10.formatFallbackMessages = t.formatFallbackMessages || e10.formatFallbackMessages, e10.postTranslation = t.postTranslation || e10.postTranslation, e10.warnHtmlInMessage = t.warnHtmlInMessage || e10.warnHtmlInMessage, e10.escapeParameterHtml = t.escapeParameterHtml || e10.escapeParameterHtml, e10.sync = t.sync || e10.sync, e10.__composer[lO](t.pluralizationRules || e10.pluralizationRules);
  const n = Dy(e10.locale, {
    messages: t.messages,
    __i18n: t.__i18n
  });
  return Object.keys(n).forEach((o) => e10.mergeLocaleMessage(o, n[o])), t.datetimeFormats && Object.keys(t.datetimeFormats).forEach((o) => e10.mergeDateTimeFormat(o, t.datetimeFormats[o])), t.numberFormats && Object.keys(t.numberFormats).forEach((o) => e10.mergeNumberFormat(o, t.numberFormats[o])), e10;
}
const By = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
    validator: (e10) => e10 === "parent" || e10 === "global",
    default: "parent"
    /* ComponentI18nScope */
  },
  i18n: {
    type: Object
  }
};
function Nre({ slots: e10 }, t) {
  return t.length === 1 && t[0] === "default" ? (e10.default ? e10.default() : []).reduce((o, r) => [
    ...o,
    // prettier-ignore
    ...r.type === Ie ? r.children : [r]
  ], []) : t.reduce((n, o) => {
    const r = e10[o];
    return r && (n[o] = r()), n;
  }, an());
}
function pO() {
  return Ie;
}
const Tre = /* @__PURE__ */ j({
  /* eslint-disable */
  name: "i18n-t",
  props: Pn({
    keypath: {
      type: String,
      required: true
    },
    plural: {
      type: [Number, String],
      validator: (e10) => kn(e10) || !isNaN(e10)
    }
  }, By),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(e10, t) {
    const { slots: n, attrs: o } = t, r = e10.i18n || yo({
      useScope: e10.scope,
      __useComponent: true
    });
    return () => {
      const a = Object.keys(n).filter((f) => f[0] !== "_"), l = an();
      e10.locale && (l.locale = e10.locale), e10.plural !== void 0 && (l.plural = pt(e10.plural) ? +e10.plural : e10.plural);
      const s = Nre(t, a), u = r[tm](e10.keypath, s, l), c = Pn(an(), o), d = pt(e10.tag) || Gt(e10.tag) ? e10.tag : pO();
      return Ke(d, c, u);
    };
  }
}), cw = Tre;
function Ore(e10) {
  return mn(e10) && !pt(e10[0]);
}
function vO(e10, t, n, o) {
  const { slots: r, attrs: a } = t;
  return () => {
    const l = { part: true };
    let s = an();
    e10.locale && (l.locale = e10.locale), pt(e10.format) ? l.key = e10.format : Gt(e10.format) && (pt(e10.format.key) && (l.key = e10.format.key), s = Object.keys(e10.format).reduce((p, v) => n.includes(v) ? Pn(an(), p, { [v]: e10.format[v] }) : p, an()));
    const u = o(e10.value, l, s);
    let c = [l.key];
    mn(u) ? c = u.map((p, v) => {
      const m = r[p.type], h = m ? m({ [p.type]: p.value, index: v, parts: u }) : [p.value];
      return Ore(h) && (h[0].key = `${p.type}-${v}`), h;
    }) : pt(u) && (c = [u]);
    const d = Pn(an(), a), f = pt(e10.tag) || Gt(e10.tag) ? e10.tag : pO();
    return Ke(f, d, c);
  };
}
const $re = /* @__PURE__ */ j({
  /* eslint-disable */
  name: "i18n-n",
  props: Pn({
    value: {
      type: Number,
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, By),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(e10, t) {
    const n = e10.i18n || yo({
      useScope: e10.scope,
      __useComponent: true
    });
    return vO(e10, t, nO, (...o) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      n[om](...o)
    ));
  }
}), dw = $re;
function Ire(e10, t) {
  const n = e10;
  if (e10.mode === "composition")
    return n.__getInstance(t) || e10.global;
  {
    const o = n.__getInstance(t);
    return o != null ? o.__composer : e10.global.__composer;
  }
}
function Mre(e10) {
  const t = (l) => {
     true && Iy(_c(Dr.DEPRECATE_TRANSLATE_CUSTOME_DIRECTIVE));
    const { instance: s, value: u } = l;
    if (!s || !s.$)
      throw $o(cn.UNEXPECTED_ERROR);
    const c = Ire(e10, s.$), d = fw(u);
    return [
      Reflect.apply(c.t, c, [...pw(d)]),
      c
    ];
  };
  return {
    created: (l, s) => {
      const [u, c] = t(s);
      _r && e10.global === c && (l.__i18nWatcher = ge(c.locale, () => {
        s.instance && s.instance.$forceUpdate();
      })), l.__composer = c, l.textContent = u;
    },
    unmounted: (l) => {
      _r && l.__i18nWatcher && (l.__i18nWatcher(), l.__i18nWatcher = void 0, delete l.__i18nWatcher), l.__composer && (l.__composer = void 0, delete l.__composer);
    },
    beforeUpdate: (l, { value: s }) => {
      if (l.__composer) {
        const u = l.__composer, c = fw(s);
        l.textContent = Reflect.apply(u.t, u, [
          ...pw(c)
        ]);
      }
    },
    getSSRProps: (l) => {
      const [s] = t(l);
      return { textContent: s };
    }
  };
}
function fw(e10) {
  if (pt(e10))
    return { path: e10 };
  if (Wt(e10)) {
    if (!("path" in e10))
      throw $o(cn.REQUIRED_VALUE, "path");
    return e10;
  } else
    throw $o(cn.INVALID_VALUE);
}
function pw(e10) {
  const { path: t, locale: n, args: o, choice: r, plural: a } = e10, l = {}, s = o || {};
  return pt(n) && (l.locale = n), kn(r) && (l.plural = r), kn(a) && (l.plural = a), [t, s, l];
}
function Pre(e10, t, ...n) {
  const o = Wt(n[0]) ? n[0] : {};
  (Xt(o.globalInstall) ? o.globalInstall : true) && ([cw.name, "I18nT"].forEach((a) => e10.component(a, cw)), [dw.name, "I18nN"].forEach((a) => e10.component(a, dw)), [hw.name, "I18nD"].forEach((a) => e10.component(a, hw))), e10.directive("t", Mre(t));
}
const Rre = /* @__PURE__ */ oa("global-vue-i18n");
function Are(e10 = {}) {
  const t = __VUE_I18N_LEGACY_API__ && Xt(e10.legacy) ? e10.legacy : __VUE_I18N_LEGACY_API__;
   true && t && Iy(_c(Dr.DEPRECATE_LEGACY_MODE));
  const n = Xt(e10.globalInjection) ? e10.globalInjection : true, o = /* @__PURE__ */ new Map(), [r, a] = Lre(e10, t), l = /* @__PURE__ */ oa( true ? "vue-i18n" : 0);
  function s(f) {
    return o.get(f) || null;
  }
  function u(f, p) {
    o.set(f, p);
  }
  function c(f) {
    o.delete(f);
  }
  const d = {
    // mode
    get mode() {
      return __VUE_I18N_LEGACY_API__ && t ? "legacy" : "composition";
    },
    // install plugin
    async install(f, ...p) {
      if ( true && (f.__VUE_I18N__ = d), f.__VUE_I18N_SYMBOL__ = l, f.provide(f.__VUE_I18N_SYMBOL__, d), Wt(p[0])) {
        const h = p[0];
        d.__composerExtend = h.__composerExtend, d.__vueI18nExtend = h.__vueI18nExtend;
      }
      let v = null;
      !t && n && (v = Kre(f, d.global)), __VUE_I18N_FULL_INSTALL__ && Pre(f, d, ...p), __VUE_I18N_LEGACY_API__ && t && f.mixin(kre(a, a.__composer, d));
      const m = f.unmount;
      if (f.unmount = () => {
        v && v(), d.dispose(), m();
      }, "development" !== "production") {
        if (!await pre(f, d))
          throw $o(cn.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN);
        const b = My();
        if (t) {
          const g = a;
          g.__enableEmitter && g.__enableEmitter(b);
        } else {
          const g = a;
          g[as] && g[as](b);
        }
        b.on("*", ju);
      }
    },
    // global accessor
    get global() {
      return a;
    },
    dispose() {
      r.stop();
    },
    // @internal
    __instances: o,
    // @internal
    __getInstance: s,
    // @internal
    __setInstance: u,
    // @internal
    __deleteInstance: c
  };
  return d;
}
function yo(e10 = {}) {
  const t = it();
  if (t == null)
    throw $o(cn.MUST_BE_CALL_SETUP_TOP);
  if (!t.isCE && t.appContext.app != null && !t.appContext.app.__VUE_I18N_SYMBOL__)
    throw $o(cn.NOT_INSTALLED);
  const n = xre(t), o = Vre(n), r = iO(t), a = Dre(e10, r);
  if (a === "global")
    return uO(o, e10, r), o;
  if (a === "parent") {
    let u = Fre(n, t, e10.__useComponent);
    return u == null && ( true && hl(_c(Dr.NOT_FOUND_PARENT_SCOPE)), u = o), u;
  }
  const l = n;
  let s = l.__getInstance(t);
  if (s == null) {
    const u = Pn({}, e10);
    "__i18n" in r && (u.__i18n = r.__i18n), o && (u.__root = o), s = Vy(u), l.__composerExtend && (s[rm] = l.__composerExtend(s)), Hre(l, t, s), l.__setInstance(t, s);
  }
  return s;
}
function Lre(e10, t) {
  const n = Bw(), o = __VUE_I18N_LEGACY_API__ && t ? n.run(() => lm(e10)) : n.run(() => Vy(e10));
  if (o == null)
    throw $o(cn.UNEXPECTED_ERROR);
  return [n, o];
}
function xre(e10) {
  const t = Le(e10.isCE ? Rre : e10.appContext.app.__VUE_I18N_SYMBOL__);
  if (!t)
    throw $o(e10.isCE ? cn.NOT_INSTALLED_WITH_PROVIDE : cn.UNEXPECTED_ERROR);
  return t;
}
function Dre(e10, t) {
  return bp(e10) ? "__i18n" in t ? "local" : "global" : e10.useScope ? e10.useScope : "local";
}
function Vre(e10) {
  return e10.mode === "composition" ? e10.global : e10.global.__composer;
}
function Fre(e10, t, n = false) {
  let o = null;
  const r = t.root;
  let a = Bre(t, n);
  for (; a != null; ) {
    const l = e10;
    if (e10.mode === "composition")
      o = l.__getInstance(a);
    else if (__VUE_I18N_LEGACY_API__) {
      const s = l.__getInstance(a);
      s != null && (o = s.__composer, n && o && !o[sO] && (o = null));
    }
    if (o != null || r === a)
      break;
    a = a.parent;
  }
  return o;
}
function Bre(e10, t = false) {
  return e10 == null ? null : t && e10.vnode.ctx || e10.parent;
}
function Hre(e10, t, n) {
  let o = null;
  dt(() => {
    if ( true && t.vnode.el) {
      t.vnode.el.__VUE_I18N__ = n, o = My();
      const r = n;
      r[as] && r[as](o), o.on("*", ju);
    }
  }, t), Jr(() => {
    const r = n;
     true && t.vnode.el && t.vnode.el.__VUE_I18N__ && (o && o.off("*", ju), r[Ku] && r[Ku](), delete t.vnode.el.__VUE_I18N__), e10.__deleteInstance(t);
    const a = r[rm];
    a && (a(), delete r[rm]);
  }, t);
}
const zre = [
  "locale",
  "fallbackLocale",
  "availableLocales"
], vw = ["t", "rt", "d", "n", "tm", "te"];
function Kre(e10, t) {
  const n = /* @__PURE__ */ Object.create(null);
  return zre.forEach((r) => {
    const a = Object.getOwnPropertyDescriptor(t, r);
    if (!a)
      throw $o(cn.UNEXPECTED_ERROR);
    const l = Ot(a.value) ? {
      get() {
        return a.value.value;
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set(s) {
        a.value.value = s;
      }
    } : {
      get() {
        return a.get && a.get();
      }
    };
    Object.defineProperty(n, r, l);
  }), e10.config.globalProperties.$i18n = n, vw.forEach((r) => {
    const a = Object.getOwnPropertyDescriptor(t, r);
    if (!a || !a.value)
      throw $o(cn.UNEXPECTED_ERROR);
    Object.defineProperty(e10.config.globalProperties, `$${r}`, a);
  }), () => {
    delete e10.config.globalProperties.$i18n, vw.forEach((r) => {
      delete e10.config.globalProperties[`$${r}`];
    });
  };
}
const Wre = /* @__PURE__ */ j({
  /* eslint-disable */
  name: "i18n-d",
  props: Pn({
    value: {
      type: [Number, Date],
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, By),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(e10, t) {
    const n = e10.i18n || yo({
      useScope: e10.scope,
      __useComponent: true
    });
    return vO(e10, t, tO, (...o) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      n[nm](...o)
    ));
  }
}), hw = Wre;
lre();
Ioe(ioe);
Moe(koe);
Poe(Ly);
if (true) {
  const e10 = Al();
  e10.__INTLIFY__ = true, uoe(e10.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}
"development";
function ra() {
  const e10 = yo(), t = {};
  return (n) => {
    if (!n || typeof n == "string") return n;
    const o = Ly(t, e10.fallbackLocale.value, e10.locale.value);
    for (const r of o)
      if (r in n) return n[r];
    return n[""];
  };
}
const jre = ["function", "transform", "is"];
function wc(e10) {
  const t = [], n = e10.list.filter((o) => {
    if (!o.meta.hidden)
      return o.type === "transform" && t.push(o.inner), !jre.includes(o.type);
  });
  return n.length ? n : t;
}
function Us(e10, t = false) {
  var _a2;
  if (!(!e10 || e10.type === "union" && wc(e10).length === 1))
    return (_a2 = Fu(e10.meta.default)) != null ? _a2 : t ? Ure(e10) : void 0;
}
function Ure(e10) {
  if (e10.type === "string") return "";
  if (e10.type === "number") return 0;
  if (e10.type === "boolean") return false;
  if (["dict", "object", "intersect"].includes(e10.type)) return {};
}
function da(e10) {
  return e10.type === "const" ? e10 : e10.type === "transform" ? da(e10.inner) : (e10 = new schemastery__WEBPACK_IMPORTED_MODULE_0__["default"](e10).required(false), e10.type === "object" ? e10.dict = PT(e10.dict, da) : e10.type === "tuple" || e10.type === "intersect" || e10.type === "union" ? e10.list = e10.list.map(da) : (e10.type === "dict" || e10.type === "array") && (e10.inner = da(e10.inner)), e10);
}
function Yre(e10, t) {
  try {
    return da(e10)(t), true;
  } catch {
    return false;
  }
}
function sm(e10, t) {
  if (!vo(t) && e10.type === "string" && e10.meta.pattern) {
    const { source: n, flags: o } = e10.meta.pattern, r = new RegExp(n, o);
    if (!r.test(t))
      return ["errors.regexp-not-matched", [r.toString()]];
  }
}
function qre() {
  const { props: e10 } = it();
  return S(() => {
    var t, n;
    return e10.disabled || ((n = (t = e10.schema) == null ? void 0 : t.meta) == null ? void 0 : n.disabled);
  });
}
function La(e10) {
  let t;
  const n = L(), { props: o, emit: r } = it(), a = () => ge(n, (l) => {
    try {
      e10 != null && e10.output && (l = e10.output(l));
      const s = da((0,schemastery__WEBPACK_IMPORTED_MODULE_0__["default"])(o.schema));
      ns(s(l), o.schema.meta.default, e10 == null ? void 0 : e10.strict) && (l = null);
    } catch {
      return;
    }
    r("update:modelValue", l);
  }, { deep: true });
  return ge(() => [o.modelValue, o.schema], ([l, s]) => {
    t == null || t(), l != null ? l : l = Us(s), e10 != null && e10.input && (l = e10.input(l)), n.value = l, t = a();
  }, { deep: true, immediate: true }), n;
}
function Hy() {
  const { props: e10 } = it(), t = La({
    strict: true,
    input: (l) => {
      var _a2;
      const s = Object.entries(l);
      if (e10.schema.type === "array") {
        const u = ((_a2 = e10.schema.meta.min) != null ? _a2 : 0) - s.length;
        for (let c = 0; c < u; c++)
          s.push(["" + s.length, null]);
      }
      return s;
    },
    output: (l) => {
      if (e10.schema.type === "array")
        return l.map(([, u]) => u);
      const s = {};
      for (const [u, c] of l) {
        if (u in s) throw new Error("duplicate entries");
        s[u] = c;
      }
      return s;
    }
  }), n = S(() => e10.schema.meta.min && e10.schema.meta.min === e10.schema.meta.max), o = S(() => t.value.length >= e10.schema.meta.max), r = S(() => t.value.length >= e10.schema.meta.max), a = () => {
    if (e10.schema.type === "array")
      for (let l = 0; l < t.value.length; l++)
        t.value[l][0] = "" + l;
  };
  return {
    entries: t,
    isMax: o,
    isMin: r,
    isFixedLength: n,
    up(l) {
      if (e10.schema.type === "dict")
        t.value.splice(l - 1, 0, ...t.value.splice(l, 1));
      else {
        const s = t.value[l][1];
        t.value[l][1] = t.value[l - 1][1], t.value[l - 1][1] = s;
      }
      a();
    },
    down(l) {
      if (e10.schema.type === "dict")
        t.value.splice(l + 1, 0, ...t.value.splice(l, 1));
      else {
        const s = t.value[l][1];
        t.value[l][1] = t.value[l + 1][1], t.value[l + 1][1] = s;
      }
      a();
    },
    del(l) {
      t.value.splice(l, 1), a();
    },
    insert(l) {
      t.value.splice(l, 0, ["", null]), a();
    }
  };
}
function hO(e10) {
  return e10.type === "union" && e10.list.every((t) => t.type === "const");
}
function im(e10) {
  if (e10.type === "bitset") return true;
  if (e10.type === "array") return hO(e10.inner);
}
function zy() {
  const { props: e10 } = it(), t = S(() => {
    if (e10.schema.type === "bitset")
      return Object.keys(e10.schema.bits);
    if (e10.schema.type === "array")
      return e10.schema.inner.list.map((r) => r.value);
  }), n = S(() => {
    if (e10.schema.type === "bitset")
      return Object.keys(e10.schema.bits).map((r) => schemastery__WEBPACK_IMPORTED_MODULE_0__["default"].const(r));
    if (e10.schema.type === "array")
      return e10.schema.inner.list;
  }), o = La({
    input(r) {
      return im(e10.schema) ? vo(r) ? [] : Array.isArray(r) ? r : Object.entries(e10.schema.bits).filter(([a, l]) => r & l).map(([a]) => a) : r;
    },
    output(r) {
      return im(e10.schema) ? r.sort((a, l) => {
        const s = t.value.indexOf(a), u = t.value.indexOf(l);
        return s < 0 ? u < 0 ? 0 : 1 : u < 0 ? -1 : s - u;
      }) : r;
    }
  });
  return {
    values: o,
    items: n,
    selectAll() {
      o.value = AT(o.value, t.value);
    },
    selectNone() {
      o.value = RT(o.value, t.value);
    },
    toggle(r) {
      o.value.includes(r) ? o.value = o.value.filter((a) => a !== r) : o.value = [...o.value, r];
    }
  };
}
function mO(e10) {
  return ["string", "number", "boolean"].includes(e10.type) || hO(e10) || im(e10);
}
function mw(e10) {
  if (e10 = e10.filter(([, t]) => !t.meta.hidden), e10.every(([, t]) => mO(t))) return e10;
}
function Ky(e10) {
  if (mO(e10))
    return [[null, e10]];
  if (e10.type === "tuple")
    return mw(Object.entries(e10.list));
  if (e10.type === "object")
    return mw(Object.entries(e10.dict));
}
const zn = (e10, t) => {
  const n = e10.__vccOpts || e10;
  for (const [o, r] of t)
    n[o] = r;
  return n;
}, Gre = {}, Xre = {
  class: "k-icon",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 384 512"
};
function Jre(e10, t) {
  return k(), x("svg", Xre, t[0] || (t[0] = [
    B("path", {
      fill: "currentColor",
      d: "M377.4 296.6l-168 176C204.8 477.3 198.6 480 192 480s-12.84-2.688-17.38-7.438l-168-176C-2.5 286.1-2.156 271.8 7.438 262.6c9.5-9.156 24.75-8.812 33.94 .8125L168 396.1V56.02c0-13.25 10.75-24.01 23.1-24.01S216 42.77 216 56.02v340.1l126.6-132.7c9.156-9.625 24.41-9.969 33.94-.8125C386.2 271.8 386.5 286.1 377.4 296.6z"
    }, null, -1)
  ]));
}
const gO = /* @__PURE__ */ zn(Gre, [["render", Jre]]), Zre = {}, Qre = {
  class: "k-icon",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 384 512"
};
function eae(e10, t) {
  return k(), x("svg", Qre, t[0] || (t[0] = [
    B("path", {
      fill: "currentColor",
      d: "M6.625 215.5l168-176C179.2 34.7 185.4 32.02 192 32.02s12.84 2.688 17.38 7.438l168 176c9.125 9.594 8.781 24.78-.8125 33.94c-9.5 9.156-24.75 8.812-33.94-.8125L216 115.9V456c0 13.25-10.75 23.1-23.1 23.1S168 469.3 168 456V115.9l-126.6 132.7C32.22 258.2 16.97 258.5 7.438 249.4C-2.156 240.2-2.5 225 6.625 215.5z"
    }, null, -1)
  ]));
}
const yO = /* @__PURE__ */ zn(Zre, [["render", eae]]), tae = {}, nae = {
  class: "k-icon",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 640 512"
};
function oae(e10, t) {
  return k(), x("svg", nae, t[0] || (t[0] = [
    B("path", {
      fill: "currentColor",
      d: "M414.9 31.11L270.9 495.1C266.1 507.8 253.5 514.8 240.9 510.9C228.2 506.1 221.1 493.5 225.1 480.9L369.1 16.89C373 4.226 386.5-2.852 399.1 1.077C411.8 5.006 418.9 18.45 414.9 31.11V31.11zM504.4 118.5L632.4 238.5C637.3 243 640 249.4 640 255.1C640 262.6 637.3 268.1 632.4 273.5L504.4 393.5C494.7 402.6 479.6 402.1 470.5 392.4C461.4 382.7 461.9 367.6 471.6 358.5L580.9 255.1L471.6 153.5C461.9 144.4 461.4 129.3 470.5 119.6C479.6 109.9 494.7 109.4 504.4 118.5V118.5zM168.4 153.5L59.09 255.1L168.4 358.5C178.1 367.6 178.6 382.7 169.5 392.4C160.4 402.1 145.3 402.6 135.6 393.5L7.585 273.5C2.746 268.1 0 262.6 0 255.1C0 249.4 2.746 243 7.585 238.5L135.6 118.5C145.3 109.4 160.4 109.9 169.5 119.6C178.6 129.3 178.1 144.4 168.4 153.5V153.5z"
    }, null, -1)
  ]));
}
const rae = /* @__PURE__ */ zn(tae, [["render", oae]]), aae = {}, lae = {
  class: "k-icon",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 448 512"
};
function sae(e10, t) {
  return k(), x("svg", lae, t[0] || (t[0] = [
    B("path", {
      fill: "currentColor",
      d: "M207 184.1C209.6 187.5 215.5 192 224 192s14.4-4.461 16.97-7.031l72-72C317.7 108.3 320 102.1 320 96c0-13.71-11.21-24-24-24c-6.141 0-12.28 2.344-16.97 7.031L248 110.1V24C248 10.75 237.3 0 224 0S200 10.75 200 24v86.06L168.1 79.03C164.3 74.34 158.1 72 152 72C138.3 72 128 83.21 128 96c0 6.141 2.344 12.28 7.031 16.97L207 184.1zM240.1 327C234.9 321 227.7 320 224 320c-3.682 0-10.94 .9906-16.97 7.022l-72 72C130.3 403.7 128 409.9 128 416c0 13.71 11.21 24 24 24c6.141 0 12.28-2.344 16.97-7.031L200 401.9V488C200 501.3 210.8 512 224 512s24-10.75 24-24v-86.06l31.03 31.03C283.7 437.7 289.8 440 296 440c18.79 0 24-17.2 24-24c0-6.141-2.344-12.28-7.031-16.97L240.1 327zM424 232H24C10.75 232 0 242.7 0 255.1S10.75 280 24 280h400c13.25 0 24-10.76 24-24.01S437.3 232 424 232z"
    }, null, -1)
  ]));
}
const iae = /* @__PURE__ */ zn(aae, [["render", sae]]), uae = {}, cae = {
  class: "k-icon",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 448 512"
};
function dae(e10, t) {
  return k(), x("svg", cae, t[0] || (t[0] = [
    B("path", {
      fill: "currentColor",
      d: "M160 400C160 408.8 152.8 416 144 416C135.2 416 128 408.8 128 400V192C128 183.2 135.2 176 144 176C152.8 176 160 183.2 160 192V400zM240 400C240 408.8 232.8 416 224 416C215.2 416 208 408.8 208 400V192C208 183.2 215.2 176 224 176C232.8 176 240 183.2 240 192V400zM320 400C320 408.8 312.8 416 304 416C295.2 416 288 408.8 288 400V192C288 183.2 295.2 176 304 176C312.8 176 320 183.2 320 192V400zM317.5 24.94L354.2 80H424C437.3 80 448 90.75 448 104C448 117.3 437.3 128 424 128H416V432C416 476.2 380.2 512 336 512H112C67.82 512 32 476.2 32 432V128H24C10.75 128 0 117.3 0 104C0 90.75 10.75 80 24 80H93.82L130.5 24.94C140.9 9.357 158.4 0 177.1 0H270.9C289.6 0 307.1 9.358 317.5 24.94H317.5zM151.5 80H296.5L277.5 51.56C276 49.34 273.5 48 270.9 48H177.1C174.5 48 171.1 49.34 170.5 51.56L151.5 80zM80 432C80 449.7 94.33 464 112 464H336C353.7 464 368 449.7 368 432V128H80V432z"
    }, null, -1)
  ]));
}
const bO = /* @__PURE__ */ zn(uae, [["render", dae]]), fae = {}, pae = {
  class: "k-icon",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 448 512"
};
function vae(e10, t) {
  return k(), x("svg", pae, t[0] || (t[0] = [
    B("path", {
      fill: "currentColor",
      d: "M352 256C352 238.3 366.3 224 384 224C401.7 224 416 238.3 416 256C416 273.7 401.7 288 384 288C366.3 288 352 273.7 352 256zM192 256C192 238.3 206.3 224 224 224C241.7 224 256 238.3 256 256C256 273.7 241.7 288 224 288C206.3 288 192 273.7 192 256zM96 256C96 273.7 81.67 288 64 288C46.33 288 32 273.7 32 256C32 238.3 46.33 224 64 224C81.67 224 96 238.3 96 256z"
    }, null, -1)
  ]));
}
const hae = /* @__PURE__ */ zn(fae, [["render", vae]]), mae = {}, gae = {
  class: "k-icon",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 448 512"
};
function yae(e10, t) {
  return k(), x("svg", gae, t[0] || (t[0] = [
    B("path", {
      fill: "currentColor",
      d: "M296 391.1c-6.141 0-12.28 2.344-16.97 7.031L248 430.1v-86.06c0-13.25-10.75-24-24-24s-24 10.75-24 24v86.06l-31.03-31.03C164.3 394.3 158.1 391.1 152 391.1c-12.82 0-24 10.33-24 24c0 6.141 2.344 12.28 7.031 16.97l72 72.01C209.6 507.5 215.5 512 224 512s14.4-4.461 16.97-7.031l72-72.01C317.7 428.3 320 422.1 320 415.1C320 402.3 308.8 391.1 296 391.1zM152 119.1c6.141 0 12.28-2.344 16.97-7.031L200 81.91v86.07c0 13.25 10.75 24 24 24s24-10.75 24-24V81.91l31.03 31.03C283.7 117.6 289.8 119.1 296 119.1c18.79 0 24-17.2 24-23.1c0-6.141-2.344-12.28-7.031-16.97l-72-72.01C234.9 .9766 227.7 0 223.1 0C220.3 0 213.1 .9687 207 7l-72 72.01C130.3 83.7 128 89.84 128 95.98C128 109.7 139.2 119.1 152 119.1zM424 232H24C10.75 232 0 242.7 0 255.1S10.75 280 24 280h400c13.25 0 24-10.76 24-24.01S437.3 232 424 232z"
    }, null, -1)
  ]));
}
const bae = /* @__PURE__ */ zn(mae, [["render", yae]]), _ae = {}, wae = {
  class: "k-icon k-icon-external",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 512 512"
};
function Cae(e10, t) {
  return k(), x("svg", wae, t[0] || (t[0] = [
    B("path", {
      fill: "currentColor",
      d: "M432,320H400a16,16,0,0,0-16,16V448H64V128H208a16,16,0,0,0,16-16V80a16,16,0,0,0-16-16H48A48,48,0,0,0,0,112V464a48,48,0,0,0,48,48H400a48,48,0,0,0,48-48V336A16,16,0,0,0,432,320ZM488,0h-128c-21.37,0-32.05,25.91-17,41l35.73,35.73L135,320.37a24,24,0,0,0,0,34L157.67,377a24,24,0,0,0,34,0L435.28,133.32,471,169c15,15,41,4.5,41-17V24A24,24,0,0,0,488,0Z"
    }, null, -1)
  ]));
}
const Eae = /* @__PURE__ */ zn(_ae, [["render", Cae]]), Sae = {}, kae = {
  class: "k-icon",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 640 512"
};
function Nae(e10, t) {
  return k(), x("svg", kae, t[0] || (t[0] = [
    B("path", {
      fill: "currentColor",
      d: "M320 400c-75.85 0-137.25-58.71-142.9-133.11L72.2 185.82c-13.79 17.3-26.48 35.59-36.72 55.59a32.35 32.35 0 0 0 0 29.19C89.71 376.41 197.07 448 320 448c26.91 0 52.87-4 77.89-10.46L346 397.39a144.13 144.13 0 0 1-26 2.61zm313.82 58.1l-110.55-85.44a331.25 331.25 0 0 0 81.25-102.07 32.35 32.35 0 0 0 0-29.19C550.29 135.59 442.93 64 320 64a308.15 308.15 0 0 0-147.32 37.7L45.46 3.37A16 16 0 0 0 23 6.18L3.37 31.45A16 16 0 0 0 6.18 53.9l588.36 454.73a16 16 0 0 0 22.46-2.81l19.64-25.27a16 16 0 0 0-2.82-22.45zm-183.72-142l-39.3-30.38A94.75 94.75 0 0 0 416 256a94.76 94.76 0 0 0-121.31-92.21A47.65 47.65 0 0 1 304 192a46.64 46.64 0 0 1-1.54 10l-73.61-56.89A142.31 142.31 0 0 1 320 112a143.92 143.92 0 0 1 144 144c0 21.63-5.29 41.79-13.9 60.11z"
    }, null, -1)
  ]));
}
const Tae = /* @__PURE__ */ zn(Sae, [["render", Nae]]), Oae = {}, $ae = {
  class: "k-icon",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 576 512"
};
function Iae(e10, t) {
  return k(), x("svg", $ae, t[0] || (t[0] = [
    B("path", {
      fill: "currentColor",
      d: "M572.52 241.4C518.29 135.59 410.93 64 288 64S57.68 135.64 3.48 241.41a32.35 32.35 0 0 0 0 29.19C57.71 376.41 165.07 448 288 448s230.32-71.64 284.52-177.41a32.35 32.35 0 0 0 0-29.19zM288 400a144 144 0 1 1 144-144 143.93 143.93 0 0 1-144 144zm0-240a95.31 95.31 0 0 0-25.31 3.79 47.85 47.85 0 0 1-66.9 66.9A95.78 95.78 0 1 0 288 160z"
    }, null, -1)
  ]));
}
const Mae = /* @__PURE__ */ zn(Oae, [["render", Iae]]), Pae = {}, Rae = {
  class: "k-icon",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 512 512"
};
function Aae(e10, t) {
  return k(), x("svg", Rae, t[0] || (t[0] = [
    B("path", {
      fill: "currentColor",
      d: "M280 224V310.1L303 287C312.4 277.7 327.6 277.7 336.1 287C346.3 296.4 346.3 311.6 336.1 320.1L272.1 384.1C263.6 394.3 248.4 394.3 239 384.1L175 320.1C165.7 311.6 165.7 296.4 175 287C184.4 277.7 199.6 277.7 208.1 287L232 310.1V224H64C28.65 224 0 195.3 0 160V96C0 60.65 28.65 32 64 32H448C483.3 32 512 60.65 512 96V160C512 195.3 483.3 224 448 224H280zM64 288H130C125.9 304 128.1 321.3 136.6 336H64C55.16 336 48 343.2 48 352V416C48 424.8 55.16 432 64 432H448C456.8 432 464 424.8 464 416V352C464 343.2 456.8 336 448 336H375.4C383.9 321.3 386.1 304 381.1 288H448C483.3 288 512 316.7 512 352V416C512 451.3 483.3 480 448 480H64C28.65 480 0 451.3 0 416V352C0 316.7 28.65 288 64 288z"
    }, null, -1)
  ]));
}
const Lae = /* @__PURE__ */ zn(Pae, [["render", Aae]]), xae = {}, Dae = {
  class: "k-icon",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 512 512"
};
function Vae(e10, t) {
  return k(), x("svg", Dae, t[0] || (t[0] = [
    B("path", {
      fill: "currentColor",
      d: "M232,288v-86.1L209,225c-9.4,9.3-24.6,9.3-33.1,0c-10.2-9.4-10.2-24.6,0-33.1l64-64c8.5-10.2,23.7-10.2,33.1,0l64,64c9.3,8.5,9.3,23.7,0,33.1c-9.4,9.3-24.6,9.3-33.1,0L280,201.9V288h168c35.4,0,64,28.7,64,64v64c0,35.4-28.6,64-64,64H64c-35.3,0-64-28.6-64-64l0-64c0-35.3,28.7-64,64-64H232z M448,224h-66c4.1-16,1.9-33.3-6.6-48H448c8.8,0,16-7.2,16-16V96c0-8.8-7.2-16-16-16H64c-8.8,0-16,7.2-16,16v64c0,8.8,7.2,16,16,16h72.6c-8.5,14.7-10.7,32-5.7,48H64c-35.3,0-64-28.7-64-64l0-64c0-35.3,28.7-64,64-64h384c35.4,0,64,28.7,64,64v64C512,195.3,483.4,224,448,224z"
    }, null, -1)
  ]));
}
const Fae = /* @__PURE__ */ zn(xae, [["render", Vae]]), Bae = {}, Hae = {
  class: "k-icon",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 512 512"
};
function zae(e10, t) {
  return k(), x("svg", Hae, t[0] || (t[0] = [
    B("path", {
      fill: "currentColor",
      d: "M506.3 417l-213.3-364c-16.33-28-57.54-28-73.98 0l-213.2 364C-10.59 444.9 9.849 480 42.74 480h426.6C502.1 480 522.6 445 506.3 417zM232 168c0-13.25 10.75-24 24-24S280 154.8 280 168v128c0 13.25-10.75 24-23.1 24S232 309.3 232 296V168zM256 416c-17.36 0-31.44-14.08-31.44-31.44c0-17.36 14.07-31.44 31.44-31.44s31.44 14.08 31.44 31.44C287.4 401.9 273.4 416 256 416z"
    }, null, -1)
  ]));
}
const _O = /* @__PURE__ */ zn(Bae, [["render", zae]]), Kae = {}, Wae = {
  class: "k-icon",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 512 512"
};
function jae(e10, t) {
  return k(), x("svg", Wae, t[0] || (t[0] = [
    B("path", {
      fill: "currentColor",
      d: "M264 479.1C263.4 479.1 262.7 480 262.1 480H153.9C134.8 480 116.5 472.4 103 458.9L31.03 386.9C2.912 358.8 2.912 313.2 31.03 285.1L253.1 63.03C281.2 34.91 326.8 34.91 354.9 63.03L480.1 189.1C509.1 217.2 509.1 262.8 480.1 290.9L339.9 432H488C501.3 432 512 442.7 512 456C512 469.3 501.3 480 488 480L264 479.1zM64.97 352.1L136.1 424.1C141.5 429.5 147.6 432 153.9 432H262.1C268.4 432 274.5 429.5 279 424.1L344 360L184 200L64.97 319C55.6 328.4 55.6 343.6 64.97 352.1zM31.03 285.1L64.97 319z"
    }, null, -1)
  ]));
}
const Uae = /* @__PURE__ */ zn(Kae, [["render", jae]]), Yae = {}, qae = {
  class: "k-icon",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 448 512"
};
function Gae(e10, t) {
  return k(), x("svg", qae, t[0] || (t[0] = [
    B("path", {
      fill: "currentColor",
      d: "M211.8 339.8C200.9 350.7 183.1 350.7 172.2 339.8L108.2 275.8C97.27 264.9 97.27 247.1 108.2 236.2C119.1 225.3 136.9 225.3 147.8 236.2L192 280.4L300.2 172.2C311.1 161.3 328.9 161.3 339.8 172.2C350.7 183.1 350.7 200.9 339.8 211.8L211.8 339.8zM0 96C0 60.65 28.65 32 64 32H384C419.3 32 448 60.65 448 96V416C448 451.3 419.3 480 384 480H64C28.65 480 0 451.3 0 416V96zM48 96V416C48 424.8 55.16 432 64 432H384C392.8 432 400 424.8 400 416V96C400 87.16 392.8 80 384 80H64C55.16 80 48 87.16 48 96z"
    }, null, -1)
  ]));
}
const wO = /* @__PURE__ */ zn(Yae, [["render", Gae]]), Xae = {}, Jae = {
  class: "k-icon",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 448 512"
};
function Zae(e10, t) {
  return k(), x("svg", Jae, t[0] || (t[0] = [
    B("path", {
      fill: "currentColor",
      d: "M384 32C419.3 32 448 60.65 448 96V416C448 451.3 419.3 480 384 480H64C28.65 480 0 451.3 0 416V96C0 60.65 28.65 32 64 32H384zM384 80H64C55.16 80 48 87.16 48 96V416C48 424.8 55.16 432 64 432H384C392.8 432 400 424.8 400 416V96C400 87.16 392.8 80 384 80z"
    }, null, -1)
  ]));
}
const CO = /* @__PURE__ */ zn(Xae, [["render", Zae]]), Qae = {}, ele = {
  class: "k-icon",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 512 512"
};
function tle(e10, t) {
  return k(), x("svg", ele, t[0] || (t[0] = [
    B("path", {
      fill: "currentColor",
      d: "M30.81 49.81c8.969-3.656 19.28-1.656 26.16 5.219l41.1 41.1c41.07-40.38 97.11-64.92 157.1-64.92C379.6 32.11 480 132.5 480 256s-100.4 223.9-223.9 223.9c-52.31 0-103.3-18.33-143.5-51.77c-10.19-8.5-11.56-23.62-3.062-33.81c8.531-10.22 23.62-11.56 33.81-3.062C174.9 417.5 214.9 432 256 432c97.03 0 176-78.97 176-176S353 80 256 80c-47.08 0-90.93 19.29-123.2 50.89l52.14 52.14c6.875 6.875 8.906 17.19 5.219 26.16C186.5 218.2 177.7 224 168 224h-128C26.75 224 16 213.3 16 200v-128C16 62.28 21.84 53.53 30.81 49.81z"
    }, null, -1)
  ]));
}
const nle = /* @__PURE__ */ zn(Qae, [["render", tle]]), Nr = {
  title: "\u57FA\u7840\u8BBE\u7F6E",
  initial: "\u64A4\u9500\u66F4\u6539",
  default: "\u6062\u590D\u9ED8\u8BA4\u503C",
  collapse: "\u6298\u53E0\u5B50\u9879",
  expand: "\u5C55\u5F00\u4EE5\u7F16\u8F91",
  edit: {
    json: "\u7F16\u8F91 JSON",
    invalid: "\u65E0\u6548\u7684\u914D\u7F6E\u3002",
    save: "\u4FDD\u5B58\u66F4\u6539",
    copy: "\u590D\u5236\u5230\u526A\u8D34\u677F",
    copied: "\u5DF2\u590D\u5236"
  },
  badge: {
    deprecated: "\u5DF2\u5E9F\u5F03",
    experimental: "\u5B9E\u9A8C\u6027"
  },
  entry: {
    key: "\u952E",
    value: "\u503C",
    "add-item": "\u6DFB\u52A0\u9879\u76EE",
    "del-item": "\u5220\u9664\u9879\u76EE",
    "add-row": "\u6DFB\u52A0\u884C",
    "del-row": "\u5220\u9664\u884C",
    "move-up": "\u4E0A\u79FB\u9879\u76EE",
    "move-down": "\u4E0B\u79FB\u9879\u76EE",
    "insert-before": "\u5728\u4E0A\u65B9\u63D2\u5165",
    "insert-after": "\u5728\u4E0B\u65B9\u63D2\u5165"
  },
  select: {
    all: "\u5168\u90E8\u9009\u4E2D",
    none: "\u6E05\u7A7A\u9009\u62E9"
  },
  errors: {
    "duplicate-key": "\u952E\u540D\u91CD\u590D",
    "regexp-not-matched": "\u672A\u80FD\u5339\u914D\u6B63\u5219\u8868\u8FBE\u5F0F {0}"
  }
}, Tr = {
  title: "Basic Settings",
  initial: "Undo",
  default: "Restore to Default",
  collapse: "Collapse",
  expand: "Expand to Edit",
  edit: {
    json: "Edit JSON",
    invalid: "Invalid configuration.",
    save: "Save Changes",
    copy: "Copy to Clipboard",
    copied: "Copied"
  },
  badge: {
    deprecated: "deprecated",
    experimental: "experimental"
  },
  entry: {
    key: "Key",
    value: "Value",
    "add-item": "Add Item",
    "del-item": "Delete Item",
    "add-row": "Add Row",
    "del-row": "Delete Row",
    "move-up": "Move Up",
    "move-down": "Move Down",
    "insert-before": "Insert Before",
    "insert-after": "Insert After"
  },
  select: {
    all: "Select All",
    none: "Clear Selection"
  },
  errors: {
    "duplicate-key": "Duplicate key",
    "regexp-not-matched": "Not matched with regexp {0}"
  }
}, ole = { class: "k-schema-main" }, rle = { class: "k-schema-left" }, ale = { class: "k-schema-right" }, lle = { class: "k-schema-menu" }, sle = { class: "k-menu-icon" }, ile = { class: "k-menu-icon" }, Or = /* @__PURE__ */ j({
  __name: "base",
  props: {
    schema: {},
    modelValue: {},
    disabled: {},
    prefix: {},
    initial: {},
    extra: {},
    collapsible: {}
  },
  emits: ["update:modelValue"],
  setup(e10) {
    var l;
    const n = L((l = e10.collapsible) == null ? void 0 : l.initial), o = L(null), { t: r, setLocaleMessage: a } = yo({
      messages: {
        "zh-CN": Nr,
        "en-US": Tr
      }
    });
    return (s, u) => {
      const c = je("el-button"), d = je("el-tooltip"), f = je("el-collapse-transition");
      return k(), x(Ie, null, [
        B("div", vt({ class: "k-schema-item" }, s.$attrs), [
          u[5] || (u[5] = B("div", { class: "actions" }, null, -1)),
          B("div", ole, [
            B("div", rle, [
              B("h3", null, [
                J(s.$slots, "title")
              ]),
              J(s.$slots, "desc")
            ]),
            B("div", ale, [
              n.value ? ee("", true) : (k(), x(Ie, { key: 0 }, [
                J(s.$slots, "prefix"),
                J(s.$slots, "control"),
                J(s.$slots, "suffix")
              ], 64)),
              e10.collapsible ? (k(), x(Ie, { key: 1 }, [
                n.value ? (k(), ae(c, {
                  key: 0,
                  onClick: u[0] || (u[0] = (p) => n.value = false)
                }, {
                  default: H(() => [
                    Ze(_e(i(r)("expand")), 1)
                  ]),
                  _: 1
                })) : ee("", true)
              ], 64)) : ee("", true)
            ]),
            B("div", lle, [
              W(d, {
                ref_key: "tooltip",
                ref: o,
                placement: "bottom-end",
                "popper-class": "k-menu",
                effect: "light"
              }, {
                content: H(() => [
                  B("div", {
                    onClick: u[3] || (u[3] = (p) => {
                      var v;
                      return (v = o.value) == null ? void 0 : v.hide();
                    })
                  }, [
                    J(s.$slots, "menu"),
                    e10.collapsible ? (k(), x(Ie, { key: 0 }, [
                      u[4] || (u[4] = B("div", { class: "k-menu-separator" }, null, -1)),
                      n.value ? (k(), x("div", {
                        key: 0,
                        class: "k-menu-item",
                        onClick: u[1] || (u[1] = (p) => n.value = false)
                      }, [
                        B("span", sle, [
                          W(i(bae))
                        ]),
                        Ze(" " + _e(i(r)("expand")), 1)
                      ])) : (k(), x("div", {
                        key: 1,
                        class: "k-menu-item",
                        onClick: u[2] || (u[2] = (p) => n.value = true)
                      }, [
                        B("span", ile, [
                          W(i(iae))
                        ]),
                        Ze(" " + _e(i(r)("collapse")), 1)
                      ]))
                    ], 64)) : ee("", true)
                  ])
                ]),
                default: H(() => [
                  W(c, { class: "ellipsis" }, {
                    default: H(() => [
                      W(i(hae))
                    ]),
                    _: 1
                  })
                ]),
                _: 3
              }, 512)
            ])
          ]),
          J(s.$slots, "default")
        ], 16),
        e10.collapsible ? (k(), ae(f, { key: 1 }, {
          default: H(() => [
            lt(B("div", {
              class: I(["k-schema-group", { collapsed: n.value }])
            }, [
              J(s.$slots, "collapse")
            ], 2), [
              [Nt, !n.value]
            ])
          ]),
          _: 3
        })) : J(s.$slots, "collapse", { key: 0 })
      ], 64);
    };
  }
}), ule = {
  key: 0,
  class: "suffix-icon"
}, cle = {
  key: 1,
  class: "suffix-icon"
}, dle = { class: "suffix-icon" }, Wy = /* @__PURE__ */ j({
  __name: "primitive",
  props: {
    schema: {},
    modelValue: {},
    disabled: Boolean,
    minimal: Boolean
  },
  emits: ["update:modelValue", "focus", "blur"],
  setup(e10, { emit: t }) {
    const n = t, o = e10, r = L(false), a = La(), { values: l, items: s } = zy(), u = ra(), c = S(() => vo(a.value)), d = S(() => sm(o.schema, a.value)), f = S(() => ["url", "link"].includes(o.schema.meta.role)), p = S(() => {
      const { type: w, meta: y } = o.schema;
      return w === "number" ? "number" : y.role === "secret" && !r.value ? "password" : "text";
    }), v = S({
      get() {
        if (o.modelValue) {
          if (["date", "datetime"].includes(o.schema.meta.role))
            return new Date(a.value);
          if (o.schema.meta.role === "time")
            return /* @__PURE__ */ new Date("1970-01-01 " + a.value);
        }
      },
      set(w) {
        o.schema.meta.role === "datetime" ? n("update:modelValue", w.toLocaleString()) : o.schema.meta.role === "date" ? n("update:modelValue", w.toLocaleDateString()) : o.schema.meta.role === "time" && n("update:modelValue", w.toLocaleTimeString());
      }
    }), m = S({
      get() {
        const w = o.schema.list.find((y) => y.value === a.value);
        if (w)
          return u(w.meta.description) || w.value;
      },
      set(w) {
        a.value = o.schema.list[w].value;
      }
    });
    function h(w) {
      w && open(w, "_blank");
    }
    const { t: b, setLocaleMessage: g } = yo({
      messages: {
        "zh-CN": Nr,
        "en-US": Tr
      }
    });
    return (w, y) => {
      const _ = je("el-checkbox"), C = je("el-switch"), E = je("el-slider"), T = je("el-input-number"), O = je("el-color-picker"), N = je("el-time-picker"), $ = je("el-date-picker"), R = je("el-tooltip"), P = je("el-input"), z = je("k-badge"), Y = je("el-option"), D = je("el-select");
      return e10.schema.type === "boolean" ? (k(), x(Ie, { key: 0 }, [
        e10.minimal ? (k(), ae(_, {
          key: 0,
          modelValue: i(a),
          "onUpdate:modelValue": y[0] || (y[0] = (M) => Ot(a) ? a.value = M : null),
          class: I({ nullable: c.value }),
          disabled: e10.disabled
        }, null, 8, ["modelValue", "class", "disabled"])) : (k(), ae(C, {
          key: 1,
          modelValue: i(a),
          "onUpdate:modelValue": y[1] || (y[1] = (M) => Ot(a) ? a.value = M : null),
          class: I({ nullable: c.value }),
          disabled: e10.disabled
        }, null, 8, ["modelValue", "class", "disabled"]))
      ], 64)) : e10.schema.type === "number" ? (k(), x(Ie, { key: 1 }, [
        e10.schema.meta.role === "slider" ? (k(), ae(E, {
          key: 0,
          style: { width: "200px" },
          modelValue: i(a),
          "onUpdate:modelValue": y[2] || (y[2] = (M) => Ot(a) ? a.value = M : null),
          disabled: e10.disabled,
          max: e10.schema.meta.max,
          min: e10.schema.meta.min,
          step: e10.schema.meta.step
        }, null, 8, ["modelValue", "disabled", "max", "min", "step"])) : (k(), ae(T, {
          key: 1,
          modelValue: i(a),
          "onUpdate:modelValue": y[3] || (y[3] = (M) => Ot(a) ? a.value = M : null),
          disabled: e10.disabled,
          max: e10.schema.meta.max,
          min: e10.schema.meta.min,
          step: e10.schema.meta.step,
          onFocus: y[4] || (y[4] = (M) => w.$emit("focus", M)),
          onBlur: y[5] || (y[5] = (M) => w.$emit("blur", M))
        }, null, 8, ["modelValue", "disabled", "max", "min", "step"]))
      ], 64)) : e10.schema.type === "string" ? (k(), x(Ie, { key: 2 }, [
        e10.schema.meta.role === "color" ? (k(), ae(O, {
          key: 0,
          disabled: e10.disabled,
          modelValue: i(a),
          "onUpdate:modelValue": y[6] || (y[6] = (M) => Ot(a) ? a.value = M : null),
          "show-alpha": ""
        }, null, 8, ["disabled", "modelValue"])) : e10.schema.meta.role === "time" ? (k(), ae(N, {
          key: 1,
          disabled: e10.disabled,
          modelValue: v.value,
          "onUpdate:modelValue": y[7] || (y[7] = (M) => v.value = M),
          onFocus: y[8] || (y[8] = (M) => w.$emit("focus", M)),
          onBlur: y[9] || (y[9] = (M) => w.$emit("blur", M))
        }, null, 8, ["disabled", "modelValue"])) : ["date", "datetime"].includes(e10.schema.meta.role) ? (k(), ae($, {
          key: 2,
          disabled: e10.disabled,
          type: e10.schema.meta.role,
          modelValue: v.value,
          "onUpdate:modelValue": y[10] || (y[10] = (M) => v.value = M),
          onFocus: y[11] || (y[11] = (M) => w.$emit("focus", M)),
          onBlur: y[12] || (y[12] = (M) => w.$emit("blur", M))
        }, null, 8, ["disabled", "type", "modelValue"])) : (k(), ae(P, {
          key: 3,
          modelValue: i(a),
          "onUpdate:modelValue": y[16] || (y[16] = (M) => Ot(a) ? a.value = M : null),
          disabled: e10.disabled,
          class: I({ minimal: e10.minimal, nullable: c.value, invalid: d.value }),
          style: ze({ width: e10.minimal ? "100%" : f.value ? "16rem" : "12rem" }),
          type: p.value,
          onFocus: y[17] || (y[17] = (M) => w.$emit("focus", M)),
          onBlur: y[18] || (y[18] = (M) => w.$emit("blur", M))
        }, ro({
          suffix: H(() => [
            f.value ? (k(), x("span", ule, [
              W(i(Eae), {
                onClick: y[13] || (y[13] = (M) => h(i(a)))
              })
            ])) : e10.schema.meta.role === "secret" ? (k(), x("span", cle, [
              r.value ? (k(), ae(i(Mae), {
                key: 0,
                onClick: y[14] || (y[14] = (M) => r.value = !r.value)
              })) : (k(), ae(i(Tae), {
                key: 1,
                onClick: y[15] || (y[15] = (M) => r.value = !r.value)
              }))
            ])) : ee("", true),
            d.value ? (k(), ae(R, {
              key: 2,
              content: i(b)(...d.value)
            }, {
              default: H(() => [
                B("span", dle, [
                  W(i(_O), { class: "invalid" })
                ])
              ]),
              _: 1
            }, 8, ["content"])) : ee("", true)
          ]),
          _: 2
        }, [
          c.value ? {
            name: "prefix",
            fn: H(() => []),
            key: "0"
          } : void 0
        ]), 1032, ["modelValue", "disabled", "class", "style", "type"]))
      ], 64)) : e10.schema.type === "union" ? (k(), ae(D, {
        key: 3,
        modelValue: m.value,
        "onUpdate:modelValue": y[19] || (y[19] = (M) => m.value = M),
        filterable: "",
        disabled: e10.disabled,
        onFocus: y[20] || (y[20] = (M) => w.$emit("focus", M)),
        onBlur: y[21] || (y[21] = (M) => w.$emit("blur", M))
      }, {
        default: H(() => [
          (k(true), x(Ie, null, st(e10.schema.list, (M, F) => (k(), ae(Y, {
            key: F,
            value: F,
            disabled: M.meta.disabled
          }, {
            default: H(() => [
              Ze(_e(i(u)(M.meta.description) || M.value) + " ", 1),
              (k(true), x(Ie, null, st(M.meta.badges || [], ({ text: A, type: V }) => (k(), ae(z, { type: V }, {
                default: H(() => [
                  Ze(_e(i(b)("badge." + A)), 1)
                ]),
                _: 2
              }, 1032, ["type"]))), 256))
            ]),
            _: 2
          }, 1032, ["value", "disabled"]))), 128))
        ]),
        _: 1
      }, 8, ["modelValue", "disabled"])) : e10.schema.type === "array" || e10.schema.type === "bitset" ? (k(), ae(D, {
        key: 4,
        multiple: "",
        "collapse-tags": "",
        modelValue: i(l),
        "onUpdate:modelValue": y[22] || (y[22] = (M) => Ot(l) ? l.value = M : null),
        disabled: e10.disabled
      }, {
        default: H(() => [
          (k(true), x(Ie, null, st(i(s), (M) => (k(), ae(Y, {
            key: M.value,
            value: M.value,
            disabled: M.meta.disabled
          }, {
            default: H(() => [
              Ze(_e(i(u)(M.meta.description) || M.value) + " ", 1),
              (k(true), x(Ie, null, st(M.meta.badges || [], ({ text: F, type: A }) => (k(), ae(z, { type: A }, {
                default: H(() => [
                  Ze(_e(i(b)("badge." + F)), 1)
                ]),
                _: 2
              }, 1032, ["type"]))), 256))
            ]),
            _: 2
          }, 1032, ["value", "disabled"]))), 128))
        ]),
        _: 1
      }, 8, ["modelValue", "disabled"])) : ee("", true);
    };
  }
}), fle = { class: "k-menu-icon" }, ple = { class: "k-menu-icon" }, vle = { class: "bottom" }, EO = /* @__PURE__ */ j({
  __name: "checkbox",
  props: {
    schema: {},
    modelValue: {},
    disabled: {},
    prefix: {},
    initial: {}
  },
  emits: ["update:modelValue"],
  setup(e10) {
    const t = ra(), { values: n, items: o, toggle: r, selectAll: a, selectNone: l } = zy(), { t: s, setLocaleMessage: u } = yo({
      messages: {
        "zh-CN": Nr,
        "en-US": Tr
      }
    });
    return (c, d) => {
      const f = je("k-badge"), p = je("el-checkbox");
      return k(), ae(Or, null, {
        title: H(() => [
          J(c.$slots, "title")
        ]),
        desc: H(() => [
          J(c.$slots, "desc")
        ]),
        menu: H(() => [
          J(c.$slots, "menu"),
          d[2] || (d[2] = B("div", { class: "k-menu-separator" }, null, -1)),
          B("div", {
            class: I(["k-menu-item", { disabled: e10.disabled }]),
            onClick: d[0] || (d[0] = //@ts-ignore
            (...v) => i(a) && i(a)(...v))
          }, [
            B("span", fle, [
              W(i(wO))
            ]),
            Ze(" " + _e(i(s)("select.all")), 1)
          ], 2),
          B("div", {
            class: I(["k-menu-item", { disabled: e10.disabled }]),
            onClick: d[1] || (d[1] = //@ts-ignore
            (...v) => i(l) && i(l)(...v))
          }, [
            B("span", ple, [
              W(i(CO))
            ]),
            Ze(" " + _e(i(s)("select.none")), 1)
          ], 2)
        ]),
        prefix: H(() => [
          J(c.$slots, "prefix")
        ]),
        suffix: H(() => [
          J(c.$slots, "suffix")
        ]),
        default: H(() => [
          B("ul", vle, [
            (k(true), x(Ie, null, st(i(o), (v) => (k(), x("li", {
              key: v.value
            }, [
              W(p, {
                disabled: e10.disabled || v.meta.disabled,
                modelValue: i(n).includes(v.value),
                "onUpdate:modelValue": (m) => i(r)(v.value)
              }, {
                default: H(() => [
                  Ze(_e(i(t)(v.meta.description) || v.value) + " ", 1),
                  (k(true), x(Ie, null, st(v.meta.badges || [], ({ text: m, type: h }) => (k(), ae(f, { type: h }, {
                    default: H(() => [
                      Ze(_e(i(s)("badge." + m)), 1)
                    ]),
                    _: 2
                  }, 1032, ["type"]))), 256))
                ]),
                _: 2
              }, 1032, ["disabled", "modelValue", "onUpdate:modelValue"])
            ]))), 128))
          ])
        ]),
        _: 3
      });
    };
  }
}), hle = ["onClick"], mle = { class: "k-menu-icon" }, gle = ["onClick"], yle = { class: "k-menu-icon" }, ble = ["onClick"], _le = { class: "k-menu-icon" }, wle = ["onClick"], Cle = { class: "k-menu-icon" }, Ele = ["onClick"], Sle = { class: "k-menu-icon" }, kle = { class: "prefix" }, Nle = { class: "entry-input" }, Tle = {
  key: 0,
  class: "shadow"
}, Ole = {
  key: 1,
  class: "placeholder"
}, $le = ["onUpdate:modelValue"], Ile = /* @__PURE__ */ j({
  __name: "group",
  props: {
    schema: {},
    modelValue: {},
    disabled: {},
    prefix: {},
    initial: {},
    extra: {}
  },
  emits: ["update:modelValue"],
  setup(e10) {
    const { entries: t, up: n, down: o, insert: r, del: a, isMax: l, isMin: s, isFixedLength: u } = Hy(), { t: c, setLocaleMessage: d } = yo({
      messages: {
        "zh-CN": Nr,
        "en-US": Tr
      }
    });
    return (f, p) => {
      const v = je("el-button"), m = je("k-schema");
      return k(), ae(Or, vt(f.$attrs, {
        collapsible: { initial: e10.schema.meta.collapse }
      }), {
        title: H(() => [
          J(f.$slots, "title", {}, void 0, true)
        ]),
        desc: H(() => [
          J(f.$slots, "desc", {}, void 0, true)
        ]),
        menu: H(() => [
          J(f.$slots, "menu", {}, void 0, true)
        ]),
        prefix: H(() => [
          J(f.$slots, "prefix", {}, void 0, true)
        ]),
        suffix: H(() => [
          J(f.$slots, "suffix", {}, void 0, true)
        ]),
        control: H(() => [
          i(u) ? ee("", true) : (k(), ae(v, {
            key: 0,
            onClick: p[0] || (p[0] = (h) => i(r)(i(t).length)),
            disabled: e10.disabled || i(l)
          }, {
            default: H(() => [
              Ze(_e(i(c)("entry.add-item")), 1)
            ]),
            _: 1
          }, 8, ["disabled"]))
        ]),
        collapse: H(() => [
          (k(true), x(Ie, null, st(i(t), ([h, b], g) => {
            var _a2, _b2;
            return k(), ae(m, {
              key: g,
              modelValue: i(t)[g][1],
              "onUpdate:modelValue": (w) => i(t)[g][1] = w,
              initial: ((_a2 = e10.initial) != null ? _a2 : e10.schema.meta.default)[h],
              schema: e10.schema.inner,
              disabled: e10.disabled,
              prefix: e10.schema.type === "array" ? `${e10.prefix.slice(0, -1)}[${h}].` : e10.prefix + h + ".",
              extra: {
                foldable: true,
                changed: h in ((_b2 = e10.initial) != null ? _b2 : e10.schema.meta.default) ? void 0 : true,
                invalid: i(t).filter((w) => w[0] === h).length > 1
              }
            }, {
              menu: H(() => [
                p[1] || (p[1] = B("div", { class: "k-menu-separator" }, null, -1)),
                B("div", {
                  class: I(["k-menu-item", { disabled: e10.disabled || !g }]),
                  onClick: (w) => i(n)(g)
                }, [
                  B("span", mle, [
                    W(i(yO))
                  ]),
                  Ze(" " + _e(i(c)("entry.move-up")), 1)
                ], 10, hle),
                B("div", {
                  class: I(["k-menu-item", { disabled: e10.disabled || g === i(t).length - 1 }]),
                  onClick: (w) => i(o)(g)
                }, [
                  B("span", yle, [
                    W(i(gO))
                  ]),
                  Ze(" " + _e(i(c)("entry.move-down")), 1)
                ], 10, gle),
                i(u) ? ee("", true) : (k(), x("div", {
                  key: 0,
                  class: I(["k-menu-item", { disabled: e10.disabled || i(s) }]),
                  onClick: (w) => i(a)(g)
                }, [
                  B("span", _le, [
                    W(i(bO))
                  ]),
                  Ze(" " + _e(i(c)("entry.del-item")), 1)
                ], 10, ble)),
                i(u) ? ee("", true) : (k(), x("div", {
                  key: 1,
                  class: I(["k-menu-item", { disabled: e10.disabled || i(l) }]),
                  onClick: (w) => i(r)(g)
                }, [
                  B("span", Cle, [
                    W(i(Fae))
                  ]),
                  Ze(" " + _e(i(c)("entry.insert-before")), 1)
                ], 10, wle)),
                i(u) ? ee("", true) : (k(), x("div", {
                  key: 2,
                  class: I(["k-menu-item", { disabled: e10.disabled || i(l) }]),
                  onClick: (w) => i(r)(g + 1)
                }, [
                  B("span", Sle, [
                    W(i(Lae))
                  ]),
                  Ze(" " + _e(i(c)("entry.insert-after")), 1)
                ], 10, Ele))
              ]),
              title: H(() => [
                B("span", kle, _e(e10.prefix.slice(0, -1)), 1),
                e10.schema.type === "array" ? (k(), x(Ie, { key: 0 }, [
                  Ze("[" + _e(h) + "]", 1)
                ], 64)) : (k(), x(Ie, { key: 1 }, [
                  p[2] || (p[2] = Ze(" [' ")),
                  B("span", Nle, [
                    i(t)[g][0] ? (k(), x("span", Tle, _e(i(t)[g][0]), 1)) : (k(), x("span", Ole, "\xA0")),
                    lt(B("input", {
                      "onUpdate:modelValue": (w) => i(t)[g][0] = w
                    }, null, 8, $le), [
                      [Qu, i(t)[g][0]]
                    ])
                  ]),
                  p[3] || (p[3] = Ze(" '] "))
                ], 64))
              ]),
              _: 2
            }, 1032, ["modelValue", "onUpdate:modelValue", "initial", "schema", "disabled", "prefix", "extra"]);
          }), 128))
        ]),
        _: 3
      }, 16, ["collapsible"]);
    };
  }
}), SO = /* @__PURE__ */ zn(Ile, [["__scopeId", "data-v-1699fcf7"]]);
function Mle(e10, t) {
  if (typeof Symbol < "u") {
    const n = { ...e10 };
    return Object.defineProperty(n, Symbol.iterator, {
      enumerable: false,
      value() {
        let o = 0;
        return {
          next: () => ({
            value: t[o++],
            done: o > t.length
          })
        };
      }
    }), n;
  } else
    return Object.assign([...t], e10);
}
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
function Ple(e10) {
  const t = /* @__PURE__ */ Object.create(null);
  return (n) => t[n] || (t[n] = e10(n));
}
const Rle = /-(\w)/g, Ale = Ple((e10) => e10.replace(Rle, (t, n) => n ? n.toUpperCase() : ""));
function kO(e10 = {}) {
  const {
    inheritAttrs: t = true
  } = e10, n = qt(), o = /* @__PURE__ */ j({
    setup(a, { slots: l }) {
      return () => {
        n.value = l.default;
      };
    }
  }), r = /* @__PURE__ */ j({
    inheritAttrs: t,
    props: e10.props,
    setup(a, { attrs: l, slots: s }) {
      return () => {
        var u;
        if (!n.value && "development" !== "production")
          throw new Error("[VueUse] Failed to find the definition of reusable template");
        const c = (u = n.value) == null ? void 0 : u.call(n, {
          ...e10.props == null ? Lle(l) : a,
          $slots: s
        });
        return t && (c == null ? void 0 : c.length) === 1 ? c[0] : c;
      };
    }
  });
  return Mle(
    { define: o, reuse: r },
    [o, r]
  );
}
function Lle(e10) {
  const t = {};
  for (const n in e10)
    t[Ale(n)] = e10[n];
  return t;
}
const xle = {
  key: 0,
  class: "k-schema-header"
}, Dle = /* @__PURE__ */ j({
  inheritAttrs: false,
  __name: "intersect",
  props: {
    schema: {},
    modelValue: {},
    disabled: {},
    prefix: {},
    initial: {},
    extra: {}
  },
  emits: ["update:modelValue"],
  setup(e10) {
    const t = e10, [n, o] = kO(), r = ra(), a = S(() => r(t.schema.meta.description));
    return (l, s) => {
      var _a2;
      var d;
      const u = je("k-schema"), c = je("k-markdown");
      return k(), x(Ie, null, [
        W(i(n), null, {
          default: H(() => [
            (k(true), x(Ie, null, st(i(wc)(e10.schema), (f, p) => {
              var v;
              return k(), ae(u, {
                key: p,
                modelValue: e10.modelValue,
                "onUpdate:modelValue": s[0] || (s[0] = (m) => l.$emit("update:modelValue", m)),
                schema: (v = e10.extra) != null && v.foldable ? f : { ...f, meta: { ...e10.schema.meta, ...f.meta } },
                initial: e10.initial,
                disabled: e10.disabled,
                prefix: e10.prefix,
                extra: { foldable: false }
              }, {
                title: H(() => [
                  J(l.$slots, "title")
                ]),
                prefix: H(() => [
                  J(l.$slots, "prefix")
                ]),
                suffix: H(() => [
                  J(l.$slots, "suffix")
                ]),
                _: 2
              }, 1032, ["modelValue", "schema", "initial", "disabled", "prefix"]);
            }), 128))
          ]),
          _: 3
        }),
        ((_a2 = (d = e10.extra) == null ? void 0 : d.foldable) != null ? _a2 : e10.schema.meta.collapse) ? (k(), ae(Or, vt({ key: 0 }, l.$attrs, {
          collapsible: { initial: e10.schema.meta.collapse }
        }), {
          title: H(() => [
            J(l.$slots, "title")
          ]),
          desc: H(() => [
            J(l.$slots, "desc", {}, () => [
              W(c, { source: a.value }, null, 8, ["source"])
            ])
          ]),
          menu: H(() => [
            J(l.$slots, "menu")
          ]),
          prefix: H(() => [
            J(l.$slots, "prefix")
          ]),
          suffix: H(() => [
            J(l.$slots, "suffix")
          ]),
          collapse: H(() => [
            W(i(o))
          ]),
          _: 3
        }, 16, ["collapsible"])) : (k(), x(Ie, { key: 1 }, [
          a.value ? (k(), x("h2", xle, _e(a.value), 1)) : ee("", true),
          W(i(o))
        ], 64))
      ], 64);
    };
  }
}), Vle = { class: "prefix" }, Fle = {
  key: 0,
  class: "k-schema-header"
}, Ble = /* @__PURE__ */ j({
  inheritAttrs: false,
  __name: "object",
  props: {
    schema: {},
    modelValue: {},
    disabled: {},
    prefix: {},
    initial: {},
    extra: {}
  },
  emits: ["update:modelValue"],
  setup(e10) {
    const t = e10, [n, o] = kO(), r = ra(), a = La(), l = S(() => r(t.schema.meta.description)), { t: s, setLocaleMessage: u } = yo({
      messages: {
        "zh-CN": Nr,
        "en-US": Tr
      }
    });
    return (c, d) => {
      var _a2;
      var m;
      const f = je("k-badge"), p = je("k-schema"), v = je("k-markdown");
      return k(), x(Ie, null, [
        W(i(n), null, {
          default: H(() => [
            (k(true), x(Ie, null, st(e10.schema.dict, (h, b) => {
              var g;
              return k(), ae(p, {
                key: b,
                modelValue: i(a)[b],
                "onUpdate:modelValue": (w) => i(a)[b] = w != null ? w : void 0,
                schema: h,
                initial: (g = e10.initial) == null ? void 0 : g[b],
                disabled: e10.disabled,
                prefix: e10.prefix + b + "."
              }, {
                title: H(() => [
                  B("span", Vle, _e(e10.prefix), 1),
                  B("span", null, _e(b), 1),
                  (k(true), x(Ie, null, st(h.meta.badges || [], ({ text: w, type: y }) => (k(), ae(f, { type: y }, {
                    default: H(() => [
                      Ze(_e(i(s)("badge." + w)), 1)
                    ]),
                    _: 2
                  }, 1032, ["type"]))), 256))
                ]),
                _: 2
              }, 1032, ["modelValue", "onUpdate:modelValue", "schema", "initial", "disabled", "prefix"]);
            }), 128))
          ]),
          _: 1
        }),
        ((_a2 = (m = e10.extra) == null ? void 0 : m.foldable) != null ? _a2 : e10.schema.meta.collapse) ? (k(), ae(Or, vt({ key: 0 }, c.$attrs, {
          collapsible: { initial: e10.schema.meta.collapse }
        }), {
          title: H(() => [
            J(c.$slots, "title")
          ]),
          desc: H(() => [
            J(c.$slots, "desc", {}, () => [
              W(v, { source: l.value }, null, 8, ["source"])
            ])
          ]),
          menu: H(() => [
            J(c.$slots, "menu")
          ]),
          prefix: H(() => [
            J(c.$slots, "prefix")
          ]),
          suffix: H(() => [
            J(c.$slots, "suffix")
          ]),
          collapse: H(() => [
            W(i(o))
          ]),
          _: 3
        }, 16, ["collapsible"])) : (k(), x(Ie, { key: 1 }, [
          l.value ? (k(), x("h2", Fle, _e(l.value), 1)) : ee("", true),
          W(i(o))
        ], 64))
      ], 64);
    };
  }
}), Hle = { class: "bottom" }, zle = /* @__PURE__ */ j({
  __name: "radio",
  props: {
    schema: {},
    modelValue: {},
    disabled: {},
    prefix: {},
    initial: {}
  },
  emits: ["update:modelValue"],
  setup(e10) {
    const t = ra(), n = La(), { t: o, setLocaleMessage: r } = yo({
      messages: {
        "zh-CN": Nr,
        "en-US": Tr
      }
    });
    return (a, l) => {
      const s = je("k-badge"), u = je("el-radio");
      return k(), ae(Or, null, {
        title: H(() => [
          J(a.$slots, "title")
        ]),
        desc: H(() => [
          J(a.$slots, "desc")
        ]),
        menu: H(() => [
          J(a.$slots, "menu")
        ]),
        prefix: H(() => [
          J(a.$slots, "prefix")
        ]),
        suffix: H(() => [
          J(a.$slots, "suffix")
        ]),
        default: H(() => [
          B("ul", Hle, [
            (k(true), x(Ie, null, st(i(wc)(e10.schema), (c) => (k(), x("li", {
              key: c.value
            }, [
              W(u, {
                label: c.value,
                disabled: e10.disabled || c.meta.disabled,
                modelValue: i(n),
                "onUpdate:modelValue": l[0] || (l[0] = (d) => Ot(n) ? n.value = d : null)
              }, {
                default: H(() => [
                  Ze(_e(i(t)(c.meta.description) || c.value) + " ", 1),
                  (k(true), x(Ie, null, st(c.meta.badges || [], ({ text: d, type: f }) => (k(), ae(s, { type: f }, {
                    default: H(() => [
                      Ze(_e(i(o)("badge." + d)), 1)
                    ]),
                    _: 2
                  }, 1032, ["type"]))), 256))
                ]),
                _: 2
              }, 1032, ["label", "disabled", "modelValue"])
            ]))), 128))
          ])
        ]),
        _: 3
      });
    };
  }
}), Kle = { class: "k-menu-icon" }, Wle = { class: "k-menu-icon" }, NO = /* @__PURE__ */ j({
  __name: "multiselect",
  props: {
    schema: {},
    modelValue: {},
    disabled: {},
    prefix: {},
    initial: {}
  },
  emits: ["update:modelValue"],
  setup(e10) {
    const t = ra(), { values: n, items: o, selectAll: r, selectNone: a } = zy(), { t: l, setLocaleMessage: s } = yo({
      messages: {
        "zh-CN": Nr,
        "en-US": Tr
      }
    });
    return (u, c) => {
      const d = je("k-badge"), f = je("el-option"), p = je("el-select");
      return k(), ae(Or, null, {
        title: H(() => [
          J(u.$slots, "title")
        ]),
        desc: H(() => [
          J(u.$slots, "desc")
        ]),
        menu: H(() => [
          J(u.$slots, "menu"),
          c[3] || (c[3] = B("div", { class: "k-menu-separator" }, null, -1)),
          B("div", {
            class: I(["k-menu-item", { disabled: e10.disabled }]),
            onClick: c[0] || (c[0] = //@ts-ignore
            (...v) => i(r) && i(r)(...v))
          }, [
            B("span", Kle, [
              W(i(wO))
            ]),
            Ze(" " + _e(i(l)("select.all")), 1)
          ], 2),
          B("div", {
            class: I(["k-menu-item", { disabled: e10.disabled }]),
            onClick: c[1] || (c[1] = //@ts-ignore
            (...v) => i(a) && i(a)(...v))
          }, [
            B("span", Wle, [
              W(i(CO))
            ]),
            Ze(" " + _e(i(l)("select.none")), 1)
          ], 2)
        ]),
        prefix: H(() => [
          J(u.$slots, "prefix")
        ]),
        suffix: H(() => [
          J(u.$slots, "suffix")
        ]),
        control: H(() => [
          W(p, {
            multiple: "",
            "collapse-tags": "",
            modelValue: i(n),
            "onUpdate:modelValue": c[2] || (c[2] = (v) => Ot(n) ? n.value = v : null),
            disabled: e10.disabled
          }, {
            default: H(() => [
              (k(true), x(Ie, null, st(i(o), (v) => (k(), ae(f, {
                key: v.value,
                value: v.value,
                disabled: v.meta.disabled
              }, {
                default: H(() => [
                  Ze(_e(i(t)(v.meta.description) || v.value) + " ", 1),
                  (k(true), x(Ie, null, st(v.meta.badges || [], ({ text: m, type: h }) => (k(), ae(d, { type: h }, {
                    default: H(() => [
                      Ze(_e(i(l)("badge." + m)), 1)
                    ]),
                    _: 2
                  }, 1032, ["type"]))), 256))
                ]),
                _: 2
              }, 1032, ["value", "disabled"]))), 128))
            ]),
            _: 1
          }, 8, ["modelValue", "disabled"])
        ]),
        _: 3
      });
    };
  }
}), jle = { class: "k-schema-table" }, Ule = { key: 0 }, Yle = { key: 0 }, qle = ["onMouseenter", "onMouseleave"], Gle = { class: "suffix-icon" }, Xle = ["onMouseenter", "onMouseleave"], Jle = ["onClick"], Zle = { class: "inner" }, Qle = ["onClick"], ese = { class: "inner" }, tse = ["onClick"], nse = { class: "inner" }, TO = /* @__PURE__ */ j({
  __name: "table",
  props: {
    schema: {},
    modelValue: {},
    disabled: {},
    prefix: {},
    initial: {}
  },
  emits: ["update:modelValue"],
  setup(e10) {
    const t = e10, n = S(() => Ky(t.schema.inner)), { entries: o, insert: r, del: a, up: l, down: s, isMax: u, isMin: c, isFixedLength: d } = Hy(), f = L(), p = L(), v = L();
    function m(O, N) {
      const $ = O.getBoundingClientRect(), R = f.value.getBoundingClientRect();
      return {
        el: O,
        invalid: !!N,
        top: $.top - R.top,
        left: $.left - R.left,
        width: $.width,
        height: $.height
      };
    }
    function h(O, N) {
      if (O === null) return;
      if (N >= 0) return sm(n.value[N][1], o.value[O][1]);
      const $ = sm(t.schema.sKey, o.value[O][0]);
      if ($) return $;
      if (N === -1 && o.value.filter(([R]) => R === o.value[O][0]).length > 1)
        return ["errors.duplicate-key"];
    }
    function b(O, N, $) {
      var P, z;
      const R = O.target;
      R !== ((P = p.value) == null ? void 0 : P.el) && ((z = n.value[$]) != null && z[1].meta.disabled || (p.value = m(R, h(N, $))));
    }
    function g(O, N, $) {
      p.value = void 0;
    }
    function w(O, N, $) {
      var P;
      let R = O.target;
      for (; R && R.tagName !== "TD"; )
        R = R.parentElement;
      !R || R === ((P = v.value) == null ? void 0 : P.el) || (v.value = m(R, h(N, $)));
    }
    function y(O, N, $) {
      v.value = void 0;
    }
    function _(O) {
      return O.type === "boolean" ? "checkbox" : O.type === "number" ? "input-number" : O.type === "string" ? "input" : "select";
    }
    const C = ra(), { t: E, setLocaleMessage: T } = yo({
      messages: {
        "zh-CN": Nr,
        "en-US": Tr
      }
    });
    return (O, N) => {
      const $ = je("el-button"), R = je("k-badge"), P = je("el-tooltip"), z = je("el-input");
      return k(), ae(Or, null, {
        title: H(() => [
          J(O.$slots, "title")
        ]),
        desc: H(() => [
          J(O.$slots, "desc")
        ]),
        menu: H(() => [
          J(O.$slots, "menu")
        ]),
        prefix: H(() => [
          J(O.$slots, "prefix")
        ]),
        suffix: H(() => [
          J(O.$slots, "suffix")
        ]),
        control: H(() => [
          i(d) ? ee("", true) : (k(), ae($, {
            key: 0,
            onClick: N[0] || (N[0] = (Y) => i(r)(i(o).length)),
            disabled: e10.disabled || i(u)
          }, {
            default: H(() => [
              Ze(_e(i(E)("entry.add-row")), 1)
            ]),
            _: 1
          }, 8, ["disabled"]))
        ]),
        default: H(() => {
          var Y;
          return [
            n.value && i(o).length ? (k(), x("div", {
              key: 0,
              class: "bottom k-schema-table-container",
              ref_key: "container",
              ref: f
            }, [
              B("table", jle, [
                e10.schema.type === "dict" || n.value[0][0] !== null ? (k(), x("tr", Ule, [
                  e10.schema.type === "dict" ? (k(), x("th", Yle, _e(i(C)((Y = e10.schema.sKey) == null ? void 0 : Y.meta.description) || i(E)("entry.key")), 1)) : ee("", true),
                  (k(true), x(Ie, null, st(n.value, ([D, M]) => (k(), x("th", { key: D }, [
                    B("span", null, _e(i(C)(M.meta.description) || D || i(E)("entry.value")), 1),
                    (k(true), x(Ie, null, st(M.meta.badges || [], ({ text: F, type: A }) => (k(), ae(R, { type: A }, {
                      default: H(() => [
                        Ze(_e(i(E)("badge." + F)), 1)
                      ]),
                      _: 2
                    }, 1032, ["type"]))), 256))
                  ]))), 128)),
                  N[7] || (N[7] = B("th", { colspan: "3" }, null, -1))
                ])) : ee("", true),
                (k(true), x(Ie, null, st(i(o), (D, M) => (k(), x("tr", null, [
                  e10.schema.type === "dict" ? (k(), x("td", {
                    key: 0,
                    class: "k-schema-table-cell-input",
                    onMouseenter: (F) => b(F, M, -1),
                    onMouseleave: (F) => g(F, M, -1)
                  }, [
                    W(z, {
                      modelValue: i(o)[M][0],
                      "onUpdate:modelValue": (F) => i(o)[M][0] = F,
                      disabled: e10.disabled,
                      onFocus: (F) => w(F, M, -1),
                      onBlur: (F) => y(F, M, -1)
                    }, {
                      suffix: H(() => [
                        h(M, -1) ? (k(), ae(P, {
                          key: 0,
                          content: i(E)(...h(M, -1))
                        }, {
                          default: H(() => [
                            B("span", Gle, [
                              W(i(_O), { class: "invalid" })
                            ])
                          ]),
                          _: 2
                        }, 1032, ["content"])) : ee("", true)
                      ]),
                      _: 2
                    }, 1032, ["modelValue", "onUpdate:modelValue", "disabled", "onFocus", "onBlur"])
                  ], 40, qle)) : ee("", true),
                  (k(true), x(Ie, null, st(n.value, ([F, A], V) => {
                    var Z;
                    return k(), x("td", {
                      key: F,
                      class: I(["k-schema-table-cell", "k-schema-table-cell-" + _(A)]),
                      onMouseenter: (G) => b(G, M, V),
                      onMouseleave: (G) => g(G, M, V)
                    }, [
                      W(Wy, {
                        minimal: "",
                        schema: A,
                        disabled: e10.disabled || A.meta.disabled,
                        modelValue: F === null ? i(o)[M][1] : (Z = i(o)[M][1]) == null ? void 0 : Z[F],
                        "onUpdate:modelValue": (G) => {
                          var le;
                          return F === null ? i(o)[M][1] = G : ((le = i(o)[M])[1] || (le[1] = {}))[F] = G;
                        },
                        onFocus: (G) => w(G, M, V),
                        onBlur: (G) => y(G, M, V)
                      }, null, 8, ["schema", "disabled", "modelValue", "onUpdate:modelValue", "onFocus", "onBlur"])
                    ], 42, Xle);
                  }), 128)),
                  e10.disabled ? ee("", true) : (k(), x("td", {
                    key: 1,
                    class: I(["k-schema-table-button", { disabled: !M }]),
                    onClick: Xe((F) => i(l)(M), ["stop"]),
                    onMouseenter: N[1] || (N[1] = (F) => b(F, null)),
                    onMouseleave: N[2] || (N[2] = (F) => g(F, null))
                  }, [
                    B("div", Zle, [
                      W(i(yO))
                    ])
                  ], 42, Jle)),
                  e10.disabled ? ee("", true) : (k(), x("td", {
                    key: 2,
                    class: I(["k-schema-table-button", { disabled: M === i(o).length - 1 }]),
                    onClick: Xe((F) => i(s)(M), ["stop"]),
                    onMouseenter: N[3] || (N[3] = (F) => b(F, null)),
                    onMouseleave: N[4] || (N[4] = (F) => g(F, null))
                  }, [
                    B("div", ese, [
                      W(i(gO))
                    ])
                  ], 42, Qle)),
                  !e10.disabled && !i(d) ? (k(), x("td", {
                    key: 3,
                    class: I(["k-schema-table-button", { disabled: i(c) }]),
                    onClick: Xe((F) => i(a)(M), ["stop"]),
                    onMouseenter: N[5] || (N[5] = (F) => b(F, null)),
                    onMouseleave: N[6] || (N[6] = (F) => g(F, null))
                  }, [
                    B("div", nse, [
                      W(i(bO))
                    ])
                  ], 42, tse)) : ee("", true)
                ]))), 256))
              ]),
              (k(true), x(Ie, null, st({ hover: p.value, focus: v.value }, (D) => (k(), x(Ie, null, [
                D ? (k(), x("div", {
                  key: 0,
                  class: I(["cell-outline", { invalid: D.invalid }]),
                  style: ze({
                    top: D.top + "px",
                    left: D.left + "px",
                    width: D.width + "px",
                    height: D.height + "px"
                  })
                }, null, 6)) : ee("", true)
              ], 64))), 256))
            ], 512)) : ee("", true)
          ];
        }),
        _: 3
      });
    };
  }
}), ose = { class: "bottom" }, rse = /* @__PURE__ */ j({
  __name: "textarea",
  props: {
    schema: {},
    modelValue: {},
    disabled: {},
    prefix: {},
    initial: {}
  },
  emits: ["update:modelValue"],
  setup(e10) {
    const t = e10, n = La(), o = S(() => {
      const { rows: r } = t.schema.meta.extra || {};
      return typeof r == "number" ? { minRows: r, maxRows: r } : Array.isArray(r) ? { minRows: r[0], maxRows: r[1] } : true;
    });
    return (r, a) => {
      const l = je("el-input");
      return k(), ae(Or, null, {
        title: H(() => [
          J(r.$slots, "title")
        ]),
        desc: H(() => [
          J(r.$slots, "desc")
        ]),
        menu: H(() => [
          J(r.$slots, "menu")
        ]),
        prefix: H(() => [
          J(r.$slots, "prefix")
        ]),
        suffix: H(() => [
          J(r.$slots, "suffix")
        ]),
        default: H(() => [
          B("div", ose, [
            W(l, {
              type: "textarea",
              modelValue: i(n),
              "onUpdate:modelValue": a[0] || (a[0] = (s) => Ot(n) ? n.value = s : null),
              autosize: o.value,
              disabled: e10.disabled
            }, null, 8, ["modelValue", "autosize", "disabled"])
          ])
        ]),
        _: 3
      });
    };
  }
}), ase = /* @__PURE__ */ j({
  __name: "tuple",
  props: {
    schema: {},
    modelValue: {},
    disabled: {},
    prefix: {},
    initial: {}
  },
  emits: ["update:modelValue"],
  setup(e10) {
    const t = e10, n = La(), o = S(() => t.schema.list.every((r) => ["string", "number", "boolean"].includes(r.type)));
    return (r, a) => (k(), ae(Or, null, ro({
      title: H(() => [
        J(r.$slots, "title")
      ]),
      desc: H(() => [
        J(r.$slots, "desc")
      ]),
      menu: H(() => [
        J(r.$slots, "menu")
      ]),
      _: 2
    }, [
      o.value ? {
        name: "prefix",
        fn: H(() => [
          J(r.$slots, "prefix")
        ]),
        key: "0"
      } : void 0,
      o.value ? {
        name: "suffix",
        fn: H(() => [
          J(r.$slots, "suffix")
        ]),
        key: "1"
      } : void 0,
      o.value ? {
        name: "control",
        fn: H(() => [
          (k(true), x(Ie, null, st(e10.schema.list, (l, s) => (k(), ae(Wy, {
            key: s,
            schema: l,
            disabled: e10.disabled,
            modelValue: i(n)[s],
            "onUpdate:modelValue": (u) => i(n)[s] = u
          }, null, 8, ["schema", "disabled", "modelValue", "onUpdate:modelValue"]))), 128))
        ]),
        key: "2"
      } : void 0
    ]), 1024));
  }
}), lse = /* @__PURE__ */ j({
  __name: "union",
  props: {
    schema: {},
    modelValue: {},
    disabled: {},
    prefix: {},
    initial: {},
    extra: {}
  },
  emits: ["update:modelValue"],
  setup(e10) {
    const t = e10, n = ra(), o = L(), r = L(), a = L(), l = L();
    ge(() => t.schema, (p) => {
      r.value = wc(t.schema), a.value = r.value.map((v) => v.type === "const" ? v.value : Us(v, true));
    }, { immediate: true });
    const s = (p) => {
      var v;
      if (!p) {
        o.value = ((v = r.value) == null ? void 0 : v.map((m, h) => [m, h])) || [];
        return;
      }
      o.value = r.value.map((m, h) => [m, h]).filter(([m]) => (n(m.meta.description) || String(m.value)).includes(p));
    }, u = La({
      input(p) {
        l.value = null;
        let v = true, m = 0;
        for (; !l.value && v && ++m < 10; ) {
          v = false;
          for (const [h, b] of t.schema.list.entries())
            if (!b.meta.hidden && Yre(b, p)) {
              if (b.type === "transform") {
                if (!b.callback) continue;
                try {
                  p = b.callback(p);
                } catch (g) {
                  console.error(g);
                  continue;
                }
                v = true, p != null ? p : p = Us(t.schema);
              } else
                l.value = b, a.value[h] = p;
              break;
            }
        }
        return ns(p, Us(t.schema)) && (p = null), p;
      }
    }), c = S({
      get() {
        var p, v;
        if (l.value !== t.schema)
          return n((p = l.value) == null ? void 0 : p.meta.description) || ((v = l.value) == null ? void 0 : v.value);
      },
      set(p) {
        l.value !== r.value[p] && (u.value = a.value[p], l.value = r.value[p]);
      }
    }), { t: d, setLocaleMessage: f } = yo({
      messages: {
        "zh-CN": Nr,
        "en-US": Tr
      }
    });
    return (p, v) => {
      var _a2;
      var y;
      const m = je("k-markdown"), h = je("k-badge"), b = je("el-option"), g = je("el-select"), w = je("k-schema");
      return k(), ae(w, {
        modelValue: i(u),
        "onUpdate:modelValue": v[1] || (v[1] = (_) => Ot(u) ? u.value = _ : null),
        schema: l.value,
        initial: e10.initial,
        disabled: e10.disabled,
        prefix: e10.prefix,
        extra: {
          foldable: (_a2 = (y = e10.extra) == null ? void 0 : y.foldable) != null ? _a2 : true,
          required: !!e10.schema.meta.required && i(vo)(e10.schema.meta.default) && i(vo)(e10.modelValue)
        }
      }, {
        title: H(() => [
          J(p.$slots, "title")
        ]),
        desc: H(() => [
          J(p.$slots, "desc", {}, () => [
            W(m, {
              source: i(n)(e10.schema.meta.description)
            }, null, 8, ["source"])
          ])
        ]),
        prefix: H(() => [
          r.value.length > 1 ? (k(), ae(g, {
            key: 0,
            modelValue: c.value,
            "onUpdate:modelValue": v[0] || (v[0] = (_) => c.value = _),
            filterable: "",
            "filter-method": s,
            disabled: e10.disabled
          }, {
            default: H(() => [
              (k(true), x(Ie, null, st(o.value, ([_, C]) => (k(), ae(b, {
                key: C,
                value: C,
                disabled: _.meta.disabled
              }, {
                default: H(() => [
                  Ze(_e(i(n)(_.meta.description) || _.value) + " ", 1),
                  (k(true), x(Ie, null, st(_.meta.badges || [], ({ text: E, type: T }) => (k(), ae(h, { type: T }, {
                    default: H(() => [
                      Ze(_e(i(d)("badge." + E)), 1)
                    ]),
                    _: 2
                  }, 1032, ["type"]))), 256))
                ]),
                _: 2
              }, 1032, ["value", "disabled"]))), 128))
            ]),
            _: 1
          }, 8, ["modelValue", "disabled"])) : ee("", true)
        ]),
        suffix: H(() => [
          J(p.$slots, "suffix")
        ]),
        _: 3
      }, 8, ["modelValue", "schema", "initial", "disabled", "prefix", "extra"]);
    };
  }
}), gw = /* @__PURE__ */ j({
  __name: "badge",
  props: {
    type: {}
  },
  setup(e10) {
    return (t, n) => (k(), x("span", {
      class: I(["k-badge", t.type])
    }, [
      J(t.$slots, "default")
    ], 2));
  }
}), sse = { class: "k-menu-icon" }, ise = { class: "k-menu-icon" }, use = { class: "k-menu-icon" }, yw = /* @__PURE__ */ j({
  inheritAttrs: false,
  __name: "schema",
  props: {
    schema: {},
    initial: {},
    modelValue: {},
    extra: {},
    disabled: Boolean,
    branch: Boolean,
    prefix: { type: String, default: "" }
  },
  emits: ["update:modelValue"],
  setup(e10, { emit: t }) {
    const n = e10, o = Le("__SCHEMASTERY_EXTENSIONS__");
    Le("__SCHEMASTERY_SLOTS__");
    const r = t, a = L(), l = L(false), s = L(""), u = L("");
    ge(() => n.modelValue, (g) => {
      s.value = JSON.stringify(g != null ? g : Us(n.schema), null, 2);
    }, { immediate: true }), ge(s, (g) => {
      u.value = "";
      try {
        const w = JSON.parse(g);
        (0,schemastery__WEBPACK_IMPORTED_MODULE_0__["default"])(n.schema)(w);
      } catch {
        u.value = h("edit.invalid");
      }
    });
    async function c() {
      await navigator.clipboard.writeText(s.value), IT.success(h("edit.copied"));
    }
    function d() {
      r("update:modelValue", (0,schemastery__WEBPACK_IMPORTED_MODULE_0__["default"])(n.schema).simplify(JSON.parse(s.value))), l.value = false;
    }
    const f = ra(), p = S(() => {
      var g;
      return n.disabled || ((g = n.schema) == null ? void 0 : g.meta.disabled);
    }), v = S(() => {
      var g;
      return ["string", "number", "boolean"].includes((g = n.schema) == null ? void 0 : g.type) && (vo(n.modelValue) || typeof n.modelValue === n.schema.type);
    }), m = S(() => {
      const g = [...o].map((w) => {
        var y, _;
        if (!(w.type && ((y = n.schema) == null ? void 0 : y.type) !== w.type) && !(w.role && ((_ = n.schema) == null ? void 0 : _.meta.role) !== w.role) && !(w.validate && !(vo(n.modelValue) && !w.important || w.validate(n.modelValue, n.schema))))
          return [w.component, +!!w.type + +!!w.role + (w.important ? 1 / 0 : 0)];
      }).filter(Boolean).sort((w, y) => y[1] - w[1]);
      return g.push([Or, 0]), g[0][0];
    }), { t: h, setLocaleMessage: b } = yo({
      messages: {
        "zh-CN": Nr,
        "en-US": Tr
      }
    });
    return (g, w) => {
      var _a2, _b2;
      var T, O, N, $, R, P, z;
      const y = je("k-markdown"), _ = je("el-input"), C = je("el-button"), E = je("el-dialog");
      return k(), x(Ie, null, [
        !((T = e10.schema) != null && T.meta.hidden) && ((O = e10.extra) != null && O.foldable || e10.schema && e10.schema.type !== "const") ? (k(), ae(i(m), vt({ key: 0 }, g.$attrs, {
          schema: e10.schema,
          prefix: e10.prefix,
          initial: e10.initial,
          disabled: p.value,
          extra: e10.extra,
          modelValue: e10.modelValue,
          "onUpdate:modelValue": w[5] || (w[5] = (Y) => g.$emit("update:modelValue", Y)),
          class: {
            changed: (_a2 = (N = e10.extra) == null ? void 0 : N.changed) != null ? _a2 : !i(ns)(e10.initial, e10.modelValue),
            required: (_b2 = ($ = e10.extra) == null ? void 0 : $.required) != null ? _b2 : ((R = e10.schema) == null ? void 0 : R.meta.required) && i(vo)((P = e10.schema) == null ? void 0 : P.meta.default) && i(vo)(e10.modelValue),
            invalid: (z = e10.extra) == null ? void 0 : z.invalid
          }
        }), {
          title: H(() => [
            J(g.$slots, "title")
          ]),
          menu: H(() => [
            B("div", {
              class: "k-menu-item",
              onClick: w[0] || (w[0] = (Y) => l.value = true)
            }, [
              B("span", sse, [
                W(i(rae))
              ]),
              Ze(" " + _e(i(h)("edit.json")), 1)
            ]),
            (k(), ae(ht(g.$slots.menu), vt({ schema: e10.schema, modelValue: e10.modelValue, initial: e10.initial, disabled: p.value }, {
              "onUpdate:modelValue": w[1] || (w[1] = (Y) => g.$emit("update:modelValue", Y))
            }), null, 16)),
            B("div", {
              class: I(["k-menu-item", { disabled: p.value || i(ns)(e10.initial, e10.modelValue) }]),
              onClick: w[2] || (w[2] = (Y) => g.$emit("update:modelValue", i(Fu)(e10.initial)))
            }, [
              B("span", ise, [
                W(i(nle))
              ]),
              Ze(" " + _e(i(h)("initial")), 1)
            ], 2),
            B("div", {
              class: I(["k-menu-item", { disabled: p.value || i(vo)(e10.modelValue) }]),
              onClick: w[3] || (w[3] = (Y) => g.$emit("update:modelValue", null))
            }, [
              B("span", use, [
                W(i(Uae))
              ]),
              Ze(" " + _e(i(h)("default")), 1)
            ], 2)
          ]),
          desc: H(() => [
            J(g.$slots, "desc", {}, () => {
              var Y;
              return [
                W(y, {
                  source: i(f)((Y = e10.schema) == null ? void 0 : Y.meta.description)
                }, null, 8, ["source"])
              ];
            })
          ]),
          collapse: H(() => [
            J(g.$slots, "collapse")
          ]),
          prefix: H(() => [
            J(g.$slots, "prefix")
          ]),
          suffix: H(() => [
            J(g.$slots, "suffix")
          ]),
          control: H(() => [
            v.value ? (k(), ae(Wy, {
              key: 0,
              schema: e10.schema,
              disabled: p.value,
              modelValue: e10.modelValue,
              "onUpdate:modelValue": w[4] || (w[4] = (Y) => g.$emit("update:modelValue", Y))
            }, null, 8, ["schema", "disabled", "modelValue"])) : ee("", true)
          ]),
          _: 3
        }, 16, ["schema", "prefix", "initial", "disabled", "extra", "modelValue", "class"])) : ee("", true),
        W(E, {
          modelValue: l.value,
          "onUpdate:modelValue": w[7] || (w[7] = (Y) => l.value = Y),
          "destroy-on-close": "",
          "append-to-body": "",
          class: "k-schema-edit-dialog",
          title: i(h)("edit.json"),
          onOpen: w[8] || (w[8] = (Y) => {
            var D;
            return (D = a.value) == null ? void 0 : D.focus();
          })
        }, {
          footer: H(() => [
            w[9] || (w[9] = B("div", null, null, -1)),
            B("div", null, [
              W(C, { onClick: c }, {
                default: H(() => [
                  Ze(_e(i(h)("edit.copy")), 1)
                ]),
                _: 1
              }),
              W(C, {
                type: "primary",
                disabled: !!u.value,
                onClick: d
              }, {
                default: H(() => [
                  Ze(_e(i(h)("edit.save")), 1)
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ]),
          default: H(() => [
            W(_, {
              ref_key: "input",
              ref: a,
              type: "textarea",
              class: I({ invalid: u.value }),
              autosize: { minRows: 2, maxRows: 10 },
              modelValue: s.value,
              "onUpdate:modelValue": w[6] || (w[6] = (Y) => s.value = Y)
            }, null, 8, ["class", "modelValue"])
          ]),
          _: 1
        }, 8, ["modelValue", "title"])
      ], 64);
    };
  }
}), cse = { class: "k-form" }, dse = {
  key: 0,
  class: "k-schema-header"
}, bw = /* @__PURE__ */ j({
  __name: "form",
  props: {
    schema: {},
    initial: {},
    modelValue: {},
    disabled: Boolean,
    showHeader: Boolean,
    slots: { default: {} },
    extensions: Array
  },
  emits: ["update:modelValue"],
  setup(e10, { emit: t }) {
    var _a2;
    const n = e10, o = ra(), r = S(() => n.schema && new schemastery__WEBPACK_IMPORTED_MODULE_0__["default"](n.schema));
    function a(p) {
      for (const v of p) {
        const [m, h] = l(v);
        if (!m) return [false, false];
        if (!h) return [true, false];
      }
      return [true, true];
    }
    function l(p) {
      if (!p) return [true, true];
      if (p.meta.hidden) return [true, true];
      if (p.type === "object")
        return o(p.meta.description) ? [true, false] : a(Object.entries(p.dict).filter(([, v]) => !v.meta.hidden).map(([, v]) => v));
      if (p.type === "intersect")
        return a(p.list);
      if (p.type === "union") {
        const v = wc(p);
        return v.length === 1 ? l(v[0]) : [false, false];
      } else
        return [false, false];
    }
    const s = Le("__SCHEMASTERY_EXTENSIONS__");
    yt("__SCHEMASTERY_EXTENSIONS__", /* @__PURE__ */ new Set([...s, ...(_a2 = n.extensions) != null ? _a2 : []])), yt("__SCHEMASTERY_SLOTS__", n.slots);
    const c = S({
      get: () => n.modelValue,
      set: t.bind(null, "update:modelValue")
    }), { t: d, setLocaleMessage: f } = yo({
      messages: {
        "zh-CN": Nr,
        "en-US": Tr
      }
    });
    return (p, v) => {
      const m = je("k-schema");
      return k(), x("form", cse, [
        e10.showHeader || !l(r.value)[0] ? (k(), x("h2", dse, [
          J(p.$slots, "title", {}, () => [
            Ze(_e(i(d)("title")), 1)
          ])
        ])) : ee("", true),
        J(p.$slots, "before"),
        W(m, {
          modelValue: c.value,
          "onUpdate:modelValue": v[0] || (v[0] = (h) => c.value = h),
          initial: e10.initial,
          schema: r.value,
          disabled: e10.disabled
        }, null, 8, ["modelValue", "initial", "schema", "disabled"]),
        J(p.$slots, "after")
      ]);
    };
  }
}), _w = /* @__PURE__ */ new Set(), qn = Object.assign(Or, {
  Form: bw,
  Badge: gw,
  Schema: yw,
  useModel: La,
  useEntries: Hy,
  useDisabled: qre,
  getFallback: Us,
  extensions: _w,
  install(e10) {
    e10.provide("__SCHEMASTERY_EXTENSIONS__", _w), e10.component("k-form", bw), e10.component("k-badge", gw), e10.component("k-schema", yw);
  }
});
qn.extensions.add({
  type: "bitset",
  role: "select",
  component: NO,
  validate: (e10) => typeof e10 == "number" || Array.isArray(e10) && e10.every((t) => typeof t == "string")
});
qn.extensions.add({
  type: "array",
  role: "select",
  component: NO,
  validate: (e10) => Array.isArray(e10) && e10.every((t) => typeof t == "string")
});
qn.extensions.add({
  type: "bitset",
  component: EO,
  validate: (e10) => typeof e10 == "number" || Array.isArray(e10) && e10.every((t) => typeof t == "string")
});
qn.extensions.add({
  type: "array",
  role: "checkbox",
  component: EO,
  validate: (e10) => Array.isArray(e10) && e10.every((t) => typeof t == "string")
});
qn.extensions.add({
  type: "array",
  component: SO,
  validate: (e10) => Array.isArray(e10)
});
qn.extensions.add({
  type: "dict",
  component: SO,
  validate: (e10) => typeof e10 == "object"
});
qn.extensions.add({
  type: "object",
  component: Ble,
  validate: (e10) => typeof e10 == "object"
});
qn.extensions.add({
  type: "intersect",
  component: Dle,
  validate: (e10) => typeof e10 == "object"
});
qn.extensions.add({
  type: "union",
  role: "radio",
  component: zle
});
qn.extensions.add({
  type: "array",
  role: "table",
  component: TO,
  validate: (e10, t) => Array.isArray(e10) && !!Ky(t.inner)
});
qn.extensions.add({
  type: "dict",
  role: "table",
  component: TO,
  validate: (e10, t) => typeof e10 == "object" && !!Ky(t.inner)
});
qn.extensions.add({
  type: "string",
  role: "textarea",
  component: rse,
  validate: (e10) => typeof e10 == "string"
});
qn.extensions.add({
  type: "tuple",
  component: ase,
  validate: (e10) => Array.isArray(e10)
});
qn.extensions.add({
  type: "union",
  component: lse
});
function um(e10, t) {
  (t == null || t > e10.length) && (t = e10.length);
  for (var n = 0, o = Array(t); n < t; n++) o[n] = e10[n];
  return o;
}
function fse(e10) {
  if (Array.isArray(e10)) return e10;
}
function pse(e10) {
  if (Array.isArray(e10)) return um(e10);
}
function vse(e10) {
  if (e10 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e10;
}
function Cp(e10, t, n) {
  return t = cm(t), _se(e10, OO() ? Reflect.construct(t, n || [], cm(e10).constructor) : t.apply(e10, n));
}
function Cc(e10, t) {
  if (!(e10 instanceof t)) throw new TypeError("Cannot call a class as a function");
}
function ww(e10, t) {
  for (var n = 0; n < t.length; n++) {
    var o = t[n];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e10, Nf(o.key), o);
  }
}
function Ec(e10, t, n) {
  return t && ww(e10.prototype, t), n && ww(e10, n), Object.defineProperty(e10, "prototype", { writable: false }), e10;
}
function Ri(e10, t, n) {
  return (t = Nf(t)) in e10 ? Object.defineProperty(e10, t, { value: n, enumerable: true, configurable: true, writable: true }) : e10[t] = n, e10;
}
function ls() {
  return (ls = Object.assign ? Object.assign.bind() : function(e10) {
    for (var t = 1; t < arguments.length; t++) {
      var n, o = arguments[t];
      for (n in o) !{}.hasOwnProperty.call(o, n) || (e10[n] = o[n]);
    }
    return e10;
  }).apply(null, arguments);
}
function cm(e10) {
  return (cm = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  })(e10);
}
function Ep(e10, t) {
  if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
  e10.prototype = Object.create(t && t.prototype, { constructor: { value: e10, writable: true, configurable: true } }), Object.defineProperty(e10, "prototype", { writable: false }), t && $O(e10, t);
}
function OO() {
  try {
    var e10 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (OO = function() {
    return !!e10;
  })();
}
function hse(e10) {
  if (typeof Symbol < "u" && e10[Symbol.iterator] != null || e10["@@iterator"] != null) return Array.from(e10);
}
function mse(e10, t) {
  var n = e10 == null ? null : typeof Symbol < "u" && e10[Symbol.iterator] || e10["@@iterator"];
  if (n != null) {
    var o, r, a, l, s = [], u = true, c = false;
    try {
      if (a = (n = n.call(e10)).next, t === 0) {
        if (Object(n) !== n) return;
        u = false;
      } else for (; !(u = (o = a.call(n)).done) && (s.push(o.value), s.length !== t); u = true) ;
    } catch (d) {
      c = true, r = d;
    } finally {
      try {
        if (!u && n.return != null && (l = n.return(), Object(l) !== l)) return;
      } finally {
        if (c) throw r;
      }
    }
    return s;
  }
}
function gse() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function yse() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Cw(e10, t) {
  var n, o = Object.keys(e10);
  return Object.getOwnPropertySymbols && (n = Object.getOwnPropertySymbols(e10), t && (n = n.filter(function(r) {
    return Object.getOwnPropertyDescriptor(e10, r).enumerable;
  })), o.push.apply(o, n)), o;
}
function Ue(e10) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Cw(Object(n), true).forEach(function(o) {
      Ri(e10, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e10, Object.getOwnPropertyDescriptors(n)) : Cw(Object(n)).forEach(function(o) {
      Object.defineProperty(e10, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return e10;
}
function Vo(e10, t) {
  if (e10 == null) return {};
  var n, o = bse(e10, t);
  if (Object.getOwnPropertySymbols) for (var r = Object.getOwnPropertySymbols(e10), a = 0; a < r.length; a++) n = r[a], t.includes(n) || {}.propertyIsEnumerable.call(e10, n) && (o[n] = e10[n]);
  return o;
}
function bse(e10, t) {
  if (e10 == null) return {};
  var n, o = {};
  for (n in e10) if ({}.hasOwnProperty.call(e10, n)) {
    if (t.includes(n)) continue;
    o[n] = e10[n];
  }
  return o;
}
function _se(e10, t) {
  if (t && (typeof t == "object" || typeof t == "function")) return t;
  if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
  return vse(e10);
}
function $O(e10, t) {
  return ($O = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, o) {
    return n.__proto__ = o, n;
  })(e10, t);
}
function dm(e10, t) {
  return fse(e10) || mse(e10, t) || IO(e10, t) || gse();
}
function Sp(e10) {
  return pse(e10) || hse(e10) || IO(e10) || yse();
}
function wse(e10, t) {
  if (typeof e10 != "object" || !e10) return e10;
  var n = e10[Symbol.toPrimitive];
  if (n === void 0) return (t === "string" ? String : Number)(e10);
  if (n = n.call(e10, t), typeof n != "object") return n;
  throw new TypeError("@@toPrimitive must return a primitive value.");
}
function Nf(e10) {
  return e10 = wse(e10, "string"), typeof e10 == "symbol" ? e10 : e10 + "";
}
function jn(e10) {
  return (jn = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  })(e10);
}
function IO(e10, t) {
  var n;
  if (e10) return typeof e10 == "string" ? um(e10, t) : (n = (n = {}.toString.call(e10).slice(8, -1)) === "Object" && e10.constructor ? e10.constructor.name : n) === "Map" || n === "Set" ? Array.from(e10) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? um(e10, t) : void 0;
}
var MO = { react: { componentWrap: "div", slotWrap: "div", componentWrapAttrs: { __use_react_component_wrap: "", style: { all: "unset" } }, slotWrapAttrs: { __use_react_slot_wrap: "", style: { all: "unset" } }, vueNamedSlotsKey: ["node:"] }, vue: { componentWrapHOC: function(e10) {
  return function() {
    var t = (0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : {}).portals;
    return (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, e10, (t === void 0 ? [] : t).map(function(n) {
      var o = n.Portal;
      return (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(o, { key: n.key });
    }));
  };
}, componentWrapAttrs: { "data-use-vue-component-wrap": "", style: { all: "unset" } }, slotWrapAttrs: { "data-use-vue-slot-wrap": "", style: { all: "unset" } } } };
function PO() {
  var e10 = 0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : { react: {}, vue: {} }, n = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : MO, t = 2 < arguments.length ? arguments[2] : void 0, n = (e10.vue || (e10.vue = {}), e10.react || (e10.react = {}), [n, Ue(Ue({}, e10), {}, { react: Ue(Ue(Ue({}, n.react), e10.react), {}, { componentWrapAttrs: Ue(Ue({}, n.react.componentWrapAttrs), e10.react.componentWrapAttrs), slotWrapAttrs: Ue(Ue({}, n.react.slotWrapAttrs), e10.react.slotWrapAttrs) }), vue: Ue(Ue(Ue({}, n.vue), e10.vue), {}, { componentWrapAttrs: Ue(Ue({}, n.vue.componentWrapAttrs), e10.vue.componentWrapAttrs), slotWrapAttrs: Ue(Ue({}, n.vue.slotWrapAttrs), e10.vue.slotWrapAttrs) }) })]);
  return t && n.unshift({}), Object.assign.apply(this, n);
}
var RO = ["getElementById", "getElementsByClassName", "getElementsByTagName", "getElementsByTagNameNS", "querySelector", "querySelectorAll"], Rs = { Document: {}, Element: {} };
function Cse(e10) {
  Object.keys(Rs).forEach(function(t) {
    RO.forEach(function(n) {
      var o = Rs[t][n] || window[t].prototype[n];
      o && (Rs[t][n] = o, window[t].prototype[n] = function() {
        for (var r = arguments.length, a = new Array(r), l = 0; l < r; l++) a[l] = arguments[l];
        var s = o.apply(this, a);
        return s && (s.constructor !== NodeList || s.constructor === NodeList && 0 < s.length) ? s : ((s = n) === "getElementById" && (s = "querySelector", a = ["#" + a[0]]), (Rs.Element[s] || Element.prototype[s]).apply(e10, a));
      });
    });
  });
}
function Ese() {
  Object.keys(Rs).forEach(function(e10) {
    RO.forEach(function(t) {
      window[e10].prototype[t] = Rs[e10][t];
    });
  });
}
var Sse = ["ref"], kse = ["key"], Nse = ["hashList"], Sv = parseInt(react_dom__WEBPACK_IMPORTED_MODULE_2__.version);
var Tse = (() => {
  function e10(t) {
    return Cc(this, e10), Cp(this, e10, [t]);
  }
  return Ep(e10, react__WEBPACK_IMPORTED_MODULE_1__.Component), Ec(e10, [{ key: "render", value: function() {
    var t = this.props.component, n = this.props.passedProps, n = (n.ref, Vo(n, Sse));
    return (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(t, n, this.props.children);
  } }]);
})(), Ose = function(e10, t, n) {
  var o = (() => {
    function r(a) {
      var l;
      return Cc(this, r), (l = Cp(this, r, [a])).state = Ue(Ue({}, a), t.isSlots ? { children: e10 } : {}), l.setRef = l.setRef.bind(l), l.vueInReactCall = l.vueInReactCall.bind(l), (l.__veauryVueWrapperRef__ = n).__veauryVueInReactCall__ = l.vueInReactCall, l;
    }
    return Ep(r, react__WEBPACK_IMPORTED_MODULE_1__.Component), Ec(r, [{ key: "reactPropsLinkToVueInstance", value: function(a) {
      Object.keys(a).forEach(function(l) {
        n[l] || (n[l] = a[l]);
      }), Object.getOwnPropertyNames(a.__proto__).filter(function(l) {
        return ["constructor", "render"].indexOf(l) < 0;
      }).forEach(function(l) {
        n[l] || (n[l] = a[l]);
      });
    } }, { key: "setRef", value: function(a) {
      var l = this;
      a && (n.__veauryReactRef__ = a, this.reactPropsLinkToVueInstance(a), Promise.resolve().then(function() {
        return l.reactPropsLinkToVueInstance(a);
      }), (this.setRef.current = a).__veauryVueWrapperRef__ = n);
    } }, { key: "createSlot", value: function(a) {
      return { originVNode: a, inheritAttrs: false, __fromReactSlot: true, render: function() {
        var l, s;
        return ((l = a = (a = ((s = this.$slots) == null || (l = s.default) == null ? void 0 : l.call(s)) || a) instanceof Function ? a(this) : a) == null ? void 0 : l.length) === 1 && (s = a[0]) != null && s.data && ((l = this.$attrs).key, s = Vo(l, kse), a[0].props = Ue(Ue({}, s), a[0].props)), a;
      } };
    } }, { key: "componentWillUnmount", value: function() {
      n.__veauryReactRef__ && (n.__veauryReactRef__.__veauryVueWrapperRef__ = null, n.__veauryReactRef__ = null);
    } }, { key: "vueInReactCall", value: function(a) {
      var l = this, s = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : {};
      return 2 < arguments.length && arguments[2] && a && a[0] ? a.map(function(u, c) {
        return Ys(l.createSlot(u instanceof Function ? u : [u]), Ue(Ue(Ue({}, t), s), {}, { isSlots: true, wrapInstance: n })).render({ key: (u == null ? void 0 : u.key) || void 0 });
      }) : Ys(this.createSlot(a), Ue(Ue(Ue({}, t), s), {}, { isSlots: true, wrapInstance: n })).render();
    } }, { key: "render", value: function() {
      var a, l, s, u = this, h = this.state, c = h.hashList, d = Vo(h, Nse), f = {}, p = {};
      for (a in d) l = a, s = void 0, d.hasOwnProperty(l) && d[l] != null && (d[l].__slot ? (d[l].reactSlot ? d[l] = d[l].reactSlot : (s = d[l], t.defaultSlotsFormatter && d[l].__trueChildren ? (d[l].__trueChildren.__top__ = u.__veauryVueWrapperRef__, d[l] = t.defaultSlotsFormatter(d[l].__trueChildren, u.vueInReactCall, c), d[l] instanceof Array ? d[l] = Sp(d[l]) : -1 < ["string", "number"].indexOf(jn(d[l])) ? d[l] = [d[l]] : jn(d[l]) === "object" && (d[l] = Ue({}, d[l]))) : d[l] = Ue({}, Ys(u.createSlot(d[l]), Ue(Ue({}, t), {}, { isSlots: true, wrapInstance: n })).render()), d[l].vueFunction = s), f[l] = d[l]) : d[l].__scopedSlot && (d[l] = d[l](u.createSlot), p[l] = d[l]));
      var v, m, h = {};
      return h.ref = this.setRef, t.isSlots ? this.state.children || this.props.children : (v = d, e10.__syncUpdateForPureReactInVue && Object.keys(e10.__syncUpdateForPureReactInVue).map(function(b) {
        var g, w;
        v[b] && typeof v[b] == "function" && (g = u.__veauryVueWrapperRef__, w = v[b], v[b] = function() {
          for (var y = arguments.length, _ = new Array(y), C = 0; C < y; C++) _[C] = arguments[C];
          g.__veaurySyncUpdateProps__(e10.__syncUpdateForPureReactInVue[b].apply(this, _)), w.apply(this, _), g.macroTaskUpdate = true, g.__veauryMountReactComponent__(true, true, {});
        });
      }), m = Ue(Ue(Ue({}, v = t.defaultPropsFormatter ? t.defaultPropsFormatter.call(this, v, this.vueInReactCall, c) : v), f), p), Object.getPrototypeOf(e10) !== Function.prototype && (jn(e10) !== "object" || e10.render) || r.catchVueRefs() ? (Object.getPrototypeOf(e10) === Function.prototype && delete h.ref, (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(e10, ls({}, m, h))) : (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(Tse, ls({ passedProps: m, component: e10 }, h), m.children));
    } }], [{ key: "catchVueRefs", value: function() {
      if (n.$parent) {
        for (var a in n.$parent.$refs) if (n.$parent.$refs[a] === n) return true;
      }
      return false;
    } }]);
  })();
  return Ri(o, "displayName", "applyReact_".concat(e10.displayName || e10.name || "Component")), o;
};
function kp(e10) {
  var t = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : {};
  return e10.__esModule && e10.default && (e10 = e10.default), t.isSlots && (e10 = e10()), t = PO(t, void 0, true), { originReactComponent: e10, setup: function(n, o) {
    var r, a, l, s;
    if (!t.isSlots) return r = {}, a = It({}), l = it(), typeof (s = t.useInjectPropsFromWrapper || e10.__veauryInjectPropsFromWrapper__) == "function" && (typeof (s = s.call(l.proxy, n)) != "function" ? (Object.assign(a, s), r.__veauryInjectedProps__ = a) : l.proxy.__veauryInjectedComputed__ = s), r;
  }, data: function() {
    return { VEAURY_Portals: [] };
  }, created: function() {
    this.__veauryPortalKeyPool__ = [], this.__veauryMaxPortalCount__ = 0;
  }, computed: { __veauryInjectedProps__: function() {
    var n;
    return (n = this.__veauryInjectedComputed__) == null ? void 0 : n.call(this);
  } }, render: function() {
    var n = Ke(t.react.componentWrap, Ue({ ref: "react" }, t.react.componentWrapAttrs || {}), this.VEAURY_Portals.map(function(o) {
      return (0, o.Portal)(Ke, o.key);
    }));
    return this.__veauryCheckReactSlot__(this.$slots), n;
  }, methods: { __veauryCheckReactSlot__: function(n) {
    var o = this;
    function r(a, l, s) {
      return l[s] && (a[s] = l[s], 1);
    }
    jn(n) === "object" && n != null && (n instanceof Array ? n.forEach(function(a) {
      o.__veauryCheckReactSlot__(a.children);
    }) : Object.keys(n).forEach(function(u) {
      var l, s, u = n[u];
      if (typeof u == "function") {
        try {
          l = u.apply(o, u.__reactArgs || [{}]);
        } catch {
          return;
        }
        (u.__trueChildren = l).forEach(function(c) {
          c.children && o.__veauryCheckReactSlot__(c.children);
        }), l.length !== 1 || r(u, l = l[0], "reactSlot") || r(u, l, "reactFunction") || l.type !== Ie || ((s = l.children) == null ? void 0 : s.length) !== 1 || r(u, s = l.children[0], "reactSlot") || r(u, s, "reactFunction");
      }
    }));
  }, __veauryPushVuePortal__: function(n) {
    var o = this.__veauryPortalKeyPool__.shift() || this.__veauryMaxPortalCount__++;
    this.VEAURY_Portals.push({ Portal: n, key: o });
  }, __veauryRemoveVuePortal__: function(n) {
    var o, r = this.VEAURY_Portals.find(function(a, l) {
      if (a.Portal === n) return o = l, true;
    });
    this.__veauryPortalKeyPool__.push(r.key), this.VEAURY_Portals.splice(o, 1);
  }, __veauryGetScopeSlot__: function(n, o, r) {
    var a = this;
    function l(s) {
      function u() {
        for (var c, d = this, f = arguments.length, p = new Array(f), v = 0; v < f; v++) p[v] = arguments[v];
        return n.reactFunction ? n.reactFunction.apply(this, p) : t.defaultSlotsFormatter ? ((c = n.apply(this, p)).__top__ = a, (c = t.defaultSlotsFormatter(c, a.__veauryVueInReactCall__, o)) instanceof Array || -1 < jn(c).indexOf("string", "number") ? c = Sp(c) : jn(c) === "object" && (c = Ue({}, c)), c) : Ys(s(function() {
          return n.apply(d, p);
        }), Ue(Ue({}, t), {}, { isSlots: true, wrapInstance: a })).render();
      }
      return t.pureTransformer && r ? u.vueFunction = r : u.vueFunction = n, u;
    }
    return l.__scopedSlot = true, l;
  }, __veaurySyncUpdateProps__: function(n) {
    this.__veauryReactInstance__ && this.__veauryReactInstance__.setState(n);
  }, __veauryMountReactComponent__: function(n, o) {
    var r, a, l = this, s = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : {}, u = {}, c = [], d = this.$.vnode.scopeId, f = (d && (u[d] = "", c.push(d)), {}), p = {};
    if (!n || o != null && o.slot) for (var v in this.$slots || {}) ((_) => {
      var C;
      l.$slots.hasOwnProperty(_) && l.$slots[_] != null && ((C = t.react.vueNamedSlotsKey.find(function(E) {
        return _.indexOf(E) === 0;
      })) || _ === "default" ? (C = _.replace(new RegExp("^".concat(C)), ""), f[C] = l.$slots[_], f[C].__slot = true) : p[_] = l.__veauryGetScopeSlot__(l.$slots[_], c, (C = l.$.vnode) == null || (C = C.children) == null ? void 0 : C[_]));
    })(v);
    (!n || o != null && o.slot) && (a = Ue({}, f), r = a.default, delete a.default), this.__veauryLast__ = this.__veauryLast__ || {}, this.__veauryLast__.slot = this.__veauryLast__.slot || {}, this.__veauryLast__.attrs = this.__veauryLast__.attrs || {};
    var m = { slot: function() {
      l.__veauryLast__.slot = Ue(Ue(Ue({}, r ? { children: r } : { children: null }), a), p);
    }, attrs: function() {
      l.__veauryLast__.attrs = l.$attrs;
    } };
    if (o && Object.keys(o).forEach(function(_) {
      return m[_]();
    }), n) {
      var h = function() {
        l.__veauryReactInstance__ && l.__veauryReactInstance__.setState(function(_) {
          return Object.keys(_).forEach(function(C) {
            t.isSlots && C === "children" || delete _[C];
          }), Ue(Ue(Ue(Ue({}, l.__veauryCache__), l.__veauryInjectedProps__), !t.isSlots && l.__veauryLast__.slot), l.__veauryLast__.attrs);
        }), l.__veauryCache__ = null;
      };
      !this.microTaskUpdate || this.__veauryCache__ || this.$nextTick(function() {
        h(), l.microTaskUpdate = false;
      }), this.macroTaskUpdate && (clearTimeout(this.updateTimer), this.updateTimer = setTimeout(function() {
        clearTimeout(l.updateTimer), h(), l.macroTaskUpdate = false;
      })), this.__veauryCache__ = Ue(Ue({}, this.__veauryCache__ || {}), Ue(Ue(Ue(Ue({}, s), this.$attrs.class ? { className: this.$attrs.class } : {}), Ue({}, u)), {}, { hashList: c }, this.$attrs.style ? { style: this.$attrs.style } : {})), this.macroTaskUpdate || this.microTaskUpdate || h();
    } else {
      m.slot(), m.attrs();
      var d = Ose(e10, t, this), b = (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(d, ls({}, this.$attrs, this.__veauryInjectedProps__, { children: r }, a, p, this.$attrs.class ? { className: this.$attrs.class } : {}, u, { hashList: c }, this.$attrs.style ? { style: this.$attrs.style } : {}, { ref: function(C) {
        return l.__veauryReactInstance__ = C;
      } })), g = this.$refs.react, w = t.wrapInstance;
      if (w) (w = t.wrapInstance).__veauryVueWrapperRef__ = this;
      else for (var y = this.$parent; y; ) {
        if (y.parentReactWrapperRef) {
          w = y.parentReactWrapperRef;
          break;
        }
        if (y.reactWrapperRef) {
          w = y.reactWrapperRef;
          break;
        }
        y = y.$parent;
      }
      w ? (this.parentReactWrapperRef = w, this.reactPortal = function() {
        return (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(b, g);
      }, w.pushReactPortal(this.reactPortal)) : 17 < Sv ? (react_dom__WEBPACK_IMPORTED_MODULE_2__.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED !== void 0 && (react_dom__WEBPACK_IMPORTED_MODULE_2__.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint = true), o = t.react.createRoot || react_dom__WEBPACK_IMPORTED_MODULE_2__.createRoot, 18 < Sv && !o && console.warn("'react-dom 19' no longer supports dynamically determining whether to use 'render' or 'createRoot'. In order to be compatible with 'react-dom 17' and previous versions, you need to manually configure 'createRoot' in the veaury configuration."), this.__veauryReactApp__ = o(g), this.__veauryReactApp__.render(b)) : react_dom__WEBPACK_IMPORTED_MODULE_2__.render(b, g);
    }
  } }, mounted: function() {
    var n = this;
    this.__VEAURY_IGNORE_STRANGE_UPDATE__ = true, Promise.resolve().then(function() {
      n.__VEAURY_IGNORE_STRANGE_UPDATE__ = false;
    }), clearTimeout(this.updateTimer), this.__veauryMountReactComponent__();
  }, beforeUnmount: function() {
    var n;
    clearTimeout(this.updateTimer), Cse(this.$refs.react), this.reactPortal ? (n = this.parentReactWrapperRef) != null && n.removeReactPortal(this.reactPortal) : 17 < Sv ? (n = this.__veauryReactApp__) != null && n.unmount() : react_dom__WEBPACK_IMPORTED_MODULE_2__.unmountComponentAtNode(this.$refs.react), Ese();
  }, updated: function() {
    this.__VEAURY_IGNORE_STRANGE_UPDATE__ || this.__veauryMountReactComponent__(true, { slot: true });
  }, inheritAttrs: false, watch: { $attrs: { handler: function() {
    this.__veauryMountReactComponent__(true, { attrs: true });
  }, deep: true }, __veauryInjectedProps__: { handler: function() {
    this.__veauryMountReactComponent__(true, { attrs: true });
  }, deep: true } } };
}
var $se = /* @__PURE__ */ new Set(["onClick", "onContextMenu", "onDoubleClick", "onDrag", "onDragEnd", "onDragEnter", "onDragExit", "onDragLeave", "onDragOver", "onDragStart", "onDrop", "onMouseDown", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseOut", "onMouseOver", "onMouseUp", "onChange", "onInput", "onInvalid", "onReset", "onSubmit", "onError", "onLoad", "onPointerDown", "onPointerMove", "onPointerUp", "onPointerCancel", "onGotPointerCapture", "onLostPointerCapture", "onPointerEnter", "onPointerLeave", "onPointerOver", "onPointerOut", "onSelect", "onTouchCancel", "onTouchEnd", "onTouchMove", "onTouchStart", "onScroll", "onWheel", "onAbort", "onCanPlay", "onCanPlayThrough", "onDurationChange", "onEmptied", "onEncrypted", "onEnded", "onError", "onLoadedData", "onLoadedMetadata", "onLoadStart", "onPause", "onPlay", "onPlaying", "onProgress", "onRateChange", "onSeeked", "onSeeking", "onStalled", "onSuspend", "onTimeUpdate", "onVolumeChange", "onWaiting", "onLoad", "onError", "onAnimationStart", "onAnimationEnd", "onAnimationIteration", "onTransitionEnd", "onToggle"]);
function Ise(e10, t) {
  for (var n = (e10 = t = (e10 == null ? void 0 : e10._reactInternals) || (e10 == null ? void 0 : e10._reactInternalFiber) || t) == null ? void 0 : e10.return; n; ) {
    var o = n.stateNode;
    if (o = (o == null ? void 0 : o.parentVueWrapperRef) || (o == null ? void 0 : o.__veauryVueWrapperRef__)) return o;
    n = n.return;
  }
}
function Ew(e10, t, n) {
  var o = {};
  return n.forEach(function(r) {
    o[r] = true;
  }), e10[(t === "modelValue" ? "model" : t) + "Modifiers"] = o;
}
function Sw(e10, t, n) {
  var o = this, r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : "v-model";
  if (!(t instanceof Array)) throw Error("[error:veaury] Parameter type error from '".concat(r, "', a single v-model is an array, such as [val, setter, argumentKey, modifiers] or [val, setter, modifiers]"));
  if (typeof t[1] != "function") throw Error("[error:veaury] Parameter type error from '".concat(r, "', a single v-model is an array, the second element of the array must be a setter function"));
  var a = t[1], l = (typeof t[2] == "string" ? (n = t[2], t[3] instanceof Array && Ew(e10, n, t[3])) : t[2] instanceof Array && Ew(e10, n, t[2]), e10["onUpdate:" + n]);
  e10["onUpdate:" + n] = typeof l == "function" ? function() {
    for (var s = arguments.length, u = new Array(s), c = 0; c < s; c++) u[c] = arguments[c];
    l.apply(o, u), a.apply(o, u);
  } : a, e10[n] = t[0];
}
function fm(e10) {
  var t = this, n = {}, o = Ue({}, e10);
  return Object.keys(e10).forEach(function(r) {
    var a, l = r.match(/^onUpdate-([^-]+)/);
    if (l) delete o[r], a = n["onUpdate:".concat(l[1])], n["onUpdate:".concat(l[1])] = typeof a == "function" ? function() {
      for (var u = arguments.length, c = new Array(u), d = 0; d < u; d++) c[d] = arguments[d];
      a.apply(t, c), e10[r].apply(t, c);
    } : e10[r];
    else if (l = r.match(/^v-model($|:([^:]+)|-([^:]+))/)) l = l[2] || l[3] || "modelValue", Sw(n, e10[r], l), delete o[r];
    else if (r === "v-models") {
      if (jn(e10[r]) !== "object" || e10[r] instanceof Array) throw Error("[error:veaury] The parameter 'v-models' must be an object type, such as {[argumentKey]: singleVModel}");
      var s = e10[r];
      Object.keys(s).forEach(function(u) {
        Sw(n, s[u], u, "v-models");
      }), delete o[r];
    }
  }), Ue(Ue({}, o), n);
}
var Np = Ec(function e() {
  Cc(this, e), Ri(this, "pool", /* @__PURE__ */ new Set());
}, [{ key: "getRandomId", value: function(e10) {
  var t = e10 + (Math.random() + "").substr(2);
  return this.pool.has(t) ? this.getRandomId(e10) : (this.pool.add(t), t);
} }]);
function AO(o, t) {
  var n, o = o.node;
  if (typeof o == "function" && (o = o()), (n = t) != null && n.current || typeof t == "function" || (n = t) != null && n.toString().match(/^function/) || (t = null), -1 < ["string", "number"].indexOf(jn(o))) return o;
  if (o instanceof Array) {
    if (o.length !== 1) return o;
    o = o[0];
  }
  return Ue(Ue({}, o), {}, { ref: t });
}
var Mse = kp(AO);
function pm(e10) {
  return Ke(Mse, { node: function() {
    return e10.node;
  } });
}
pm.originReactComponent = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(AO);
var Pse = ["component", "node"], Rse = ["component", "$slots", "children", "class", "style"], Ase = ["className", "classname"], Ll = "veaury-options", kw = new Np();
function Lse(e10, t) {
  var n;
  return e10 = typeof e10 == "string" && t ? (t = t.$) == null || (t = t.appContext) == null || (t = t.app) == null || (n = t.component) == null ? void 0 : n.call(t, e10) : e10;
}
function Nw(e10) {
  if (e10) return Object.keys(e10).forEach(function(t) {
    var n = e10[t];
    n != null && (typeof n == "function" ? (e10[t] = n, e10[t].reactFunction = n) : (e10[t] = function() {
      return n;
    }, e10[t].reactSlot = n), n.vueFunction) && (e10[t].vueFunction = n.vueFunction);
  }), e10;
}
function xse(e10) {
  var t;
  return (t = e10.node) == null ? void 0 : t.call(e10);
}
var vm = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(function(r, t) {
  var n, l = r.component, o = r.node, r = Vo(r, Pse);
  if (l == null && o == null) return null;
  if (o != null) {
    if (o.$$typeof || typeof o == "string" || typeof o == "number") return o;
    typeof o != "function" && (n = o, o = function() {
      return n;
    });
  }
  var a, l = l || xse, s = PO(r[Ll] || {}, void 0, true), u = s.useInjectPropsFromWrapper || l.__veauryInjectPropsFromWrapper__;
  return s.isSlots || typeof u == "function" && (a = u(r)), (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(Dse, ls({}, Ue(Ue(Ue(Ue({ component: l }, o ? { node: o } : {}), r), a), {}, Ri({}, Ll, s)), { ref: t }));
}), Dse = (() => {
  function e10(t) {
    var n;
    return Cc(this, e10), (n = Cp(this, e10, [t])).state = { portals: [] }, n.__veauryPortalKeyPool__ = [], n.__veauryMaxPortalCount__ = 0, n.__veauryCurrentVueComponent__ = t.component, n.__veauryCreateVueInstance__ = n.__veauryCreateVueInstance__.bind(n), n.__veauryVueComponentContainer__ = n.createVueComponentContainer(), n;
  }
  return Ep(e10, react__WEBPACK_IMPORTED_MODULE_1__.Component), Ec(e10, [{ key: "pushReactPortal", value: function(t) {
    var n = this.state.portals, o = this.__veauryPortalKeyPool__.shift() || this.__veauryMaxPortalCount__++;
    n.push({ Portal: t, key: o }), this.setState({ portals: n });
  } }, { key: "removeReactPortal", value: function(t) {
    var n, o = this.state.portals, r = o.find(function(a, l) {
      if (a.Portal === t) return n = l, true;
    });
    this.__veauryPortalKeyPool__.push(r.key), o.splice(n, 1), this.__veauryVueRef__ && this.setState({ portals: o });
  } }, { key: "createVueComponentContainer", value: function() {
    var t = this, n = {}, o = this.props[Ll];
    return o.isSlots ? (Object.keys(this.props).forEach(function(r) {
      $se.has(r) && typeof t.props[r] == "function" && (n[r] = t.props[r]);
    }), o.vue.slotWrapAttrs && (n = Ue(Ue({}, n), o.vue.slotWrapAttrs))) : o.vue.componentWrapAttrs && (n = Ue(Ue({}, n), o.vue.componentWrapAttrs)), o.vue.componentWrapHOC((0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)("div", ls({}, o.vue.componentWrapAttrs, { ref: this.__veauryCreateVueInstance__, key: null })), n);
  } }, { key: "shouldComponentUpdate", value: function(t, n, o) {
    var r, a, l, s, u = this;
    return t === this.props || (r = t.component, a = (a = t["v-slots"]) === void 0 ? null : a, l = t.children, t = Vo(t, ["component", Ll, "v-slots", "children"].map(Nf)), this.__veauryCurrentVueComponent__ !== r && this.updateVueComponent(r), r.__fromReactSlot) || this.__veauryVueInstance__ && (l && (a = a || {}, jn(l) !== "object" || l instanceof Array || l.$$typeof ? a.default = l : a = l), (s = this.__veauryVueInstance__.$data.$slots) && Object.keys(s).forEach(function(c) {
      delete s[c];
    }), a && (s || (this.__veauryVueInstance__.$data.$slots = {}), Object.assign(this.__veauryVueInstance__.$data.$slots, Nw(a))), Object.keys(this.__veauryVueInstance__.$data).forEach(function(c) {
      c !== "$slots" && delete u.__veauryVueInstance__.$data[c];
    }), this.__veauryVueInstance__) && Object.assign(this.__veauryVueInstance__.$data, fm(t)), true;
  } }, { key: "componentWillUnmount", value: function() {
    this.vuePortal ? this.parentVueWrapperRef.__veauryRemoveVuePortal__(this.vuePortal) : (this.__veauryVueInstance__ && this.__veauryVueInstance__.$.appContext.app.unmount(), kw.pool.delete(this.__veauryVueTargetId__), this.vueCreated = false);
  } }, { key: "componentDidMount", value: function() {
    this.__veauryCreateVueInstance__(this.vueContainerElement);
  } }, { key: "__veauryCreateVueInstance__", value: function(t) {
    var n, o, r, a, l, s, u, c, d = this;
    function f(p) {
      this.__veauryVueInstance__ || (this.__veauryVueInstance__ = p);
    }
    this.vueCreated || (this.vueCreated = true, (n = this).vueContainerElement = t, (r = this.props).component, o = r[Ll], u = r.children, c = (c = r["v-slots"]) === void 0 ? {} : c, r = Vo(r, ["component", Ll, "children", "v-slots"].map(Nf)), u && (jn(u) !== "object" || u instanceof Array || u.$$typeof ? c.default = u : c = u), (c = Nw(c)) && (r.$slots = c), f = f.bind(this), a = Ue({}, fm(r)), l = { data: function() {
      return o.isSlots ? { children: n.__veauryCurrentVueComponent__.originVNode } : a;
    }, created: function() {
      this.reactWrapperRef = n, f(this);
    }, methods: { reactInVueCall: function(p) {
      return 2 < arguments.length && arguments[2] && p && p[0] ? p.map(function(v, m) {
        return Ke(pm, { node: v, key: (v == null || (v = v.data) == null ? void 0 : v.key) || m });
      }) : Ke(pm, { node: p });
    }, getScopedSlots: function(p, v) {
      var m, h = this, b = (this.getScopedSlots.__scopeSlots || (this.getScopedSlots.__scopeSlots = {}), Ue({}, v));
      for (m in b) ((g) => {
        var w, y;
        !b.hasOwnProperty(g) || (w = b[g]) == null || (b[g] = (y = w, function() {
          for (var _, C, E, T, O = arguments.length, N = new Array(O), $ = 0; $ < O; $++) N[$] = arguments[$];
          return y.vueFunction ? y.vueFunction.apply(h, N) : (E = y.reactFunction, E = y.reactSlot || (E == null ? void 0 : E.apply(h, N)), T = o.defaultSlotsFormatter, (_ = h.getScopedSlots.__scopeSlots[g]) != null && (_ = _.component) != null && (_ = _.ctx) != null && _.__veauryReactInstance__ ? (C = h.getScopedSlots.__scopeSlots[g], Promise.resolve().then(function() {
            var R;
            (R = C) != null && (R = R.component) != null && (R = R.ctx) != null && (R = R.__veauryReactInstance__) != null && R.setState({ children: y.apply(h, N) });
          })) : (C = T && E ? [T(E, h.reactInVueCall)] : p(kp(function() {
            return y.apply(h, N);
          }, Ue(Ue({}, o), {}, { isSlots: true, wrapInstance: n }))), h.getScopedSlots.__scopeSlots[g] = C), y.reactFunction ? C.reactFunction = y.reactFunction : y.reactSlot && (C.reactSlot = y.reactSlot), C);
        }), b[g].reactFunction = w);
      })(m);
      return b;
    } }, mounted: function() {
      t.removeAttribute("id"), n.__veauryVueRef__ = this.$refs.use_vue_wrapper, this.$refs.use_vue_wrapper.reactWrapperRef = n;
    }, beforeUnmount: function() {
      n.__veauryVueRef__ = null, this.$refs.use_vue_wrapper.reactWrapperRef = null;
    }, render: function() {
      var p = this, w = this.$data, b = (w.component, w.$slots), v = w.class, m = w.style, w = Vo(w, Rse), h = this.getScopedSlots(Ke, Ue({}, b)), b = w.className, g = w.classname, w = Vo(w, Ase), y = {};
      return Object.keys(h).forEach(function(_) {
        var C = h[_];
        y[_] = typeof C == "function" ? C : function() {
          return C;
        };
      }), Ke(Lse(n.__veauryCurrentVueComponent__, this), Ue(Ue(Ue(Ue({}, w), v || b || g ? { class: v || b || g } : {}), m ? { style: m } : {}), {}, { ref: "use_vue_wrapper" }), Ue({}, o.isSlots && this.children ? { default: typeof this.children == "function" ? this.children : function() {
        return p.children;
      } } : Ue({}, y)));
    } }, t && (s = kw.getRandomId("__vue_wrapper_container_"), t.id = s, this.__veauryVueTargetId__ = s, (u = o.wrapInstance) ? (u = o.wrapInstance).reactWrapperRef = n : u = Ise(this), u && document.getElementById(s) ? (this.parentVueWrapperRef = u, this.vuePortal = function(p, v) {
      return p(EC, { to: "#" + s, key: s }, [p(Object.assign(l, { router: d._router }))]);
    }, u.__veauryPushVuePortal__(this.vuePortal)) : (c = wE(l), typeof o.beforeVueAppMount == "function" && o.beforeVueAppMount(c), this.__veauryVueInstance__ = c.mount(t))));
  } }, { key: "updateVueComponent", value: function(t) {
    this.__veauryVueInstance__ && (t.__fromReactSlot ? this.__veauryVueInstance__.children = typeof t.originVNode == "function" ? t.originVNode : function() {
      return t.originVNode;
    } : (this.__veauryCurrentVueComponent__ = t, this.__veauryVueInstance__.$forceUpdate()));
  } }, { key: "render", value: function() {
    return (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(this.__veauryVueComponentContainer__, { portals: this.state.portals });
  } }]);
})();
function Ys(e10) {
  var t = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : {}, n = (e10 || console.warn("Component must be passed in applyVueInReact!"), e10.__esModule && e10.default && (e10 = e10.default), (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(function(o, r) {
    return (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(vm, ls({}, o, { component: e10, ref: r }, Ri({}, Ll, t)));
  }));
  return n.originVueComponent = e10, n;
}
var Vse = ["children"];
function Fse(e10) {
  var t = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({});
  return [function() {
    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(t);
  }, kp(function(r) {
    var o = r.children, r = Vo(r, Vse);
    return (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(t.Provider, { value: Ue({}, r) }, o);
  }, { useInjectPropsFromWrapper: e10 }), t];
}
new Np();
function Bse(t) {
  var n = t.useVueInjection, t = t.beforeVueAppMount, n = dm(Fse(n), 3), o = n[0], r = n[2];
  return [o, Ys(n[1], { beforeVueAppMount: t }), r];
}
function Hse(e10) {
  var t = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : {}, n = t.globalName, o = kp(e10, t.combinedOption || {});
  return o.install = function(r) {
    var a = (1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : {}).globalName;
    return n && r.component(a || n, o), o;
  }, o;
}
function Tw(e10) {
  return e10.replace(/-(\w)/g, function(t, n) {
    return n.toUpperCase();
  });
}
function Tp(e10) {
  var t;
  return e10 ? typeof e10 == "string" ? (e10 = e10.trim()).split(/\s*;\s*/).reduce(function(n, o) {
    return o && (o = o.split(/\s*:\s*/)).length === 2 && Object.assign(n, Ri({}, Tw(o[0]), o[1])), n;
  }, {}) : jn(e10) === "object" ? (t = {}, Object.keys(e10).forEach(function(n) {
    t[Tw(n)] = e10[n];
  }), t) : {} : {};
}
function Op(e10) {
  return e10 ? e10 instanceof Array ? e10 : typeof e10 == "string" ? (e10 = e10.trim()).split(/\s+/) : jn(e10) === "object" ? Object.keys(e10).filter(function(t) {
    return !!e10[t];
  }) : [] : [];
}
var zse = ["ref"];
function Kse(e10, t, n, o, r) {
  var a = e10.props || {}, a = (a.ref, Vo(a, zse)), l = {}, s = (Object.keys(e10.children || {}).forEach(function(d) {
    var f = e10.children[d], p = MO.react.vueNamedSlotsKey.find(function(v) {
      return d.indexOf(v) === 0;
    });
    p || d === "default" ? (p = d.replace(new RegExp("^".concat(p)), "").replace(/^default$/, "children"), l[p] = o.call(e10.__top__, f(), n, r)) : typeof f == "function" && (l[d] = function() {
      for (var v = arguments.length, m = new Array(v), h = 0; h < v; h++) m[h] = arguments[h];
      return f.__reactArgs = m, o(f.apply(this, m), n, r);
    });
  }), {}), u = Tp(a.style), c = Array.from(new Set(Op(a.class))).join(" ");
  return 0 < Object.keys(u).length && (s.style = u), c !== "" && (s.className = c), Object.assign(a, Ue(Ue({}, s), l)), delete a.class, typeof a.ref_for == "boolean" && delete a.ref_for, a;
}
function Ow(e10) {
  return e10.type === Zr;
}
new Np();
function LO(e10, t) {
  var n;
  return 0 < ((n = e10.dirs) == null ? void 0 : n.length) ? (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(Wse, { vnode: e10 }, t) : t;
}
var Wse = (() => {
  function e10(t) {
    var n;
    return Cc(this, e10), (n = Cp(this, e10, [t])).state = { prevVnode: null, savedDirectives: [], ref: null, prevProps: t }, n;
  }
  return Ep(e10, react__WEBPACK_IMPORTED_MODULE_1__.Component), Ec(e10, [{ key: "findDirectiveName", value: function(t) {
    var n = t.dir, o = -1;
    return [this.state.savedDirectives.find(function(r, a) {
      if (r.dir === n) return o = a, true;
    }), o];
  } }, { key: "doDirective", value: function() {
    var t = this, a = this.state, n = a.savedDirectives;
    if (!(o = a.ref)) {
      for (var o = (this._reactInternals || this._reactInternalFiber).child; o && o.tag !== 5; ) o = o.child;
      if (!o) return;
      o = o.stateNode;
    }
    var r = this.props.vnode, a = r.dirs;
    a && (a.forEach(function(l) {
      var s, u, c, d, f, p, v;
      l && (v = (s = dm(t.findDirectiveName(l), 2))[0], s = s[1], u = (f = l.dir).created, c = f.beforeMount, d = f.mounted, p = f.beforeUpdate, f = f.updated, v ? (n[s] = Ue(Ue(Ue({}, v), l), {}, { oldValue: v.oldValue }), v = [o, n[s], r, t.state.prevVnode], p != null && p.apply(null, v), f != null && f.apply(null, v), n[s].oldValue = l.value) : (n.push(l), p = [o, l, r, null], u != null && u.apply(null, p), c != null && c.apply(null, p), d != null && d.apply(null, p), l.oldValue = l.value));
    }), this.setState({ prevVnode: Ue({}, r), savedDirectives: n, ref: o }));
  } }, { key: "componentDidMount", value: function() {
    this.doDirective();
  } }, { key: "componentDidUpdate", value: function(t) {
    t.vnode !== this.props.vnode && this.doDirective();
  } }, { key: "componentWillUnmount", value: function() {
    var t = this, n = this.props.vnode, l = this.state, o = l.savedDirectives, r = l.ref, a = l.prevVnode, l = n.dirs;
    l && (l.forEach(function(s) {
      var u, c, d, f;
      s && (u = (f = dm(t.findDirectiveName(s), 2))[0]) && (c = (d = s.dir).beforeUnmount, d = d.unmounted, o[f[1]] = Ue(Ue({}, u), s), f = [r, u, n, a], c != null && c.apply(null, f), d != null) && d.apply(null, f);
    }), this.setState({ prevVnode: Ue({}, n), savedDirectives: o }));
  } }, { key: "render", value: function() {
    var t = this.props;
    return t.vnode, t.children;
  } }]);
})();
function jse(e10, t) {
  var n;
  return typeof e10 == "function" && (n = e10.toString(), e10.prototype !== void 0) && e10.prototype.constructor === e10 && (n.slice(0, 5) == "class" || 2 <= Object.getOwnPropertyNames(e10.prototype).length || !/^function\s+\(|^function\s+anonymous\(/.test(n) && (!(!t || !/^function\s+[A-Z]/.test(n)) || !!/\b\(this\b|\bthis[\.\[]\b/.test(n) && (!(t && !/classCallCheck\(this/.test(n)) || /^function\sdefault_\d+\s*\(/.test(n))));
}
function xO(e10, t) {
  var n, o, r, a;
  return typeof ((r = e10.type) == null ? void 0 : r.originReactComponent) != "function" || jse((r = e10.type) == null ? void 0 : r.originReactComponent) ? ((r = e10.ref) != null && r.k ? (n = (r = e10.ref) == null ? void 0 : r.k, o = (r = e10.ref) == null ? void 0 : r.r) : n = (r = e10.ref) == null ? void 0 : r.r, n && typeof n == "string" && (a = n, n = function(l) {
    var s;
    (s = e10.ref) != null && (s = s.i) != null && s.refs && ((s = Ue({}, e10.ref.i.refs))[a] = l, e10.ref.i.refs = s), o ? o.value = l : e10.ref.i.setupState && a in e10.ref.i.setupState && (e10.ref.i.setupState[a] = l), l && (l.__syncUpdateProps = function() {
      t.__top__ && (e10.__extraData = 0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : {}, t.__top__.__syncUpdateProps({}));
    });
  }, n = new Proxy(n, { get: function(l, s) {
    return l[s];
  }, set: function(l, s, u) {
    var c;
    return (c = e10.ref) != null && (c = c.i) != null && c.refs && a in ((c = e10.ref) == null || (c = c.i) == null ? void 0 : c.refs) && ((c = Ue({}, e10.ref.i.refs))[s] = u, e10.ref.i.refs = c), u;
  } })), n) : null;
}
function hm(e10, t) {
  return !t || t instanceof Array && t.length === 0 || (typeof t == "string" && (t = [t]), (e10 = Ue({}, e10)).props = Ue({}, e10.props), t.forEach(function(n) {
    e10.props[n] = "";
  })), e10;
}
var Use = ["style", "class"];
function $w(e10, t, n, o, r, a, l) {
  var s, u, c;
  return t === "all" || t instanceof Array || (t = t ? [t] : []), e10.type === Ie ? r.call(l, e10.children, n, a) : typeof e10.type == "string" && (t === "all" || -1 < t.indexOf(e10.type)) ? (t = xO(e10), c = (u = e10.props || {}).style, s = u.class, u = Ue(Ue({}, Vo(u, Use)), {}, { style: Tp(c), className: Array.from(new Set(Op(s))).join(" ") }, t ? { ref: t } : {}), (c = e10.children || u.children) && ((c = -1 < ["string", "number"].indexOf(jn(c)) ? [c] : Sp(c)).__top__ = l), LO(e10, hm(react__WEBPACK_IMPORTED_MODULE_1___default().createElement(e10.type, u, r.call(l, c, n, a)), e10.scopeId))) : n([e10], null, o);
}
function Yse() {
  var e10 = 0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : {}, t = 1 < arguments.length ? arguments[1] : void 0, n = 2 < arguments.length ? arguments[2] : void 0;
  return n.__syncUpdateForPureReactInVue && Object.keys(n.__syncUpdateForPureReactInVue).map(function(o) {
    var r;
    e10[o] && typeof e10[o] == "function" && t.__top__ && (r = e10[o], e10[o] = function() {
      for (var a = arguments.length, l = new Array(a), s = 0; s < a; s++) l[s] = arguments[s];
      t.__extraData = n.__syncUpdateForPureReactInVue[o].apply(this, l), t.__top__.__veaurySyncUpdateProps__({}), t.__top__.macroTaskUpdate = true, r.apply(this, l), t.__top__ && Promise.resolve().then(function() {
        t.__extraData = null, t.__top__.__veauryMountReactComponent__(true);
      });
    });
  }), e10;
}
function Iw(e10, t, n) {
  return !((e10 = e10 instanceof Array && e10.length === 1 ? e10[0] : e10) instanceof Array) && e10.key == null && 1 < t.length && ((e10 = Ue({}, e10)).key = "_key_".concat(n)), e10;
}
function DO(o) {
  var t = o.reactComponents, n = o.domTags, o = o.division, r = o === void 0 || o;
  return function a(l, s, u) {
    var c;
    return l && l.forEach ? (l.__top__ || (l.__top__ = this), c = [], l.forEach(function(d, f) {
      if (d && d.type !== tn) {
        if ((m = d.type) == null || !m.originReactComponent) return d.$$typeof || typeof d == "string" || typeof d == "number" ? void c.push(d) : Ow(d) ? void (d.children.trim() !== "" && c.push(d.children.trim())) : void (d.type && (hm(m = Iw($w(d, n, s, r, a, u, l.__top__), l, f), d.scopeId), c.push(m)));
        var p, v, m = d.type.originReactComponent;
        hm(p = Iw(p = (t = t === "all" || t instanceof Array ? t : [t]) === "all" || -1 < t.indexOf(m) ? (d.__top__ = l.__top__, p = Kse(d, "_key_".concat(f), s, a, u), v = xO(d, l), d.children && (d.children.__top__ = l.__top__), LO(d, react__WEBPACK_IMPORTED_MODULE_1___default().createElement(m, Ue(Ue(Ue({}, Yse(p, d, m)), d.__extraData || {}), v ? { ref: v } : {})))) : Ow(d) ? d.text : $w(d, n, s, r, a, u), l, f), d.scopeId), c.push(p);
      }
    }), c.length === 1 ? c[0] : c) : l;
  };
}
var kv = DO({ reactComponents: "all", domTags: "all" });
function qse(e10, t) {
  return Hse(e10, { combinedOption: Ue({ pureTransformer: true, defaultSlotsFormatter: kv, defaultPropsFormatter: function(n, o, r) {
    var a = {};
    return Object.keys(n).forEach(function(l) {
      var s = n[l];
      s && (s.vueFunction ? (a[l] = function() {
        for (var u = arguments.length, c = new Array(u), d = 0; d < u; d++) c[d] = arguments[d];
        return kv(s.vueFunction.apply(this, c), o, r);
      }, Object.defineProperty(a[l], "length", { get: function() {
        return s.vueFunction.length;
      } })) : s.vueSlot && (a[l] = kv(s.vueSlot, o, r)));
    }), Object.assign(n, a);
  } }, t) });
}
DO({ reactComponents: "all", domTags: "all" });
var Gse = ["ref", "children", "v-slots"];
function Xse(u, t, n, o, r) {
  var u = u.props || {}, c = (u.ref, u.children), l = u["v-slots"], a = l === void 0 ? {} : l, l = Vo(u, Gse), s = (c && (jn(c) !== "object" || c instanceof Array || c.$$typeof ? a.default = c : a = c), null), u = (Object.keys(a || {}).forEach(function(f) {
    var p = a[f];
    (s = s || {})[f] = function() {
      if (typeof p == "function") {
        for (var v = arguments.length, m = new Array(v), h = 0; h < v; h++) m[h] = arguments[h];
        p = p.apply(this, m);
      }
      return o(p, n, r);
    };
  }), {}), c = Tp(l.style), d = Array.from(new Set(Op(l.className))).join(" ");
  return 0 < Object.keys(c).length && (u.style = c), d !== "" && (u.class = d), Object.assign(l, Ue({}, u)), delete l.className, { props: l = fm(l), slots: s };
}
function VO(e10) {
  var t = e10.ref;
  if (t) return jn(t) === "object" ? function(n) {
    e10.ref.current = n;
  } : typeof t == "function" ? t : void 0;
}
var Jse = ["style", "class", "children"];
function Mw(e10, t, n, o, r, a) {
  var l, s, u, c;
  return t === "all" || t instanceof Array || (t = t ? [t] : []), e10.type === react__WEBPACK_IMPORTED_MODULE_1__.Fragment ? r((l = e10.props) == null ? void 0 : l.children, n) : typeof e10.type == "string" && (t === "all" || -1 < t.indexOf(e10.type)) ? (l = VO(e10), c = (t = e10.props || {}).style, u = t.class, s = t.children, t = Vo(t, Jse), u = Array.from(new Set(Op(u))).join(" "), c = Tp(c), t = Ue(Ue(Ue(Ue({}, t), Object.keys(c).length === 0 ? {} : { style: c }), u ? { className: u } : {}), l ? { ref: l } : {}), Object.keys(t).length === 0 && (t = null), (c = s) && ((c = -1 < ["string", "number"].indexOf(jn(c)) ? [c] : c instanceof Array ? Sp(c) : Ue({}, c)).__top__ = a), Ke(e10.type, t, r(c, n))) : n([e10], null, o);
}
function FO(o) {
  var t = o.vueComponents, n = o.domTags, o = o.division, r = o === void 0 || o;
  return function a(l, s) {
    if (l == null) return l;
    l instanceof Array || (l = [l]);
    var u = [];
    return l.forEach(function(c, d) {
      if (((f = c.type) == null || !f.originVueComponent) && c.type !== vm) return c.__v_isVNode || typeof c == "string" || typeof c == "number" ? void u.push(c) : void (c.type && (f = Mw(c, n, s, r, a, l.__top__), u.push(f)));
      var f = c.type.originVueComponent;
      if (c.type === vm) {
        if (!c.props.component) return void u.push(c.props.node);
        f = c.props.component, c = Ue({}, c);
        var p = Ue({}, c.props);
        delete p.component, c.props = p;
      }
      f = (t = t === "all" || t instanceof Array ? t : [t]) === "all" || -1 < t.indexOf(f) ? ((c = Ue({}, c)).__top__ = l.__top__, d = (p = Xse(c, "_key_".concat(d), s, a)).props, p = p.slots, VO(c), c.children && (c.children.__top__ = l.__top__), Ke(f, Ue({}, d), p)) : Mw(c, n, s, r, a), u.push(f);
    }), (u = u.flat(1 / 0)).length === 1 ? u[0] : u;
  };
}
FO({ vueComponents: "all", domTags: "all" });
FO({ reactComponents: "all", domTags: "all" });
new Np();
const Zse = /* @__PURE__ */ j({
  __name: "dynamic",
  props: {
    schema: {},
    modelValue: {},
    disabled: {},
    prefix: {},
    initial: {},
    extra: {}
  },
  emits: ["update:modelValue"],
  setup(e10) {
    const t = e10;
    Le("storeDynamic");
    const n = S(() => {
      var r, a, l;
      const o = (l = storeDynamic == null ? void 0 : storeDynamic.dynamic) == null ? void 0 : l[(a = (r = t.schema) == null ? void 0 : r.meta.extra) == null ? void 0 : a.name];
      return o && new schemastery__WEBPACK_IMPORTED_MODULE_0__["default"](o);
    });
    return (o, r) => {
      const a = je("k-schema"), l = je("schema-base");
      return n.value ? (k(), ae(a, {
        key: 0,
        modelValue: e10.modelValue,
        "onUpdate:modelValue": r[0] || (r[0] = (s) => o.$emit("update:modelValue", s)),
        schema: { ...n.value, meta: { ...e10.schema.meta, ...n.value.meta } },
        initial: e10.initial,
        disabled: e10.disabled,
        prefix: e10.prefix
      }, {
        title: H(() => [
          J(o.$slots, "title")
        ]),
        prefix: H(() => [
          J(o.$slots, "prefix")
        ]),
        suffix: H(() => [
          J(o.$slots, "suffix")
        ]),
        _: 3
      }, 8, ["modelValue", "schema", "initial", "disabled", "prefix"])) : (k(), ae(l, {
        key: 1,
        modelValue: e10.modelValue,
        "onUpdate:modelValue": r[1] || (r[1] = (s) => o.$emit("update:modelValue", s)),
        schema: e10.schema,
        initial: e10.initial,
        disabled: e10.disabled,
        prefix: e10.prefix
      }, {
        title: H(() => [
          J(o.$slots, "title")
        ]),
        desc: H(() => [
          J(o.$slots, "desc")
        ]),
        menu: H(() => [
          J(o.$slots, "menu")
        ]),
        _: 3
      }, 8, ["modelValue", "schema", "initial", "disabled", "prefix"]));
    };
  }
}), Qse = Ys(qn.Form);
qn.extensions.add({
  type: "any",
  role: "dynamic",
  component: Zse
});
function iie({
  Markdown: e10,
  setupVue: t,
  locale: n
}) {
  const o = It({ dynamic: {} }), [, r] = Bse({
    useVueInjection() {
      return {
        storeDynamic: o
      };
    },
    beforeVueAppMount(l) {
      l.use(qn), l.use(Are({
        legacy: false,
        locale: n || "en-US"
      })), l.use(Yte), l.component("k-markdown", qse(e10)), t == null || t(l);
    }
  });
  function a({
    schema: l,
    initial: s,
    value: u,
    onChange: c,
    dynamic: d,
    ...f
  }) {
    return o.dynamic = d, (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(r, {}, (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(Qse, { ...f, schema: l, initial: s, "v-model": [u, c] }));
  }
  return a;
}



/***/ })

}]);